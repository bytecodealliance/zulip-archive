<html>
<head><meta charset="utf-8"><title>How can a function exported by one WASM component be called? · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/index.html">general</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/How.20can.20a.20function.20exported.20by.20one.20WASM.20component.20be.20called.3F.html">How can a function exported by one WASM component be called?</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="560744119"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/How%20can%20a%20function%20exported%20by%20one%20WASM%20component%20be%20called%3F/near/560744119" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hua <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/How.20can.20a.20function.20exported.20by.20one.20WASM.20component.20be.20called.3F.html#560744119">(Nov 28 2025 at 09:47)</a>:</h4>
<p>I’m relatively new to WebAssembly and would appreciate some guidance on the following challenge.</p>
<p>I currently have the following setup:</p>
<ul>
<li>Library A is implemented in Python and compiled into a WASM component.</li>
<li>Library B is implemented in Rust and also compiled into a WASM component.</li>
<li>Library B exports functions and resources using WIT.</li>
</ul>
<p>My questions are:</p>
<ul>
<li>How can Library A call the functions exported by Library B from within Python?</li>
<li>Is it possible to automatically generate Python bindings from the interfaces exported by B, so that A can use them easily?</li>
</ul>
<p>I’ve looked through relevant documentation, but most resources focus on Guest/Host interoperability. I haven’t been able to find clear guidance on interoperability between two WASM components.</p>
<p>My use case seems similar to the one shown in this example:</p>
<p><a href="https://github.com/bytecodealliance/wac/tree/main/examples">https://github.com/bytecodealliance/wac/tree/main/examples</a></p>
<p>However, I’m interested in understanding how the underlying code that generates these WASM components actually works.</p>
<p>It would be beneficial if there were any similar project examples available.</p>
<p>Thank you!</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wac/tree/main/examples" style="background-image: url(&quot;https://uploads.zulipusercontent.net/6d9c3b42f73157ffbac5e4369bb9af45162baf40/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f333030386362356664646163336336363262346432383063303264363438633662646536353666353939353735363139373937323766353436633566633565642f62797465636f6465616c6c69616e63652f776163&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wac/tree/main/examples" title="wac/examples at main · bytecodealliance/wac">wac/examples at main · bytecodealliance/wac</a></div><div class="message_embed_description">WebAssembly Composition (WAC) tooling. Contribute to bytecodealliance/wac development by creating an account on GitHub.</div></div></div>



<a name="560788283"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/How%20can%20a%20function%20exported%20by%20one%20WASM%20component%20be%20called%3F/near/560788283" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Milan (rajsite) <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/How.20can.20a.20function.20exported.20by.20one.20WASM.20component.20be.20called.3F.html#560788283">(Nov 28 2025 at 13:33)</a>:</h4>
<p>The component model book goes through the concepts with a Rust component (calculator) calling a JavaScript component (adder): <a href="https://component-model.bytecodealliance.org/importing-and-reusing-components.html">https://component-model.bytecodealliance.org/importing-and-reusing-components.html</a></p>
<p>The key bit is that the wit used to define the API of B is what A uses to generate Python bindings. The componentize-py docs show what it's like to generate bindings for a hello world wit: <a href="https://github.com/bytecodealliance/componentize-py?tab=readme-ov-file#getting-started">https://github.com/bytecodealliance/componentize-py?tab=readme-ov-file#getting-started</a><br>
That example is exporting the interface, but in your version from the Python component it sounds like you'll want to import the interface.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/componentize-py?tab=readme-ov-file#getting-started" style="background-image: url(&quot;https://uploads.zulipusercontent.net/c9a307ce7db6f82b361aa753d148eea799d7f5fb/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633865316364393031396632313438313235393330663439643230353239366563623731643561343665623661396666353462333635616163626134326265362f62797465636f6465616c6c69616e63652f636f6d706f6e656e74697a652d7079&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/componentize-py?tab=readme-ov-file#getting-started" title="GitHub - bytecodealliance/componentize-py: Tool for targetting the WebAssembly Component Model using Python">GitHub - bytecodealliance/componentize-py: Tool for targetting the WebAssembly Component Model using Python</a></div><div class="message_embed_description">Tool for targetting the WebAssembly Component Model using Python - bytecodealliance/componentize-py</div></div></div>



<a name="561660396"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/How%20can%20a%20function%20exported%20by%20one%20WASM%20component%20be%20called%3F/near/561660396" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Hua <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/How.20can.20a.20function.20exported.20by.20one.20WASM.20component.20be.20called.3F.html#561660396">(Dec 03 2025 at 14:07)</a>:</h4>
<p><span class="user-mention silent" data-user-id="417958">Milan (rajsite)</span> <a href="#narrow/channel/206238-general/topic/How.20can.20a.20function.20exported.20by.20one.20WASM.20component.20be.20called.3F/near/560788283">說</a>：</p>
<blockquote>
<p>The component model book goes through the concepts with a Rust component (calculator) calling a JavaScript component (adder): <a href="https://component-model.bytecodealliance.org/importing-and-reusing-components.html">https://component-model.bytecodealliance.org/importing-and-reusing-components.html</a></p>
<p>The key bit is that the wit used to define the API of B is what A uses to generate Python bindings. The componentize-py docs show what it's like to generate bindings for a hello world wit: <a href="https://github.com/bytecodealliance/componentize-py?tab=readme-ov-file#getting-started">https://github.com/bytecodealliance/componentize-py?tab=readme-ov-file#getting-started</a><br>
That example is exporting the interface, but in your version from the Python component it sounds like you'll want to import the interface.</p>
</blockquote>
<p>Thank you for your reply.</p>
<p>I've reviewed the Rust component (calculator) example in the documentation. My needs are similar, but I require a Python version. I have searched extensively but have been unable to locate one. The available componentize-py examples focus on exporting components, whereas I specifically need the interface for importing a component into Python.</p>



<a name="561688967"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/How%20can%20a%20function%20exported%20by%20one%20WASM%20component%20be%20called%3F/near/561688967" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joel Dice <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/How.20can.20a.20function.20exported.20by.20one.20WASM.20component.20be.20called.3F.html#561688967">(Dec 03 2025 at 15:46)</a>:</h4>
<p>Here's a quick example of building two components using <code>componentize-py</code>, composing them, and running the result:</p>
<div class="codehilite" data-code-language="Bash"><pre><span></span><code>mkdir<span class="w"> </span>compose
<span class="nb">cd</span><span class="w"> </span>compose
python3<span class="w"> </span>-m<span class="w"> </span>venv<span class="w"> </span>.venv
<span class="nb">source</span><span class="w"> </span>.venv/bin/activate
pip<span class="w"> </span>install<span class="w"> </span>componentize-py
cat<span class="w"> </span>&gt;worlds.wit<span class="w"> </span><span class="s">&lt;&lt;EOF</span>
<span class="s">package test:test;</span>

<span class="s">interface foo {</span>
<span class="s">  bar: func() -&gt; string;</span>
<span class="s">}</span>

<span class="s">world thing1 {</span>
<span class="s">  export foo;</span>
<span class="s">}</span>

<span class="s">world thing2 {</span>
<span class="s">  import foo;</span>
<span class="s">  export run: func() -&gt; string;</span>
<span class="s">}</span>
<span class="s">EOF</span>
cat<span class="w"> </span>&gt;mything1.py<span class="w"> </span><span class="s">&lt;&lt;EOF</span>
<span class="s">from wit_world import exports</span>

<span class="s">class Foo(exports.Foo):</span>
<span class="s">    def bar(self) -&gt; string:</span>
<span class="s">        return "Hello, world!"</span>
<span class="s">EOF</span>
cat<span class="w"> </span>&gt;mything2.py<span class="w"> </span><span class="s">&lt;&lt;EOF</span>
<span class="s">import wit_world</span>
<span class="s">from wit_world.imports import foo</span>

<span class="s">class WitWorld(wit_world.WitWorld):</span>
<span class="s">    def run(self) -&gt; string:</span>
<span class="s">        return foo.bar()</span>
<span class="s">EOF</span>
componentize-py<span class="w"> </span>-d<span class="w"> </span>worlds.wit<span class="w"> </span>-w<span class="w"> </span>thing1<span class="w"> </span>componentize<span class="w"> </span>mything1<span class="w"> </span>-o<span class="w"> </span>thing1.wasm
componentize-py<span class="w"> </span>-d<span class="w"> </span>worlds.wit<span class="w"> </span>-w<span class="w"> </span>thing2<span class="w"> </span>componentize<span class="w"> </span>mything2<span class="w"> </span>-o<span class="w"> </span>thing2.wasm
wasm-tools<span class="w"> </span>compose<span class="w"> </span>-d<span class="w"> </span>thing1.wasm<span class="w"> </span>thing2.wasm<span class="w"> </span>-o<span class="w"> </span>composed.wasm
wasmtime<span class="w"> </span>run<span class="w"> </span>--invoke<span class="w"> </span><span class="s1">'run()'</span><span class="w"> </span>composed.wasm
</code></pre></div>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>