<html>
<head><meta charset="utf-8"><title>High Overhead for Wasm Import Call Despite AOT Compilation · general · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/index.html">general</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/High.20Overhead.20for.20Wasm.20Import.20Call.20Despite.20AOT.20Compilation.html">High Overhead for Wasm Import Call Despite AOT Compilation</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="531496883"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/High%20Overhead%20for%20Wasm%20Import%20Call%20Despite%20AOT%20Compilation/near/531496883" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nicholas Renner <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/High.20Overhead.20for.20Wasm.20Import.20Call.20Despite.20AOT.20Compilation.html#531496883">(Jul 29 2025 at 02:20)</a>:</h4>
<p>Hi everyone,</p>
<p>I’m currently benchmarking a host function modeled after the <code>__imported_wasi_snapshot_preview1</code> template and observing <strong>~2 µs per import call</strong> from Wasm, which feels excessively slow. Meanwhile, a Wasmtime PR claims this overhead should be closer to <strong>10 ns</strong>: <a href="https://github.com/bytecodealliance/wasmtime/pull/6262">https://github.com/bytecodealliance/wasmtime/pull/6262</a>. Has anyone seen this level of performance in practice?</p>
<p>We are <strong>ahead-of-time compiling</strong> the Wasm module and would appreciate any insight into what might cause this kind of discrepancy or how import call overhead is typically minimized when using Wasmtime with <code>__imported_wasi_snapshot_preview1</code>-style imports. Thanks!</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/pull/6262" style="background-image: url(&quot;https://uploads.zulipusercontent.net/fa057180708853f6c12cc9d1cbd498166a7b7645/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633838303163333962666534643463313864396238316438373035636438643234613136613865353065613037626239353363376263343836663232656562352f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f36323632&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/pull/6262" title="wasmtime: Overhaul trampolines by fitzgen · Pull Request #6262 · bytecodealliance/wasmtime">wasmtime: Overhaul trampolines by fitzgen · Pull Request #6262 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">This commit splits VMCallerCheckedFuncRef::func_ptr into three new function pointers: VMCallerCheckedFuncRef::{wasm,array,native}_call. Each one has a dedicated calling convention, so callers just ...</div></div></div>



<a name="531511604"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/High%20Overhead%20for%20Wasm%20Import%20Call%20Despite%20AOT%20Compilation/near/531511604" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pat Hickey <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/High.20Overhead.20for.20Wasm.20Import.20Call.20Despite.20AOT.20Compilation.html#531511604">(Jul 29 2025 at 04:51)</a>:</h4>
<p>can you share something where we can reproduce your measurements?</p>



<a name="531629870"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/High%20Overhead%20for%20Wasm%20Import%20Call%20Despite%20AOT%20Compilation/near/531629870" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/High.20Overhead.20for.20Wasm.20Import.20Call.20Despite.20AOT.20Compilation.html#531629870">(Jul 29 2025 at 14:48)</a>:</h4>
<p>Are you using WAMR, not Wasmtime? Wasmtime doesn't have any  mention of <code>__imported_*</code> but searching the WAMR repository  it looks like it's there. If so you might want to raise this with WAMR developers.</p>



<a name="531664839"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/High%20Overhead%20for%20Wasm%20Import%20Call%20Despite%20AOT%20Compilation/near/531664839" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nicholas Renner <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/High.20Overhead.20for.20Wasm.20Import.20Call.20Despite.20AOT.20Compilation.html#531664839">(Jul 29 2025 at 17:32)</a>:</h4>
<p>@Alex: To clarify — we’re using <strong>WASI-SDK with Wasmtime</strong>, not WAMR. The <code>__imported_wasi_snapshot_preview1_*</code> naming came from <strong>WASI-SDK’s import declarations</strong>, and we modeled our own import on that pattern. For example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">int</span><span class="w"> </span><span class="n">__imported_wasi_snapshot_preview1_lind_syscall</span><span class="p">(</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="n">callnumber</span><span class="p">,</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">callname</span><span class="p">,</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">arg1</span><span class="p">,</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">arg2</span><span class="p">,</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">arg3</span><span class="p">,</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">arg4</span><span class="p">,</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">arg5</span><span class="p">,</span>
<span class="w">    </span><span class="n">unsigned</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">long</span><span class="w"> </span><span class="n">arg6</span><span class="p">)</span>
<span class="w">  </span><span class="n">__attribute__</span><span class="p">((</span><span class="n">__import_module__</span><span class="p">(</span><span class="s">"lind"</span><span class="p">),</span>
<span class="w">                 </span><span class="n">__import_name__</span><span class="p">(</span><span class="s">"lind-syscall"</span><span class="p">)));</span>
</code></pre></div>
<p>I did forget to mention that we're calling from C code, perhaps that adds to overhead?</p>
<p>If theres a good example of how to do this from C in a wasmtime specific way that would be awesome to be pointed to. <span class="user-mention" data-user-id="253992">@Pat Hickey</span> I can try that out and report back on what overhead I see.</p>
<p>Thanks for your help all!</p>



<a name="531665019"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/High%20Overhead%20for%20Wasm%20Import%20Call%20Despite%20AOT%20Compilation/near/531665019" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pat Hickey <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/High.20Overhead.20for.20Wasm.20Import.20Call.20Despite.20AOT.20Compilation.html#531665019">(Jul 29 2025 at 17:33)</a>:</h4>
<p>yes, using wasmtime's C API adds overhead compared to the rust API, and the results described in the linked PR wont apply to use of the C API</p>



<a name="531666103"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/High%20Overhead%20for%20Wasm%20Import%20Call%20Despite%20AOT%20Compilation/near/531666103" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pat Hickey <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/High.20Overhead.20for.20Wasm.20Import.20Call.20Despite.20AOT.20Compilation.html#531666103">(Jul 29 2025 at 17:39)</a>:</h4>
<p>I still dont really understand what you mean by the wasi-sdk import declarations style. wasi-sdk contains wasi-libc which describes to guest wasm how to call wasm import functions. the implementation of those import functons in the host is using wasmtime to resolve import functions to native code, using wasmtime's linker. the C api to wasmtime's linker has the prototypes given here <a href="https://docs.wasmtime.dev/c-api/linker_8h_source.html">https://docs.wasmtime.dev/c-api/linker_8h_source.html</a> . Nobody has taken the time to write up comprehensive docs for the c api, so you're going to have to read the source code (e.g. <a href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/c-api/src/func.rs">https://github.com/bytecodealliance/wasmtime/blob/main/crates/c-api/src/func.rs</a>) and then the docs of the wasmtime Rust apis that calls (e.g. <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html#method.call_unchecked">https://docs.rs/wasmtime/latest/wasmtime/struct.Func.html#method.call_unchecked</a>)</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/c-api/src/func.rs" style="background-image: url(&quot;https://uploads.zulipusercontent.net/486ea58fcbd35b0b0cf9aacf54e599ed17c0083f/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633839303437646635373463393330303761313739353536633732353135393834353466333833363234393136643332363130383662306636323361356164622f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/c-api/src/func.rs" title="wasmtime/crates/c-api/src/func.rs at main · bytecodealliance/wasmtime">wasmtime/crates/c-api/src/func.rs at main · bytecodealliance/wasmtime</a></div><div class="message_embed_description">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>



<a name="531666418"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/High%20Overhead%20for%20Wasm%20Import%20Call%20Despite%20AOT%20Compilation/near/531666418" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pat Hickey <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/High.20Overhead.20for.20Wasm.20Import.20Call.20Despite.20AOT.20Compilation.html#531666418">(Jul 29 2025 at 17:41)</a>:</h4>
<p>in particular if you need lower overhead on func calls then you need to use the unchecked variants. those are tricky to use correctly in C, because the type system cant do any work for you, but that should get you just about the same performance as the typed apis get you in Rust (where the type system provides assurances that the unchecked call is correct)</p>



<a name="531668973"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/High%20Overhead%20for%20Wasm%20Import%20Call%20Despite%20AOT%20Compilation/near/531668973" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nicholas Renner <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/High.20Overhead.20for.20Wasm.20Import.20Call.20Despite.20AOT.20Compilation.html#531668973">(Jul 29 2025 at 17:55)</a>:</h4>
<p>Okay this is super helpful thank you. Sorry about my weird nomenclature, kind of fumbling around here but I don't think that matters.</p>
<p>I'll read through the links you sent and try out a minimal example.</p>



<a name="531669747"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/High%20Overhead%20for%20Wasm%20Import%20Call%20Despite%20AOT%20Compilation/near/531669747" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pat Hickey <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/High.20Overhead.20for.20Wasm.20Import.20Call.20Despite.20AOT.20Compilation.html#531669747">(Jul 29 2025 at 17:59)</a>:</h4>
<p>thats fine, im being particular because the details here are subtle and may matter.</p>



<a name="531670194"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/High%20Overhead%20for%20Wasm%20Import%20Call%20Despite%20AOT%20Compilation/near/531670194" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/High.20Overhead.20for.20Wasm.20Import.20Call.20Despite.20AOT.20Compilation.html#531670194">(Jul 29 2025 at 18:01)</a>:</h4>
<p>For the lowest overhead in the C API you'll want to use the <code>*_unchecked</code> APIs such as <a href="https://docs.wasmtime.dev/c-api/linker_8h.html#a15c170f76af88d1aa3b15ef23d741827"><code>wasmtime_linker_define_func_unchecked</code></a></p>



<a name="532150969"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/206238-general/topic/High%20Overhead%20for%20Wasm%20Import%20Call%20Despite%20AOT%20Compilation/near/532150969" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nicholas Renner <a href="https://bytecodealliance.github.io/zulip-archive/stream/206238-general/topic/High.20Overhead.20for.20Wasm.20Import.20Call.20Despite.20AOT.20Compilation.html#532150969">(Jul 31 2025 at 19:19)</a>:</h4>
<p>Hi all,</p>
<p>Thank you for all your help and pointing me in the right direction. Once I understood how the linker works I realized that the trampoline is costing close to whats reported and the overhead I was seeing was from marshalling a somewhat large data struct. Sorry for my confusion and thanks again!</p>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>