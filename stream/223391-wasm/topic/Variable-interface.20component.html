<html>
<head><meta charset="utf-8"><title>Variable-interface component · wasm · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/223391-wasm/index.html">wasm</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/223391-wasm/topic/Variable-interface.20component.html">Variable-interface component</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="534471886"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/223391-wasm/topic/Variable-interface%20component/near/534471886" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lachlan Gunn <a href="https://bytecodealliance.github.io/zulip-archive/stream/223391-wasm/topic/Variable-interface.20component.html#534471886">(Aug 14 2025 at 12:24)</a>:</h4>
<p>Is there any existing way that one might build a component that can export a function having an indeterminate signature?  We could obviously build a new component for each signature of interest and then link that in where it's needed, but for something like e.g. wrpc, it seems like it would be nice if it were possible to build a component that could be connected to any import, and that would get at runtime some representation of the types that it's been called with.</p>



<a name="534473349"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/223391-wasm/topic/Variable-interface%20component/near/534473349" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lann Martin <a href="https://bytecodealliance.github.io/zulip-archive/stream/223391-wasm/topic/Variable-interface.20component.html#534473349">(Aug 14 2025 at 12:32)</a>:</h4>
<p>There is not, and I'm not sure that the component model itself would ever support exactly what you are describing. You could certainly define an interface that provides this functionality, which would likely end up looking a lot like existing RPC systems with reflection interfaces.</p>



<a name="534474417"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/223391-wasm/topic/Variable-interface%20component/near/534474417" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ralph <a href="https://bytecodealliance.github.io/zulip-archive/stream/223391-wasm/topic/Variable-interface.20component.html#534474417">(Aug 14 2025 at 12:38)</a>:</h4>
<p>I mean, speaking as an old Microsoft-ee, you're free to reimplement IQueryInterface if you want, but ymmv: <a href="https://news.ycombinator.com/item?id=43021361">https://news.ycombinator.com/item?id=43021361</a></p>



<a name="534474480"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/223391-wasm/topic/Variable-interface%20component/near/534474480" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ralph <a href="https://bytecodealliance.github.io/zulip-archive/stream/223391-wasm/topic/Variable-interface.20component.html#534474480">(Aug 14 2025 at 12:38)</a>:</h4>
<p>We shall not be reimplementing DCOM, speaking for my MegaCorp. :-)</p>



<a name="534474506"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/223391-wasm/topic/Variable-interface%20component/near/534474506" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ralph <a href="https://bytecodealliance.github.io/zulip-archive/stream/223391-wasm/topic/Variable-interface.20component.html#534474506">(Aug 14 2025 at 12:38)</a>:</h4>
<p>but others can.....</p>



<a name="534489072"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/223391-wasm/topic/Variable-interface%20component/near/534489072" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lachlan Gunn <a href="https://bytecodealliance.github.io/zulip-archive/stream/223391-wasm/topic/Variable-interface.20component.html#534489072">(Aug 14 2025 at 13:58)</a>:</h4>
<p>Yeah, I was about five years too young to get into DCOM so don't know better.  My thinking was that you could, in principle, create some adaptor module that could pull out the data directly and then transform it to a standard form before using the component model's lifting and lowering.</p>



<a name="534489396"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/223391-wasm/topic/Variable-interface%20component/near/534489396" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lachlan Gunn <a href="https://bytecodealliance.github.io/zulip-archive/stream/223391-wasm/topic/Variable-interface.20component.html#534489396">(Aug 14 2025 at 14:00)</a>:</h4>
<p>The thinking was that then you wouldn't need to somehow generate a monomorphised core module when linking in an RPC adaptor.</p>



<a name="535132945"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/223391-wasm/topic/Variable-interface%20component/near/535132945" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Till Schneidereit <a href="https://bytecodealliance.github.io/zulip-archive/stream/223391-wasm/topic/Variable-interface.20component.html#535132945">(Aug 19 2025 at 13:45)</a>:</h4>
<blockquote>
<p>My thinking was that you could, in principle, create some adaptor module that could pull out the data directly and then transform it to a standard form before using the component model's lifting and lowering.</p>
</blockquote>
<p>this is one of the nice properties of the component model: exactly what you're describing here is possible today, without any special support by the component model itself. Obviously you either have to write the adapters by hand or have a tool generate them for you. But in either case, you can fully do it in your toolchain, without the runtime or the spec needing to support it in any way</p>



<a name="535135083"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/223391-wasm/topic/Variable-interface%20component/near/535135083" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lann Martin <a href="https://bytecodealliance.github.io/zulip-archive/stream/223391-wasm/topic/Variable-interface.20component.html#535135083">(Aug 19 2025 at 13:55)</a>:</h4>
<p>...and in case this isn't clear, you can do all this <em>without source code</em>; component binaries encode their own interface types.</p>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>