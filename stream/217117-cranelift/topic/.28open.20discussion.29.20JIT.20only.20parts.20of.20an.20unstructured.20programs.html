<html>
<head><meta charset="utf-8"><title>(open discussion) JIT only parts of an unstructured programs 路 cranelift 路 Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/index.html">cranelift</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html">(open discussion) JIT only parts of an unstructured programs</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="494461699"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494461699" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nate <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494461699">(Jan 18 2025 at 00:19)</a>:</h4>
<p>So I have this (maybe rather strange) use case of JITing only "parts" of some riscv(32) bytecode.</p>
<p>For a bit of context, I run these instructions in a interpreter normally because I am generating proofs of correct execution which requires me to collect auxiliary information per cycle, however I also have an "unconstrained" mode, which runs the instructions without collecting this data, this is the part I want to JIT.</p>
<p>For my use case, Im only given this bytecode, and I only want to JIT some parts of it that are "sandwhiched" say, between two placeholder opcodes.</p>
<p>I think most of what i'm trying to do is clear to me, but one thing im having trouble fleshing out is the JALR instruction.</p>
<p>My naive approach to solve this is to actually JIT the whole program, interpreting each instruction as a basic block, and basically implementing like a dynamic jump table at runtime.</p>
<p>Im curious to gather feedback and see if anyone can help me think of a better approach to handling these dynamic jumps.</p>
<p>Thank you in advance!</p>



<a name="494467761"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494467761" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494467761">(Jan 18 2025 at 01:34)</a>:</h4>
<p>The classical way of handling indirect jumps in a dynamic binary translation (DBT) system like Valgrind, Pin or Dynamo (to give some keywords to search on!) is to have a big dispatch hashtable from entry-point PC to "trace" or "block" of jit'd code starting at that address. You then compile indirect jumps (or calls) into a sequence that looks up in that hashtable, does a jump to the equivalent native code if present, otherwise invokes the JIT compiler to generate new code (or escape to an interpreter or whatever)</p>



<a name="494467818"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494467818" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494467818">(Jan 18 2025 at 01:35)</a>:</h4>
<p>It sounds like what you're wanting to do is a slightly more precomputed version of that where you handle every individual instruction as a potential entry point ahead of time; probably you'll have much better results if you do it on demand (if your environment permits true JIT), since relatively few instructions will be targets of indirect jumps/calls</p>



<a name="494468540"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494468540" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nate <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494468540">(Jan 18 2025 at 01:45)</a>:</h4>
<p>Thanks for the response, lots of interesting info here.</p>
<p>I think that last part is exactly what im looking to do. I think my next question is, once I do know my entrypoint, say at some pc=X,</p>
<p>How much of the program do I start jitting from pc=X? Until I hit another indirect jump? </p>
<p>Maybe im misunderstanding, but my understanding of what youre saying is that I should basically maintain a mapping, just in time, of pc -&gt; jitted function, but how do i share state between this?</p>



<a name="494468640"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494468640" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nate <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494468640">(Jan 18 2025 at 01:46)</a>:</h4>
<p>And maybe for more clarity I will always be starting off in the interpreter, and then enter the JIT at some arbitrary PC</p>



<a name="494468696"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494468696" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nate <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494468696">(Jan 18 2025 at 01:47)</a>:</h4>
<blockquote>
<p>Maybe im misunderstanding, but my understanding of what youre saying is that I should basically maintain a mapping, just in time, of pc -&gt; jitted function, but how do i share state between this?</p>
</blockquote>
<p>Is it like I might pass in some pointer to my "virtual registers", ie some *mut [Value; 32] and pass this between jitted functions</p>



<a name="494469006"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494469006" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494469006">(Jan 18 2025 at 01:51)</a>:</h4>
<p>Yes, exactly, typically you have a "struct CPUState" and within a jit'd block you can load and store to this, perhaps keeping values in registers (SSA values) until the end; and your interpreter operates on the same state.</p>



<a name="494469062"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494469062" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494469062">(Jan 18 2025 at 01:52)</a>:</h4>
<p>How long to JIT, and whether you follow one path or both sides of a conditional, etc., is an interesting heuristic question that different systems answer differently</p>



<a name="494469133"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494469133" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494469133">(Jan 18 2025 at 01:53)</a>:</h4>
<p>Basically your questions boil down to "how do I design a dynamic binary translation system" and I'd recommend reading at least the Dynamo paper (<a href="https://dl.acm.org/doi/pdf/10.1145/349299.349303">https://dl.acm.org/doi/pdf/10.1145/349299.349303</a>) -- "fragment cache", "trace selection" and all the rest</p>



<a name="494469154"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494469154" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494469154">(Jan 18 2025 at 01:53)</a>:</h4>
<p>Valgrind is a good open-source contemporary example of a system like this, and you may find it instructive to read their internal docs and source too</p>



<a name="494469226"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494469226" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nate <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494469226">(Jan 18 2025 at 01:54)</a>:</h4>
<p>Awesome thank you very much!</p>



<a name="494544525"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494544525" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nate <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494544525">(Jan 18 2025 at 18:53)</a>:</h4>
<p><span class="user-mention" data-user-id="254389">@Chris Fallin</span> Last question for now would be which do you think is better for my registers, the stack operations vs the <code>*mut [Value; u32]</code> approach?</p>
<p>Couldnt find much info on how cranelift treats/reasons about the stack assignments, are they persistent between functions from the same context?</p>



<a name="494544927"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/494544927" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#494544927">(Jan 18 2025 at 18:58)</a>:</h4>
<p>Cranelift has stackslots but they are local to the current function; so if you need to store state that persists across different compiled instruction traces and your interpreter (I think you do, for CPU registers?) then you'll want to emit normal loads and stores to an array of values in memory</p>



<a name="495180287"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/495180287" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nate <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#495180287">(Jan 22 2025 at 01:53)</a>:</h4>
<p>Hey <span class="user-mention" data-user-id="254389">@Chris Fallin</span> ive made alot of progress already and its been such a pleasure to use Cranelift so far!</p>
<p>No pressure at all, but im curious if you would have some insight on how to implement this function correctly, as it fails during (Cranelift) compilation with </p>
<p><code>failed to compile: Compilation(Verifier(VerifierErrors([VerifierError { location: inst3, context: Some("jump block1(v8)"), message: "uses value arg from non-dominating block1" }])))</code></p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="cp">#[tracing::instrument(skip_all, fields(opcode = instruction.opcode.mnemonic(), pc = pc))]</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">translate_branch</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">instruction</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Instruction</span><span class="p">,</span><span class="w"> </span><span class="n">pc</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">BuilderResult</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">tracing</span><span class="p">::</span><span class="n">trace</span><span class="o">!</span><span class="p">(</span><span class="s">"Translating branch"</span><span class="p">);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">rs1</span><span class="p">,</span><span class="w"> </span><span class="n">rs2</span><span class="p">,</span><span class="w"> </span><span class="n">imm</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instruction</span><span class="p">.</span><span class="n">b_type</span><span class="p">();</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">rs1_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">load</span><span class="p">(</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">int_32_type</span><span class="p">,</span>
<span class="w">            </span><span class="n">MemFlags</span><span class="p">::</span><span class="n">trusted</span><span class="p">(),</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">registers_ptr</span><span class="p">,</span>
<span class="w">            </span><span class="n">rs1</span><span class="p">.</span><span class="n">register_offset</span><span class="p">(),</span>
<span class="w">        </span><span class="p">);</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">rs2_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">load</span><span class="p">(</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">int_32_type</span><span class="p">,</span>
<span class="w">            </span><span class="n">MemFlags</span><span class="p">::</span><span class="n">trusted</span><span class="p">(),</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">registers_ptr</span><span class="p">,</span>
<span class="w">            </span><span class="n">rs2</span><span class="p">.</span><span class="n">register_offset</span><span class="p">(),</span>
<span class="w">        </span><span class="p">);</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">cond</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">instruction</span><span class="p">.</span><span class="n">opcode</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Opcode</span><span class="p">::</span><span class="n">BEQ</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">icmp</span><span class="p">(</span><span class="n">IntCC</span><span class="p">::</span><span class="n">Equal</span><span class="p">,</span><span class="w"> </span><span class="n">rs1_val</span><span class="p">,</span><span class="w"> </span><span class="n">rs2_val</span><span class="p">),</span>
<span class="w">            </span><span class="n">Opcode</span><span class="p">::</span><span class="n">BNE</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">icmp</span><span class="p">(</span><span class="n">IntCC</span><span class="p">::</span><span class="n">NotEqual</span><span class="p">,</span><span class="w"> </span><span class="n">rs1_val</span><span class="p">,</span><span class="w"> </span><span class="n">rs2_val</span><span class="p">),</span>
<span class="w">            </span><span class="n">Opcode</span><span class="p">::</span><span class="n">BLT</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">icmp</span><span class="p">(</span><span class="n">IntCC</span><span class="p">::</span><span class="n">SignedLessThan</span><span class="p">,</span><span class="w"> </span><span class="n">rs1_val</span><span class="p">,</span><span class="w"> </span><span class="n">rs2_val</span><span class="p">),</span>
<span class="w">            </span><span class="n">Opcode</span><span class="p">::</span><span class="n">BGE</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">icmp</span><span class="p">(</span><span class="n">IntCC</span><span class="p">::</span><span class="n">SignedGreaterThanOrEqual</span><span class="p">,</span><span class="w"> </span><span class="n">rs1_val</span><span class="p">,</span><span class="w"> </span><span class="n">rs2_val</span><span class="p">)</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">Opcode</span><span class="p">::</span><span class="n">BLTU</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">icmp</span><span class="p">(</span><span class="n">IntCC</span><span class="p">::</span><span class="n">UnsignedLessThan</span><span class="p">,</span><span class="w"> </span><span class="n">rs1_val</span><span class="p">,</span><span class="w"> </span><span class="n">rs2_val</span><span class="p">),</span>
<span class="w">            </span><span class="n">Opcode</span><span class="p">::</span><span class="n">BGEU</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">icmp</span><span class="p">(</span><span class="n">IntCC</span><span class="p">::</span><span class="n">UnsignedGreaterThanOrEqual</span><span class="p">,</span><span class="w"> </span><span class="n">rs1_val</span><span class="p">,</span><span class="w"> </span><span class="n">rs2_val</span><span class="p">)</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">unreachable!</span><span class="p">(),</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// If weve already visited this branch point, jump to it.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">branch_block</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">branch_points</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">tracing</span><span class="p">::</span><span class="n">trace</span><span class="o">!</span><span class="p">(</span><span class="s">"Found a branch we already know about: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">pc</span><span class="p">);</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">jump</span><span class="p">(</span><span class="o">*</span><span class="n">branch_block</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">cond</span><span class="p">]);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">BuilderResult</span><span class="p">::</span><span class="n">Branch</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">branch_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">branch_points</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span><span class="w"> </span><span class="n">branch_block</span><span class="p">);</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">cond_param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">append_block_param</span><span class="p">(</span><span class="n">branch_block</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">int_32_type</span><span class="p">);</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">jump</span><span class="p">(</span><span class="n">branch_block</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">cond_param</span><span class="p">]);</span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">branch_block</span><span class="p">);</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">branched</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">not_branched</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">brif</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span><span class="w"> </span><span class="n">branched</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[],</span><span class="w"> </span><span class="n">not_branched</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span>

<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">branched</span><span class="p">);</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">seal_block</span><span class="p">(</span><span class="n">branched</span><span class="p">);</span>

<span class="w">        </span><span class="n">BuilderResult</span><span class="p">::</span><span class="n">NewBranch</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">target</span><span class="p">:</span><span class="w"> </span><span class="nc">pc</span><span class="p">.</span><span class="n">wrapping_add</span><span class="p">(</span><span class="n">imm</span><span class="p">),</span><span class="w"> </span><span class="n">not_branched</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<p>I beleive the problem is here:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">        </span><span class="c1">// If weve already visited this branch point, jump to it.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">branch_block</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">branch_points</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">tracing</span><span class="p">::</span><span class="n">trace</span><span class="o">!</span><span class="p">(</span><span class="s">"Found a branch we already know about: {}"</span><span class="p">,</span><span class="w"> </span><span class="n">pc</span><span class="p">);</span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">jump</span><span class="p">(</span><span class="o">*</span><span class="n">branch_block</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">cond</span><span class="p">]);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">BuilderResult</span><span class="p">::</span><span class="n">Branch</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
</code></pre></div>
<p>Basically I think we can encounter a situation when translating like a for loop that says something like</p>
<ul>
<li>do loop</li>
<li>if condition branch to the beginning</li>
<li>else continue</li>
</ul>
<p>so my strategy is to store these branch points, and immediately eval the case where we branched, (since its an immediate offset) sure this means we might have some overlapping instructions in diff blocks but thats ok for now.</p>
<p>If i hit this branch at this pc again, then I can signal to "translator" to follow the non branch case, but this is where the error comes from</p>
<p>Thanks for all the help so far!</p>



<a name="495181811"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/495181811" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nate <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#495181811">(Jan 22 2025 at 02:08)</a>:</h4>
<p>The error message I think makes sense, cond comes from a block that is like a successor of the branch block, but im curious f theres like an obvious way to make this work im not seeing</p>



<a name="495193728"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/495193728" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#495193728">(Jan 22 2025 at 04:03)</a>:</h4>
<p>the error message is indicating that an SSA invariant is not valid -- basically you're using a value that isn't always set on all paths into a use-point (that's the "non-dominating block" bit)</p>



<a name="495193809"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/495193809" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#495193809">(Jan 22 2025 at 04:04)</a>:</h4>
<p>the high-level idea is that you need to add block params whenever you have a "merge point" -- control flow coming in and a use that comes from one of several defs in the joining paths</p>



<a name="495193840"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/495193840" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#495193840">(Jan 22 2025 at 04:05)</a>:</h4>
<p>if you're tracking SSA values for registers in the translated riscv32 code, I suspect the simplest way about this will be to have a block param for each machine register on every basic block</p>



<a name="495193887"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/495193887" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#495193887">(Jan 22 2025 at 04:05)</a>:</h4>
<p>(there are more optimal ways, but you'll need to get more into SSA construction algorithms to get there -- the above should be sufficient to get a correct compilation)</p>



<a name="495348460"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/495348460" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Notification Bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#495348460">(Jan 22 2025 at 18:24)</a>:</h4>
<p>This topic was moved here from <a class="stream-topic" data-stream-id="206238" href="/#narrow/channel/206238-general/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs">#general &gt; (open discussion) JIT only parts of an unstructured programs</a> by <span class="user-mention silent" data-user-id="234973">Till Schneidereit</span>.</p>



<a name="495378286"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/495378286" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#495378286">(Jan 22 2025 at 21:38)</a>:</h4>
<p><span class="user-mention" data-user-id="868311">@Nate</span> You may be interested in <a href="https://github.com/Amanieu/a-tale-of-binary-translation">https://github.com/Amanieu/a-tale-of-binary-translation</a> which seems to be exactly what your are trying to do. It's a simple binary translator that I developed as a teaching example which targets RV32I.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/Amanieu/a-tale-of-binary-translation" style="background-image: url(&quot;https://uploads.zulipusercontent.net/63b543597ba0bc50240f845eec403dbe422f49e7/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f653334386530613431386236323234646231343163396162643661653131383837626462343731353839396632643637333434393530643732623363643039372f416d616e6965752f612d74616c652d6f662d62696e6172792d7472616e736c6174696f6e&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/Amanieu/a-tale-of-binary-translation" title="GitHub - Amanieu/a-tale-of-binary-translation: Simple RISC-V emulator presented at Rust Nation 2023">GitHub - Amanieu/a-tale-of-binary-translation: Simple RISC-V emulator presented at Rust Nation 2023</a></div><div class="message_embed_description">Simple RISC-V emulator presented at Rust Nation 2023 - Amanieu/a-tale-of-binary-translation</div></div></div>



<a name="495383110"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/495383110" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#495383110">(Jan 22 2025 at 22:12)</a>:</h4>
<p>This is the cranelift backend: <a href="https://github.com/Amanieu/a-tale-of-binary-translation/blob/master/src/backend/jit/cranelift.rs">https://github.com/Amanieu/a-tale-of-binary-translation/blob/master/src/backend/jit/cranelift.rs</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/Amanieu/a-tale-of-binary-translation/blob/master/src/backend/jit/cranelift.rs" style="background-image: url(&quot;https://uploads.zulipusercontent.net/63b543597ba0bc50240f845eec403dbe422f49e7/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f653334386530613431386236323234646231343163396162643661653131383837626462343731353839396632643637333434393530643732623363643039372f416d616e6965752f612d74616c652d6f662d62696e6172792d7472616e736c6174696f6e&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/Amanieu/a-tale-of-binary-translation/blob/master/src/backend/jit/cranelift.rs" title="a-tale-of-binary-translation/src/backend/jit/cranelift.rs at master 路 Amanieu/a-tale-of-binary-translation">a-tale-of-binary-translation/src/backend/jit/cranelift.rs at master 路 Amanieu/a-tale-of-binary-translation</a></div><div class="message_embed_description">Simple RISC-V emulator presented at Rust Nation 2023 - Amanieu/a-tale-of-binary-translation</div></div></div>



<a name="495818899"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/495818899" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nate <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#495818899">(Jan 25 2025 at 01:13)</a>:</h4>
<p>I was actually able to get this to work end to end! Appreciate the additional resources! Were getting something like 15x speed up over the interpreter, and its only a bit slower than native (due to it being 32 bit taget were translating)</p>



<a name="495818976"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/495818976" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nate <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#495818976">(Jan 25 2025 at 01:14)</a>:</h4>
<p>(The solution was that we should compute the branch condition in the branch block, rather than passing it from the current block)</p>



<a name="495819413"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/%28open%20discussion%29%20JIT%20only%20parts%20of%20an%20unstructured%20programs/near/495819413" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nate <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs.html#495819413">(Jan 25 2025 at 01:19)</a>:</h4>
<p>Once its public ill share here as well!</p>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>