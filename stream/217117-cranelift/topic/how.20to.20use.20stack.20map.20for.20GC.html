<html>
<head><meta charset="utf-8"><title>how to use stack map for GC · cranelift · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/index.html">cranelift</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html">how to use stack map for GC</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="539147384"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/539147384" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> dwuggh <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#539147384">(Sep 12 2025 at 19:01)</a>:</h4>
<p>hello, I'm writing an JIT lisp intepreter using cranelift, which is a Gc'd language. I see that cranelift has <code>declare_var_in_stack_map</code> and <code>UserStackMap</code> struct, but how should I actually use it? I only find that <code>MachBuffer</code> has some functions and fields about it, but I still don't know how to get the stack map information.</p>



<a name="539272712"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/539272712" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Till Schneidereit <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#539272712">(Sep 13 2025 at 13:46)</a>:</h4>
<p><span class="user-mention" data-user-id="253990">@fitzgen (he/him)</span> would probably be the best person to give good answers, but one thing you might want to look at is the <a href="https://github.com/bytecodealliance/wasmtime/pull/9082">PR</a> that introduced Wasmtime's usage of Cranelift's user stack maps, as well as the current state of the files introduced by that PR</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/pull/9082" style="background-image: url(&quot;https://uploads.zulipusercontent.net/a881ed39943691448b9e5b933c9f38c66cee635f/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f396530663463613330386162346434623830323635633235636535613765316335623239383962636236366537346166383362376364313336313363326364392f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f39303832&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/pull/9082" title="Switch to new &quot;user&quot; stack maps and use `i32` for GC refs in Wasmtime by fitzgen · Pull Request #9082 · bytecodealliance/wasmtime">Switch to new "user" stack maps and use `i32` for GC refs in Wasmtime by fitzgen · Pull Request #9082 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">This moves Wasmtime over from the old, regalloc-based stack maps system to the new &quot;user&quot; stack maps system.
Removing the old regalloc-based stack maps system is left for follow-up work.
...</div></div></div>



<a name="539276486"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/539276486" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> dwuggh <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#539276486">(Sep 13 2025 at 14:43)</a>:</h4>
<p>thanks, I'll look into it right away</p>



<a name="539611424"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/539611424" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fitzgen (he/him) <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#539611424">(Sep 15 2025 at 17:08)</a>:</h4>
<p>you can get them from the <code>MachBufferFinalized</code> compilation output via the <code>user_stack_maps</code> and <code>take_user_stack_maps</code> methods</p>
<p><a href="https://docs.rs/cranelift-codegen/latest/cranelift_codegen/struct.MachBufferFinalized.html#method.user_stack_maps">https://docs.rs/cranelift-codegen/latest/cranelift_codegen/struct.MachBufferFinalized.html#method.user_stack_maps</a></p>



<a name="539611462"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/539611462" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fitzgen (he/him) <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#539611462">(Sep 15 2025 at 17:09)</a>:</h4>
<p>happy to answer more specific questions if you have them</p>



<a name="542696807"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/542696807" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> dwuggh <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#542696807">(Oct 02 2025 at 09:31)</a>:</h4>
<p><span class="user-mention" data-user-id="253990">@fitzgen (he/him)</span> Hi, could you please check whether my following statement is correct:</p>
<p>My understandings:</p>
<ul>
<li><em>safepoint</em> is placed at every (non-tail) call, in cranelift, it is</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">()</span>
<span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call_indirect</span><span class="p">()</span>
</code></pre></div>
<ul>
<li>
<p>to do stack walking(without libunwind), I need to pass fp to <code>gc_collect</code>, and walk through<br>
the fp linked list</p>
</li>
<li>
<p>the user stack maps can be saved globally, with form <code>[(CodeOffset, span, ir::UserStackMap)]</code>,<br>
the <code>CodeOffset</code> here is the offset to the function pointer retrieved by <code>get_finalized_function</code>.<br>
this list records all the functions' stack map that are called inside the function we are compiling, in other words, the stack maps record its callee's stack map. Specifically, suppose I'm compiling <code>foo</code> which called <code>bar</code>:</p>
</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// in foo</span>
<span class="n">builder</span><span class="p">().</span><span class="n">declare_var_in_stack_map</span><span class="p">(</span><span class="n">var</span><span class="p">);</span><span class="w"> </span><span class="c1">// record local variable</span>
<span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call_indirect</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">var</span><span class="p">]);</span><span class="w"> </span><span class="c1">// pesudo code, call bar with value of var</span>
<span class="c1">// this call will emit a stackmap used by calling bar</span>
</code></pre></div>
<ul>
<li>during stack walking, I can get ip by (fp + 8) (loading from address), which is the <em>return address(RA)</em> of this funcall. I should lookup RA in the global stack map table, and if I find a match: </li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">ra</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">func_ptr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">CodeOffset</span>
</code></pre></div>
<p>then the stack map is found. Then I can get the entries by</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">parent_fp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fp</span><span class="p">.</span><span class="n">parent</span><span class="p">()</span><span class="w"> </span><span class="c1">// the fp linked list, accessed by (fp)</span>
<span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parent_fp</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">span</span><span class="p">;</span>
<span class="p">(</span><span class="n">sp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">sp_offset</span><span class="p">)</span><span class="w"> </span><span class="c1">// access stack slot</span>
</code></pre></div>
<p>question:</p>
<ul>
<li>How to properly call <code>gc_collect</code> at safepoint? Should I call them right before <code>call</code> or <code>call_indirect</code> instruction, or place them at the beginning of a function? The document said that safepoints cannot be skipped, but if we have to call gc on our own, then obviously we are able to choose to skip it.</li>
<li>is <code>span</code> just the callee's frame size? In the source code, it is computed via <code>emit_state.frame_layout().active_size()</code>, I assume they are identical</li>
<li>I'm especially uncertain of the last understanding. should I use <code>fp</code> or <code>parent_fp</code>? Why are we using SP-relative offsets, instead of FP-relative which saves <code>span</code>?</li>
</ul>
<p>thanks in advance!</p>



<a name="542700493"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/542700493" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> dwuggh <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#542700493">(Oct 02 2025 at 09:51)</a>:</h4>
<p>another question:</p>
<ul>
<li>I'm compiling a dynamic language, so probably every value need to be marked as need stack map in the baseline JIT. The question is, I should mark the variables on caller or callee?</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// inside foo</span>
<span class="n">declare_variable_needs_stack_map</span><span class="p">(</span><span class="n">a</span><span class="p">);</span><span class="w"> </span><span class="c1">// a is some local variable here</span>
<span class="n">call</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="c1">// or it should just be:</span>
<span class="n">call</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span>
<span class="c1">// and inside bar, suppose bar is defined like</span>
<span class="c1">// def bar(arg):</span>
<span class="c1">//      # codes</span>
<span class="n">declare_variable_needs_stack_map</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
</code></pre></div>
<p>in my understanding, I need to use the first approach because <code>a</code> and <code>arg</code> are different variables, and cranelift's compilation do not across functions, so the stack map in approach 2 cannot be found in <code>foo</code>. I currently declares everything so both approach 1 and 2. Is this redundant, that I only have to declare those local variables  which act as arguments?</p>



<a name="542790890"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/542790890" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fitzgen (he/him) <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#542790890">(Oct 02 2025 at 17:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="961161">dwuggh</span> <a href="#narrow/channel/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC/near/542696807">said</a>:</p>
<blockquote>
<ul>
<li><em>safepoint</em> is placed at every (non-tail) call, in cranelift, it is</li>
</ul>
</blockquote>
<p>Correct</p>
<p><span class="user-mention silent" data-user-id="961161">dwuggh</span> <a href="#narrow/channel/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC/near/542696807">said</a>:</p>
<blockquote>
<ul>
<li>to do stack walking(without libunwind), I need to pass fp to <code>gc_collect</code>, and walk through<br>
  the fp linked list</li>
</ul>
</blockquote>
<p>I mean you can also implement your own DWARF-based stack walker without using libunwind, but if you are using frame pointers to walk the stack then yeah you need to get the first frame pointer somehow. Note that, unless you can guarantee that all code on the stack (rust, C, whatever shared libraries, etc) are using frame pointers, then you need to take care to only load from the FP when you 100% know it is actually a frame pointer, otherwise you risk UB (treating the contents of a general purpose register as a pointer and derefing it). The way wasmtime handles this is with trampolines at the host&lt;--&gt;wasm boundary that record FP/SP in a runtime structure on the side and let us bound the stack walk (and its FP-derefing) to within <em>only</em> the cranelift-emitted frames</p>
<p><span class="user-mention silent" data-user-id="961161">dwuggh</span> <a href="#narrow/channel/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC/near/542696807">said</a>:</p>
<blockquote>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// in foo</span>
<span class="n">builder</span><span class="p">().</span><span class="n">declare_var_in_stack_map</span><span class="p">(</span><span class="n">var</span><span class="p">);</span><span class="w"> </span><span class="c1">// record local variable</span>
<span class="n">builder</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call_indirect</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[</span><span class="n">var</span><span class="p">]);</span><span class="w"> </span><span class="c1">// pesudo code, call bar with value of var</span>
<span class="c1">// this call will emit a stackmap used by calling bar</span>
</code></pre></div><br>
</p>
</blockquote>
<p>we will only emit a stack map entry for <code>var</code> if it is live across the call; if it is only passed in to <code>bar</code> as an argument, then it is <code>bar</code>'s responsibility to keep it alive (via inclusion in stack maps or the host rooting it or whatever) or not (if the program doesn't actually keep using the value)</p>
<p><span class="user-mention silent" data-user-id="961161">dwuggh</span> <a href="#narrow/channel/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC/near/542696807">said</a>:</p>
<blockquote>
<ul>
<li>during stack walking, I can get ip by (fp + 8) (loading from address), which is the <em>return address(RA)</em> of this funcall</li>
</ul>
</blockquote>
<p>these details are architecture and ABI dependent, but yes that describes e.g. x86-64 with sys-v</p>
<p><span class="user-mention silent" data-user-id="961161">dwuggh</span> <a href="#narrow/channel/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC/near/542696807">said</a>:</p>
<blockquote>
<ul>
<li>How to properly call <code>gc_collect</code> at safepoint? Should I call them right before <code>call</code> or <code>call_indirect</code> instruction, or place them at the beginning of a function? The document said that safepoints cannot be skipped, but if we have to call gc on our own, then obviously we are able to choose to skip it.</li>
</ul>
</blockquote>
<p>there are roughly two cases:</p>
<ol>
<li>you are calling from a source language function to another source language function (eg wasm function calling another wasm function in wasmtime) and the callee triggers a GC somehow. in this case, the caller doesn't need to do anything, the GC will walk the stack and see the caller frame and its stack maps at the call site</li>
<li>you are calling from a source language function to a runtime function (e.g. a wasm function calling the wasmtime internal helper for allocating a GC object). in this case, if the allocation cannot be satisfied because there isn't space in the gc heap or whatever, then the host routine should trigger a GC. again, the caller function doesn't need to do anything special, it just makes the call to the host routine and the GC will walk the stack and see the stack maps at the call site.</li>
</ol>
<p>a sub-case of (2) is "I want to call the GC routine directly from a source function, for whatever reason". I think this is what you mean be <code>gc_collect</code>. In this sub-case, you do the exact same thing as the general (2) case: just call the host routine and then the host routine will trigger GC, walk the stack, see the stack maps at the caller's call site, and after it has collected all the on-stack GC roots can proceed with garbage collection</p>
<p><span class="user-mention silent" data-user-id="961161">dwuggh</span> <a href="#narrow/channel/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC/near/542696807">said</a>:</p>
<blockquote>
<ul>
<li>is <code>span</code> just the callee's frame size? In the source code, it is computed via <code>emit_state.frame_layout().active_size()</code>, I assume they are identical</li>
</ul>
</blockquote>
<p>roughly. it is the region of the stack that is covered by the stack map. in theory the end could be trimmed to stop after the last stack slot containing a gc ref, rather than cover the whole stack frame.</p>
<p><span class="user-mention silent" data-user-id="961161">dwuggh</span> <a href="#narrow/channel/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC/near/542696807">said</a>:</p>
<blockquote>
<ul>
<li>I'm especially uncertain of the last understanding. should I use <code>fp</code> or <code>parent_fp</code>? Why are we using SP-relative offsets, instead of FP-relative which saves <code>span</code>?</li>
</ul>
</blockquote>
<p>I'm not sure there is a great reason. this code has evolved organically over the years and it is possible that we've ended up in some local maximums. I don't off the top of my head remember what things are relative to, I'd review the doc comments and if that doesn't give you an answer, then look at what wasmtime does (and use rust-analyzer or github search to follow function and type references to get a larger picture of how things are used):</p>
<p><a href="https://github.com/bytecodealliance/wasmtime/blob/7cebfa206fe4a40ab54e9862f30b05c5fefb9043/crates/wasmtime/src/runtime/store.rs#L1867">https://github.com/bytecodealliance/wasmtime/blob/7cebfa206fe4a40ab54e9862f30b05c5fefb9043/crates/wasmtime/src/runtime/store.rs#L1867</a></p>
<p><span class="user-mention silent" data-user-id="961161">dwuggh</span> <a href="#narrow/channel/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC/near/542700493">said</a>:</p>
<blockquote>
<ul>
<li>I should mark the variables on caller or callee?</li>
</ul>
</blockquote>
<p>almost definitely both. you technically can try and do global reasoining about "I don't need to keep this in stack maps because all callees that I call will already do so" but this is pretty tricky and fragile. best to follow the discipline of "is this a gc value? then put it in stack maps"</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/blob/7cebfa206fe4a40ab54e9862f30b05c5fefb9043/crates/wasmtime/src/runtime/store.rs#L1867" style="background-image: url(&quot;https://uploads.zulipusercontent.net/5a223459f56a970f059de25825e4d971d0df7541/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f646264366532623664363530333263326339626561613065646361623133343062626238326234323261303630333234313936393938343331613662623362332f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/blob/7cebfa206fe4a40ab54e9862f30b05c5fefb9043/crates/wasmtime/src/runtime/store.rs#L1867" title="wasmtime/crates/wasmtime/src/runtime/store.rs at 7cebfa206fe4a40ab54e9862f30b05c5fefb9043 · bytecodealliance/wasmtime">wasmtime/crates/wasmtime/src/runtime/store.rs at 7cebfa206fe4a40ab54e9862f30b05c5fefb9043 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>



<a name="543078255"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/543078255" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> dwuggh <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#543078255">(Oct 04 2025 at 10:47)</a>:</h4>
<p>thanks! I've succeed on using frame pointers to retrieve stackmap. </p>
<blockquote>
<p>The way wasmtime handles this is with trampolines at the host&lt;--&gt;wasm boundary that record FP/SP in a runtime structure on the side and let us bound the stack walk (and its FP-derefing) to within <em>only</em> the cranelift-emitted frames</p>
</blockquote>
<p>Is this the technique using in unwinder crate? I've read it from <a href="https://github.com/bytecodealliance/wasmtime/pull/11710">https://github.com/bytecodealliance/wasmtime/pull/11710</a>, and there seems to be some relevant code. but <code>cfallin</code> there also said that</p>
<blockquote>
<ul>
<li>No, Wasmtime's unwinder has nothing to do with native stack frames</li>
</ul>
</blockquote>
<blockquote>
<p>I mean you can also implement your own DWARF-based stack walker without using libunwind</p>
</blockquote>
<p>not familiar with this for now, adding it to my roadmap</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/pull/11710" style="background-image: url(&quot;https://uploads.zulipusercontent.net/fa2998ce1db9ed5fa3d05c57615165a5eac94d37/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f376532613136356133656462356533386564373138663235356462373732353865643137353739376562343731306638343235623935313465353038373534312f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3131373130&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/pull/11710" title="docs: add documentation and example of using stack maps for GC by maxnatamo · Pull Request #11710 · bytecodealliance/wasmtime">docs: add documentation and example of using stack maps for GC by maxnatamo · Pull Request #11710 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">Adds a documentation entry for how stack maps might be used to implement a garbage collector.
Adds an example project which shows off how a simple garbage collector might actually be implemented. C...</div></div></div>



<a name="543111577"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/543111577" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#543111577">(Oct 04 2025 at 19:27)</a>:</h4>
<blockquote>
<p>Is this the technique [saving FP in a trampoline] using in unwinder crate?</p>
</blockquote>
<p>It's what Wasmtime does, yes. The actual save/restore happens in Cranelift-generated trampolines -- see <a href="https://github.com/bytecodealliance/wasmtime/blob/3a136421d433a4951f1164c97a27db5e6b5f0f02/crates/cranelift/src/compiler.rs#L1466-L1480">here</a>.</p>
<p>I'll note as well re this</p>
<blockquote>
<p><code>cfallin</code> there also said that<br>
* No, Wasmtime's unwinder has nothing to do with native stack frames<br>
I mean you can also implement your own DWARF-based stack walker without using libunwind<br>
not familiar with this for now, adding it to my roadmap</p>
</blockquote>
<p>that in the context I said that, someone was asking about observing frames of functions compiled by rustc; and I was stating that Wasmtime's functionality has nothing to offer here unfortunately, as system-native compilers (like rustc) have different ways of describing frame layouts.</p>
<p>That said, in most language-runtime situations, you would probably use a different technique to root GC refs in your runtime/host-side code anyway (e.g. see our <code>Rooted</code> abstraction in Wasmtime) so it's not necessary to directly trace host frames. In other words, the direct stack-walk may only have to visit frames from Cranelift-compiled code, depending on how you architect things.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/blob/3a136421d433a4951f1164c97a27db5e6b5f0f02/crates/cranelift/src/compiler.rs#L1466-L1480" style="background-image: url(&quot;https://uploads.zulipusercontent.net/bb9523c560db40a06a5ef6e59b68153a162744d8/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f613434616136636561346335343238383762643637653336356463636336313935656563363663343537383962663361623562343366643935363232336332322f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/blob/3a136421d433a4951f1164c97a27db5e6b5f0f02/crates/cranelift/src/compiler.rs#L1466-L1480" title="wasmtime/crates/cranelift/src/compiler.rs at 3a136421d433a4951f1164c97a27db5e6b5f0f02 · bytecodealliance/wasmtime">wasmtime/crates/cranelift/src/compiler.rs at 3a136421d433a4951f1164c97a27db5e6b5f0f02 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>



<a name="543112069"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/543112069" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> dwuggh <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#543112069">(Oct 04 2025 at 19:37)</a>:</h4>
<p>thanks, I understand it now, probably because I misunderstood what "native" actually means due to my bad english</p>



<a name="543112485"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/543112485" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#543112485">(Oct 04 2025 at 19:46)</a>:</h4>
<p>sorry, really it was my imprecision -- "native" in the sense of "native system compilers" like rustc/clang as opposed to a language runtime's builtin one. Cranelift code's frames are still "native" in that they are frames created by real machine code :-)</p>



<a name="543113301"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/543113301" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> dwuggh <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#543113301">(Oct 04 2025 at 20:01)</a>:</h4>
<p>just saw <a href="https://github.com/bytecodealliance/wasmtime/commit/2a2e8f62b9f20606f89a2e6619d6ece22eb57001">https://github.com/bytecodealliance/wasmtime/commit/2a2e8f62b9f20606f89a2e6619d6ece22eb57001</a>, is <code>enable_safepoints</code> option deprecated/removed due to the new user stack map?</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/commit/2a2e8f62b9f20606f89a2e6619d6ece22eb57001" style="background-image: url(&quot;https://uploads.zulipusercontent.net/ed7853fc8eff557bff777c3cd22e4b60f039aef5/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f613966383764393033383439353038316361373863313538626631336561386137336637353035396661626362663930333565613835656232396235666138372f62797465636f6465616c6c69616e63652f7761736d74696d652f636f6d6d69742f32613265386636326239663230363036663839613265363631396436656365323265623537303031&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/commit/2a2e8f62b9f20606f89a2e6619d6ece22eb57001" title="Couple cleanups to the flags/settings handling in Cranelift (#11744) · bytecodealliance/wasmtime@2a2e8f6">Couple cleanups to the flags/settings handling in Cranelift (#11744) · bytecodealliance/wasmtime@2a2e8f6</a></div><div class="message_embed_description">* Remove unused shared flags

* Get rid of predicate settings

They were important in the old backend framework, but with the new
backend framework if we need a combination of multiple settings, th...</div></div></div>



<a name="543118539"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/how%20to%20use%20stack%20map%20for%20GC/near/543118539" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/how.20to.20use.20stack.20map.20for.20GC.html#543118539">(Oct 04 2025 at 21:42)</a>:</h4>
<p>Right, at a high level, "user stack maps" means that Cranelift doesn't have a concept of safepoints anymore. It only has the ability to lower (user) stack maps to refer to compiled function frame offsets. Nick's post at <a href="https://bytecodealliance.org/articles/new-stack-maps-for-wasmtime">https://bytecodealliance.org/articles/new-stack-maps-for-wasmtime</a> details more of the reasoning for this</p>
<div class="message_embed"><a class="message_embed_image" href="https://bytecodealliance.org/articles/new-stack-maps-for-wasmtime" style="background-image: url(&quot;https://uploads.zulipusercontent.net/b666ca74a20745aca2566cd241108afdcfa09d04/68747470733a2f2f62797465636f6465616c6c69616e63652e6f72672f696d616765732f6176617461722e706e67&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://bytecodealliance.org/articles/new-stack-maps-for-wasmtime" title="New Stack Maps for Wasmtime and Cranelift">New Stack Maps for Wasmtime and Cranelift</a></div><div class="message_embed_description">As part of implementing the WebAssembly garbage collection proposal in Wasmtime,which is an ongoing process, we’ve overhauled the stack map infrastructure inCranelift. This post will explain what stack maps are, why we needed to changeth...</div></div></div>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>