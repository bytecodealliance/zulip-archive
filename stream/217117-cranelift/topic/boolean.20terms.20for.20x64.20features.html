<html>
<head><meta charset="utf-8"><title>boolean terms for x64 features · cranelift · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/index.html">cranelift</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html">boolean terms for x64 features</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="529180399"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529180399" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Andrew Brown <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529180399">(Jul 16 2025 at 23:23)</a>:</h4>
<p>While fixing up an EVEX PR, I <a href="https://github.com/bytecodealliance/wasmtime/pull/11153#discussion_r2211605389">noted</a> that we currently don't handle the feature logic in a complete way. Currently we only have an OR operator, <code>|</code>, for concatenating features into a too-simple boolean term: <code>32-bit OR 64-bit OR ...</code>. <span class="user-mention" data-user-id="253994">@Alex Crichton</span> brought up, correctly I believe, that everything still works out because we build up a list of all the features we expect to see, essentially treating these ORs as ANDs--so, for now, all is well (or at least overly restrictive in a safe way).</p>
<p>If in the future we want to use the new assembler for 32-bit compatibility mode, our current scheme breaks down: we need to write <code>(32-bit OR 64-bit) AND ....</code> for instructions that are valid in this mode and then actually check that the target features include <code>32-bit</code>. We eventually will have the same problem with AVX10 instructions, since we'll see CPUs that have either AVX512 feature or AVX10 features (?) and we'll need to calculate a boolean term like: <code>(32-bit OR 64-bit) AND ((AVX512VL AND AVX512F) OR AVX10.1)</code>.</p>
<p>I was planning to build out the functionality to evaluate these boolean terms but thought I would check here first: is there any reason _not_ to prefer a more complete implementation? The main one I can think of is performance: perhaps evaluating the boolean term is slower than the current approach of building up a <code>Vec</code> and running <code>iter().all(matches_isa_flags)</code> on it (?). I suspect we could mitigate this with some memoization, where we hash the feature set and store off a boolean for each unique feature set to avoid re-evaluating the term. But, then again, this might be overkill.</p>
<p>Any thoughts on this?</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/pull/11153#discussion_r2211605389" style="background-image: url(&quot;https://uploads.zulipusercontent.net/6ac84d9b6d3dcd4bc4dccab5c0a61ff0bc06c05a/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f383762366464653861633730343337613830306333343235643736663434333634356637343861616663626431383139666563323936313361363133373466382f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3131313533&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/pull/11153#discussion_r2211605389" title="x64: EVEX Encoding for new assembler by rahulchaphalkar · Pull Request #11153 · bytecodealliance/wasmtime">x64: EVEX Encoding for new assembler by rahulchaphalkar · Pull Request #11153 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">Adds evex encoding for new assembler.
Adds vaddpd evex instr.
Following items are not implemented in this PR / left out intentionally -

Broadcast attribute (bcst). Will be implemented in future pr...</div></div></div>



<a name="529180498"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529180498" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Andrew Brown <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529180498">(Jul 16 2025 at 23:24)</a>:</h4>
<p>cc: <span class="user-mention" data-user-id="253994">@Alex Crichton</span>, <span class="user-mention" data-user-id="254389">@Chris Fallin</span>, <span class="user-mention" data-user-id="253990">@fitzgen (he/him)</span></p>



<a name="529180722"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529180722" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529180722">(Jul 16 2025 at 23:28)</a>:</h4>
<p>Having a little boolean expression grammar seems reasonable to me!</p>



<a name="529183042"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529183042" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529183042">(Jul 17 2025 at 00:01)</a>:</h4>
<p>I've been a little worried about the preexisting inefficiency of the current implementation, but it's never bubbled up enough that I've bothered to worry about it. In the current system it feels pretty inefficient codegen-wise to generate source that, for each instrution, builds a vec that is mostly a bitset. Then at runtime we, for each instruction, allocate this vector, transform it into a small vector, then iterate over the small vector, then check the bits.</p>
<p>I have no doubts that this could all be far more efficient though. For example we could probably remove <code>available_in_any_isa</code> entirely to operating exclusively on assembler instructions (as they're basically the only ones left) and then we could generate a function that takes the IsaFlags directly (sort of, probably via a trait since it's in another crate) and tests whether it's valid.</p>
<p>Effectively if we're gonna overhaul things I'd prefer to move towards something that's a bit leaner both for codegen and for runtime testing. How about something like we generate this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">CpuFeatures</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">sse42</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Inst</span><span class="w"> </span><span class="p">{</span>
</code></pre></div>



<a name="529183130"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529183130" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529183130">(Jul 17 2025 at 00:02)</a>:</h4>
<p>er gimme a sec I can't edit code on zulip</p>



<a name="529183312"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529183312" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529183312">(Jul 17 2025 at 00:04)</a>:</h4>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="n">CpuFeatures</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">sse42</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">Inst</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_available</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">features</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">CpuFeatures</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// ...</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">addb_mi</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_available</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_features</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">CpuFeatures</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kc">true</span><span class="w"> </span><span class="c1">// no features here, or maybe fake _64b and compat?</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">vaddpd_mi</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_available</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">features</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">CpuFeatures</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">features</span><span class="p">.</span><span class="n">avx</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">vaddpd_evex_version</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_available</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">features</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">impl</span><span class="w"> </span><span class="n">CpuFeatures</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">features</span><span class="p">.</span><span class="n">avx512</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">features</span><span class="p">.</span><span class="n">avx10</span><span class="p">()</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>



<a name="529183473"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529183473" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529183473">(Jul 17 2025 at 00:05)</a>:</h4>
<p>then for the codegen side of things I think it's not the end of the world to continue to overload the <code>|</code> and <code>&amp;</code> operators to build a symoblic expression, but I'm wary there too of doing too much because we have to codegen, when compiling the assembler itself, all the code to generate the code to be the assembler</p>



<a name="529183539"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529183539" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529183539">(Jul 17 2025 at 00:06)</a>:</h4>
<p>in that <code>a | b | c</code> creates a lot of <code>Vec&lt;Flags&gt;</code> temoraries today with a lot of drop flags that rustc has to generate. The compile-time impact isn't huge from what I've tried to measure in the past but striving to generate less code is in theory always better</p>



<a name="529183556"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529183556" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Andrew Brown <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529183556">(Jul 17 2025 at 00:06)</a>:</h4>
<p>yeah, makes sense</p>



<a name="529183565"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529183565" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529183565">(Jul 17 2025 at 00:06)</a>:</h4>
<p>but in any case nothing I'm thinking about is a dealbreaker one way or another and it's "just a refactor" away from any other solution</p>



<a name="529183609"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529183609" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529183609">(Jul 17 2025 at 00:07)</a>:</h4>
<p>the main thing I'd like to see is to have the boolean tree reified in generated rust code for the assembler, not like an AST we forward and then parse in cranelift</p>



<a name="529183612"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529183612" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529183612">(Jul 17 2025 at 00:07)</a>:</h4>
<p>er, traverse, not parse</p>



<a name="529183619"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529183619" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Andrew Brown <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529183619">(Jul 17 2025 at 00:07)</a>:</h4>
<p>yup, I was just going to say that</p>



<a name="529420335"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/boolean%20terms%20for%20x64%20features/near/529420335" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jacob Lifshay <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/boolean.20terms.20for.20x64.20features.html#529420335">(Jul 18 2025 at 09:00)</a>:</h4>
<p><span class="user-mention silent" data-user-id="254110">Andrew Brown</span> <a href="#narrow/channel/217117-cranelift/topic/boolean.20terms.20for.20x64.20features/near/529180399">said</a>:</p>
<blockquote>
<p>We eventually will have the same problem with AVX10 instructions, since we'll see CPUs that have either AVX512 feature or AVX10 features (?) and we'll need to calculate a boolean term like: <code>(32-bit OR 64-bit) AND ((AVX512VL AND AVX512F) OR AVX10.1)</code>.</p>
</blockquote>
<p>Since <a href="https://gcc.gnu.org/pipermail/gcc-patches/2025-March/678195.html">AVX10 now always has 512-bit registers</a>, I'd expect that all future CPUs with AVX10 also support the corresponding AVX512 features. That said, this wouldn't be the first time Intel or AMD decided to do something weird.</p>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>