<html>
<head><meta charset="utf-8"><title>Cranelift regalloc on arm64 · cranelift · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/index.html">cranelift</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html">Cranelift regalloc on arm64</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="556890251"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556890251" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556890251">(Nov 17 2025 at 17:23)</a>:</h4>
<p>I'm having some issues with cranelift's code generation being quite bad...</p>
<p>IR and assembly: <a href="https://paste.sr.ht/~pitust/29f8e92da8a90f94336d4d7b648f3a514dd612b4">https://paste.sr.ht/~pitust/29f8e92da8a90f94336d4d7b648f3a514dd612b4</a></p>
<p>Note that at line 24 of the asssembly, cranelift decides to move a saved register into x1, dereference it, then overwrite x1 with something else. Is there something weird going on that I'm not aware of around regalloc in cranelift or something like that? Or maybe I'm missing some option (I set <code>opt_level</code> to <code>speed</code> and <code>regalloc_algorithm</code> to <code>backtracking</code>, but the behavior persists...)</p>



<a name="556891278"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556891278" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556891278">(Nov 17 2025 at 17:27)</a>:</h4>
<p>The short answer is that regalloc (in general, not just ours) is full of heuristics and sometimes does the wrong thing because it's an NP-hard binpacking problem. Unfortunately I don't have time to look at specific cases at the moment, but if you're willing to, PRs welcome. (Sorry, I don't mean to sound dismissive with that, just trying to level-set -- we aren't at a level of staffing that can allow for fine-tuning at this level at the moment)</p>



<a name="556891827"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556891827" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556891827">(Nov 17 2025 at 17:30)</a>:</h4>
<p>Yeah, I know it's an NP-hard problem and all, but this specific case is also not a very complex one (there are more available machine registers than values, and not all of the values even need a register of their own, and this definitely has the "some heuristic broke" vibe rather than the "this is just a really hard problem to solve" vibe), so I figured I'd ask anyway in case it's like a known bug or something.</p>



<a name="556891923"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556891923" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556891923">(Nov 17 2025 at 17:31)</a>:</h4>
<p>It's a fair question to ask! If you decide to dig into this, I'm at least happy to point at relevant bits of code</p>



<a name="556892002"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556892002" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556892002">(Nov 17 2025 at 17:31)</a>:</h4>
<p>Sure! I guess the first step is enabling logs from <code>log</code>?</p>



<a name="556892161"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556892161" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556892161">(Nov 17 2025 at 17:32)</a>:</h4>
<p>yes, the <code>trace-log</code> feature in cranelift-codegen guards a bunch of logging to eliminate dynamic checks, so enable that, then <code>WASMTIME_LOG=trace</code> will give you gigabytes of stuff; probably also <code>RAYON_NUM_THREADS=1</code> so parallel compilation doesn't confuse you</p>



<a name="556892402"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556892402" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556892402">(Nov 17 2025 at 17:33)</a>:</h4>
<p>Does cranelift create threads on its own? (since I'm writing a custom frontend)</p>



<a name="556892428"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556892428" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556892428">(Nov 17 2025 at 17:33)</a>:</h4>
<p>ah, no, that's a Wasmtime thing</p>



<a name="556892476"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556892476" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556892476">(Nov 17 2025 at 17:33)</a>:</h4>
<p>so <code>RUST_LOG=trace</code> (or whatever your logging frontend is in your embedding) too</p>



<a name="556893203"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556893203" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556893203">(Nov 17 2025 at 17:37)</a>:</h4>
<p>Okay, sure. I have a whole lot of logs now. What should I look for?</p>



<a name="556894702"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556894702" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556894702">(Nov 17 2025 at 17:44)</a>:</h4>
<p>I think I know what might be going wrong. It seems like cranelift tries really hard to keep the arguments in the same registers as they were passed in, even if that makes no sense...</p>



<a name="556896667"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556896667" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556896667">(Nov 17 2025 at 17:54)</a>:</h4>
<p>Yeah, the bad codegen disappears if i set <code>opt_level</code> to <code>none</code> and mangle the pointer by running <code>let ctx = b.ins().band_imm(ctx, (!1u64) as i64);</code>...</p>



<a name="556896779"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556896779" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556896779">(Nov 17 2025 at 17:55)</a>:</h4>
<p>With optimizations enabled, then the bitand gets rematerialized and the bad regalloc is back.</p>



<a name="556897521"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556897521" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556897521">(Nov 17 2025 at 17:58)</a>:</h4>
<blockquote>
<p>What should I look for?</p>
</blockquote>
<p>You aren't going to like the answer but unfortunately it's "understand the regalloc's algorithms and see where they are doing something suboptimal" :-/</p>



<a name="556897717"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556897717" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556897717">(Nov 17 2025 at 17:59)</a>:</h4>
<blockquote>
<p>cranelift tries really hard to keep the arguments in the same registers as they were passed in</p>
</blockquote>
<p>It's not exactly that, more that regalloc has constraints, the fixed-reg constraints apply to the args, and there are heuristics for when one wants to split liveranges</p>



<a name="556898623"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556898623" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556898623">(Nov 17 2025 at 18:03)</a>:</h4>
<p>Yeah, I figured. What I <em>think</em> happens is that cranelift decides to not split the liverange but just spill, and then after unspilling it maintains the same register assignment (for whatever reason), and then later it decides to move it into a different register instead of spilling, and then move elision fails for whatever reason.</p>



<a name="556899022"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556899022" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556899022">(Nov 17 2025 at 18:05)</a>:</h4>
<p>a few things just to help: (i) there aren't any spills here, just moves between registers (those are distinct); (ii) move elision will remove moves that are redundant, but it's not going to see that A was copied to B and we can use A directly instead of B</p>



<a name="556899588"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556899588" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556899588">(Nov 17 2025 at 18:09)</a>:</h4>
<p>thanks</p>



<a name="556908308"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556908308" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556908308">(Nov 17 2025 at 18:55)</a>:</h4>
<p>I think the issue is around <code>split_and_requeue_bundle</code>: when a bundle is split because one fixed register constraint contradicts another, then the register allocator should explicitly try to not use that fixed register when allocating, instead of having it be the <em>preferred</em> register...</p>



<a name="556908765"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556908765" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556908765">(Nov 17 2025 at 18:58)</a>:</h4>
<p>when a split happens, the split-off portion has a preference but not a hard requirement anymore -- the requirements for each half are recomputed</p>



<a name="556908825"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556908825" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556908825">(Nov 17 2025 at 18:59)</a>:</h4>
<p>Yeah, but the soft assignment is still problematic.</p>



<a name="556909030"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909030" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909030">(Nov 17 2025 at 19:00)</a>:</h4>
<p>The ranges may have been split because that register <em>cannot</em> be used, in which case, the register is explicitly the one you <em>don't</em> want to use.</p>



<a name="556909257"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909257" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909257">(Nov 17 2025 at 19:01)</a>:</h4>
<p>OK -- if there is a conflict, or if other liveranges have stronger preference, the weights should move the split-off half to another register instead</p>



<a name="556909321"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909321" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909321">(Nov 17 2025 at 19:01)</a>:</h4>
<p>Yeah. I'll try implementing something like that.</p>



<a name="556909344"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909344" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909344">(Nov 17 2025 at 19:01)</a>:</h4>
<p>No, I mean, that's how things already work</p>



<a name="556909352"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909352" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909352">(Nov 17 2025 at 19:01)</a>:</h4>
<p>Oh?</p>



<a name="556909394"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909394" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909394">(Nov 17 2025 at 19:01)</a>:</h4>
<p>That.. doesn't seem to be happening?</p>



<a name="556909592"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909592" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909592">(Nov 17 2025 at 19:03)</a>:</h4>
<p>Well, it's all heuristics. There are use-weights and there are costs that are considered during assignment. A simplistic "I would simply not use that register" heuristic stacked on top isn't going to be the answer, because there is already a fairly complex cost machinery considering the tradeoffs</p>



<a name="556909609"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909609" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909609">(Nov 17 2025 at 19:03)</a>:</h4>
<p>In the split off LR, the hint is checked as the first thing to be processed. It <em>can</em> work (because the thing stopping the register from being viable is between the two LRs), but it results in some extra shuffling (because to get the register from one LR to the other, some other register needs to be used).</p>



<a name="556909784"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909784" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909784">(Nov 17 2025 at 19:04)</a>:</h4>
<p>This is the backtracking part of the allocator: when another use comes along that can make use of the register, it has the opportunity to undo that choice</p>



<a name="556909807"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909807" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909807">(Nov 17 2025 at 19:04)</a>:</h4>
<p>if it doesn't, then the cost machinery could use tuning</p>



<a name="556909830"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909830" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909830">(Nov 17 2025 at 19:04)</a>:</h4>
<p>Ah, wait, I didn't read the code carefully enough. Hmm.</p>



<a name="556909844"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909844" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909844">(Nov 17 2025 at 19:04)</a>:</h4>
<p>I'd caution against simplistic answers here though: "don't consider the hint" is going to break a lot of other stuff</p>



<a name="556909864"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556909864" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556909864">(Nov 17 2025 at 19:04)</a>:</h4>
<p>(or not "break" but "make much less good")</p>



<a name="556912902"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556912902" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556912902">(Nov 17 2025 at 19:23)</a>:</h4>
<p>I'm confused by something. When cranelift splits the liverange into two parts, the log it prints  is<code>split bundle LiveBundleIndex(0) at progpoint4-pre and requeue with reg hint (for first part) PReg(hw = 0, class = Int, index = 0)</code>.</p>
<p>But it uses the hint for both parts?</p>



<a name="556914240"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556914240" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556914240">(Nov 17 2025 at 19:31)</a>:</h4>
<p>I believe the hint is just for the first part, but the code would be the definitive answer. Unfortunately I can't give much more time to this this morning, but best of luck (sorry!)</p>



<a name="556914445"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556914445" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556914445">(Nov 17 2025 at 19:33)</a>:</h4>
<p>no worries</p>



<a name="556976961"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556976961" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556976961">(Nov 18 2025 at 04:36)</a>:</h4>
<p>I looked into this: the root cause from regalloc2's choice to split bundles into 3 parts instead of 2. It moves the middle part of the live range between 2 conflicting uses directly to the spill bundle (which is then allocated to a register in the second chance allocation pass). This results in the unnecessary move because the middle and end bundles end up assigned different registers since regalloc2 doesn't know they are related.</p>



<a name="556977674"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/556977674" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#556977674">(Nov 18 2025 at 04:44)</a>:</h4>
<p>I also tried the example code with regalloc3 (<a href="https://gist.github.com/Amanieu/54d5d89c119ca74409a4b458c4fa013b">disassembly</a> since it has a completely different live range splitting algorithm. However it avoids the splitting in the first place by not putting a fixed-register constraint on the whole live range, instead only treating the constraint as a hint (which only applies to the first part of the live range if it is split).</p>
<p>I also looked into why regalloc2 spills more than regalloc3 and it's because of regalloc2's randomization of the probe order. This will tend to spread bundles over all available registers instead of minimizing the number of registers used.</p>
<div class="message_embed"><a class="message_embed_image" href="https://gist.github.com/Amanieu/54d5d89c119ca74409a4b458c4fa013b" style="background-image: url(&quot;https://uploads.zulipusercontent.net/91f9baed8f4fc08c462d1a4de5a8c23942d45e97/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f6173736574732f676973742d6f672d696d6167652d3534666437646330373133652e706e67&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://gist.github.com/Amanieu/54d5d89c119ca74409a4b458c4fa013b" title="gist:54d5d89c119ca74409a4b458c4fa013b">gist:54d5d89c119ca74409a4b458c4fa013b</a></div><div class="message_embed_description">GitHub Gist: instantly share code, notes, and snippets.</div></div></div>



<a name="557887229"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/557887229" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#557887229">(Nov 18 2025 at 10:15)</a>:</h4>
<p>Yeah, the regaloc3 codegen looks much more reasonable. Out of curiousity, is it possible to use regalloc3 with cranelift? (I know it's not yet production-ready, but this isn't very security-critical code and I don't mind getting crashes).</p>



<a name="557998666"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/557998666" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#557998666">(Nov 18 2025 at 17:22)</a>:</h4>
<p>We talked about that over the summer in Cranelift meetings; the conclusion was that we who use Wasmtime+Cranelift in security-critical contexts (i) would need to review regalloc3 but (ii) don't have the bandwidth to do so to the degree that we would understand the codebase and be able to fix it in an emergency or add features as needed. Basically, regalloc is too load-bearing to outsource</p>



<a name="557999549"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/557999549" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> pitust <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#557999549">(Nov 18 2025 at 17:26)</a>:</h4>
<p>Ah, and I guess the burden of maintaining both concurrently is too great? That is understandable, then.</p>



<a name="558000265"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/558000265" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#558000265">(Nov 18 2025 at 17:28)</a>:</h4>
<p>Unfortunately, yeah. If we had a large compiler team it would be an obvious choice to ramp up on it, but, sadly, that's not the case</p>



<a name="558004247"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217117-cranelift/topic/Cranelift%20regalloc%20on%20arm64/near/558004247" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amanieu <a href="https://bytecodealliance.github.io/zulip-archive/stream/217117-cranelift/topic/Cranelift.20regalloc.20on.20arm64.html#558004247">(Nov 18 2025 at 17:44)</a>:</h4>
<p><span class="user-mention" data-user-id="993027">@pitust</span> If you really want to try it out then you can use my branch from <a href="https://github.com/bytecodealliance/wasmtime/pull/11213">https://github.com/bytecodealliance/wasmtime/pull/11213</a>. It may be slightly out of date though since the regalloc2 API has changed a bit since.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/pull/11213" style="background-image: url(&quot;https://uploads.zulipusercontent.net/761cb04fcad84e06390398d07a3aa0d8ee98fedb/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f623132363430613538386564633330646132326132306465646636386538626539323938393364306663316139633764396263613465653032343461306263302f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3131323133&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/pull/11213" title="Add option to use regalloc3 as the register allocator by Amanieu · Pull Request #11213 · bytecodealliance/wasmtime">Add option to use regalloc3 as the register allocator by Amanieu · Pull Request #11213 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">This is based on bytecodealliance/regalloc2#230 which adds regalloc3 as a back-end to regalloc2.
Only one change had to be made to codegen: tail calls were reserving r11 as a scratch register by ma...</div></div></div>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>