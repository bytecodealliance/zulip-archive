<html>
<head><meta charset="utf-8"><title>portable / deterministic stack depth checks · winch · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/index.html">winch</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html">portable / deterministic stack depth checks</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="563900555"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563900555" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Graydon Hoare <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563900555">(Dec 15 2025 at 19:04)</a>:</h4>
<p>Hi! I'm curious if there's been any discussion in the past, or there would be any appetite for, a mode of stack-depth-checking that is more portable/deterministic than the current one (which relies on arch-specific byte counts -- I think using <a href="https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.max_wasm_stack">https://docs.wasmtime.dev/api/wasmtime/struct.Config.html#method.max_wasm_stack</a> )</p>



<a name="563904165"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563904165" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Graydon Hoare <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563904165">(Dec 15 2025 at 19:06)</a>:</h4>
<p>crudely: I was thinking it might be possible to extend the <a href="https://docs.rs/wasmtime/latest/wasmtime/trait.ResourceLimiter.html">https://docs.rs/wasmtime/latest/wasmtime/trait.ResourceLimiter.html</a> interface to get increment/decrement calls on each frame entry/exit, or perhaps something more efficient like "wasm calls that interface when it's first entered to get a frame-limit number, and tracks the entry/exit counts against that number, and calls the interface _back_ before any host call with the current frame depth"</p>



<a name="563904371"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563904371" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Graydon Hoare <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563904371">(Dec 15 2025 at 19:07)</a>:</h4>
<p>I'm asking because, well, at the moment if we use the max_wasm_stack method the same code running on two different-arch hosts that need to be in consensus will potentially fail with stack-exhaustion on one host but not the other, leading to divergence.</p>



<a name="563904453"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563904453" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Graydon Hoare <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563904453">(Dec 15 2025 at 19:08)</a>:</h4>
<p>(I suppose this isn't strictly a winch issue so much as an "anything wasmtime" issue, but our use case is on winch and I'd be perfectly happy with a winch-only solution)</p>



<a name="563907629"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563907629" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563907629">(Dec 15 2025 at 19:29)</a>:</h4>
<p>It's an interesting question. It seems more feasible to offer some guarantees here for Winch than for Cranelift: in Winch the stack is more-or-less 1-to-1 with the Wasm operand stack and locals, plus or minus some alignment concerns, plus a few words for the frame/return address. (I don't remember if callsites push extra or use the args already on the stack -- <span class="user-mention" data-user-id="477345">@Jeff Charles</span> ?)</p>
<p>In Cranelift in contrast putting any sort of deterministic requirement on frame size would essentially require regalloc to use the same number of spillslots on every architecture, at every release, and there's no way to say that about the pile of heuristics we have and the different machine instruction shapes and dataflow patterns for each lowering (as I'm sure you're well aware!). One could maybe impose a worst-case cap, and then pad up to that cap so that failures are deterministic, but then there's the classical overprovisioning dilemma (same as with e.g. memory overcommit): one wastes a lot to ensure the average case is the same as the worst case.</p>
<p>Also, I guess implicit in my thinking above is continuing to count stack usage in bytes, not frames; otherwise one has the problem that the actual stack limit needs to be sized for the worst case. (What if we have 100k locals in every Wasm function? Then a 2MiB thread stack means we can only have ~2 frames)</p>



<a name="563907782"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563907782" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563907782">(Dec 15 2025 at 19:30)</a>:</h4>
<p>So tl;dr: seems potentially feasible for Winch backend in particular to lock down the frame size as a guarantee but I'd defer to <span class="user-mention" data-user-id="477345">@Jeff Charles</span></p>



<a name="563908044"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563908044" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Graydon Hoare <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563908044">(Dec 15 2025 at 19:31)</a>:</h4>
<p>yeah I was thinking more of "counting frames" because we can restrict the number of locals through simpler static analysis of inputs.</p>
<p>the other thing about "counting bytes" is that a wasm -&gt; native host function -&gt; wasm -&gt; native host function chain will build up arch-specific frames from the native host functions.</p>



<a name="563908190"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563908190" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563908190">(Dec 15 2025 at 19:32)</a>:</h4>
<p>Oh, that's a great point -- and there's no telling what LLVM will do in the native frames</p>



<a name="563908619"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563908619" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563908619">(Dec 15 2025 at 19:34)</a>:</h4>
<p>I don't see the harm in a "frame counting" approach; it would necessarily be implemented differently for Winch and Cranelift backends and so if the need is specifically for Winch, and Wasmtime involvement is mostly adding one field in vmctx to track this depth and API to set it, I'd defer to the Winch folks for any other thoughts :-)</p>



<a name="563909490"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563909490" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Graydon Hoare <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563909490">(Dec 15 2025 at 19:38)</a>:</h4>
<p>cool  -- so from your perspective, adding such a field + a getter/setter API for the host wouldn't be the end of the world? (I'd be happy to at least poke around prototyping this)</p>



<a name="563910001"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563910001" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563910001">(Dec 15 2025 at 19:41)</a>:</h4>
<p>Yep, I'd be happy to review that at least; Alex would probably want a say as well</p>



<a name="563913099"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563913099" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jeff Charles <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563913099">(Dec 15 2025 at 19:57)</a>:</h4>
<p>Someone adding a "frame counting" approach seems reasonable to me as well</p>



<a name="563941963"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/563941963" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Saúl Cabrera <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#563941963">(Dec 15 2025 at 23:14)</a>:</h4>
<blockquote>
<p>I'd defer to the Winch folks for any other thoughts :-)</p>
</blockquote>
<p>Sounds reasonable to me as well. I doesn't sound like any of this is really Winch specific as stated in the OP (assuming  I'm not missing any details). From Winch's perspective we have built all the infrastructure needed to handle operations involving the vmctx, so that should hopefully give you a reasonable starting point e.g.,  <a href="https://github.com/bytecodealliance/wasmtime/blob/main/winch/codegen/src/codegen/mod.rs#L1273">https://github.com/bytecodealliance/wasmtime/blob/main/winch/codegen/src/codegen/mod.rs#L1273</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/blob/main/winch/codegen/src/codegen/mod.rs#L1273" style="background-image: url(&quot;https://uploads.zulipusercontent.net/6810c20208b9c413e82fd8059d4d9bbd0d015433/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f346239336636353862613261623239323436373063393836326435326136616437306263333362393630326333373030316466616661313662316233666335382f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/blob/main/winch/codegen/src/codegen/mod.rs#L1273" title="wasmtime/winch/codegen/src/codegen/mod.rs at main · bytecodealliance/wasmtime">wasmtime/winch/codegen/src/codegen/mod.rs at main · bytecodealliance/wasmtime</a></div><div class="message_embed_description">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>



<a name="565187549"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/565187549" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fitzgen (he/him) <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#565187549">(Dec 23 2025 at 16:59)</a>:</h4>
<p>FWIW, this would be pretty easy to implement as a wasm-to-wasm transform, and that's what I'd suggest starting with. I don't think this should require any changes to wasmtime or winch, just append a new global and increment it at the start of every function, trap or call out to a host function if it gets beyond your limit N, and decrement it at every return (or branch to the return label index).</p>



<a name="566432478"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/566432478" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Graydon Hoare <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#566432478">(Jan 05 2026 at 20:23)</a>:</h4>
<p><span class="user-mention silent" data-user-id="253990">fitzgen (he/him)</span> <a href="#narrow/channel/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks/near/565187549">said</a>:</p>
<blockquote>
<p>FWIW, this would be pretty easy to implement as a wasm-to-wasm transform, and that's what I'd suggest starting with. I don't think this should require any changes to wasmtime or winch, just append a new global and increment it at the start of every function, trap or call out to a host function if it gets beyond your limit N, and decrement it at every return (or branch to the return label index).</p>
</blockquote>
<p>we've certainly considered this. I've been hesitating for three reasons: </p>
<ol>
<li>it doesn't handle the issue of tracking stack depth globally across multiple VMs-that-call-VMs with host frames interspersed, though in theory we could handle this by being conservative with the VM nesting depth and just picking a worst case bound, it might penalize guests quite a bit. </li>
<li>more importantly, I'm concerned about my ability to write an instrumentation pass that guests can't subvert. like I guess between the fact that wasm has control flow integrity built in and globals .. can't be aliased? can they? .. I am just unsure that I can inject a counter and a check-and-trap code fragment into the guest's sandbox that the guest can't figure out a way to tinker with themselves. but maybe I am just too burned by past experience with clever guests breaking out of their sandboxes.</li>
<li>I'm not super confident in my ability to write such a pass _at all_, like to identify all the places that need instrumenting and be sure I always emit the instrumentation. somehow it feels more plausible to me to modify the host. but I guess I can make a mistake in either, and it's heartening to hear you say you think it'd be easy. I assumed it'd be fairly hard.</li>
</ol>



<a name="566444411"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/566444411" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fitzgen (he/him) <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#566444411">(Jan 05 2026 at 21:53)</a>:</h4>
<p><span class="user-mention" data-user-id="634398">@Graydon Hoare</span> </p>
<p>Regarding (1): are you saying you want to count host functions' frames as well or that re-entrancy through the host is problematic? The latter doesn't seem like it should be a problem. The former seems like something you'd have to handle on your own regardless of using a wasm transform vs something built into Wasmtime.</p>
<p>Regarding (2): Correct, nothing can alias globals. There is no way to enumerate globals and no <code>globalref</code> type. If the wasm is initially valid then it can never access any globals that you append to the globals index space after the fact.</p>
<p>Regarding (3): If you want it to be portable across architectures and such, and you're really just counting the number of frames in the stack, then you just need to instrument every function prologue, the family of return instructions, and the family of branch instructions iff the branch target is the outermost label (i.e. the branch is equivalent to a (potentially conditional) return).</p>



<a name="566448841"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/566448841" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Graydon Hoare <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#566448841">(Jan 05 2026 at 22:31)</a>:</h4>
<p>re #1 it's not reentrancy it's one VM calling another VM calling another VM. they're all isolated from one another. so their globals won't know about one another. whereas if it's tracked in the host there's more of a chance of using a single counter across all VMs.</p>
<p>I guess I can try sketching this and see how bad it is.</p>



<a name="566542369"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/417703-winch/topic/portable%20/%20deterministic%20stack%20depth%20checks/near/566542369" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Chris Fallin <a href="https://bytecodealliance.github.io/zulip-archive/stream/417703-winch/topic/portable.20.2F.20deterministic.20stack.20depth.20checks.html#566542369">(Jan 06 2026 at 13:22)</a>:</h4>
<p>Regarding in-wasm instrumentation: does your guest use Wasm exceptions? If so, that's a bit tricky (possible though: e.g. one could add a local to every func, save this func's depth in that local, and at any catch-points, reset the global to that. The latter requires splitting edges though because catch-points can also be ordinary labels (or, well, I guess you don't have to, it's just a redundant store))</p>
<p>I sort of wonder if an alternative approach that adds a new parameter <code>depth</code> to every function and threads it through as <code>depth+1</code> at all callsites (except tail calls!) would be a little easier -- at least, it's more "functional" (no possibility of forgetting to update mutable state)</p>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>