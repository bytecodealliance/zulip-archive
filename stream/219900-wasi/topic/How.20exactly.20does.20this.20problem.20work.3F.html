<html>
<head><meta charset="utf-8"><title>How exactly does this problem work? · wasi · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/index.html">wasi</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html">How exactly does this problem work?</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="535887188"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/535887188" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#535887188">(Aug 24 2025 at 07:36)</a>:</h4>
<p><a href="https://github.com/WebAssembly/component-model/issues/223#issuecomment-1664258641">https://github.com/WebAssembly/component-model/issues/223#issuecomment-1664258641</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/WebAssembly/component-model/issues/223#issuecomment-1664258641" style="background-image: url(&quot;https://uploads.zulipusercontent.net/60a059a034f6b2c12978a76bce06da8fa4acf8ee/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f376563303430343734336538346232333766663661626330396539653663373039393333646234306630383965646438316232396563376637323833633666632f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f6973737565732f323233&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/WebAssembly/component-model/issues/223#issuecomment-1664258641" title="Defining client callback type in WIT · Issue #223 · WebAssembly/component-model">Defining client callback type in WIT · Issue #223 · WebAssembly/component-model</a></div><div class="message_embed_description">I'm trying to define a component interface in WIT format so that components (client) can pass callbacks (closures) to host. Host can then store the callback somewhere and then invoke the callback w...</div></div></div>



<a name="535887218"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/535887218" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#535887218">(Aug 24 2025 at 07:36)</a>:</h4>
<p>Sorry if this isn't a good format, I'm new here</p>



<a name="535888247"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/535888247" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#535888247">(Aug 24 2025 at 08:03)</a>:</h4>
<p>I want to understand, why strictly reference counting? And can there be a way to prevent closures from referencing host resourses?</p>



<a name="535888399"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/535888399" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#535888399">(Aug 24 2025 at 08:06)</a>:</h4>
<p>The problem seems to be when host references callback references host, making a circular dependency graph. It wouldn't be a callback if the host didn't reference it, so the other place to break the circle is preventing the callback from referencing the host.</p>



<a name="535888497"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/535888497" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#535888497">(Aug 24 2025 at 08:08)</a>:</h4>
<p>In the example given, that translates to the JS callback not being able to reference the DOM node that registers it. Is that so bad?</p>



<a name="535965004"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/535965004" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Andy Wingo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#535965004">(Aug 25 2025 at 07:01)</a>:</h4>
<p>i think one of the points is that it is hard to know what a JS callback references; it's not just textually what is in the closure, and not even specified on a language level.  (all implementations that i know of use a scope chain which may include objects not captured by the closure.)</p>



<a name="535965087"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/535965087" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Andy Wingo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#535965087">(Aug 25 2025 at 07:02)</a>:</h4>
<p>but yes, there are a few ways to break the cycles, they are just annoying to do, and if there is a design pattern that doesn't have the tendency to make cycles, then it is better for the component model</p>



<a name="535969025"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/535969025" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#535969025">(Aug 25 2025 at 07:32)</a>:</h4>
<p>In Rust, only stuff used in a closure get moved into the closure. It's unfortunate that JavaScript has this problem.</p>



<a name="536054321"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536054321" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pat Hickey <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536054321">(Aug 25 2025 at 15:46)</a>:</h4>
<p>the component model needs to be agnostic of whatever language is compiled to the wasm modules inside the component (and also whatever language the host is implemented in), and it cant protect against anything it cant determine from the arguments passed to the canonical abi functions. the component model can't "see" into a module to determine whether or not the implementation of a closure contains cycles</p>



<a name="536103420"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536103420" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536103420">(Aug 25 2025 at 20:32)</a>:</h4>
<p>I have an idea. What if the spec disallowed callbacks from capturing the host resource, it's up to the various implementations to enforce that for their language, and the JS implementation does it by just punting on callbacks because of the scope chains? Thereby making this Javascript's problem, and not WASI's problem, such that you specifically can't register callbacks from JS.</p>



<a name="536104030"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536104030" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536104030">(Aug 25 2025 at 20:36)</a>:</h4>
<p>Whereas for Rust, the tooling could detect the host resource being moved into the closure and only disallow that.</p>



<a name="536104713"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536104713" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536104713">(Aug 25 2025 at 20:40)</a>:</h4>
<p>You could, however, still register callbacks <em>into</em> JS, because those callbacks could know they are not capturing the host.</p>



<a name="536105401"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536105401" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536105401">(Aug 25 2025 at 20:44)</a>:</h4>
<p>So overall, JS would struggle to produce its own callbacks because of scope chains, but it could still easily work with callbacks from elsewhere.</p>



<a name="536105838"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536105838" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536105838">(Aug 25 2025 at 20:47)</a>:</h4>
<p>Then in the future, if a JS implementation figures out how to adhere to the spec less bluntly, that would be all it takes for JS to produce callbacks.</p>



<a name="536112110"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536112110" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pat Hickey <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536112110">(Aug 25 2025 at 21:28)</a>:</h4>
<p>in general we don't design features that only work in some languages and not others, one of the big ideas of the component model is that its an abstraction boundary where one side of an interface doesn't know or care what language the implementation on the other side of the interface is written in</p>



<a name="536122009"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536122009" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536122009">(Aug 25 2025 at 22:57)</a>:</h4>
<p>I understand that. I don't think my idea makes one side know or care what the other side is written in. Only a component developer would have to care, if they were working with JS and were met with "sorry we don't know how to determine that your callback does not reference the host." The choice around my idea boils down to, should we let JS's difficulties keep everyone else from having the feature as well?</p>



<a name="536123670"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536123670" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536123670">(Aug 25 2025 at 23:13)</a>:</h4>
<p>Of course, if there was a way for JS to be included that would be ideal, but it seems to me that scope chains pose a fundamental difficulty here and it sucks for other languages to be burdened with that. It feels like right now, no one gets to have callbacks because a component <em>might</em> be Javascript, which doesn't quite feel in the spirit of language agnostic. I would rather have callbacks for as many languages as possible, than not at all because one language struggles with it.</p>



<a name="536126014"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536126014" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536126014">(Aug 25 2025 at 23:36)</a>:</h4>
<p>I'll put it another way: if the JS implementation was ever gonna support WASI callbacks, it would probably have to work something like this out first regardless, because closures capturing entire scope chains seems inherently problematic in this context. WASI callbacks, if we ever get them, should capture as little as possible. So, should the other languages be made to wait for JS, or can we let them have callbacks in the meantime while JS works it out?</p>



<a name="536137699"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536137699" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536137699">(Aug 26 2025 at 01:46)</a>:</h4>
<p>For context, my motivation is I want to make a UI engine centering WASM, and part of that is a signals engine inspired by SolidJS and Svelte. I need callbacks for the declaration of memos and effects, which to the best of my knowledge never need to reference their host, the signal engine.</p>



<a name="536176412"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536176412" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Andy Wingo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536176412">(Aug 26 2025 at 07:36)</a>:</h4>
<p>can you implement signals in terms of futures or streams?</p>



<a name="536198852"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536198852" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536198852">(Aug 26 2025 at 09:43)</a>:</h4>
<p>I'd have to think on it. The basic requirement is telling the engine "do this whenever one of the signal dependencies updates". It must be declared by the component, but registered by the engine so the engine can invoke it later. I can't specify it as a regular function in the WIT because a component might declare arbitrarily many memos and effects, and I don't want the interface to limit a component to just one.</p>



<a name="536199304"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536199304" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536199304">(Aug 26 2025 at 09:46)</a>:</h4>
<p>I think probably the answer is no, because the engine has to invoke them, ideally synchronously. Whereas, futures and streams both have their execution driven by the component that owns them.</p>



<a name="536225823"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536225823" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Andy Wingo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536225823">(Aug 26 2025 at 12:31)</a>:</h4>
<p>well, just spitballing here, if it's the sort of thing that doesn't need synchronous execution, streams sound great, and if it does need synchronous execution, i wonder if the framework could pass the writer side of a future in the stream and then wait on the reader side.</p>



<a name="536226130"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536226130" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Andy Wingo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536226130">(Aug 26 2025 at 12:33)</a>:</h4>
<p>the engine could transfer control directly to the stream reader (signal consumer) and then directly back if the consumer fulfilled the promise synchronously</p>



<a name="536296051"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536296051" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536296051">(Aug 26 2025 at 18:59)</a>:</h4>
<p>Good suggestions. I think I need to study how async will work. For instance, will futures and streams all share a single wasm async runtime, or will some languages bring their own?</p>



<a name="536298038"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536298038" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joel Dice <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536298038">(Aug 26 2025 at 19:14)</a>:</h4>
<p>In a sense, the async runtime is provided by the host, given that it's the one responsible for starting and resuming tasks, dispatching events, etc.  And a guest must return control to the host in order to allow other tasks to run (i.e. this is not preemptive multithreading we're talking about; that will be a separate project).</p>
<p>So yes, all async tasks, futures, and streams are backed by a single runtime in the host, but each guest language will have an appropriate abstraction on top of the raw intrinsic operations implemented by the host, and that will be responsible for bridging those low-level operations to the higher-level idioms of the language (e.g. async/await in JS, Rust, Python, and C#; goroutines in Go; virtual threads in Java; etc.).  That abstraction might need to do non-trivial things, so you could consider it a guest-level runtime on top of the host-level runtime.</p>



<a name="536336275"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536336275" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536336275">(Aug 27 2025 at 01:57)</a>:</h4>
<p>Today's breakthrough: My signal engine should register components as signal subscribers, rather than individual memos and effects. I'm still working out the details, but I think this makes sense. What I've worked out so far is components need to be able to register signals with the engine by creating streams and passing the reader to the signal engine so the engine can propagate updates, and also they need to be able to subscribe to signals from the engine, which will prompt the engine to create a new stream, subscribe its writer to the designated signal, and return its reader to the component. From there, I think these mechanisms should plug into a component's internal signals library.</p>



<a name="536336396"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536336396" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536336396">(Aug 27 2025 at 01:59)</a>:</h4>
<p>On the engine's part, it needs to receive and store stream readers, subscribe new stream writers to them, and pass readers to the components requesting them.</p>



<a name="536336586"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536336586" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536336586">(Aug 27 2025 at 02:02)</a>:</h4>
<p>A signal, in the engine, will consist of one stream reader and a collection of subscribed stream writers. The engine will pass on everything from the reader to all of the writers. In the end, a WASI signal engine is basically a stream mediator.</p>



<a name="536337181"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536337181" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536337181">(Aug 27 2025 at 02:12)</a>:</h4>
<p>A key insight is that a component should only have one stream reader for a given foreign signal, meaning from the signal's pov, every subscribed stream corresponds to a single component.</p>



<a name="536337396"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536337396" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536337396">(Aug 27 2025 at 02:15)</a>:</h4>
<p>Normally, a signal library implicitly subscribes to a signal the first time its getter is called with a global variable holding the context. This works for native signals, but foreign signals must be brought into scope before they can be used, which makes that the natural time to create the subscription instead.</p>



<a name="536337555"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536337555" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536337555">(Aug 27 2025 at 02:18)</a>:</h4>
<p>It's looking like this will result in a component's internal signals library needing a new signal type in addition to signal, memo, and effect for this kind of foreign signal.</p>



<a name="536348341"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536348341" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536348341">(Aug 27 2025 at 05:12)</a>:</h4>
<p>I prototyped out a possible importSignal() function. Not sure what the stream API will actually look like in JS though</p>
<div class="codehilite" data-code-language="JavaScript"><pre><span></span><code><span class="kd">function</span><span class="w"> </span><span class="nx">importSignal</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="nx">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">Engine</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">id</span><span class="p">);</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">observers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">getter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">current</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="nx">observers</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">current</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nx">observers</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">current</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">stream</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span><span class="w"> </span><span class="c1">// Guessing at stream API</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="c1">// Extra logic needed for calling all the observers on a stream event.</span>
<span class="w">  </span><span class="c1">// Depends on stream API.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">getter</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>



<a name="536348566"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536348566" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Nathan Petrangelo <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536348566">(Aug 27 2025 at 05:15)</a>:</h4>
<p>Say, are there any plans to support generics in WIT? I sure would like to let Engine.subscribe() here return stream&lt;T&gt;.</p>



<a name="536411123"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/How%20exactly%20does%20this%20problem%20work%3F/near/536411123" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lann Martin <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/How.20exactly.20does.20this.20problem.20work.3F.html#536411123">(Aug 27 2025 at 12:40)</a>:</h4>
<p>Some discussion here: <a href="https://github.com/WebAssembly/component-model/issues/543">https://github.com/WebAssembly/component-model/issues/543</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/WebAssembly/component-model/issues/543" style="background-image: url(&quot;https://uploads.zulipusercontent.net/b7834331d7136d62ca1ae6ae5fd042e629aad697/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f613530386464303339613338613461663861316165353730656234383562613531623034666532656137306365353535616338346363353364333365633262372f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f6973737565732f353433&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/WebAssembly/component-model/issues/543" title="User-defined generic types (parametric polymorphism) · Issue #543 · WebAssembly/component-model">User-defined generic types (parametric polymorphism) · Issue #543 · WebAssembly/component-model</a></div><div class="message_embed_description">Doing a search in the github issues, I have yet to see a ticket where anyone has explicitly asked for this yet. Apparently, there has been discussion on something similar to this, but from what I c...</div></div></div>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>