<html>
<head><meta charset="utf-8"><title>0-length stream writes with files and stdio · wasi · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/index.html">wasi</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/0-length.20stream.20writes.20with.20files.20and.20stdio.html">0-length stream writes with files and stdio</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="536625023"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/0-length%20stream%20writes%20with%20files%20and%20stdio/near/536625023" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Roman Volosatovs <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/0-length.20stream.20writes.20with.20files.20and.20stdio.html#536625023">(Aug 28 2025 at 14:53)</a>:</h4>
<p>with recent spec changes, 0-length stream writes are used to await "readiness" and, from what I understand, the expectation is that a non-zero-length write following a 0-length write is non-blocking. This works great for e.g. TCP sockets that have a well-defined and clear way of querying the readiness, however, how is this feature expected to be implemented for files and/or stdio?<br>
It appears that the only way to provide this functionality in the host would be buffering the data in the host and have a dedicated worker thread/task performing I/O</p>
<p>With this approach <code>stream.write</code> returning would not guarantee that the data has reached the kernel. In case of stdio, for example, that would mean that <code>println("hello, world")</code> returning does not guarantee that <code>"hello, world"</code> has even attempted to be written to the terminal.</p>
<p><code>wasi:filesystem</code> defines <code>sync</code>, which seems to be the place where we could hook in to <em>await</em> the "flush" of file worker's buffer, but we would need to introduce a similar construct to <code>wasi:cli</code>.</p>
<p>Personally, I have been under impression that we wanted to avoid buffering in the host - and if so, how would we implement the expected behavior for 0-length writes?</p>
<p>cc <span class="user-mention" data-user-id="253994">@Alex Crichton</span> <span class="user-mention" data-user-id="509936">@Joel Dice</span> </p>
<p>related:</p>
<ul>
<li><a href="https://github.com/WebAssembly/component-model/pull/444">https://github.com/WebAssembly/component-model/pull/444</a></li>
<li><a href="https://github.com/WebAssembly/component-model/issues/441">https://github.com/WebAssembly/component-model/issues/441</a></li>
<li><a href="https://github.com/bytecodealliance/wasmtime/pull/11515#issuecomment-3233723027">https://github.com/bytecodealliance/wasmtime/pull/11515#issuecomment-3233723027</a></li>
</ul>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/WebAssembly/component-model/pull/444" style="background-image: url(&quot;https://uploads.zulipusercontent.net/82340290550f5fd0d79f50d2631b6c9bfefeb09e/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f303365396164623861646536653933393566396438393930383962336361613963316430303437623530353364626338366365643630366236303462373630382f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f70756c6c2f343434&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/WebAssembly/component-model/pull/444" title="Allow stream.{read,write}s of length 0 to query/signal readiness by lukewagner · Pull Request #444 · WebAssembly/component-model">Allow stream.{read,write}s of length 0 to query/signal readiness by lukewagner · Pull Request #444 · WebAssembly/component-model</a></div><div class="message_embed_description">This PR relaxes the rules for stream.{read,write} to accept lengths of 0.  This can be useful for signalling and querying readiness which in turn can be used to implement non-blocking POSIX operati...</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/WebAssembly/component-model/issues/441" style="background-image: url(&quot;https://uploads.zulipusercontent.net/7de654900cdfd419ea9c7962aff36b8223c7bf56/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f646436636237306532323764393665323231633335336230336562316634666366663233366330366132323662326638653964353538313264623834353333652f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f6973737565732f343431&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/WebAssembly/component-model/issues/441" title="How to implement non-blocking POSIX `send` in terms of `stream.write`? · Issue #441 · WebAssembly/component-model">How to implement non-blocking POSIX `send` in terms of `stream.write`? · Issue #441 · WebAssembly/component-model</a></div><div class="message_embed_description">Am I correct to say that: when stream.write returns BLOCKED, it continues to have access to the provided memory buffer until the write either finishes or is canceled? If so, does this mean wasi-lib...</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/pull/11515#issuecomment-3233723027" style="background-image: url(&quot;https://uploads.zulipusercontent.net/c396da18a524708d5613f1d2bc625163bc97d933/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f373835313032363263653038343737363037366363316666646538663066393830306133653133656365376538356238646663313363613732323834646235322f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3131353135&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/pull/11515#issuecomment-3233723027" title="Revamp component model stream/future host API (again) by dicej · Pull Request #11515 · bytecodealliance/wasmtime">Revamp component model stream/future host API (again) by dicej · Pull Request #11515 · bytecodealliance/wasmtime</a></div><div class="message_embed_description">This changes the host APIs for dealing with futures and streams from a &quot;rendezvous&quot;-style API to a callback-oriented one.
Previously you would create e.g. a StreamReader/StreamWriter pair...</div></div></div>



<a name="536627036"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/0-length%20stream%20writes%20with%20files%20and%20stdio/near/536627036" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joel Dice <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/0-length.20stream.20writes.20with.20files.20and.20stdio.html#536627036">(Aug 28 2025 at 15:02)</a>:</h4>
<p>cc <span class="user-mention" data-user-id="253998">@Luke Wagner</span> <span class="user-mention" data-user-id="378155">@Dave Bakker (badeend)</span>, who came up with the zero-length read/write semantics, I believe.</p>



<a name="536632312"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/0-length%20stream%20writes%20with%20files%20and%20stdio/near/536632312" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lann Martin <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/0-length.20stream.20writes.20with.20files.20and.20stdio.html#536632312">(Aug 28 2025 at 15:24)</a>:</h4>
<p>Does <code>AsyncWrite::poll_write(..., &amp;[])</code> not await readiness for files or stdout?</p>



<a name="536632900"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/0-length%20stream%20writes%20with%20files%20and%20stdio/near/536632900" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Roman Volosatovs <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/0-length.20stream.20writes.20with.20files.20and.20stdio.html#536632900">(Aug 28 2025 at 15:27)</a>:</h4>
<p>it appears that at least for files it actually might <a href="https://github.com/tokio-rs/tokio/blob/925c614c89d0a26777a334612e2ed6ad0e7935c3/tokio/src/fs/file.rs#L721-L791">https://github.com/tokio-rs/tokio/blob/925c614c89d0a26777a334612e2ed6ad0e7935c3/tokio/src/fs/file.rs#L721-L791</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/tokio-rs/tokio/blob/925c614c89d0a26777a334612e2ed6ad0e7935c3/tokio/src/fs/file.rs#L721-L791" style="background-image: url(&quot;https://uploads.zulipusercontent.net/c643aaa3ca3d4a98bba8203143ae34fd752632b9/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f313837363164383038663333653664636661303935636564623663613261303864623762383636333033343562383033343235396264326465613931373031612f746f6b696f2d72732f746f6b696f&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/tokio-rs/tokio/blob/925c614c89d0a26777a334612e2ed6ad0e7935c3/tokio/src/fs/file.rs#L721-L791" title="tokio/tokio/src/fs/file.rs at 925c614c89d0a26777a334612e2ed6ad0e7935c3 · tokio-rs/tokio">tokio/tokio/src/fs/file.rs at 925c614c89d0a26777a334612e2ed6ad0e7935c3 · tokio-rs/tokio</a></div><div class="message_embed_description">A runtime for writing reliable asynchronous applications with Rust. Provides I/O, networking, scheduling, timers, ... - tokio-rs/tokio</div></div></div>



<a name="536633479"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/0-length%20stream%20writes%20with%20files%20and%20stdio/near/536633479" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lann Martin <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/0-length.20stream.20writes.20with.20files.20and.20stdio.html#536633479">(Aug 28 2025 at 15:30)</a>:</h4>
<p>It appears to buffer by default, but maybe that is <del>complete</del> ready enough from a guest's perspective?</p>



<a name="536633945"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/0-length%20stream%20writes%20with%20files%20and%20stdio/near/536633945" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Roman Volosatovs <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/0-length.20stream.20writes.20with.20files.20and.20stdio.html#536633945">(Aug 28 2025 at 15:32)</a>:</h4>
<p>I've just had a quick chat with <span class="user-mention" data-user-id="253998">@Luke Wagner</span> about it and it appears that only 0-length reads are expected to have these semantics, 0-length writes to files/stdio are free to return immediately</p>
<p>I think the empty <code>poll_write</code> is certainly "good enough"</p>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>