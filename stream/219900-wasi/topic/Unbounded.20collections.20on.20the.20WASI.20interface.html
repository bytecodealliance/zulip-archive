<html>
<head><meta charset="utf-8"><title>Unbounded collections on the WASI interface · wasi · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/index.html">wasi</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/Unbounded.20collections.20on.20the.20WASI.20interface.html">Unbounded collections on the WASI interface</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="574262425"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/Unbounded%20collections%20on%20the%20WASI%20interface/near/574262425" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pavel Šavara <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/Unbounded.20collections.20on.20the.20WASI.20interface.html#574262425">(Feb 17 2026 at 10:48)</a>:</h4>
<p>Consider following scenarios</p>
<ul>
<li>Interaction between corrupted or malicious WASM guest component, calling (our) receiving guest component with too large collection as a parameter. For example 64bit component calling 32bit component. Leading to OOM and denial of service. Is receiving component responsible for argument size validation ? If it's the host and the specification, where I could find it ? If it's guest component responsible, could we improve wit-bindgen to take some of that responsibility ?</li>
<li>Malicious HTTP client is sending unbounded number of HTTP request headers. The HTTP server handler code in the guest is allocating data structures and could OOM if there are too many. Is the guest code responsible to do this level of HTTP validation ? If not, could we say in wasi:http specification that this is guarded by host (server component) and it's part of the contract ? In non-WASM C# HTTP this is achieved by overall max request header length.</li>
<li>Malicious HTTP server is sending  unbounded number of HTTP response (trailing) headers. Same question as above.</li>
</ul>
<p>Should parameter constraints become part of WIT language ?</p>
<p>cc <span class="user-mention" data-user-id="509936">@Joel Dice</span> <span class="user-mention" data-user-id="253998">@Luke Wagner</span> <span class="user-mention" data-user-id="268586">@Ralph</span></p>



<a name="574290040"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/Unbounded%20collections%20on%20the%20WASI%20interface/near/574290040" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> bjorn3 <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/Unbounded.20collections.20on.20the.20WASI.20interface.html#574290040">(Feb 17 2026 at 13:29)</a>:</h4>
<blockquote>
<p>Malicious HTTP client is sending unbounded number of HTTP request headers. The HTTP server handler code in the guest is allocating data structures and could OOM if there are too many. Is the guest code responsible to do this level of HTTP validation ? If not, could we say in wasi:http specification that this is guarded by host (server component) and it's part of the contract ? In non-WASM C# HTTP this is achieved by overall max request header length.</p>
</blockquote>
<p>Each request is handled in a separate wasm instance, so for as long as you limit the amount of memory each individual wasm instance can consume, you don't risk a DOS beyond that one request. And if a client is sending you garbage, they shouldn't be expecting a non-garbage result anway.</p>
<blockquote>
<p>Malicious HTTP server is sending  unbounded number of HTTP response (trailing) headers. Same question as above.</p>
</blockquote>
<p>Do you mean when the server is a wasm component? If the wasm component was compromised by the client, that is effectively a self-DOS like above. And if the wasm component was malicious from the start, a zip bomb would probably be more effective at bringing down the client. The client is responsible for handling a malicious response I would say.</p>
<p>Or do you mean a wasm component connecting to a malicious server? That seems equivalent to your first scenario in terms of how to defend against it.</p>



<a name="574348343"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/Unbounded%20collections%20on%20the%20WASI%20interface/near/574348343" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Luke Wagner <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/Unbounded.20collections.20on.20the.20WASI.20interface.html#574348343">(Feb 17 2026 at 17:29)</a>:</h4>
<p>Good points <span class="user-mention" data-user-id="264278">@bjorn3</span>.  Additionally I'd say that while components are isolated in terms of capabilities, they're not isolated in terms of traps, OOM and excessive resource usage.  For this "stronger" (cgroups-y) degree of isolation, there's a general post-1.0 idea of <a href="https://github.com/WebAssembly/component-model/blob/main/design/mvp/FutureFeatures.md#blast-zones">blast zones</a> but, for now, when you want this stronger degree of isolation, you need to use host powers (as most production wasm embeddings are doing today).</p>
<p>That being said, for the specific case of "too-large list/string passed into a component": today this ends up trapping (when <code>cabi_realloc</code> is called for this too-large list/string and <code>memory.grow</code> returns <code>-1</code>, you have no option other than to trap).  But one corollary of the <a href="https://github.com/WebAssembly/component-model/issues/383">lazy lowering ABI</a> that we're thinking about working on next is that <code>cabi_realloc</code> goes away and too-large values can be dropped without copying which means that guest code is able to gracefully handle OOM (via error results, etc) if it wants to instead of trapping.</p>



<a name="574473045"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/Unbounded%20collections%20on%20the%20WASI%20interface/near/574473045" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Pavel Šavara <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/Unbounded.20collections.20on.20the.20WASI.20interface.html#574473045">(Feb 18 2026 at 10:24)</a>:</h4>
<blockquote>
<p>"stronger" (cgroups-y) degree of isolation</p>
</blockquote>
<p>My question is the opposite direction, it's in "defense in depth" sense. <br>
I would prefer to validate the request/response with better granularity and fail gracefully. </p>
<p>OOM and trap are not really scalable and waste resources. It possibly multiplies cost of defense vs cost of attack.</p>
<blockquote>
<p>Each request is handled in a separate wasm instance</p>
</blockquote>
<p>This solution is about security/configuration on the deployment layer. I as an author of a component, don't want to rely on it. I want to do my part of the responsibility for making the attack surface smaller.</p>
<p>I would like to express something like: 'I do not accept more than 50 request headers' or <code>each header can't be longer than 10KB</code> or <code>refuse request body over 10MB</code>.</p>
<p>This could be pre-flight API that the http handler could implement. Or it could be part of the host contract in some way. Thoughts ?</p>
<blockquote>
<p>Or do you mean a wasm component connecting to a malicious server?</p>
</blockquote>
<p>Yes I was talking about both client and server, this is client side. <br>
In this scenario, it would be good if I could express what is "too large response" for my use-case. </p>
<p>Perhaps, this is similar to timeout options:<br>
<a href="https://github.com/WebAssembly/WASI/issues/813">https://github.com/WebAssembly/WASI/issues/813</a></p>
<p>Should I add my feature request there ?</p>
<blockquote>
<p>when <code>cabi_realloc</code> is called for this too-large list today this ends up trapping</p>
</blockquote>
<p>Even if the allocation of the call buffer on heap succeeds, the marshaling to guest (C#) data structures  will temporarily double the memory. With a possible bad design of the wit-bindgen generated code, this could also lead to stack overflow during marshaling.</p>
<blockquote>
<p>lazy lowering ABI</p>
</blockquote>
<p>This seems to be optimization on the marshaling layer. I wonder if there would be callbacks, that would allow the application layer to say "10K items in this list is too much" far before it becomes OOM scenario. </p>
<p>It makes sense to talk about such constraints on general component API attack surface, not just HTTP specifically. I guess wasi:sockets has similar challenges.</p>



<a name="574583759"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/Unbounded%20collections%20on%20the%20WASI%20interface/near/574583759" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Luke Wagner <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/Unbounded.20collections.20on.20the.20WASI.20interface.html#574583759">(Feb 18 2026 at 19:04)</a>:</h4>
<p><span class="user-mention" data-user-id="471788">@Pavel Šavara</span> That makes sense</p>
<blockquote>
<p>This seems to be optimization on the marshaling layer. I wonder if there would be callbacks, that would allow the application layer to say "10K items in this list is too much" far before it becomes OOM scenario.</p>
</blockquote>
<p>The Lazy ABI would allow guest code to decide whether to accept or fail lowering any particular <code>list</code>/<code>string</code> using arbitrary guest code logic (ultimately deciding whether to call some TBD <code>list.lower</code> or <code>list.drop</code> built-in before returning a possible-error <code>result</code>) and so the guest bindgen could do something more nuanced than simply "fail if <code>memory.grow</code> fails" up to and including, to your point, allowing guest code to register callbacks.  And since this is all controlled by guest wit-bindgen, it could be configurable and iterated on over time independently of the runtime or WIT interface, which is nice.</p>
<p>In the meantime, I would expect the host implementations of WASI HTTP and CLI to impose reasonable default limits so that this issue didn't arise much practice.</p>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>