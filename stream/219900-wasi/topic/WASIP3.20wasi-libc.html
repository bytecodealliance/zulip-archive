<html>
<head><meta charset="utf-8"><title>WASIP3 wasi-libc · wasi · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/index.html">wasi</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html">WASIP3 wasi-libc</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="509254910"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/WASIP3%20wasi-libc/near/509254910" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amber <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html#509254910">(Mar 31 2025 at 16:45)</a>:</h4>
<p>Hey all! First time opening a thread here, also my first time using Zulip... I appreciate any patience with any error I make opening this thread :).</p>
<p>I've been lurking and working on wasip3 support as a consumer of wasmtime for a project of mine, and I've been exploring adding p3 support to the rust libc (and thus wasi-libc, and wasi-sdk, and so on) and made some progress but there's nothing notable other than just having everything plumbed together to iterate on p3 libc support. I was hoping to do more of the work before ever mentioning it, but I want to make sure to reach out to see if what I'm doing fits into the plans for p3. Right now I've been working on wit-bindgen's c bindings.</p>
<p>If there's any interest at all in what I've done I'd be glad to push my work and we can take a look, otherwise I'm perfectly content continuing individually. I'd also be glad to rework any previous work to align with upstream goals.</p>



<a name="509257448"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/WASIP3%20wasi-libc/near/509257448" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amber <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html#509257448">(Mar 31 2025 at 16:58)</a>:</h4>
<p>My implementation is driven by the ultimate task of "port tokio (and its internal deps) to wasip3" (at least as a fork I can use myself). I felt like the tokio port for p2 using libc looked pretty reasonable, so that's the approach thats driving my p3 work.</p>



<a name="509257573"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/WASIP3%20wasi-libc/near/509257573" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joel Dice <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html#509257573">(Mar 31 2025 at 16:59)</a>:</h4>
<p>That sounds awesome!  <span class="user-mention" data-user-id="253994">@Alex Crichton</span> and I both started sketching <code>wit-bindgen</code> C support for component model async but haven't had a chance to take it beyond a sketch.  Also, <span class="user-mention" data-user-id="253992">@Pat Hickey</span> has been thinking about updating <code>wasi-libc</code>'s support for p2 by removing the dependency on the p1-&gt;p2 adapter, which would be a helpful step towards native p3 support, so you might want to coordinate your wasi-libc efforts with him.</p>
<p>Posting here is a great way to start a discussion.  In addition, opening a draft PR for the <code>wit-bindgen</code> C work would be a great way to collaborate and avoid redundant effort.</p>



<a name="509533155"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/WASIP3%20wasi-libc/near/509533155" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amber <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html#509533155">(Apr 01 2025 at 19:35)</a>:</h4>
<p>I'm interested in taking a look at the existing sketches, I did a really cursory look for where that'd be , found this: <a href="https://hackmd.io/@NXXwAQZbQ8CTpJXGoJcJ8w/SyIwhv9i6">https://hackmd.io/@NXXwAQZbQ8CTpJXGoJcJ8w/SyIwhv9i6</a>, which I suspect is a start but I'm getting the impression there's more to find. Are there any other places I should look for existing conceptualization / implementation on the wit-bindgen c support?</p>
<div class="message_embed"><a class="message_embed_image" href="https://hackmd.io/@NXXwAQZbQ8CTpJXGoJcJ8w/SyIwhv9i6" style="background-image: url(&quot;https://uploads.zulipusercontent.net/f8833a4340ab1f5f4b067117308223870fca5545/68747470733a2f2f6861636b6d642e696f2f696d616765732f6d656469612f4861636b4d442d6e656f2d6f672e6a7067&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://hackmd.io/@NXXwAQZbQ8CTpJXGoJcJ8w/SyIwhv9i6" title="Component Model Async MVP Implementation Plan - HackMD">Component Model Async MVP Implementation Plan - HackMD</a></div><div class="message_embed_description">This is a brief outline of a plan to implement conc</div></div></div>



<a name="509538346"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/WASIP3%20wasi-libc/near/509538346" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html#509538346">(Apr 01 2025 at 20:05)</a>:</h4>
<p>Currently there's no async support in <code>wit-bindgen c</code>, and while I was going to start it a month or so ago I still haven't gotten around to doing so. You're welcome though to try to take this on and see where it goes! I'll caution you though in that there is not a stable foundation to build on at this time. For example there are no runtime tests in the wit-bindgen repository for async things nor is it easy to set them up. Additionally we're still figuring out idioms and general infrasturctural questions, for example wasi-libc and wasi-sdk haven't started to add a p3 target yet (much less rustc). Basically there's a lot up in the air, and I mostly want to make sure to set expectations</p>



<a name="509542558"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/WASIP3%20wasi-libc/near/509542558" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joel Dice <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html#509542558">(Apr 01 2025 at 20:32)</a>:</h4>
<p>This is my very rough, incomplete sketch of C bindgen support from a while ago: <a href="https://github.com/dicej/wit-bindgen/tree/c-async">https://github.com/dicej/wit-bindgen/tree/c-async</a></p>
<p>The basic idea was that, for each async-lowered import (named "foo", for example), we'd declare three functions: <code>foo</code>, <code>foo_lift</code>, and <code>foo_free</code>, plus one type: <code>foo_result_t</code>.  <code>foo</code> would return a <code>foo_result_t</code> which is a newtype wrapper around a general-purpose <code>async_result_t</code> type that looks something like:</p>
<div class="codehilite" data-code-language="C"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">status_code</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">subtask_handle</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">params</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">results</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">async_result_t</span><span class="p">;</span>
</code></pre></div>
<p>The <code>foo_lift</code> function could be called once the subtask has reached <code>STATUS_RETURNED</code> and take a <code>foo_result_t *</code> parameter, plus outpointer(s) for each lifted result, lifting from the lowered results in <code>async_result_t::results</code> into the outpointer(s).  The caller is then responsible for disposing of the <code>foo_result_t</code> by passing it to <code>foo_result_free</code>.</p>
<p>Note that I hadn't even started thinking about how exports would work, but Alex recently did some brainstorming about that: <a href="https://github.com/WebAssembly/component-model/issues/485#issuecomment-2766981494">https://github.com/WebAssembly/component-model/issues/485#issuecomment-2766981494</a></p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/dicej/wit-bindgen/tree/c-async" style="background-image: url(&quot;https://uploads.zulipusercontent.net/af7a8c57cce9d733cdb6a218475d8bd06fe1f403/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f383461633737363031376234363437643161373964333435663466626635343262356133383264613134376635613162373932363738633939393431306162382f646963656a2f7769742d62696e6467656e&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/dicej/wit-bindgen/tree/c-async" title="GitHub - dicej/wit-bindgen at c-async">GitHub - dicej/wit-bindgen at c-async</a></div><div class="message_embed_description">A language binding generator for WebAssembly interface types - GitHub - dicej/wit-bindgen at c-async</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/WebAssembly/component-model/issues/485#issuecomment-2766981494" style="background-image: url(&quot;https://uploads.zulipusercontent.net/49b8dd6b5fb8905243d3f75a89e91b2f2292ac44/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f373164383230623062643738656236343038666238303531336130643961326533306633663735656535373061663666393235323162653133616665326131332f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f6973737565732f343835&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/WebAssembly/component-model/issues/485#issuecomment-2766981494" title="Toolchain conventions and `context.get` · Issue #485 · WebAssembly/component-model">Toolchain conventions and `context.get` · Issue #485 · WebAssembly/component-model</a></div><div class="message_embed_description">Currently in wit-bindgen it uses context.get to store a per-exported-task data structure which manages waitable sets and and child tasks from Rust's perspectives (not component-model tasks, Rust ta...</div></div></div>



<a name="509542954"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/WASIP3%20wasi-libc/near/509542954" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amber <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html#509542954">(Apr 01 2025 at 20:34)</a>:</h4>
<p>For what it's worth regarding the challenges of building on the existing foundation, I have a forked <code>rust</code> that I added <code>wasm32-wasip3</code> to and integrated to the point that I can consume the target and build a crate. I also have <code>libc</code>, <code>wasi-sdk</code>, and <code>wasi-libc</code> set up to build a p3 sdk sysroot along with the rest of the existing targets. Obviously there is no actual p3 implementation so there's no impact for that work, but I should be pretty well set up to iterate on some wit-bindgen work for p3. Obviously the part where my work became definitely blocked was when none of the in-progress branches with wit-bindgen changes had full implementations of the new codegen for the p3 ABI. I also am entirely willing to do some work that with requirements that change later on, so I'd love to see where I can take wit-bindgen c support with the planning available right now</p>



<a name="509546652"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/WASIP3%20wasi-libc/near/509546652" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Amber <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html#509546652">(Apr 01 2025 at 20:58)</a>:</h4>
<p>My understanding is that long term what I've said I have doesn't meet the higher level desires for what an implementation looks like since I figure anything short of a fully unit/integration tested implementation isn't what you're looking for. I like testing so I would be fine if I had to do any of that work. <br>
Ultimately what I feel like my expectation is, is that anything I do related to this task in the rustc and libc realm is something I'm doing without any proper planning or coordination and would treat it as such. The <code>wasi-sdk</code>, <code>wasi-libc</code>, and <code>wit-bindgen</code> work is relevant enough to the current phase of the p3 timeline as I understand it and so I'd continue collaborating until any potential other work I did might fit into the plans.</p>



<a name="509552595"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/WASIP3%20wasi-libc/near/509552595" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html#509552595">(Apr 01 2025 at 21:40)</a>:</h4>
<p>The root of many of these changes will definitely start with C bindings for p3/async things, so that's probably a good place to start. The main thing is that it'll be kind of hard to test and exercise that at this time</p>



<a name="558320571"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/WASIP3%20wasi-libc/near/558320571" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Christof Petig <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html#558320571">(Nov 19 2025 at 23:04)</a>:</h4>
<p>I am wondering whether the addition of cooperative threads to wasmtime could make a difference for implementing wasip3 in libc. My understanding is that <code>waitable-set.wait</code> would enable reasonable behavior for a "blocking" system call without forcing C to learn async functions.</p>



<a name="558320596"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/WASIP3%20wasi-libc/near/558320596" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Notification Bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html#558320596">(Nov 19 2025 at 23:05)</a>:</h4>
<p><span class="user-mention silent" data-user-id="590366">Christof Petig</span> has marked this topic as unresolved.</p>



<a name="558323545"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/219900-wasi/topic/WASIP3%20wasi-libc/near/558323545" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joel Dice <a href="https://bytecodealliance.github.io/zulip-archive/stream/219900-wasi/topic/WASIP3.20wasi-libc.html#558323545">(Nov 19 2025 at 23:30)</a>:</h4>
<p>I think the idea is that any given blocking call in <code>wasi-libc</code> will call an async-lowered import (or <code>stream.read</code>, <code>stream.write</code>, etc.) and then suspend the current thread if a result is not yet available, only resuming that thread once the operation finishes.  Whether <code>waitable-set.wait</code> is used (vs. returning <code>CALLBACK_CODE_WAIT</code> from an async-lifted export) to wait for an event on one of the accumulated waitables would depend on whether a sync-lifted or async-lifted export was called.</p>
<p>But yes, for the most part it would be plain old synchronous C, except for right at the edges (i.e. at the exports and imports).</p>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>