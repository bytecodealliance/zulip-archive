<html>
<head><meta charset="utf-8"><title>How to access the memory of a component 路 wasmtime 路 Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/index.html">wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/How.20to.20access.20the.20memory.20of.20a.20component.html">How to access the memory of a component</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="544975845"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/How%20to%20access%20the%20memory%20of%20a%20component/near/544975845" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Antoine Lavandier <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/How.20to.20access.20the.20memory.20of.20a.20component.html#544975845">(Oct 15 2025 at 13:57)</a>:</h4>
<p>With modules, you can access the linear memory with <code>Instance::get_memory()</code>. <code>component::Instance</code> doesn't have a similar method. What is the preferred way to access the memory directly ?</p>



<a name="544978529"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/How%20to%20access%20the%20memory%20of%20a%20component/near/544978529" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joel Dice <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/How.20to.20access.20the.20memory.20of.20a.20component.html#544978529">(Oct 15 2025 at 14:07)</a>:</h4>
<p>A component is a "shared-nothing" abstraction, meaning there's no way for it to export a memory, table, or global variable, nor is there a way to access any of those things directly using Wasmtime's API.  You can pass  e.g. <code>list&lt;u8&gt;</code> objects to and from the component when calling exported functions, or use a <code>stream&lt;u8&gt;</code> to stream bytes asynchronously (which gives you temporary access to the subset of guest memory being read from or written to), but there's no way to get access to an entire memory at once.</p>
<p>If you can elaborate on what you're trying to do, we might be able to give you more specific advice.</p>



<a name="544986622"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/How%20to%20access%20the%20memory%20of%20a%20component/near/544986622" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Antoine Lavandier <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/How.20to.20access.20the.20memory.20of.20a.20component.html#544986622">(Oct 15 2025 at 14:37)</a>:</h4>
<p>The big picture is that I want to build a GET/POST/PUT type service where requests concerning certain URIs are dealt with by a component. To that end, when said URIs appear, I want to write the request's payload directly in the component's linear memory to avoid the unnecessary copying that comes from using <code>list&lt;u8&gt;</code>. IIUC, having a back and forth with <code>list&lt;u8&gt;</code> would mean using 3 or 4 dynamic allocations every time (2 in the Host, 1 or 2 in the Guest) when really only 1 or 2 allocations (in my case they could probably even be static) in the Guest  are needed. </p>
<p>I haven't tried <code>streams</code> because I thought that they required <code>std</code>/ <code>wasi</code> to function but that perhaps isn't true. I'm using wasmtime on embedded devices so <code>no_std</code> is required.</p>



<a name="544987062"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/How%20to%20access%20the%20memory%20of%20a%20component/near/544987062" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ramon Klass <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/How.20to.20access.20the.20memory.20of.20a.20component.html#544987062">(Oct 15 2025 at 14:39)</a>:</h4>
<p>what you are describing is only possible with modules (wasip1 or wasm), components force you into sending list&lt;u8&gt; etc</p>



<a name="544988113"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/How%20to%20access%20the%20memory%20of%20a%20component/near/544988113" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joel Dice <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/How.20to.20access.20the.20memory.20of.20a.20component.html#544988113">(Oct 15 2025 at 14:43)</a>:</h4>
<p><span class="user-mention silent" data-user-id="940046">Antoine Lavandier</span> <a href="#narrow/channel/217126-wasmtime/topic/How.20to.20access.20the.20memory.20of.20a.20component/near/544986622">said</a>:</p>
<blockquote>
<p>I haven't tried <code>streams</code> because I thought that they requires <code>std</code>/ <code>wasi</code> to function but that perhaps isn't true.</p>
</blockquote>
<p><code>stream</code>s don't require WASI, but they do currently require <code>std</code>.  Theoretically, we could probably make the host implementation <code>no-std</code>-compatible, though.  I do suspect using a <code>stream&lt;u8&gt;</code> would be most optimal for your case, since it allows you to write directly to the guest memory.</p>



<a name="544989101"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/How%20to%20access%20the%20memory%20of%20a%20component/near/544989101" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Antoine Lavandier <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/How.20to.20access.20the.20memory.20of.20a.20component.html#544989101">(Oct 15 2025 at 14:46)</a>:</h4>
<p><span class="user-mention silent" data-user-id="509936">Joel Dice</span> <a href="#narrow/channel/217126-wasmtime/topic/How.20to.20access.20the.20memory.20of.20a.20component/near/544988113">said</a>:</p>
<blockquote>
<p><code>stream</code>s don't require WASI, but they do currently require <code>std</code>.  Theoretically, we could probably make the host implementation <code>no-std</code>-compatible, though.  I do suspect using a <code>stream&lt;u8&gt;</code> would be most optimal for your case, since it allows you to write directly to the guest memory.</p>
</blockquote>
<p>Where does that implementation lie in the Wasmtime repo ? If it's something I can reasonably understand I wouldn't be against participating in making it <code>no_std</code> compatible</p>



<a name="544992376"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/How%20to%20access%20the%20memory%20of%20a%20component/near/544992376" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joel Dice <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/How.20to.20access.20the.20memory.20of.20a.20component.html#544992376">(Oct 15 2025 at 14:59)</a>:</h4>
<p><a href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasmtime/src/runtime/component/concurrent.rs">https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasmtime/src/runtime/component/concurrent.rs</a> and the various submodules under <a href="https://github.com/bytecodealliance/wasmtime/tree/main/crates/wasmtime/src/runtime/component/concurrent">https://github.com/bytecodealliance/wasmtime/tree/main/crates/wasmtime/src/runtime/component/concurrent</a>, most notably <code>futures_and_streams.rs</code>.  There's a lot of code, and it's not easy to wrap your head around, but I imagine implementing <code>no_std</code> support wouldn't require deep understanding; just changing the <code>use</code> statements from <code>std</code> to <code>core</code> or <code>alloc</code> as appropriate, and maybe adding some <code>#[cfg(...)]</code> attributes to any features that really require <code>std</code> (I don't know of any offhand).</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasmtime/src/runtime/component/concurrent.rs" style="background-image: url(&quot;https://uploads.zulipusercontent.net/e10cb88e6f5d846701a2f3123949b6d09431bb2f/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633835366362626331643864343766313134313065343536633135626339636663353237343431666564666437623365313830653561396636666435666466372f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasmtime/src/runtime/component/concurrent.rs" title="wasmtime/crates/wasmtime/src/runtime/component/concurrent.rs at main 路 bytecodealliance/wasmtime">wasmtime/crates/wasmtime/src/runtime/component/concurrent.rs at main 路 bytecodealliance/wasmtime</a></div><div class="message_embed_description">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/tree/main/crates/wasmtime/src/runtime/component/concurrent" style="background-image: url(&quot;https://uploads.zulipusercontent.net/e10cb88e6f5d846701a2f3123949b6d09431bb2f/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633835366362626331643864343766313134313065343536633135626339636663353237343431666564666437623365313830653561396636666435666466372f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/tree/main/crates/wasmtime/src/runtime/component/concurrent" title="wasmtime/crates/wasmtime/src/runtime/component/concurrent at main 路 bytecodealliance/wasmtime">wasmtime/crates/wasmtime/src/runtime/component/concurrent at main 路 bytecodealliance/wasmtime</a></div><div class="message_embed_description">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>