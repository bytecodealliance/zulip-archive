<html>
<head><meta charset="utf-8"><title>Preemptive Threading for Wasmtime · wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/index.html">wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Preemptive.20Threading.20for.20Wasmtime.html">Preemptive Threading for Wasmtime</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="563333602"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Preemptive%20Threading%20for%20Wasmtime/near/563333602" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jerry Yang <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Preemptive.20Threading.20for.20Wasmtime.html#563333602">(Dec 12 2025 at 06:48)</a>:</h4>
<p>Hi folks, my friend and I are working on supporting preemptive threading in Wasmtime (i.e., adding the scheduling part to time-slice running fibers and perform runtime-managed context switches, right now, round-robin only). This work is built directly on top of the existing cooperative threading context-switching work last month. Our current prototype is x86_64-only, since the runtime currently has full support only on x86_64.</p>
<p>We have an initial implementation exploring two interrupt mechanisms:</p>
<ul>
<li>epoch interrupt, driven by a ticker thread to trigger context switches with fixed time-elasped, and</li>
<li>fuel metering, which basically works but currently still has some resources related issues around sync/async interactions that we are still debugging.</li>
</ul>
<p>This has been a fun project, but we would like to sanity-check the direction with the Wasmtime team and the broader community:</p>
<ul>
<li>Is there any existing plan to have a proposal or design around preemptive threading?</li>
<li>If not, would it be preferable for us to draft something and share it for discussion, and if so, should that discussion start on Zulip or GitHub?</li>
</ul>
<p>This work is primarily exploratory and for fun, but we are also hoping to align on whether a proposal is plausible and, if so, to have a concrete target to guide further implementation.</p>
<p>Thanks!</p>



<a name="563836688"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Preemptive%20Threading%20for%20Wasmtime/near/563836688" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joel Dice <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Preemptive.20Threading.20for.20Wasmtime.html#563836688">(Dec 15 2025 at 14:23)</a>:</h4>
<p>Sounds like a great project!</p>
<p><span class="user-mention silent" data-user-id="971645">Jerry Yang</span> <a href="#narrow/channel/217126-wasmtime/topic/Preemptive.20Threading.20for.20Wasmtime/near/563333602">said</a>:</p>
<blockquote>
<ul>
<li>Is there any existing plan to have a proposal or design around preemptive threading?</li>
</ul>
</blockquote>
<p>Not that I'm aware of -- at least not for the component model.</p>
<blockquote>
<ul>
<li>If not, would it be preferable for us to draft something and share it for discussion, and if so, should that discussion start on Zulip or GitHub?</li>
</ul>
</blockquote>
<p>A PR to the <a href="https://github.com/WebAssembly/component-model">component-model</a> would probably be a good place for a draft if you've got something concrete to share.  If you're still feeling out the design space, an issue on that repo and/or a discussion on Zulip would also be appropriate.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/WebAssembly/component-model" style="background-image: url(&quot;https://uploads.zulipusercontent.net/c377b983cce8325b44259ab785090e334268d29b/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f653466613361646531363031353235343030633364653964613765346263643939643231353630316436363239613134353861323261306530366333333363362f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/WebAssembly/component-model" title="GitHub - WebAssembly/component-model: Repository for design and specification of the Component Model">GitHub - WebAssembly/component-model: Repository for design and specification of the Component Model</a></div><div class="message_embed_description">Repository for design and specification of the Component Model - WebAssembly/component-model</div></div></div>



<a name="563871248"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Preemptive%20Threading%20for%20Wasmtime/near/563871248" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joel Dice <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Preemptive.20Threading.20for.20Wasmtime.html#563871248">(Dec 15 2025 at 16:36)</a>:</h4>
<p>The main question that comes to mind for me is: How might this be implemented in other runtimes which might not have an equivalent to epoch interruption or fuel metering?</p>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>