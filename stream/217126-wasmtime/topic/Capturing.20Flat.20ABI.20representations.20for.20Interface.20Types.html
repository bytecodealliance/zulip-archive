<html>
<head><meta charset="utf-8"><title>Capturing Flat ABI representations for Interface Types · wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/index.html">wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Capturing.20Flat.20ABI.20representations.20for.20Interface.20Types.html">Capturing Flat ABI representations for Interface Types</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="543122765"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Capturing%20Flat%20ABI%20representations%20for%20Interface%20Types/near/543122765" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Arjun Ramesh <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Capturing.20Flat.20ABI.20representations.20for.20Interface.20Types.html#543122765">(Oct 04 2025 at 23:17)</a>:</h4>
<p>As I am building RR into Wasmtime, I recognize the need to allow access to the exact flat ABI representation.Each flat slot is a <code>ValRaw</code> of 128 bytes,  and understanding the  bytes of significance to record will allow compressions on trace sizes. Right now, it doesn't seem like this ABI is captured anywhere  (correct me if I'm wrong). The canonical ABI options now only capture the flat count:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">CanonicalAbiInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// The byte-size of this type in a 32-bit memory.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">size32</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="sd">/// The byte-alignment of this type in a 32-bit memory.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">align32</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="sd">/// The byte-size of this type in a 64-bit memory.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">size64</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="sd">/// The byte-alignment of this type in a 64-bit memory.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">align64</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="sd">/// The number of types it takes to represents this type in the "flat"</span>
<span class="w">    </span><span class="sd">/// representation of the canonical abi where everything is passed as</span>
<span class="w">    </span><span class="sd">/// immediate arguments or results.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// If this is `None` then this type is not representable in the flat ABI</span>
<span class="w">    </span><span class="sd">/// because it is too large.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">flat_count</span><span class="p">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<p>My initial impression is we capture this ABI information in the above struct, with something like this, that we can build up with the types:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">FlatAbiInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">count</span><span class="p">:</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="sd">/// A `count` sized array that represents the number of bytes used within each flat slot</span>
<span class="w">    </span><span class="n">bytes</span><span class="p">:</span><span class="w"> </span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">CanonicalAbiInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// The byte-size of this type in a 32-bit memory.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">size32</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="sd">/// The byte-alignment of this type in a 32-bit memory.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">align32</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="sd">/// The byte-size of this type in a 64-bit memory.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">size64</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="sd">/// The byte-alignment of this type in a 64-bit memory.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">align64</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span>
<span class="w">    </span><span class="sd">/// The flat ABI representation when everything is passed as</span>
<span class="w">    </span><span class="sd">/// immediate arguments or results.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// If this is `None` then this type is not representable in the flat ABI</span>
<span class="w">    </span><span class="sd">/// because it is too large.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">flat</span><span class="p">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">FlatAbiInfo</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<p>In fact, we should use the above flat ABI representation to streamline <code>linear_lower_to_flat</code> implementations for all the types as well. It looks like right now this is fully ad-hoc -- to understand the flat ABI completely, I need to look into the detailed implementations of each type. </p>
<p>What do folks think of this? <span class="user-mention" data-user-id="253994">@Alex Crichton</span> might have some more detailed thoughts</p>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>