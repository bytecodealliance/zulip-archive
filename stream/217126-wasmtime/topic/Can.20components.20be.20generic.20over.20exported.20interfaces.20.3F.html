<html>
<head><meta charset="utf-8"><title>Can components be generic over exported interfaces ? · wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/index.html">wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Can.20components.20be.20generic.20over.20exported.20interfaces.20.3F.html">Can components be generic over exported interfaces ?</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="546176998"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Can%20components%20be%20generic%20over%20exported%20interfaces%20%3F/near/546176998" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Antoine Lavandier <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Can.20components.20be.20generic.20over.20exported.20interfaces.20.3F.html#546176998">(Oct 21 2025 at 08:52)</a>:</h4>
<p>It's possible to generic of the imported interfaces of a components (in fact this is how <code>add_to_linker</code> works). Is it possible to also do this with exported interfaces ?<br>
So for example this is possible</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">wastime</span><span class="p">::</span><span class="n">component</span><span class="p">::</span><span class="n">bindgen</span><span class="p">({</span>
<span class="w">    </span><span class="n">inline</span><span class="p">:</span><span class="w"> </span><span class="nc">r</span><span class="p">#</span><span class="s">"</span>
<span class="s">        package example:interface-imports;</span>

<span class="s">        interface logging {</span>
<span class="s">            enum level {</span>
<span class="s">                debug,</span>
<span class="s">                info,</span>
<span class="s">                warn,</span>
<span class="s">                error,</span>
<span class="s">            }</span>

<span class="s">            log: func(level: level, msg: string);</span>
<span class="s">        }</span>

<span class="s">        world with-imports {</span>
<span class="s">            import logging;</span>
<span class="s">        }</span>
<span class="s">    "</span><span class="p">#</span>
<span class="p">});</span>

<span class="k">use</span><span class="w"> </span><span class="n">example</span><span class="p">::</span><span class="n">interface_imports</span><span class="p">::</span><span class="n">logging</span><span class="p">::</span><span class="n">Host</span>

<span class="k">fn</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nc">Host</span><span class="o">&gt;</span><span class="p">(</span><span class="n">host</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">){</span>
<span class="w">  </span><span class="c1">// Do stuff like</span>
<span class="w">  </span><span class="c1">// Create a store owning a T</span>
<span class="w">  </span><span class="c1">// and use it to instantiate a component</span>
<span class="p">}</span>
</code></pre></div>
<p>Is there a way to something like this </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">wastime</span><span class="p">::</span><span class="n">component</span><span class="p">::</span><span class="n">bindgen</span><span class="p">({</span>
<span class="w">    </span><span class="n">inline</span><span class="p">:</span><span class="w"> </span><span class="nc">r</span><span class="p">#</span><span class="s">"</span>
<span class="s">        package example:interface-imports;</span>

<span class="s">        interface logging {</span>
<span class="s">            enum level {</span>
<span class="s">                debug,</span>
<span class="s">                info,</span>
<span class="s">                warn,</span>
<span class="s">                error,</span>
<span class="s">            }</span>

<span class="s">            log: func(level: level, msg: string);</span>
<span class="s">        }</span>

<span class="s">        world with-imports {</span>
<span class="s">            export logging;</span>
<span class="s">        }</span>
<span class="s">    "</span><span class="p">#</span>
<span class="p">});</span>

<span class="k">use</span><span class="w"> </span><span class="n">example</span><span class="p">::</span><span class="n">interface_imports</span><span class="p">::</span><span class="n">logging</span><span class="p">::</span><span class="n">Guest</span>

<span class="k">fn</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nc">Guest</span><span class="o">&gt;</span><span class="p">(</span><span class="n">guest</span><span class="p">:</span><span class="w"> </span><span class="nc">T</span><span class="p">){</span>
<span class="w">  </span><span class="c1">// Do things like calling guest.call_log():</span>
<span class="p">}</span>
</code></pre></div>
<p>The use case is that I'd like to have a library that ingests any component that implements (i.e. export) interfaces. As far as I know it's not possible to do without me creating that guest trait and users implementing it for the specific struct created when they call <code>bindgen!</code></p>



<a name="546254172"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Can%20components%20be%20generic%20over%20exported%20interfaces%20%3F/near/546254172" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Alex Crichton <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Can.20components.20be.20generic.20over.20exported.20interfaces.20.3F.html#546254172">(Oct 21 2025 at 14:35)</a>:</h4>
<p>Yeah I would agree the guest side would be pretty difficult here due to the fact that it needs to get hooked up to <code>no_mangle</code> functions. It's sort of "almost there" but not quite given the current generated bindings</p>



<a name="546262562"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Can%20components%20be%20generic%20over%20exported%20interfaces%20%3F/near/546262562" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Antoine Lavandier <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Can.20components.20be.20generic.20over.20exported.20interfaces.20.3F.html#546262562">(Oct 21 2025 at 15:08)</a>:</h4>
<p>I took more time to look at the generated code and I think that I have potential solution that would essentially mirror what happens for imported interfaces. If I'm not mistaken declaring <code>with: { "interface": path::to::mod}</code> removes the <code>mod interface { ... }</code> part of the generated code and instead adds <code>use path::to::mod::{Host, add_to_linker,  ...}</code>. <br>
Applied to exported interfaces this could look like this <br>
So by default everything is generated at the <code>bindgen</code> call site and otherwise, it's replace by  <code>use</code> statements when the <code>bindgen</code> caller provides a path to a module that already generates the approriate code.<br>
Then the trait could be defined only once and implemented directly on the struct <code>exports::interface::Guest</code> and/or the <code>MyWorld</code> struct.</p>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>