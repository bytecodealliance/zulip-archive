<html>
<head><meta charset="utf-8"><title>Pooling allocator safety · wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/index.html">wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Pooling.20allocator.20safety.html">Pooling allocator safety</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="546404640"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Pooling%20allocator%20safety/near/546404640" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Ilia <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Pooling.20allocator.20safety.html#546404640">(Oct 22 2025 at 09:16)</a>:</h4>
<p>Hello there. I've read comments in <code>PoolingAllocatorConfig</code> / <code>PoolingInstanceAllocator</code> and my understanding is that regardless of the settings the pooling allocator could not leak data neither to subsequent guest module instances when memory is reused nor to other OS processes when the memory is returned to the system. The reason I am uncertain is the fact that some things as marked on Linux only, and also there are two strategy involved (memset vs madvice), which makes it harder for me to understand as I am not that familiar with these lower level details. </p>
<p>Could you please confirm that even if pooling allocator is used, data from memory could not leak to other module instances or OS processes, or - in other words - that pooling allocator is NOT a trade-off between safety and performance?</p>



<a name="546423803"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Pooling%20allocator%20safety/near/546423803" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Till Schneidereit <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Pooling.20allocator.20safety.html#546423803">(Oct 22 2025 at 10:51)</a>:</h4>
<p>Your understanding of this is correct, yes. Any ability of guest code to access memory outside of its instance sandbox as initialized for that particular instance would be treated as a critical CVE.</p>
<p>The different strategies make use of different sets of functionality provided by the OS to optimize for different performance/resource consumption goals as enabled by the underlying OS (and CPU, where applicable.) All of this is purely in the realm of transparent optimizations, without any tradeoffs to security. To the degree possible these different strategies are also all covered by fuzzing. (The key limit is that OSS-Fuzz, where our CI fuzzing runs, only supports Linux, so that's the platform with the best assurances for operational reasons.)</p>



<a name="546520221"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Pooling%20allocator%20safety/near/546520221" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> fitzgen (he/him) <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Pooling.20allocator.20safety.html#546520221">(Oct 22 2025 at 18:03)</a>:</h4>
<p>And to add on to what Till says here</p>
<p><span class="user-mention silent" data-user-id="234973">Till Schneidereit</span> <a href="#narrow/channel/217126-wasmtime/topic/Pooling.20allocator.20safety/near/546423803">said</a>:</p>
<blockquote>
<p>Any ability of guest code to access memory outside of its instance sandbox as initialized for that particular instance would be treated as a critical CVE.</p>
</blockquote>
<p>this sandboxing is also temporal, not just spatial. That is, new instances cannot observe any data from past instances that happened to use the same pooling slot (and any bug that somehow enabled this would be considered a critical CVE).</p>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>