<html>
<head><meta charset="utf-8"><title>run_concurrent and accessor async ergonomics · wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/index.html">wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/run_concurrent.20and.20accessor.20async.20ergonomics.html">run_concurrent and accessor async ergonomics</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="547841192"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/run_concurrent%20and%20accessor%20async%20ergonomics/near/547841192" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jelle van den Hooff <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/run_concurrent.20and.20accessor.20async.20ergonomics.html#547841192">(Oct 30 2025 at 02:02)</a>:</h4>
<p>Hi, I wanted to leave a small usage report of <code>run_concurrent</code> and the <code>Accessor</code> API with the asynchronous component model. I am using wasmtime to embed a wasm component, and I want that component to run its tasks while I also invoke more tasks. In this specific case, I want to invoke more HTTP handlers while other handlers are already running. That is difficult because (it seems to me) that <code>run_concurrent</code> is the only way to get access to the <code>Accessor</code> I need to do new invocations, and <code>run_concurrent</code> takes a &amp;mut self. (And I want more control than the standard wasi-http wrapper gives, so that's why I am not using that.)</p>
<p>In my mental right now, run_concurrent plays double duty -- it lets me start tasks with an accessor when I call it, and it lets the component make progress while it is running. I wish those were detangled. In an ideal world, I would use tokio::spawn a task that invokes something like run_concurrent on a component instance to let the component do work. Then, whenever I want to muck around with the state, I wish I could get an accessor temporarily by invoking some <code>get_accessor</code> that would temporarily pause the <code>run_concurrent</code> and let me invoke tasks or modify state.</p>
<p>My janky workaround (<a href="https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/wasmtimewrapper.rs#L74">code</a>) right now is to have a worker task that invokes run_concurrent, and that takes tasks from a queue to be invoked inside of that run_concurrent. I can then post tasks (<a href="https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/main.rs#L55">code</a>) to that queue without worrying about starting and stopping the run_concurrent. But it feels yucky.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/wasmtimewrapper.rs#L74" style="background-image: url(&quot;https://uploads.zulipusercontent.net/edd64ad54267c0a881b2e76df857807e2df5f5e3/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353537636165643337613838623165346436663065623234616434333930326365666134656631356135333739616537363331386661323133373139336562632f6a656c6c6576616e64656e686f6f66662f706f7332&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/wasmtimewrapper.rs#L74" title="pos2/wasi3experiment/src/wasmtimewrapper.rs at a83e626fea10f6a90791e68a446adc5d51b5b784 · jellevandenhooff/pos2">pos2/wasi3experiment/src/wasmtimewrapper.rs at a83e626fea10f6a90791e68a446adc5d51b5b784 · jellevandenhooff/pos2</a></div><div class="message_embed_description">Contribute to jellevandenhooff/pos2 development by creating an account on GitHub.</div></div></div><div class="message_embed"><a class="message_embed_image" href="https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/main.rs#L55" style="background-image: url(&quot;https://uploads.zulipusercontent.net/edd64ad54267c0a881b2e76df857807e2df5f5e3/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353537636165643337613838623165346436663065623234616434333930326365666134656631356135333739616537363331386661323133373139336562632f6a656c6c6576616e64656e686f6f66662f706f7332&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/main.rs#L55" title="pos2/wasi3experiment/src/main.rs at a83e626fea10f6a90791e68a446adc5d51b5b784 · jellevandenhooff/pos2">pos2/wasi3experiment/src/main.rs at a83e626fea10f6a90791e68a446adc5d51b5b784 · jellevandenhooff/pos2</a></div><div class="message_embed_description">Contribute to jellevandenhooff/pos2 development by creating an account on GitHub.</div></div></div>



<a name="547841263"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/run_concurrent%20and%20accessor%20async%20ergonomics/near/547841263" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jelle van den Hooff <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/run_concurrent.20and.20accessor.20async.20ergonomics.html#547841263">(Oct 30 2025 at 02:03)</a>:</h4>
<p>It's also entirely possible I am doing something silly and there is an easier way to do this -- I am all ears :)</p>



<a name="547841394"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/run_concurrent%20and%20accessor%20async%20ergonomics/near/547841394" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Jelle van den Hooff <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/run_concurrent.20and.20accessor.20async.20ergonomics.html#547841394">(Oct 30 2025 at 02:05)</a>:</h4>
<p>(And I tried to find issues describing this on the wasmtime repo but did not find anything that quite matched this.)</p>



<a name="547937285"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/run_concurrent%20and%20accessor%20async%20ergonomics/near/547937285" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Joel Dice <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/run_concurrent.20and.20accessor.20async.20ergonomics.html#547937285">(Oct 30 2025 at 13:37)</a>:</h4>
<p><span class="user-mention silent" data-user-id="981641">Jelle van den Hooff</span> <a href="#narrow/channel/217126-wasmtime/topic/run_concurrent.20and.20accessor.20async.20ergonomics/near/547841192">said</a>:</p>
<blockquote>
<p>My janky workaround (<a href="https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/wasmtimewrapper.rs#L74">code</a>) right now is to have a worker task that invokes run_concurrent, and that takes tasks from a queue to be invoked inside of that run_concurrent. I can then post tasks (<a href="https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/main.rs#L55">code</a>) to that queue without worrying about starting and stopping the run_concurrent.</p>
</blockquote>
<p>FWIW, I think this is a fine approach, and matches what we do in <code>wasmtime-wasi-http</code> to support <a href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi-http/src/handler.rs">handling multiple concurrent incoming requests in a single instance</a>.  Perhaps we could generalize the pattern and make it a built-in part of the Wasmtime API.</p>
<div class="message_embed"><a class="message_embed_image" href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi-http/src/handler.rs" style="background-image: url(&quot;https://uploads.zulipusercontent.net/53ccd21a716c5551e22adba4f377e4e48177dd40/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f313631306661383431303832353162663530383464666137326464386234363937633830363262343661643130316438393739393838626630396661633831622f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)"></a><div class="data-container"><div class="message_embed_title"><a href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi-http/src/handler.rs" title="wasmtime/crates/wasi-http/src/handler.rs at main · bytecodealliance/wasmtime">wasmtime/crates/wasi-http/src/handler.rs at main · bytecodealliance/wasmtime</a></div><div class="message_embed_description">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>



<a name="548197689"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/run_concurrent%20and%20accessor%20async%20ergonomics/near/548197689" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Celarye <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/run_concurrent.20and.20accessor.20async.20ergonomics.html#548197689">(Oct 31 2025 at 16:14)</a>:</h4>
<p>I am also planning on using channels to solve this once I switch to WASI 0.3.</p>
<blockquote>
<p>Perhaps we could generalize the pattern and make it a built-in part of the Wasmtime API.</p>
</blockquote>
<p>I do think that simplifying the API by making this happen under the hood would be a nice improvement.</p>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>