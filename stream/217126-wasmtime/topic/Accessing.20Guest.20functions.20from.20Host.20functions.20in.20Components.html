<html>
<head><meta charset="utf-8"><title>Accessing Guest functions from Host functions in Components · wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/index.html">wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Accessing.20Guest.20functions.20from.20Host.20functions.20in.20Components.html">Accessing Guest functions from Host functions in Components</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="544710058"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Accessing%20Guest%20functions%20from%20Host%20functions%20in%20Components/near/544710058" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Antoine Lavandier <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Accessing.20Guest.20functions.20from.20Host.20functions.20in.20Components.html#544710058">(Oct 14 2025 at 10:19)</a>:</h4>
<p>When using <code>func_wrap</code>, the <code>Caller</code> arg can be used to access guest functions through <code>caller.get_export</code>. So it's possible to have something like this</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">linker</span><span class="p">.</span><span class="n">func_wrap</span><span class="p">(</span><span class="s">"test"</span><span class="p">,</span><span class="w"> </span><span class="s">"call_with"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">caller</span><span class="p">:</span><span class="w"> </span><span class="nc">Caller</span><span class="o">&lt;'</span><span class="nb">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="o">..</span><span class="p">.</span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// I'm assuming the other arguments can be used to get a function name</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">caller</span><span class="p">.</span><span class="n">get_export</span><span class="p">(</span><span class="n">func_name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">Extern</span><span class="p">::</span><span class="n">Func</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">caller</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">(),</span><span class="w"> </span><span class="o">..</span><span class="p">.,</span><span class="w"> </span><span class="o">..</span><span class="p">.).</span><span class="n">unwrap</span><span class="p">(),</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">})</span>
</code></pre></div>
<p>One use case for this is when you want to have the container drive some logic, for example networking while also leaving the routing to the host. It could look something like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">linker</span><span class="p">.</span><span class="n">func_wrap</span><span class="p">(</span><span class="s">"test"</span><span class="p">,</span><span class="w"> </span><span class="s">"register_callbacks"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">caller</span><span class="p">:</span><span class="w"> </span><span class="nc">Caller</span><span class="o">&lt;'</span><span class="nb">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="p">,</span><span class="o">..</span><span class="p">.</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="o">..</span><span class="p">.});</span>
<span class="c1">// This function is called by the guest to register routing rules first</span>

<span class="c1">// Then this is called to "deploy" the logic</span>
<span class="n">linker</span><span class="p">.</span><span class="n">func_wrap</span><span class="p">(</span><span class="s">"test"</span><span class="p">,</span><span class="w"> </span><span class="s">"receive"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">caller</span><span class="p">:</span><span class="w"> </span><span class="nc">Caller</span><span class="o">&lt;'</span><span class="nb">_</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="o">&gt;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">recv</span><span class="p">();</span>
<span class="w">  </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">results</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">caller</span><span class="p">.</span><span class="n">routing_rules</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="n">msg</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">  </span><span class="k">match</span><span class="w"> </span><span class="n">caller</span><span class="p">.</span><span class="n">get_export</span><span class="p">(</span><span class="n">func_name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">Extern</span><span class="p">::</span><span class="n">Func</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="n">caller</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">(),</span><span class="w"> </span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="n">results</span><span class="p">).</span><span class="n">unwrap</span><span class="p">(),</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">})</span>
</code></pre></div>
<p>Is this thing possible with the component model through the <code>Guest</code>, <code>Host</code> and <code>XXImports</code> traits ? A more structured way could be allowing a <code>wit</code> <code>interface</code> to import/require other interfaces or single functions and thus be allowed to call this from within the <code>Host</code> trait.</p>



<a name="544719261"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Accessing%20Guest%20functions%20from%20Host%20functions%20in%20Components/near/544719261" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Antoine Lavandier <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Accessing.20Guest.20functions.20from.20Host.20functions.20in.20Components.html#544719261">(Oct 14 2025 at 11:11)</a>:</h4>
<p>What I'm envisioning would look like this </p>
<div class="codehilite" data-code-language="wit"><pre><span></span><code>package ....;

interface api {
  require foo: func();
  bar: func();
}

world baz {
  import api;
}
</code></pre></div>
<p>Host side:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">wasmtime</span><span class="p">::</span><span class="n">component</span><span class="p">::</span><span class="n">bindgen</span><span class="o">!</span><span class="p">({</span>
<span class="p">});</span>

<span class="k">use</span><span class="w"> </span><span class="o">..</span><span class="p">.::</span><span class="n">api</span><span class="p">::{</span><span class="n">Host</span><span class="p">,</span><span class="w"> </span><span class="n">add_to_linker</span><span class="p">};</span>
<span class="k">use</span><span class="w"> </span><span class="n">api</span><span class="p">::</span><span class="n">required</span><span class="p">::</span><span class="n">foo</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MyHost</span><span class="p">;</span>
<span class="k">impl</span><span class="w"> </span><span class="n">Host</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyHost</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">foo</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Guest Side: </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">wit_bindgen</span><span class="p">::</span><span class="n">generate</span><span class="o">!</span><span class="p">();</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MyGuest</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">api</span><span class="p">::</span><span class="n">Required</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nf">foo</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">todo!</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>



<a name="544736386"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Accessing%20Guest%20functions%20from%20Host%20functions%20in%20Components/near/544736386" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lann Martin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Accessing.20Guest.20functions.20from.20Host.20functions.20in.20Components.html#544736386">(Oct 14 2025 at 12:33)</a>:</h4>
<p>The component model doesn't currently allow this kind of callback implementation; you can't call into a component instance that is already on the stack.</p>



<a name="544738885"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/217126-wasmtime/topic/Accessing%20Guest%20functions%20from%20Host%20functions%20in%20Components/near/544738885" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Lann Martin <a href="https://bytecodealliance.github.io/zulip-archive/stream/217126-wasmtime/topic/Accessing.20Guest.20functions.20from.20Host.20functions.20in.20Components.html#544738885">(Oct 14 2025 at 12:45)</a>:</h4>
<p>Some other ideas:</p>
<ul>
<li>The "callback" return value carries any "actions" the callback wants to perform (e.g. <code>variant callback-actions { increment-counter, set-value(string), ... }</code>).</li>
<li>The callback and its caller share some <code>resource</code> import from a common outer instance. The caller passes an instance of this resource to the callback which calls "update" methods on this resource and the caller observes the results after return.</li>
<li>The new component model async features give a lot more options, such as using <code>stream</code>s as a sort of rpc channel.</li>
</ul>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>