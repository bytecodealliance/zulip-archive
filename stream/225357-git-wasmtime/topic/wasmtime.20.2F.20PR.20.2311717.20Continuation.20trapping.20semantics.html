<html>
<head><meta charset="utf-8"><title>wasmtime / PR #11717 Continuation trapping semantics · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311717.20Continuation.20trapping.20semantics.html">wasmtime / PR #11717 Continuation trapping semantics</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="540481670"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311717%20Continuation%20trapping%20semantics/near/540481670" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311717.20Continuation.20trapping.20semantics.html#540481670">(Sep 19 2025 at 15:24)</a>:</h4>
<p><strong>dhil</strong> requested <a href="https://github.com/alexcrichton">alexcrichton</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/11717">PR #11717</a>.</p>



<a name="540481671"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311717%20Continuation%20trapping%20semantics/near/540481671" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311717.20Continuation.20trapping.20semantics.html#540481671">(Sep 19 2025 at 15:24)</a>:</h4>
<p>dhil opened <a href="https://github.com/bytecodealliance/wasmtime/pull/11717">PR #11717</a> from <code>dhil:continuation-trapping</code> to <code>bytecodealliance:main</code>:</p>
<blockquote>
<p>This patch fixes a problem with traps on continuations, which would otherwise allow a Wasm program to continue running after invoking a trapping instruction. Currently, a fresh trap handler is installed per continuation stack, meaning that the effects of a trap is delimited by the stack segment on which the trap occurred -- whereas it really ought to be delimited by the top-level of the program (i.e. the part just before host/engine frames).</p>
</blockquote>



<a name="540481675"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311717%20Continuation%20trapping%20semantics/near/540481675" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311717.20Continuation.20trapping.20semantics.html#540481675">(Sep 19 2025 at 15:24)</a>:</h4>
<p><strong>dhil</strong> requested <a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers">wasmtime-core-reviewers</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/11717">PR #11717</a>.</p>



<a name="540512139"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311717%20Continuation%20trapping%20semantics/near/540512139" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311717.20Continuation.20trapping.20semantics.html#540512139">(Sep 19 2025 at 18:19)</a>:</h4>
<p>posborne submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/11717#pullrequestreview-3246357798">PR review</a>.</p>



<a name="540512140"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311717%20Continuation%20trapping%20semantics/near/540512140" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311717.20Continuation.20trapping.20semantics.html#540512140">(Sep 19 2025 at 18:19)</a>:</h4>
<p>posborne created <a href="https://github.com/bytecodealliance/wasmtime/pull/11717#discussion_r2364014161">PR review comment</a>:</p>
<blockquote>
<p>Should be able to be simplified slightly to just <code>matches!(*stack_chain, VMStackChain::Continuation(_))</code></p>
</blockquote>



<a name="540627780"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311717%20Continuation%20trapping%20semantics/near/540627780" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311717.20Continuation.20trapping.20semantics.html#540627780">(Sep 21 2025 at 03:15)</a>:</h4>
<p><strong>alexcrichton</strong> requested <a href="https://github.com/fitzgen">fitzgen</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/11717">PR #11717</a>.</p>



<a name="540627807"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311717%20Continuation%20trapping%20semantics/near/540627807" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311717.20Continuation.20trapping.20semantics.html#540627807">(Sep 21 2025 at 03:16)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/11717#issuecomment-3315465336">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/11717">PR #11717</a>:</p>
<blockquote>
<p>I'm not familiar enough with the stack-switching code currently to review this myself. For example I don't know if this is accidentally skipping over native frames at the base of other continuations. Given that I'm going to defer to @fitzgen and @posborne as they're more familiar with the details</p>
</blockquote>



<a name="540833008"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311717%20Continuation%20trapping%20semantics/near/540833008" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311717.20Continuation.20trapping.20semantics.html#540833008">(Sep 22 2025 at 15:19)</a>:</h4>
<p>dhil <a href="https://github.com/bytecodealliance/wasmtime/pull/11717#issuecomment-3319689117">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/11717">PR #11717</a>:</p>
<blockquote>
<blockquote>
<p>For example I don't know if this is accidentally skipping over native frames at the base of other continuations. </p>
</blockquote>
<p>Excellent point. I think it may skip over intermediate <code>invoke_wasm_and_catch_traps</code> frames, suggesting that a "bubbling" semantics of trapping up through continuation stacks may be the right thing to do.</p>
</blockquote>



<a name="541069206"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311717%20Continuation%20trapping%20semantics/near/541069206" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311717.20Continuation.20trapping.20semantics.html#541069206">(Sep 23 2025 at 17:44)</a>:</h4>
<p>fitzgen submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/11717#pullrequestreview-3259035880">PR review</a>:</p>
<blockquote>
<p>Thanks for fixing this bug!</p>
<p>Can we add a test that spawns an N deep stack chain with M frames where every other frame is a host frame, and the last frame (whether host or Wasm) triggers a trap? Then we can run that test exhaustively for small N and M.</p>
<p>Something like</p>
<div class="codehilite" data-code-language="WebAssembly"><pre><span></span><code><span class="p">(</span><span class="k">module</span>
  <span class="c1">;; The imported host function.</span>
  <span class="p">(</span><span class="k">import</span> <span class="s2">"host"</span> <span class="s2">"func"</span> <span class="p">(</span><span class="k">func</span> <span class="nv">$host_func</span> <span class="p">(</span><span class="k">param</span> <span class="kt">i32</span> <span class="kt">i32</span><span class="p">)))</span>

  <span class="c1">;; A global that is incremented after calling the host</span>
  <span class="c1">;; function, which should trap, and therefore the</span>
  <span class="c1">;; increment should never happen.</span>
  <span class="p">(</span><span class="k">global</span> <span class="nv">$g</span> <span class="p">(</span><span class="k">export</span> <span class="s2">"g"</span><span class="p">)</span> <span class="p">(</span><span class="k">mut</span> <span class="kt">i32</span><span class="p">)</span> <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">0</span><span class="p">))</span>

  <span class="p">(</span><span class="k">func</span> <span class="p">(</span><span class="k">export</span> <span class="s2">"run"</span><span class="p">)</span> <span class="p">(</span><span class="k">param</span> <span class="nv">$frames-per-stack</span> <span class="kt">i32</span><span class="p">)</span> <span class="p">(</span><span class="k">param</span> <span class="nv">$fuel</span> <span class="kt">i32</span><span class="p">)</span>
    <span class="c1">;; Trap on out-of-fuel for frames.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">i32.eqz</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$fuel</span><span class="p">))</span>
      <span class="nb">unreachable</span>
    <span class="k">end</span>

    <span class="c1">;; Decrement frame fuel.</span>
    <span class="p">(</span><span class="nb">local.set</span> <span class="nv">$fuel</span> <span class="p">(</span><span class="nb">i32.sub</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$fuel</span><span class="p">)</span> <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">i32.eqz</span> <span class="p">(</span><span class="kt">i32</span><span class="err">.rem</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$fuel</span><span class="p">)</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$frames-per-stack</span><span class="p">))))</span>
      <span class="c1">;; TODO: Spawn a new stack, starting either with `run`</span>
      <span class="c1">;; or our host function (based on another param or a</span>
      <span class="c1">;; global or something), and switch to it...</span>
    <span class="k">else</span>
      <span class="c1">;; Call the host function to continue our mutual recursion.</span>
      <span class="p">(</span><span class="nb">call</span> <span class="nv">$host_func</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$frames-per-stack</span><span class="p">)</span> <span class="p">(</span><span class="nb">local.get</span> <span class="nv">$frame-fuel</span><span class="p">))</span>
    <span class="k">end</span>

    <span class="c1">;; Increment the global. Should never execute, dynamically.</span>
    <span class="p">(</span><span class="nb">global.set</span> <span class="nv">$g</span> <span class="p">(</span><span class="nb">i32.add</span> <span class="p">(</span><span class="nb">global.get</span> <span class="nv">$g</span><span class="p">)</span> <span class="p">(</span><span class="nb">i32.const</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">)</span>
<span class="p">)</span>
</code></pre></div>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">host_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Func</span><span class="p">::</span><span class="n">wrap</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span>
<span class="w">    </span><span class="o">|</span><span class="k">mut</span><span class="w"> </span><span class="n">caller</span><span class="p">:</span><span class="w"> </span><span class="nc">Caller</span><span class="o">&lt;'</span><span class="nb">_</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">frames_per_stack</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="n">fuel</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="o">|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">;;</span><span class="w"> </span><span class="n">Trap</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">out</span><span class="o">-</span><span class="n">of</span><span class="o">-</span><span class="n">fuel</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">frames</span><span class="p">.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">fuel</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">bail</span><span class="o">!</span><span class="p">(</span><span class="s">"out of frame fuel"</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="p">;;</span><span class="w"> </span><span class="n">Mutual</span><span class="w"> </span><span class="n">recursion</span><span class="w"> </span><span class="n">back</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Wasm</span><span class="w"> </span><span class="n">function</span><span class="p">.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instance</span><span class="p">.</span><span class="n">get_typed_func</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">caller</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">run</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">caller</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">frames_per_stack</span><span class="p">,</span><span class="w"> </span><span class="n">fuel</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="p">;;</span><span class="w"> </span><span class="n">Increment</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">global</span><span class="p">.</span><span class="w"> </span><span class="n">Should</span><span class="w"> </span><span class="n">never</span><span class="w"> </span><span class="n">execute</span><span class="p">,</span><span class="w"> </span><span class="n">dynamically</span><span class="p">.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instance</span><span class="p">.</span><span class="n">get_global</span><span class="p">(</span><span class="s">"g"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">g_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">caller</span><span class="p">).</span><span class="n">unwrap_i32</span><span class="p">();</span>
<span class="w">        </span><span class="n">g</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">caller</span><span class="p">,</span><span class="w"> </span><span class="n">Val</span><span class="p">::</span><span class="n">I32</span><span class="p">(</span><span class="n">g_val</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="w">    </span><span class="p">},</span>
<span class="p">);</span>

<span class="c1">// ...</span>

<span class="k">for</span><span class="w"> </span><span class="n">frames_per_stack</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="mi">4</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">fuel</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="n">frames_per_stack</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">());</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Instance</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">..</span><span class="p">.)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">run</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instance</span><span class="p">.</span><span class="n">get_typed_func</span><span class="p">::</span><span class="o">&lt;</span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="n">run</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">frames_per_stack</span><span class="p">,</span><span class="w"> </span><span class="n">fuel</span><span class="p">))</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instance</span><span class="p">.</span><span class="n">get_global</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="s">"g"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">unwrap_i32</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>This would give me a lot more confidence that we are properly handling traps across stacks, regardless of the stack chain, host functions, and what kind of frame is youngest or oldest.</p>
<p>(And when we add embedder API support for spawning stacks, we should also extend the host function in this new test to use that support)</p>
</blockquote>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>