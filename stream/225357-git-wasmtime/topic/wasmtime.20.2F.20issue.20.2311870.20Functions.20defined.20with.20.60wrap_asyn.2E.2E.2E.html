<html>
<head><meta charset="utf-8"><title>wasmtime / issue #11870 Functions defined with `wrap_asyn... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311870.20Functions.20defined.20with.20.60wrap_asyn.2E.2E.2E.html">wasmtime / issue #11870 Functions defined with `wrap_asyn...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="545132814"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311870%20Functions%20defined%20with%20%60wrap_asyn.../near/545132814" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311870.20Functions.20defined.20with.20.60wrap_asyn.2E.2E.2E.html#545132814">(Oct 15 2025 at 21:50)</a>:</h4>
<p>alexcrichton opened <a href="https://github.com/bytecodealliance/wasmtime/issues/11870">issue #11870</a>:</p>
<blockquote>
<p>This issue is similar to #11869 but I've separated it out to specifically deal with usage of <code>block_on</code> with respect to <code>wrap_async</code> and its variants. The <code>wrap_async</code> function has been a pillar of Wasmtime's async support historically but it's effectively entirely incompatible with component-model-async semantics. Notably <code>wrap_async</code> "locks" a store across <code>await</code> points meaning that it's not possible to progress other tasks at the same time. While this sort of means that <code>wrap_async</code> is "just another blocking call" from the perspective of a component it has the notable consequence of making <code>run_concurrent</code> not actually properly run things concurrently. Effectively this suffers from the same problems as #11869.</p>
<p>Fixing this issue is expected to be difficult. Ideally we'd "just delete all calls and use <code>wrap_concurrent</code> instead", but that's a pretty large change to make. That also doesn't clearly translate to core wasm where there's no equivalent of concurrent calls at this time. A more localized fix would be to remove all of Wasmtime's usage of <code>wrap_async</code>, document the pitfalls, and then move on. For example <code>wasmtime-wasi</code> would avoid using <code>wrap_async</code> and would use <code>wrap_concurrent</code> (or an equivalent thereof) instead. This wouldn't actually fix WASIp1 APIs since there's no <code>*_concurrent</code> available, though.</p>
<p>Regardless I wanted to write down this issue to have a place to discuss this and notably link to in the source/documentation about how this is a major limitation of <code>run_concurrent</code> today.</p>
</blockquote>



<a name="545132815"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311870%20Functions%20defined%20with%20%60wrap_asyn.../near/545132815" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311870.20Functions.20defined.20with.20.60wrap_asyn.2E.2E.2E.html#545132815">(Oct 15 2025 at 21:50)</a>:</h4>
<p><a href="https://github.com/alexcrichton">alexcrichton</a> added the wasm-proposal:component-model-async label to <a href="https://github.com/bytecodealliance/wasmtime/issues/11870">Issue #11870</a>.</p>



<a name="571350792"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311870%20Functions%20defined%20with%20%60wrap_asyn.../near/571350792" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311870.20Functions.20defined.20with.20.60wrap_asyn.2E.2E.2E.html#571350792">(Feb 02 2026 at 05:41)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11870#issuecomment-3833046174">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11870">issue #11870</a>:</p>
<blockquote>
<p>In <a href="https://github.com/bytecodealliance/wasmtime/issues/11869#issuecomment-3832992306">talking with Joel/Luke</a> some time ago, I wanted to write down thoughts relevant to this specifically as well. Notably the conclusion is that if wasm calls a synchronously-typed host function then it's not valid for the wasm to be reentered. This is entirely different for an async-typed host function but for synchronously-typed functions it's not valid for wasm to execute while the host is running.</p>
<p>This puts host calls in a similar situation as #11869 where when synchronous host functions are called we can't just start using <code>run_concurrent</code>. Instead there needs to be some sort of infrastructure to prevent executing more wasm, probably like the async lock described in <a href="https://github.com/bytecodealliance/wasmtime/issues/11869#issuecomment-3832992306">https://github.com/bytecodealliance/wasmtime/issues/11869#issuecomment-3832992306</a>.</p>
<p>This also showcases a glimmer of hope of being able to retain the function signature of <code>func_wrap_async</code> (sort of). Assuming the function signature there is changed to restrict to <code>&amp;mut T</code> instead of <code>StoreContextMut&lt;T&gt;</code>, then that's sort of what happens under the hood. The host function gets to use <code>&amp;mut T</code> and the execution of the host function will block the guest. All further guest invocations will also be blocked, too. This is <em>almost</em> the same as Rust's borrowing rules, but the problem that remains is the fact that "on the other end", the hypothetical <code>run_concurrent</code> block, the embedder still has a <code>Accessor&lt;T&gt;</code> which can temporarily grant <code>StoreContextMut&lt;T&gt;</code>. This gives unfettered access to <code>T</code>, even when it's being borrowed by a host function.</p>
<p>This is not safe in Rust, so something needs to be done. Some ideas, none of which I like, are:</p>
<ul>
<li>Panic in <code>data_mut()</code> and <code>data()</code> if the data is borrowed in a host function at the same time. This means that <code>data_mut()</code> and <code>data()</code> more-or-less couldn't be used within <code>run_concurrent</code>.</li>
<li>Change <code>func_wrap_async</code> to have some sort of extra trait bound on <code>T</code>, such as <code>T: Take</code>. That could be represented as <code>fn take(&amp;mut self) -&gt; Self</code> where the <code>T</code> is "moved" into the host function then put back when it's done. (probably with an overridable <code>restore</code> function which by default overwrites <code>self</code>). This isn't great because it still means that <code>data_mut()</code> and <code>data()</code> within <code>run_concurrent</code> basically aren't helpful. While it's sound and doesn't panic the actual data is just an unuseful shell or husk.</li>
</ul>
<p>I personally don't want to force all embedders to switch to <code>run_concurrent</code> just yet, but this may just be inevitable. That correctly and accurately models the ownership situations, which is that fundamentally you only get access to <code>T</code> temporarily, not for the duration of an async operation. It does sort of seem inevitable that <code>func_wrap_async</code> needs to become more restrictive one way or another. One end of the spectrum is deleting it outright, and the other end of the spectrum is having some sort of more restrictive trait bound which models some sort of common pattern of ownership.</p>
<p>Anyway, that's the thoughts for now at least.</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>