<html>
<head><meta charset="utf-8"><title>wasmtime / issue #9579 Make the imported memory available... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html">wasmtime / issue #9579 Make the imported memory available...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="481064544"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/481064544" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#481064544">(Nov 07 2024 at 08:10)</a>:</h4>
<p>Lohann opened <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>Thanks for filing a feature request! Please fill out the TODOs below.</p>
<h4>Feature</h4>
<p>Hello, I need to access the imported memory inside a functions, then I realized the Caller only show exports, not imports, so I had a lot of trouble to get Wasmtime store working with <a href="https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html">MaybeUnit</a>, this simple solution segfaults:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span><span class="p">::</span><span class="n">uninit</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>

<span class="kd">let</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="p">::</span><span class="n">mem</span><span class="p">::</span><span class="n">transmute</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">// segfaults below</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Instance</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">imports</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div>
<p>Then I realized the issue is that there's no way for me transmute only the State, I need to transmute the Store which is not recommended, once rust <a href="https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html#layout-1">doesn't guarantee the same memory layout</a>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
</code></pre></div>
<p>Actually I haven't find any way to use MaybeUnit that doesn't look hacky, and I want to avoid the usage of Option and unwraps in the code, once it bloats the binary with panic data.</p>
<h4>Alternatives</h4>
<ol>
<li>Make the imported memory easily available inside Functions, ex: expose it in the Caller.</li>
<li>Use <code>#[repr(C)]</code> on <code>Store</code>, so we can safely transmute it.<br>
</li>
</ol>
</blockquote>



<a name="481064808"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/481064808" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#481064808">(Nov 07 2024 at 08:12)</a>:</h4>
<p>Lohann edited <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>Thanks for filing a feature request! Please fill out the TODOs below.</p>
<h4>Feature</h4>
<p>Hello, I need to access the imported memory inside a functions, then I realized the Caller only show exports, not imports, so I had a lot of trouble to get Wasmtime store working with <a href="https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html">MaybeUnit</a>, this simple solution segfaults:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span><span class="p">::</span><span class="n">uninit</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>

<span class="kd">let</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="p">::</span><span class="n">mem</span><span class="p">::</span><span class="n">transmute</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">// ...</span>
<span class="kd">let</span><span class="w"> </span><span class="n">imports</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">memory</span><span class="p">.</span><span class="n">into</span><span class="p">()];</span>

<span class="c1">// segfaults below</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Instance</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">imports</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div>
<p>Then I realized the issue is that there's no way for me transmute only the State, I need to transmute the Store which is not recommended, once rust <a href="https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html#layout-1">doesn't guarantee the same memory layout</a>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
</code></pre></div>
<p>Actually I haven't find any way to use MaybeUnit that doesn't look hacky, and I want to avoid the usage of Option and unwraps in the code, once it bloats the binary with panic data.</p>
<h4>Alternatives</h4>
<ol>
<li>Make the imported memory easily available inside Functions, ex: expose it in the Caller.</li>
<li>Use <code>#[repr(C)]</code> on <code>Store</code>, so we can safely transmute it.<br>
</li>
</ol>
</blockquote>



<a name="481148931"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/481148931" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#481148931">(Nov 07 2024 at 15:47)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-2462576544">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>Where possible I'd recommend avoiding <code>unsafe</code>. If things are segfaulting it's probably due to that, so for example you could store <code>Option&lt;Memory&gt;</code> instead of using <code>MaybeUninit</code> and then there's no need for <code>transmute</code> and this probably won't segfault.</p>
<p>Otherwise though is there a problem with storing the memory in <code>State</code>?</p>
</blockquote>



<a name="481607315"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/481607315" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#481607315">(Nov 10 2024 at 23:33)</a>:</h4>
<p>Lohann <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-2466987241">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<blockquote>
<p>Otherwise though is there a problem with storing the memory in State?</p>
</blockquote>
<p>There's no problem, is just there's no examples of that, and is not ergonomic as using exported memory, rust encourages the use of <a href="https://cliffle.com/blog/rust-typestate/">Typestate Pattern</a>, where the state of an object guarantees it is valid. In this case I want to guarantee the memory ALWAYS exists, that's why I don't want to use Option.<br>
One example is the <a href="https://doc.rust-lang.org/std/num/type.NonZeroU32.html">NonZeroU32</a> by knowing the number is never zero, the rust compiler can do some neat optimizations:</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6778305b1980ec60413183a0a1127a4d">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6778305b1980ec60413183a0a1127a4d</a></p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonZeroU32</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
</code></pre></div>
<p>In my case I want to guarantee the memory always exists, I don't want to handle the <code>Option::None</code> everywhere, neither use <code>unwrap()</code> everywhere, that's ok if there's no other option, but I think this is something that should be supported somehow by wasmtime, once the Store owns the memory, makes sense I be able to store it together with the store.</p>
</blockquote>



<a name="481607891"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/481607891" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#481607891">(Nov 10 2024 at 23:41)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-2466987241">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<blockquote>
<p>Otherwise though is there a problem with storing the memory in State?</p>
</blockquote>
<p>There's no problem, but rust encourages the use of <a href="https://cliffle.com/blog/rust-typestate/">Typestate Pattern</a>, where the state of an object guarantees it is valid. In this case I want to guarantee the memory ALWAYS exists, that's why I don't want to use Option.<br>
One example is the <a href="https://doc.rust-lang.org/std/num/type.NonZeroU32.html">NonZeroU32</a> by knowing the number is never zero, the rust compiler can do some neat optimizations:</p>
<p><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6778305b1980ec60413183a0a1127a4d">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6778305b1980ec60413183a0a1127a4d</a></p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">u32</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">NonZeroU32</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
</code></pre></div>
<p>In my case I want to guarantee the memory always exists, I don't want to handle the <code>Option::None</code> everywhere, neither use <code>unwrap()</code> everywhere, that's ok if there's no other option, but I think this is something that should be supported somehow by wasmtime, once the Store owns the memory, makes sense I be able to store it together with the store.</p>
</blockquote>



<a name="481863294"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/481863294" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#481863294">(Nov 12 2024 at 04:37)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-2469585743">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>One thing you could perhaps do is to create a dummy <code>Memory</code> with a throwaway <code>Store</code> which is placed within future <code>Store</code>s as they're created. That would then be overwritten to the "real" memory once the store is created. That way you can store just <code>Memory</code> without having to deal with <code>Option</code> and you won't have to deal with any unsafety either.</p>
</blockquote>



<a name="553540606"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553540606" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553540606">(Nov 04 2025 at 07:14)</a>:</h4>
<p>Lohann <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to handle imported memory inside imported functions.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that is IMPORTED to the WASM instance.</span>
<span class="w">    </span><span class="sd">/// this MUST be here, otherwise you can't read it inside</span>
<span class="w">    </span><span class="sd">/// imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory that owned by the `store` itself.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State` to be created, but memory also needs `Store` to be created</span>
<span class="w">        </span><span class="c1">// and the `State` needs memory, so this is a ciclc dependency issue, to solve this by first</span>
<span class="w">        </span><span class="c1">// create the `State` using a dummy memory with `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized right below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory` that replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553540779"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553540779" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553540779">(Nov 04 2025 at 07:16)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to handle imported memory inside imported functions.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that is IMPORTED to the WASM instance.</span>
<span class="w">    </span><span class="sd">/// this MUST be here, otherwise you can't read it inside</span>
<span class="w">    </span><span class="sd">/// imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory that owned by the `store` itself.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State` to be created, but memory also needs `Store` to be created</span>
<span class="w">        </span><span class="c1">// and the `State` needs memory, so this is a ciclc dependency issue, to solve this by first</span>
<span class="w">        </span><span class="c1">// create the `State` using a dummy memory with `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory` that replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553540894"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553540894" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553540894">(Nov 04 2025 at 07:16)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to handle imported memory inside imported functions.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that is IMPORTED to the WASM instance.</span>
<span class="w">    </span><span class="sd">/// this MUST be here, otherwise you can't read it inside</span>
<span class="w">    </span><span class="sd">/// imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory that owned by the `store` itself.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State` to be created, but memory also needs `Store` to be created</span>
<span class="w">        </span><span class="c1">// and the `State` needs memory, so this is a ciclc dependency issue, solved this by first</span>
<span class="w">        </span><span class="c1">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory` that replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553541880"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553541880" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553541880">(Nov 04 2025 at 07:25)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to handle imported memory inside imported functions.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that will be IMPORTED to the WASM instance, it must be</span>
<span class="w">    </span><span class="sd">/// created before instantiate the WASM, and must be stored here</span>
<span class="w">    </span><span class="sd">/// otherwise you can't read this memory inside imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory that owned by the `store` itself.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State` to be created, but memory also needs `Store` to be created</span>
<span class="w">        </span><span class="c1">// and the `State` needs memory, so this is a ciclc dependency issue, solved this by first</span>
<span class="w">        </span><span class="c1">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory` that replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553542368"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553542368" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553542368">(Nov 04 2025 at 07:29)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to handle imported memory inside imported functions.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that will be IMPORTED to the WASM instance, it must be</span>
<span class="w">    </span><span class="sd">/// created before instantiate the WASM, and must be stored here</span>
<span class="w">    </span><span class="sd">/// otherwise you can't read this memory inside imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory that owned by the `store` itself.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>
<span class="w">        </span><span class="c1">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>
<span class="w">        </span><span class="c1">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory`, then replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Get the address of state's dummy memory.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="c1">// replaces the  dummy memory by a valid memory</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553542411"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553542411" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553542411">(Nov 04 2025 at 07:29)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to handle imported memory inside imported functions.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that will be IMPORTED to the WASM instance, it must be</span>
<span class="w">    </span><span class="sd">/// created before instantiate the WASM, and must be stored here</span>
<span class="w">    </span><span class="sd">/// otherwise you can't read this memory inside imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory that owned by the `store` itself.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>
<span class="w">        </span><span class="c1">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>
<span class="w">        </span><span class="c1">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Get the address of state's dummy memory.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="c1">// replaces the  dummy memory by a valid memory</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553542665"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553542665" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553542665">(Nov 04 2025 at 07:31)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access imported memory without <code>Option</code> and unsafe code.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that will be IMPORTED to the WASM instance, it must be</span>
<span class="w">    </span><span class="sd">/// created before instantiate the WASM, and must be stored here</span>
<span class="w">    </span><span class="sd">/// otherwise you can't read this memory inside imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory that owned by the `store` itself.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>
<span class="w">        </span><span class="c1">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>
<span class="w">        </span><span class="c1">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Get the address of state's dummy memory.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="c1">// replaces the  dummy memory by a valid memory</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553542722"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553542722" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553542722">(Nov 04 2025 at 07:31)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access imported memory without <code>Option</code> or unsafe code.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that will be IMPORTED to the WASM instance, it must be</span>
<span class="w">    </span><span class="sd">/// created before instantiate the WASM, and must be stored here</span>
<span class="w">    </span><span class="sd">/// otherwise you can't read this memory inside imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory that owned by the `store` itself.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>
<span class="w">        </span><span class="c1">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>
<span class="w">        </span><span class="c1">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Get the address of state's dummy memory.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="c1">// replaces the  dummy memory by a valid memory</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553542793"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553542793" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553542793">(Nov 04 2025 at 07:32)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access <strong>imported memory</strong> like <strong>exported memory</strong>, without <code>Option</code> or unsafe code.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that will be IMPORTED to the WASM instance, it must be</span>
<span class="w">    </span><span class="sd">/// created before instantiate the WASM, and must be stored here</span>
<span class="w">    </span><span class="sd">/// otherwise you can't read this memory inside imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory that owned by the `store` itself.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>
<span class="w">        </span><span class="c1">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>
<span class="w">        </span><span class="c1">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Get the address of state's dummy memory.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="c1">// replaces the  dummy memory by a valid memory</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553542917"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553542917" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553542917">(Nov 04 2025 at 07:33)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access <strong>imported memory</strong> like <strong>exported memory</strong>, without <code>Option</code> or unsafe code.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that will be IMPORTED to the WASM instance, then it must be</span>
<span class="w">    </span><span class="sd">/// created before instantiate the WASM, and must be stored here otherwise</span>
<span class="w">    </span><span class="sd">/// you can't access the memory inside WasmTime imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory that owned by the `store` itself.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>
<span class="w">        </span><span class="c1">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>
<span class="w">        </span><span class="c1">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Get the address of state's dummy memory.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="c1">// replaces the  dummy memory by a valid memory</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553543328"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553543328" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553543328">(Nov 04 2025 at 07:36)</a>:</h4>
<p>Lohann edited <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Hello, I need to access the imported memory inside a functions, then I realized the <a href="https://docs.rs/wasmtime/38.0.3/wasmtime/struct.Caller.html">Caller</a> only show exports, not imports, so I had a lot of trouble to get Wasmtime store working with <a href="https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html">MaybeUnit</a>, this simple solution segfaults:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span><span class="p">::</span><span class="n">uninit</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>

<span class="kd">let</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="p">::</span><span class="n">mem</span><span class="p">::</span><span class="n">transmute</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">// ...</span>
<span class="kd">let</span><span class="w"> </span><span class="n">imports</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">memory</span><span class="p">.</span><span class="n">into</span><span class="p">()];</span>

<span class="c1">// segfaults below</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Instance</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">imports</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div>
<p>Then I realized the issue is that there's no way for me transmute only the State, I need to transmute the Store which is not recommended, once rust <a href="https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html#layout-1">doesn't guarantee the same memory layout</a>:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="fm">assert_eq!</span><span class="p">(</span><span class="n">size_of</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">MaybeUninit</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;&gt;</span><span class="p">(),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
</code></pre></div>
<p>Actually I haven't find any way to use MaybeUnit that doesn't look hacky, and I want to avoid the usage of Option and unwraps in the code, once it bloats the binary with panic data.</p>
<h4>Alternatives</h4>
<ol>
<li>Make the imported memory easily available inside Functions, ex: expose it in the Caller.</li>
<li>Use <code>#[repr(C)]</code> on <code>Store</code>, so we can safely transmute it.<br>
</li>
</ol>
</blockquote>



<a name="553543430"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553543430" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553543430">(Nov 04 2025 at 07:37)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access <strong>imported memory</strong> without <code>Option</code> or <code>unsafe</code> code.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that will be IMPORTED to the WASM instance, then it must be</span>
<span class="w">    </span><span class="sd">/// created before instantiate the WASM, and must be stored here otherwise</span>
<span class="w">    </span><span class="sd">/// you can't access the memory inside WasmTime imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory that owned by the `store` itself.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>
<span class="w">        </span><span class="c1">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>
<span class="w">        </span><span class="c1">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Get the address of state's dummy memory.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="c1">// replaces the  dummy memory by a valid memory</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553543568"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553543568" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553543568">(Nov 04 2025 at 07:38)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access <strong>imported memory</strong> without <code>Option</code> or <code>unsafe</code> code.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that will be IMPORTED to the WASM instance, then it must be</span>
<span class="w">    </span><span class="sd">/// created before instantiate the WASM, and must be stored here otherwise</span>
<span class="w">    </span><span class="sd">/// you can't access the memory inside WasmTime imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory owned by the `store`.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>
<span class="w">        </span><span class="c1">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>
<span class="w">        </span><span class="c1">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Get the address of state's dummy memory.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="c1">// replaces the  dummy memory by a valid memory</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553543638"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553543638" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553543638">(Nov 04 2025 at 07:38)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>
<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access <strong>imported memory</strong> without <code>Option</code> or <code>unsafe</code> code.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Memory that will be IMPORTED to the WASM instance, then it must be</span>
<span class="w">    </span><span class="sd">/// created before instantiate the WASM, must be stored here otherwise</span>
<span class="w">    </span><span class="sd">/// you can't access the memory inside WasmTime imported functions.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Initializes a Store with a memory owned by the `store`.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">new</span><span class="p">(</span><span class="n">engine</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">Engine</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">:</span><span class="w"> </span><span class="nc">MemoryType</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Store</span><span class="o">&lt;</span><span class="bp">Self</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>
<span class="w">        </span><span class="c1">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>
<span class="w">        </span><span class="c1">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>
<span class="w">        </span><span class="c1">// References:</span>
<span class="w">        </span><span class="c1">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>
<span class="w">        </span><span class="c1">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>
<span class="w">        </span><span class="cp">#[allow(clippy::uninit_assumed_init)]</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">Self</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>
<span class="w">            </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">unsafe</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">MaybeUninit</span><span class="p">::</span><span class="o">&lt;</span><span class="n">Memory</span><span class="o">&gt;</span><span class="p">::</span><span class="n">zeroed</span><span class="p">().</span><span class="n">assume_init</span><span class="p">()</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// Now use the `State` to create the `Store`.</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>
<span class="w">        </span><span class="c1">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>
<span class="w">        </span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Get the address of state's dummy memory.</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">ptr</span><span class="p">::</span><span class="n">addr_of_mut</span><span class="o">!</span><span class="p">(</span><span class="n">store</span><span class="p">.</span><span class="n">data_mut</span><span class="p">().</span><span class="n">memory</span><span class="p">);</span>
<span class="w">            </span><span class="c1">// replaces the  dummy memory by a valid memory</span>
<span class="w">            </span><span class="n">ptr</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span><span class="o">?</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="nb">Ok</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href="https://github.com/use-ink/ink/tree/v5.1.1">ink</a> smart-contract, and the memory is always imported.</p>
</blockquote>



<a name="553634335"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/553634335" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#553634335">(Nov 04 2025 at 14:48)</a>:</h4>
<p><a href="https://github.com/alexcrichton">alexcrichton</a> added the wasmtime:api label to <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">Issue #9579</a>.</p>



<a name="558846623"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558846623" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558846623">(Nov 22 2025 at 22:13)</a>:</h4>
<p>ZylosLumen <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567089352">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>Just ran into this issue and wanted to avoid <code>unsafe Option::unwrap_unchecked()</code> everywhere but it will have to do for now.<br>
Really curious as importing the memory (or any other store-bound type) and also needing to access it from the host does not seem like a rare use case so having a low cost api would be really nice</p>
</blockquote>



<a name="558849439"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558849439" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558849439">(Nov 22 2025 at 23:17)</a>:</h4>
<p>Lohann <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it doesn't have lifetime and implements <code>Copy</code>), so one possible solutions is create the store and memory atomically, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Then need to figure what type the <code>store_ref</code> will be.. it can't be <code>Store&lt;State&gt;</code>.</p>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">})</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="558849571"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558849571" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558849571">(Nov 22 2025 at 23:19)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it doesn't have lifetime and implements <code>Copy</code>), so one possible solutions is create the store and memory atomically, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Then need to figure what type the <code>store_ref</code> will be.. it can't be <code>Store&lt;State&gt;</code>.</p>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="nb">Some</span><span class="p">(</span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">})</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="558849703"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558849703" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558849703">(Nov 22 2025 at 23:22)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it doesn't have lifetime and implements <code>Copy</code>), so one possible solutions is create the store and memory atomically, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Then need to figure what type the <code>store_ref</code> will be.. it can't be <code>Store&lt;State&gt;</code>.</p>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">init_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// SAFETY: the memory was imported above</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="558849735"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558849735" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558849735">(Nov 22 2025 at 23:23)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so one possible solutions is create the store and memory atomically, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Then need to figure what type the <code>store_ref</code> will be.. it can't be <code>Store&lt;State&gt;</code>.</p>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">init_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// SAFETY: the memory was imported above</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="558849782"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558849782" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558849782">(Nov 22 2025 at 23:24)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Then need to figure what type the <code>store_ref</code> will be.. it can't be <code>Store&lt;State&gt;</code>.</p>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">init_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// SAFETY: the memory was imported above</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="558849828"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558849828" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558849828">(Nov 22 2025 at 23:25)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Maybe <code>store_ref</code> can be another type that creates the memory instead being a reference to a dummy store.</p>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">init_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// SAFETY: the memory was imported above</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="558850196"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558850196" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558850196">(Nov 22 2025 at 23:34)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Or maybe <code>store_ref</code> can be another type able to create the memory without expose the store:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">lazy_init</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">linker</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">LazyLinker</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">lazy_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">);</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="p">})</span><span class="o">?</span><span class="p">;</span>
</code></pre></div>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">init_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// SAFETY: the memory was imported above</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="558850306"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558850306" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558850306">(Nov 22 2025 at 23:35)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Or maybe instead <code>Store&lt;()&gt;</code>, we provide some way to create the memory without expose the store:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">Store</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">lazy_init</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">linker</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">LazyLinker</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">lazy_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">);</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="p">})</span><span class="o">?</span><span class="p">;</span>
</code></pre></div>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">init_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// SAFETY: the memory was imported above</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="558850404"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558850404" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558850404">(Nov 22 2025 at 23:37)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, or create the Store last, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Or maybe instead <code>Store&lt;()&gt;</code>, we provide some way to create the memory without expose the store:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">Store</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">lazy_init</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">linker</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">LazyLinker</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">lazy_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">);</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="p">})</span><span class="o">?</span><span class="p">;</span>
</code></pre></div>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">init_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// SAFETY: the memory was imported above</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="558851523"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558851523" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558851523">(Nov 23 2025 at 00:03)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, or create the Store last, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="n">MaybeUnit</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// obs: in method requires `State` to implement Unpin, this prevents State from reference Store.</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<p>Or maybe instead <code>Store&lt;()&gt;</code>, we provide some way to create the memory without expose the store:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">Store</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">lazy_init</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">linker</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">LazyLinker</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="p">})</span><span class="o">?</span><span class="p">;</span>
</code></pre></div>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">init_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// SAFETY: the memory was imported above</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="558852022"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558852022" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558852022">(Nov 23 2025 at 00:12)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, or create the Store last, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="n">MaybeUnit</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// obs: in method requires `State` to implement Unpin, this prevents State from reference Store.</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">init_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// SAFETY: the memory was imported above</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="558852098"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558852098" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558852098">(Nov 23 2025 at 00:14)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, or create the Store last, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="n">Opaque</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// obs: in method requires `State` to implement Unpin, this prevents State from reference Store.</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">init_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// SAFETY: the memory was imported above</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="558852119"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/558852119" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#558852119">(Nov 23 2025 at 00:14)</a>:</h4>
<p>Lohann edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>@alexcrichton <br>
I noticed <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, or create the Store last, ex:</p>
<h2>Proposal 1 - <code>Store::new_with</code></h2>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new_with</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="k">move</span><span class="w"> </span><span class="o">|</span><span class="n">store_ref</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Store</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;|</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">State</span><span class="w">  </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// obs: in method requires `State` to implement Unpin, this prevents State from reference Store.</span>
<span class="w">    </span><span class="n">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">store_ref</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">});</span>
</code></pre></div>
<h2>Proposal 2 - <code>StoreBuilder</code></h2>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">memory</span><span class="p">:</span><span class="w"> </span><span class="nc">Memory</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">let</span><span class="w"> </span><span class="n">memory_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MemoryType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">);</span>
<span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">linker</span><span class="p">):</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">StoreBuilder</span><span class="p">::</span><span class="n">new</span><span class="p">()</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_memory</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">,</span><span class="w"> </span><span class="n">memory_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">with_func</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"add"</span><span class="p">,</span><span class="w"> </span><span class="o">|</span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="o">|</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="n">init_state</span><span class="p">(</span><span class="o">|</span><span class="n">linker</span><span class="o">|</span><span class="p">:</span><span class="w"> </span><span class="nc">State</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// SAFETY: the memory was imported above</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"env"</span><span class="p">,</span><span class="w"> </span><span class="s">"memory"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="n">State</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="n">build</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="kd">let</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">linker</span><span class="p">.</span><span class="n">instantiate</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">module</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
</code></pre></div><br>
</p>
</blockquote>



<a name="559095279"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239579%20Make%20the%20imported%20memory%20available.../near/559095279" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239579.20Make.20the.20imported.20memory.20available.2E.2E.2E.html#559095279">(Nov 24 2025 at 16:33)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3571696118">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9579">issue #9579</a>:</p>
<blockquote>
<p>Personally I would recommend having a <code>memory()</code> function as opposed a <code>memory.unwrap()</code> field access for ergonomics. I'll also note that <code>unsafe { MaybeUninit::&lt;Memory&gt;::zeroed().assume_init() }</code> is immediate undefined behavior. <code>Memory</code> has a <code>NonZeroU64</code> inside of it which this is explicitly setting to zero. Whether or not that actually causes a problem is entirely up to LLVM which is highly likely to change over time. </p>
<p>I would recommend measuring the overhead of doing <code>.unwrap()</code> before doing anything <code>unsafe</code> w.r.t. this issue. It is an incredibly high bar to clear, in my opinion, to save a few instructions while adding <code>unsafe</code> code.</p>
<p>In terms of "solving" this issue, personally I feel at this time that it's pretty unlikely. The APIs you're sketching out @Lohann for example are not possible to implement in a sound fashion. Once a <code>Store&lt;T&gt;</code> is presented, for example, then instances can be created which can execute wasm which can execute imports which expect functions to be there. The validity of this pattern requires the inability to invoke imported functions (or access <code>T</code> in general) before the <code>T</code> is fully filled in. That's, in general, a dynamic property of the embedding in question rather than one we can bake into the type system of Wasmtime.</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>