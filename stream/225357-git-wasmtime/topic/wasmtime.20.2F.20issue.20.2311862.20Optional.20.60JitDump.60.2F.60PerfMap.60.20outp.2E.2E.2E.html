<html>
<head><meta charset="utf-8"><title>wasmtime / issue #11862 Optional `JitDump`/`PerfMap` outp... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311862.20Optional.20.60JitDump.60.2F.60PerfMap.60.20outp.2E.2E.2E.html">wasmtime / issue #11862 Optional `JitDump`/`PerfMap` outp...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="544956060"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311862%20Optional%20%60JitDump%60/%60PerfMap%60%20outp.../near/544956060" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311862.20Optional.20.60JitDump.60.2F.60PerfMap.60.20outp.2E.2E.2E.html#544956060">(Oct 15 2025 at 12:31)</a>:</h4>
<p>lethalbit opened <a href="https://github.com/bytecodealliance/wasmtime/issues/11862">issue #11862</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>As the title says, the ability to optionally append a prefix (or suffix, doesn't matter which really) to the output <code>JitDump</code> or <code>PerfMap</code> files when profiling is enabled.</p>
<h4>Benefit</h4>
<p>The main benefit would be to allow for wasmtime to live in a process that has another different JIT engine inside of it that also emits a perf map or jitdump files.</p>
<p>While this is a niche use case, i've run into needing it myself on a few occasions, primarily when doing Python &lt;-&gt; Rust &lt;-&gt; WASM interop, as Python also emits perf map (or jitdump) files. </p>
<p>Granted this would need post-processing, but that would need to happen regardless as <code>perf</code> on linux makes the (likely sane) assumption that only one JIT runtime will be in any given process.</p>
<h4>Implementation</h4>
<p>Implementation wise, it wouldn't be too complex, the <code>jitdump</code> and <code>perfmap</code> profiling agents could take an <code>Option&lt;T&gt;</code> for the file prefix/suffix, and then just update the file name with that. The <code>ProfilingStrategy</code> enum would either need an API breaking change to add said <code>Option&lt;T&gt;</code> to the <code>PerfMap</code>/<code>JitDump</code> elements or have 2 new "prefixed" variants added that take just the <code>T</code>.</p>
<p>In the case of the <code>PerfMapAgent</code>, we would also likely want to prefix <code>wasm::</code> to the sanitized name entries to properly namespace it, i've not looked too much into the <code>JitDumpAgent</code> but it would likely need a similar change. </p>
<h4>Alternatives</h4>
<p>The primary alternative would be to not use this, and have each hosted JIT use a different method, one perf map and the other JIT dump, however, the <code>perf</code> tools will only really use the input from one or the other because as mentioned previously <code>perf</code> assumes only one JIT per process.</p>
<p>This also applies to doing the JIT dump processing and then trying to apply a perf map file to it after.</p>
<h4>Example</h4>
<p>Here is a screenshot for a locally patched version of wasmtime I had to use in order to get the wanted behaviour, showing a use case for this specific feature, in this case it is Python and wasmtime both emitting a perf map file, which I then post-process to namespace the WASM map and then merge them into a single perf map file prior to using <code>perf report</code></p>
<p>&lt;img width="1650" height="1085" alt="Image" src="<a href="https://github.com/user-attachments/assets/3653cf41-13da-4ca5-a9f0-ca5aa35fb433">https://github.com/user-attachments/assets/3653cf41-13da-4ca5-a9f0-ca5aa35fb433</a>" /&gt;</p>
</blockquote>



<a name="544970812"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311862%20Optional%20%60JitDump%60/%60PerfMap%60%20outp.../near/544970812" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311862.20Optional.20.60JitDump.60.2F.60PerfMap.60.20outp.2E.2E.2E.html#544970812">(Oct 15 2025 at 13:36)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406489276">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11862">issue #11862</a>:</p>
<blockquote>
<p>For perfmap would it work if both Wasmtime and Python open the perfmap file in append mode and try to atomically write a full entry at a time? That way you wouldn't need any post processing I think. That wouldn't work for jitdump though.</p>
</blockquote>



<a name="544972053"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311862%20Optional%20%60JitDump%60/%60PerfMap%60%20outp.../near/544972053" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311862.20Optional.20.60JitDump.60.2F.60PerfMap.60.20outp.2E.2E.2E.html#544972053">(Oct 15 2025 at 13:41)</a>:</h4>
<p>lethalbit <a href="https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406512246">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11862">issue #11862</a>:</p>
<blockquote>
<p>In Pythons case it makes the very much sane assumption that it is the only thing writing to the perf map file.</p>
<p>Plus there might be contention when flushing the file contents regardless, so I don't think that's a very viable option. </p>
</blockquote>



<a name="544974463"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311862%20Optional%20%60JitDump%60/%60PerfMap%60%20outp.../near/544974463" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311862.20Optional.20.60JitDump.60.2F.60PerfMap.60.20outp.2E.2E.2E.html#544974463">(Oct 15 2025 at 13:51)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406554837">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11862">issue #11862</a>:</p>
<blockquote>
<blockquote>
<p>Plus there might be contention when flushing the file contents regardless</p>
</blockquote>
<p>If you only buffer full entries that wouldn't matter. At worst you did get a non-deterministic order, not corrupt entries.</p>
<blockquote>
<p>In Pythons case it makes the very much sane assumption that it is the only thing writing to the perf map file.</p>
</blockquote>
<p>I guess nobody thought about having multiple jits in the same process when they designed this interface, so now everyone has to add workarounds. I presume the same kind of issues would occur if you try to use Python and C# or a javascript engine in the same process.</p>
</blockquote>



<a name="544977224"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311862%20Optional%20%60JitDump%60/%60PerfMap%60%20outp.../near/544977224" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311862.20Optional.20.60JitDump.60.2F.60PerfMap.60.20outp.2E.2E.2E.html#544977224">(Oct 15 2025 at 14:03)</a>:</h4>
<p>lethalbit <a href="https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406605908">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11862">issue #11862</a>:</p>
<blockquote>
<p>Yeah, I mean, to be fair, having multiple <em>different</em> JITs in the same process is a bit of an esoteric situation, so it's not too surprising that it was overlooked.</p>
<p>On top of that the <code>perf</code> tools have some long outstanding issues in the first place, in the case of the JIT dump files, when post-processing that into the <code>.so</code> files <code>perf</code> will try to d a symbol lookup for each object if you have <code>DEBUGINFOD_URLS</code> set, which will fail because of course the upstream debug info server won't have any symbols for them.</p>
<p>In general the perf tooling around JIT debug is pretty rough, and while I would love for there to be a better way, I think having prefixed/suffixed dumps/maps would be the current "best" solution for it, even if not optimal. </p>
</blockquote>



<a name="544984838"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311862%20Optional%20%60JitDump%60/%60PerfMap%60%20outp.../near/544984838" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311862.20Optional.20.60JitDump.60.2F.60PerfMap.60.20outp.2E.2E.2E.html#544984838">(Oct 15 2025 at 14:31)</a>:</h4>
<p>lethalbit edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406605908">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11862">issue #11862</a>:</p>
<blockquote>
<p>Yeah, I mean, to be fair, having multiple <em>different</em> JITs in the same process is a bit of an esoteric situation, so it's not too surprising that it was overlooked.</p>
<p>On top of that the <code>perf</code> tools have some long outstanding issues in the first place, in the case of the JIT dump files, when post-processing that into the <code>.so</code> files <code>perf</code> will try to do a symbol lookup for each object if you have <code>DEBUGINFOD_URLS</code> set, which will fail because of course the upstream debug info server won't have any symbols for them.</p>
<p>In general the perf tooling around JIT debug is pretty rough, and while I would love for there to be a better way, I think having prefixed/suffixed dumps/maps would be the current "best" solution for it, even if not optimal. </p>
</blockquote>



<a name="544993226"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311862%20Optional%20%60JitDump%60/%60PerfMap%60%20outp.../near/544993226" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311862.20Optional.20.60JitDump.60.2F.60PerfMap.60.20outp.2E.2E.2E.html#544993226">(Oct 15 2025 at 15:03)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406908936">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11862">issue #11862</a>:</p>
<blockquote>
<p>For perfmap support unforunately this isn't something we can fix I believe. Perf itself <a href="https://github.com/torvalds/linux/blob/9b332cece987ee1790b2ed4c989e28162fa47860/tools/perf/Documentation/jit-interface.txt#L4">hardcodes the filename</a>. Similarly for jitdump <a href="https://github.com/torvalds/linux/blob/9b332cece987ee1790b2ed4c989e28162fa47860/tools/perf/util/jitdump.c#L749-L753">the filename to be recognized is hardcoded</a>. Given that all we can really do I think is what @bjorn3 is suggestion, which is to open files in <code>O_APPEND</code> mode and write out entire entries at once.</p>
</blockquote>



<a name="544995499"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311862%20Optional%20%60JitDump%60/%60PerfMap%60%20outp.../near/544995499" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311862.20Optional.20.60JitDump.60.2F.60PerfMap.60.20outp.2E.2E.2E.html#544995499">(Oct 15 2025 at 15:13)</a>:</h4>
<p>lethalbit <a href="https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406955368">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11862">issue #11862</a>:</p>
<blockquote>
<p>Hence why I was suggesting a prefixed or postfixed variant so that it could be post-processed as needed.</p>
<p>But looking at the current implementation in Python that looks like they also open in append mode:</p>
<p><a href="https://github.com/python/cpython/blob/728d239e57b650c392517b7ae569b0eb05af826e/Python/sysmodule.c#L2674-L2703">https://github.com/python/cpython/blob/728d239e57b650c392517b7ae569b0eb05af826e/Python/sysmodule.c#L2674-L2703</a></p>
<p>So maybe that would be the best way, assuming the "namespacing" of the wasm entries is done,</p>
<p>While I would still personally like to be able to split it out, if this is the better solution then that works.<br>
</p>
</blockquote>



<a name="545005874"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311862%20Optional%20%60JitDump%60/%60PerfMap%60%20outp.../near/545005874" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311862.20Optional.20.60JitDump.60.2F.60PerfMap.60.20outp.2E.2E.2E.html#545005874">(Oct 15 2025 at 15:59)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3407184768">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11862">issue #11862</a>:</p>
<blockquote>
<p>Is your goal to separate out the profiles so wasm stacks are excluded, for example when you're profiling Python? or vice-versa? Or is the goal to be able to profile everything together? In some ways our hands are tied here as we don't really want to maintain/recommend nonstandard tooling for post-processing files (it's already confusing enough as is sort of...) so if it works for you to have everything in one file I think then that it's basically on us to work with preexisting files and ensure that we append entire records at once and fail if a partial write is ever done.</p>
</blockquote>



<a name="545007897"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311862%20Optional%20%60JitDump%60/%60PerfMap%60%20outp.../near/545007897" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311862.20Optional.20.60JitDump.60.2F.60PerfMap.60.20outp.2E.2E.2E.html#545007897">(Oct 15 2025 at 16:08)</a>:</h4>
<p>lethalbit <a href="https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3407239222">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11862">issue #11862</a>:</p>
<blockquote>
<p>Ideally It would have been nice to be able to have them seperate if I wanted to look at wasm-only or Python-only, but honestly, as long as the wasm entries are properly prefixed (with <code>wasm::</code> or something, as Python does <code>py::</code>) then they can be split out after if needed and it's not a huge deal.</p>
</blockquote>



<a name="545136284"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311862%20Optional%20%60JitDump%60/%60PerfMap%60%20outp.../near/545136284" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311862.20Optional.20.60JitDump.60.2F.60PerfMap.60.20outp.2E.2E.2E.html#545136284">(Oct 15 2025 at 22:20)</a>:</h4>
<p>alexcrichton closed <a href="https://github.com/bytecodealliance/wasmtime/issues/11862">issue #11862</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>As the title says, the ability to optionally append a prefix (or suffix, doesn't matter which really) to the output <code>JitDump</code> or <code>PerfMap</code> files when profiling is enabled.</p>
<h4>Benefit</h4>
<p>The main benefit would be to allow for wasmtime to live in a process that has another different JIT engine inside of it that also emits a perf map or jitdump files.</p>
<p>While this is a niche use case, i've run into needing it myself on a few occasions, primarily when doing Python &lt;-&gt; Rust &lt;-&gt; WASM interop, as Python also emits perf map (or jitdump) files. </p>
<p>Granted this would need post-processing, but that would need to happen regardless as <code>perf</code> on linux makes the (likely sane) assumption that only one JIT runtime will be in any given process.</p>
<h4>Implementation</h4>
<p>Implementation wise, it wouldn't be too complex, the <code>jitdump</code> and <code>perfmap</code> profiling agents could take an <code>Option&lt;T&gt;</code> for the file prefix/suffix, and then just update the file name with that. The <code>ProfilingStrategy</code> enum would either need an API breaking change to add said <code>Option&lt;T&gt;</code> to the <code>PerfMap</code>/<code>JitDump</code> elements or have 2 new "prefixed" variants added that take just the <code>T</code>.</p>
<p>In the case of the <code>PerfMapAgent</code>, we would also likely want to prefix <code>wasm::</code> to the sanitized name entries to properly namespace it, i've not looked too much into the <code>JitDumpAgent</code> but it would likely need a similar change. </p>
<h4>Alternatives</h4>
<p>The primary alternative would be to not use this, and have each hosted JIT use a different method, one perf map and the other JIT dump, however, the <code>perf</code> tools will only really use the input from one or the other because as mentioned previously <code>perf</code> assumes only one JIT per process.</p>
<p>This also applies to doing the JIT dump processing and then trying to apply a perf map file to it after.</p>
<h4>Example</h4>
<p>Here is a screenshot for a locally patched version of wasmtime I had to use in order to get the wanted behaviour, showing a use case for this specific feature, in this case it is Python and wasmtime both emitting a perf map file, which I then post-process to namespace the WASM map and then merge them into a single perf map file prior to using <code>perf report</code></p>
<p>&lt;img width="1650" height="1085" alt="Image" src="<a href="https://github.com/user-attachments/assets/3653cf41-13da-4ca5-a9f0-ca5aa35fb433">https://github.com/user-attachments/assets/3653cf41-13da-4ca5-a9f0-ca5aa35fb433</a>" /&gt;</p>
</blockquote>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>