<html>
<head><meta charset="utf-8"><title>wasmtime / issue #12502 RISC-V: Misaligned Memory Access ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312502.20RISC-V.3A.20Misaligned.20Memory.20Access.20.2E.2E.2E.html">wasmtime / issue #12502 RISC-V: Misaligned Memory Access ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="571656632"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312502%20RISC-V%3A%20Misaligned%20Memory%20Access%20.../near/571656632" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312502.20RISC-V.3A.20Misaligned.20Memory.20Access.20.2E.2E.2E.html#571656632">(Feb 03 2026 at 13:09)</a>:</h4>
<p>tage64 opened <a href="https://github.com/bytecodealliance/wasmtime/issues/12502">issue #12502</a>:</p>
<blockquote>
<p>I am ahead-of-time compiling wasm for RISC-V64 using Cranelift. The generated assembler performs a 64-bit load on a 4 B (not 8 B) aligned address. This is not allowed by the RISC-V spec although many processors does support it anyway. However our RISC-V implementation (NOEL-V) don't support misaligned memory accesses.</p>
<p>Would it be possible for Cranelift or Wasmtime to replace misaligned memory accesses with manual load/store/shift instructions to allow ahead-of-time compilation on these platforms as well?</p>
<p>It runs perfectly under Pulley but is ~15x slower compared to native speed.</p>
</blockquote>



<a name="571663013"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312502%20RISC-V%3A%20Misaligned%20Memory%20Access%20.../near/571663013" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312502.20RISC-V.3A.20Misaligned.20Memory.20Access.20.2E.2E.2E.html#571663013">(Feb 03 2026 at 13:35)</a>:</h4>
<p>tage64 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/12502">issue #12502</a>:</p>
<blockquote>
<p>I am ahead-of-time compiling wasm for RISC-V64 using Cranelift. The generated assembly performs a 64-bit load on a 4 B (not 8 B) aligned address. This is not allowed by the RISC-V spec although many processors does support it anyway. However our RISC-V implementation (NOEL-V) don't support misaligned memory accesses.</p>
<p>Would it be possible for Cranelift or Wasmtime to replace misaligned memory accesses with manual load/store/shift instructions to allow ahead-of-time compilation on these platforms as well?</p>
<p>It runs perfectly under Pulley but is ~15x slower compared to native speed.</p>
</blockquote>



<a name="571691399"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312502%20RISC-V%3A%20Misaligned%20Memory%20Access%20.../near/571691399" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312502.20RISC-V.3A.20Misaligned.20Memory.20Access.20.2E.2E.2E.html#571691399">(Feb 03 2026 at 15:26)</a>:</h4>
<p><a href="https://github.com/alexcrichton">alexcrichton</a> added the cranelift label to <a href="https://github.com/bytecodealliance/wasmtime/issues/12502">Issue #12502</a>.</p>



<a name="571691402"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312502%20RISC-V%3A%20Misaligned%20Memory%20Access%20.../near/571691402" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312502.20RISC-V.3A.20Misaligned.20Memory.20Access.20.2E.2E.2E.html#571691402">(Feb 03 2026 at 15:26)</a>:</h4>
<p><a href="https://github.com/alexcrichton">alexcrichton</a> added the cranelift:area:riscv64 label to <a href="https://github.com/bytecodealliance/wasmtime/issues/12502">Issue #12502</a>.</p>



<a name="571692601"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312502%20RISC-V%3A%20Misaligned%20Memory%20Access%20.../near/571692601" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312502.20RISC-V.3A.20Misaligned.20Memory.20Access.20.2E.2E.2E.html#571692601">(Feb 03 2026 at 15:31)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/12502#issuecomment-3842024915">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12502">issue #12502</a>:</p>
<blockquote>
<p>This is, in theory, possible, but it'd be a fair bit of implementation work to do. Loads are tagged as aligned or not in Cranelift meaning we semantically know when to generate instructions for a misaligned load, but right now there's no codegen rules, in any backend, for generating misaligned loads and shifting the result. Implementing this would probably require a new risc-v feature in Cranelift for "supports unaligned loads", which would encompass today's behavior, and then when that feature is disabled new rules would be added to handle the misaligned load case.</p>
<p>I'll note though that all loads from wasm must be assumed to have an alignment at 1 and dynamically at runtime we figure out what the alignment actually was. In the face of trapping accesses should we load too far beyond the end of an address it means that generating code for misaligned loads is probably infeasible in the long-term. I believe other wasm engines sometimes handle this use case with a signal handler that catches the misaligned access, performs the "real" accesses in the signal handler, and then resumes the instruction. Wasmtime isn't currently architected for that and would also require some significant refactoring on the Cranelift side of things to support that sort of translation.</p>
<p>Overall this is likely a very significant chunk of implementation work, and for the niche nature of not supporting unaligned loads it's unlikely to get resolved any time soon. I'd recommend using Pulley for now in the meantime.</p>
</blockquote>



<a name="571698800"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312502%20RISC-V%3A%20Misaligned%20Memory%20Access%20.../near/571698800" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312502.20RISC-V.3A.20Misaligned.20Memory.20Access.20.2E.2E.2E.html#571698800">(Feb 03 2026 at 15:52)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/12502#issuecomment-3842130423">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12502">issue #12502</a>:</p>
<blockquote>
<p>FWIW, our RISC-V backend was initially developed for the <code>riscv64gc-unknown-linux-gnu</code> target, and on Linux, <a href="https://www.kernel.org/doc/html/v6.10/arch/riscv/uabi.html#misaligned-accesses">misaligned loads/stores are guaranteed to work</a> (the base ISA spec, as I'm sure you know, <a href="https://riscv.github.io/riscv-isa-manual/snapshot/unprivileged/#ldst">leaves it up to the EEI (execution environment interface)</a>). This may not help you if you're targeting an embedded environment of some sort with a <code>no_std</code> Wasmtime build but it at least gives an idea of our history and rationale.</p>
<p>I'll second what Alex says about the implementation burden being high to do misalignment support in userspace software. I would suspect the "easier" approach to actually be to explode every load/store into byte-size pieces, as that would be localized to just the instruction lowerings. That would have pretty severe performance cost, but <em>maybe</em> not as bad as using Pulley (you'd have to experiment to know for sure). I don't think we'd upstream such a patch though.</p>
</blockquote>



<a name="572736630"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312502%20RISC-V%3A%20Misaligned%20Memory%20Access%20.../near/572736630" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312502.20RISC-V.3A.20Misaligned.20Memory.20Access.20.2E.2E.2E.html#572736630">(Feb 09 2026 at 10:37)</a>:</h4>
<p>tage64 closed <a href="https://github.com/bytecodealliance/wasmtime/issues/12502">issue #12502</a>:</p>
<blockquote>
<p>I am ahead-of-time compiling wasm for RISC-V64 using Cranelift. The generated assembly performs a 64-bit load on a 4 B (not 8 B) aligned address. This is not allowed by the RISC-V spec although many processors does support it anyway. However our RISC-V implementation (NOEL-V) don't support misaligned memory accesses.</p>
<p>Would it be possible for Cranelift or Wasmtime to replace misaligned memory accesses with manual load/store/shift instructions to allow ahead-of-time compilation on these platforms as well?</p>
<p>It runs perfectly under Pulley but is ~15x slower compared to native speed.</p>
</blockquote>



<a name="572736634"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312502%20RISC-V%3A%20Misaligned%20Memory%20Access%20.../near/572736634" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312502.20RISC-V.3A.20Misaligned.20Memory.20Access.20.2E.2E.2E.html#572736634">(Feb 09 2026 at 10:37)</a>:</h4>
<p>tage64 <a href="https://github.com/bytecodealliance/wasmtime/issues/12502#issuecomment-3870886269">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12502">issue #12502</a>:</p>
<blockquote>
<p>Thanks for the explonation.</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>