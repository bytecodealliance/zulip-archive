<html>
<head><meta charset="utf-8"><title>wasmtime / issue #11896 Debugging: build an async debugge... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311896.20Debugging.3A.20build.20an.20async.20debugge.2E.2E.2E.html">wasmtime / issue #11896 Debugging: build an async debugge...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="546289928"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311896%20Debugging%3A%20build%20an%20async%20debugge.../near/546289928" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311896.20Debugging.3A.20build.20an.20async.20debugge.2E.2E.2E.html#546289928">(Oct 21 2025 at 17:16)</a>:</h4>
<p>cfallin opened <a href="https://github.com/bytecodealliance/wasmtime/issues/11896">issue #11896</a>:</p>
<blockquote>
<p>In general when designing our guest debugger functionality, we would like to balance a few requirements:</p>
<ul>
<li>It should be relatively straightforward to compose debugging functionality on top of an existing embedder / "main Wasm invocation"; i.e., it should not require deep surgery or awkward refactors, or only work in the Wasmtime CLI.</li>
<li>It should be possible to provide access to the <code>Store</code> to the debugger, including mutability. This is needed for eventual "mutable debugger commands" (e.g., updating locals' values) but also even for any access to GC objects (because of the root-set).</li>
<li>The whole <code>Store</code> should pause when the debugger has control, so it can observe state without racing with other tasks.</li>
<li>The debugger needs to be able to run with access to IO, which in a Rust context almost always means it needs to have async entry points.</li>
</ul>
<p>We have plans to place the debugger implementation mostly inside a Wasm component, which gives us a little more flexibility to have an "ugly API" underneath, but even still, the closer we get the native host API and paradigm to what the eventual Wasm API describes, the less painful and error-prone the glue will be.</p>
<p>All of these requirements generally push toward a "coroutine"-style async design. In our <a href="https://github.com/bytecodealliance/rfcs/blob/main/accepted/wasmtime-debugging-v2.md">RFC</a> and in a draft PR (#11826), we have sketched out a general approach to a debug API that contains a "debugger" and "debuggee" as two entities that bounce control back and forth. This is naturally rendered in Rust with an API that literally provides an async API that yields a stream of "debug events", with the debuggee stopped whenever an event is received and running whenever the debugger is polling for the next event. Such an API allows for a nice debugger implementation style: it can keep its main loop in one place, and access the store directly when the debuggee is paused.</p>
<p>Unfortunately, through a bunch of conversations, we have determined that this is not sound as implemented in that draft PR. The PR "teleports" a borrow of the <code>Store</code> outward from an async yield point, where it performs a fiber yield, back to a <code>DebugSession</code> (wrapping the store) on which an <code>async fn next()</code> was invoked to get the next debug event. The idea was that the <code>next()</code> invocation exclusively owns the store while we pass control back to the guest; when it returns, we can return ownership of the store back to the debugger; this is more-or-less like passing a mutable reborrow of the store to a hostcall, except that we plumb it back out to the surface. We could even get the provenance right by passing (via a raw pointer) the reborrow outward. However...</p>
<p>Unfortunately, <code>Future</code> combinators and dropped futures are a thing, and there is a bad case with a "host code sandwich". Consider: debugger context calls Wasm, calls async host code, calls Wasm. In the second Wasm activation, we hit a debug event. We could yield all the way back up to the debugger and pass a reborrowed <code>Store</code>; but that yield control flow passes through the async host code, by way of a <code>Poll::Pending</code>. That async host code may implement some arbitrary future combinator that chooses to (for example) drop the future, in which case we have a dangling reference to the store and the rest of the debug state we were supposed to examine (e.g. stack frames). One could try to patch this up by holding fibers via reference counting and keeping the fibers alive when paused for debugging; but at that point, we have discovered that...</p>
<p>... we are reinventing a bunch of mechanisms in the component-model async implementation. In particular, (i) the <code>Accessor</code> mechanism allows for ownership passing of the <code>Store</code> (timeslicing such that access only exists during one poll, with no borrows persisted across suspends) in a way that is already vetted; and (ii) the task model gives us a first-class way to note that a stack is paused for debugging, and keep it alive. (I'm less sure about the details of (ii), but in principle, the concurrent scheduler is a little tiny OS kernel and we can build the moral equivalent of <code>ptrace</code> pauses there, I think.)</p>
<p>Given all that, the eventual plan is something like:</p>
<ul>
<li>Build a mechanism to set up a concurrent environment with an async debugger that receives a stream of events and can access the store via <code>Accessor</code>. The debugger itself needs to be within the context of the <code>run_concurrent</code> invocation, but separate/privileged: all tasks except for the debugger pause when the debugger has control.</li>
<li>Update any point in the Wasmtime runtime that needs to yield a debug event to use the "new-style" async mechanisms, i.e. <code>Accessor</code>, to safely give control of the <code>Store</code> back to the debugger.</li>
<li>Move over the "top half" of the debugger that we plan to temporarily build on #11895 and remove that API.</li>
</ul>
</blockquote>



<a name="546289994"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311896%20Debugging%3A%20build%20an%20async%20debugge.../near/546289994" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311896.20Debugging.3A.20build.20an.20async.20debugge.2E.2E.2E.html#546289994">(Oct 21 2025 at 17:16)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/11896#issuecomment-3427967912">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11896">issue #11896</a>:</p>
<blockquote>
<p>cc @alexcrichton @fitzgen -- if I missed anything from our discussion, feel free to add!</p>
</blockquote>



<a name="546298293"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311896%20Debugging%3A%20build%20an%20async%20debugge.../near/546298293" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311896.20Debugging.3A.20build.20an.20async.20debugge.2E.2E.2E.html#546298293">(Oct 21 2025 at 17:59)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/11896#issuecomment-3428398732">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11896">issue #11896</a>:</p>
<blockquote>
<p>Thanks for writing this up!</p>
<p>One small clarification:</p>
<blockquote>
<p>It should be possible to provide access to the <code>Store</code> to the debugger, including mutability. This is needed for eventual "mutable debugger commands" (e.g., updating locals' values) but also even for any access to GC objects (because of the root-set).</p>
</blockquote>
<p>Note that even reading Wasm state, without mutating it, will mutate store internals (caches and arenas and such) and therefore requires a <code>AsStoreContextMut</code>, e.g.:</p>
<ul>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Global.html#method.get"><code>Global::get</code></a></li>
<li><a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Table.html#method.get"><code>Table::get</code></a></li>
</ul>
<p>So giving the debugger APIs mutable access to the <code>Store</code> isn't something that can be delayed until we get around to adding support for debugging GC objects or mutation from the debugger comes at a later point; it must be part of the initial support for reading Wasm state.</p>
</blockquote>



<a name="546303726"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311896%20Debugging%3A%20build%20an%20async%20debugge.../near/546303726" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311896.20Debugging.3A.20build.20an.20async.20debugge.2E.2E.2E.html#546303726">(Oct 21 2025 at 18:29)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/11896#issuecomment-3428685270">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11896">issue #11896</a>:</p>
<blockquote>
<p>Yep, and to your point that it's already needed, the <a href="https://github.com/bytecodealliance/wasmtime/blob/c7dc0eb1576490c543073d8dcd14d6f53c6dad44/crates/wasmtime/src/runtime/store.rs#L1203"><code>Store::debug_frames</code></a> API already landed as part of the debug instrumentation requires a mutable context already, in order to read out (and root) GC refs from the stack. So we'd have to even regress on what we already have to build an immutable variant.</p>
</blockquote>



<a name="546316278"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311896%20Debugging%3A%20build%20an%20async%20debugge.../near/546316278" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311896.20Debugging.3A.20build.20an.20async.20debugge.2E.2E.2E.html#546316278">(Oct 21 2025 at 19:53)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11896#issuecomment-3429327536">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11896">issue #11896</a>:</p>
<blockquote>
<p>cc @dicej on this as well</p>
<p>I suspect that in the near future my job is going to be to reconcile the two async models we have in Wasmtime (e.g. <code>call_{async,concurrent}</code>) and getting the component-model-async bits to more-or-less work in core wasm as well. I have talked with all y'all about this but wanted to write it down here too.</p>
</blockquote>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>