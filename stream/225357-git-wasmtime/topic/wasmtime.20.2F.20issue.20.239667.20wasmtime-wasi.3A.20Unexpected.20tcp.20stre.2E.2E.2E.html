<html>
<head><meta charset="utf-8"><title>wasmtime / issue #9667 wasmtime-wasi: Unexpected tcp stre... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239667.20wasmtime-wasi.3A.20Unexpected.20tcp.20stre.2E.2E.2E.html">wasmtime / issue #9667 wasmtime-wasi: Unexpected tcp stre...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="484870254"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239667%20wasmtime-wasi%3A%20Unexpected%20tcp%20stre.../near/484870254" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239667.20wasmtime-wasi.3A.20Unexpected.20tcp.20stre.2E.2E.2E.html#484870254">(Nov 28 2024 at 09:05)</a>:</h4>
<p>Heap-Hop edited <a href="https://github.com/bytecodealliance/wasmtime/issues/9667">issue #9667</a>:</p>
<blockquote>
<p><a href="https://github.com/bytecodealliance/wasmtime/blob/67674881db5fbdbba8594feb52655aaa351a5f77/crates/wasi/src/tcp.rs#L719-L723">https://github.com/bytecodealliance/wasmtime/blob/67674881db5fbdbba8594feb52655aaa351a5f77/crates/wasi/src/tcp.rs#L719-L723</a></p>
<p>Returning <code>0</code> for <code>std::io::ErrorKind::WouldBlock</code> causes downstream to interpret it as a closed stream, see: <br>
<a href="https://github.com/yoshuawuyts/wstd/issues/25#issuecomment-2493294087">https://github.com/yoshuawuyts/wstd/issues/25#issuecomment-2493294087</a>.<br>
<a href="https://github.com/yoshuawuyts/wstd/blob/5ce367add5e7bcb569b6487453cb9ba94468dc99/src/io/copy.rs#L12">https://github.com/yoshuawuyts/wstd/blob/5ce367add5e7bcb569b6487453cb9ba94468dc99/src/io/copy.rs#L12</a></p>
<p>This is also found in:<br>
<a href="https://github.com/bytecodealliance/wasmtime/blob/67674881db5fbdbba8594feb52655aaa351a5f77/crates/test-programs/src/bin/preview2_tcp_streams.rs#L17-L22">https://github.com/bytecodealliance/wasmtime/blob/67674881db5fbdbba8594feb52655aaa351a5f77/crates/test-programs/src/bin/preview2_tcp_streams.rs#L17-L22</a></p>
<p><del>Given that the <code>wit</code> files already include many <code>would-block</code> errors, would it make sense to extend <code>stream-error</code> to include a <code>would-block</code>?</del><br>
</p>
</blockquote>



<a name="484933596"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239667%20wasmtime-wasi%3A%20Unexpected%20tcp%20stre.../near/484933596" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239667.20wasmtime-wasi.3A.20Unexpected.20tcp.20stre.2E.2E.2E.html#484933596">(Nov 28 2024 at 14:29)</a>:</h4>
<p>Heap-Hop <a href="https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2506253514">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9667">issue #9667</a>:</p>
<blockquote>
<p>@pchickey <a href="https://github.com/bytecodealliance/wasmtime/actions/runs/12070585313/job/33660435175?pr=9691#step:18:419">https://github.com/bytecodealliance/wasmtime/actions/runs/12070585313/job/33660435175?pr=9691#step:18:419</a></p>
</blockquote>



<a name="484957857"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239667%20wasmtime-wasi%3A%20Unexpected%20tcp%20stre.../near/484957857" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239667.20wasmtime-wasi.3A.20Unexpected.20tcp.20stre.2E.2E.2E.html#484957857">(Nov 28 2024 at 16:45)</a>:</h4>
<p>pchickey <a href="https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2506498842">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9667">issue #9667</a>:</p>
<blockquote>
<p>Thanks! Its a holiday weekend here so I’ll get to this next week.</p>
</blockquote>



<a name="495345822"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239667%20wasmtime-wasi%3A%20Unexpected%20tcp%20stre.../near/495345822" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239667.20wasmtime-wasi.3A.20Unexpected.20tcp.20stre.2E.2E.2E.html#495345822">(Jan 22 2025 at 18:09)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2607929136">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9667">issue #9667</a>:</p>
<blockquote>
<p>I apologize it's taken me quite some time to take a look at this. Now that I've read over this and <a href="https://github.com/bytecodealliance/wasmtime/pull/9691">https://github.com/bytecodealliance/wasmtime/pull/9691</a> I personally don't think there's a bug in the wasmtime-wasi implementation here. I don't think WASI can reasonably provide super strict guarantees about exactly when things become ready and exactly the states before/after reads. Attempting to do this might not even be feasible in the face of an implementation across multiple platforms.</p>
<p>For example the test in <a href="https://github.com/bytecodealliance/wasmtime/pull/9691">https://github.com/bytecodealliance/wasmtime/pull/9691</a> looks like this:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">        </span><span class="k">use</span><span class="w"> </span><span class="n">test_programs</span><span class="p">::</span><span class="n">wasi</span><span class="p">::</span><span class="n">clocks</span><span class="p">::</span><span class="n">monotonic_clock</span><span class="p">::</span><span class="n">subscribe_duration</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">timeout_100ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100_000_000</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Send some data to the server</span>
<span class="w">        </span><span class="n">client</span><span class="p">.</span><span class="n">output</span><span class="p">.</span><span class="n">blocking_write_and_flush</span><span class="p">(</span><span class="s">b"Hi!"</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">        </span><span class="n">server</span><span class="p">.</span><span class="n">input</span><span class="p">.</span><span class="n">subscribe</span><span class="p">().</span><span class="n">block</span><span class="p">();</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">server</span><span class="p">.</span><span class="n">input</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="mi">512</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="w"> </span><span class="s">b"Hi!"</span><span class="p">,</span><span class="w"> </span><span class="s">"Expected to receive data"</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Don't send any data</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">server</span>
<span class="w">            </span><span class="p">.</span><span class="n">input</span>
<span class="w">            </span><span class="p">.</span><span class="n">subscribe</span><span class="p">()</span>
<span class="w">            </span><span class="p">.</span><span class="n">block_until</span><span class="p">(</span><span class="o">&amp;</span><span class="n">subscribe_duration</span><span class="p">(</span><span class="n">timeout_100ms</span><span class="p">));</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">is_err</span><span class="p">(),</span><span class="w"> </span><span class="s">"Expected to time out cause no data was sent"</span><span class="p">);</span>
</code></pre></div>
<p>I don't believe that this can be made to work reliably. Here after the initial "Hi!" message is ready it's not actually known whether the stream is readable or not. Determining this would involve actually consulting the kernel with some sort of syscall or something like that. It's a pretty important perf optimization that in async servers you don't do anything with the kernel until absolutely necessary.</p>
<p>For example here the kernel was consulted during the first <code>server.input.subscribe().block()</code>. At this point the stream is considered readable. The issued <code>read</code> then again consults the kernel and reads out <code>"Hi!"</code>.  At this point though the stream is notably considered still readable by Tokio and Wasmtime. It's not known whether this was a "short read" or whether more data is coming soon. This is why the next <code>subscribe()</code> immediately says "yes this is readable". Doing otherwise would require unnecessarily consulting the kernel.</p>
<p>Working robustly with async is certainly an art but personally I don't think that there's a bug here that needs fixing. I would personally think we can close <a href="https://github.com/bytecodealliance/wasmtime/pull/9691">https://github.com/bytecodealliance/wasmtime/pull/9691</a> and this issue as "working as intended".</p>
</blockquote>



<a name="495362531"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239667%20wasmtime-wasi%3A%20Unexpected%20tcp%20stre.../near/495362531" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239667.20wasmtime-wasi.3A.20Unexpected.20tcp.20stre.2E.2E.2E.html#495362531">(Jan 22 2025 at 19:52)</a>:</h4>
<p>pchickey <a href="https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2608134946">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9667">issue #9667</a>:</p>
<blockquote>
<p>I apologize I never got back to this after saying I would. I started a new job and have a whole host of new problems to work on, so I dropped some of the old ones.</p>
<p>Thanks Alex for digging into this and helping me understand why the existing behavior is there. My conclusion is that my specification of "a ready pollable implies <a href="http://input-stream.read">input-stream.read</a> will succeed" is too strong of a guarantee to implement efficiently on top of POSIX. In discussion with Alex, he suggested that only the behavior of read shows whether input was ready or not, and the pollable's readiness is a best-effort indicator that provides an optimization over busy-looping on read. I expect that we can easily accommodate the weakening of that guarantee in existing code (at least in wstd), and any existing binaries can't possibly be relying on that guarantee since its never been upheld by implementations. We will have to take that discussion out to the spec repo in order to nail it all down.</p>
</blockquote>



<a name="495368355"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239667%20wasmtime-wasi%3A%20Unexpected%20tcp%20stre.../near/495368355" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239667.20wasmtime-wasi.3A.20Unexpected.20tcp.20stre.2E.2E.2E.html#495368355">(Jan 22 2025 at 20:30)</a>:</h4>
<p>badeend <a href="https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2608203882">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9667">issue #9667</a>:</p>
<blockquote>
<blockquote>
<p>I would personally think we can close (...) this issue as "working as intended".</p>
</blockquote>
<p>For non-blocking APIs: agree. There's not much wasmtime can do (efficiently).</p>
<p>Maybe this could also justify the removal of <a href="https://github.com/bytecodealliance/wasmtime/blob/ca9557646aac2d625a6d1d040e6caf065d0340f6/crates/wasi/src/filesystem.rs#L372-L373">starting an arbitrary-sized read in the FileInputStream implementation</a> that was put in place to fulfill this guarantee?</p>
<hr>
<p>For blocking APIs: there a few places where wasmtime blindly trusts that <code>ready().await</code> actually implies readiness. For example:</p>
<p><a href="https://github.com/bytecodealliance/wasmtime/blob/ca9557646aac2d625a6d1d040e6caf065d0340f6/crates/wasi-io/src/streams.rs#L24-L29">https://github.com/bytecodealliance/wasmtime/blob/ca9557646aac2d625a6d1d040e6caf065d0340f6/crates/wasi-io/src/streams.rs#L24-L29</a></p>
<p>In these cases wasmtime _is_ in a position to "fix" spurious wakeups by wrapping it in a loop.</p>
</blockquote>



<a name="495370266"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239667%20wasmtime-wasi%3A%20Unexpected%20tcp%20stre.../near/495370266" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239667.20wasmtime-wasi.3A.20Unexpected.20tcp.20stre.2E.2E.2E.html#495370266">(Jan 22 2025 at 20:44)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2608226315">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9667">issue #9667</a>:</p>
<blockquote>
<p>Yeah I would agree that <code>blocking_read</code> should have a loop to handle situations like this</p>
</blockquote>



<a name="495442979"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239667%20wasmtime-wasi%3A%20Unexpected%20tcp%20stre.../near/495442979" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239667.20wasmtime-wasi.3A.20Unexpected.20tcp.20stre.2E.2E.2E.html#495442979">(Jan 23 2025 at 07:56)</a>:</h4>
<p>Heap-Hop <a href="https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2609090727">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9667">issue #9667</a>:</p>
<blockquote>
<blockquote>
<p>This is why the next subscribe() immediately says "yes this is readable". Doing otherwise would require unnecessarily consulting the kernel.</p>
</blockquote>
<p>@alexcrichton Thank you so much for the clear explanation, it resolved my confusion about why <code>readable()</code> in Tokio is not explicit.</p>
<p>It would be great if the <code>blocking_</code> functions returned the expected results.</p>
<p>I would be happy to submit a PR to modify the <code>blocking_</code> functions if no one else is currently working on it.</p>
</blockquote>



<a name="495546747"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239667%20wasmtime-wasi%3A%20Unexpected%20tcp%20stre.../near/495546747" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239667.20wasmtime-wasi.3A.20Unexpected.20tcp.20stre.2E.2E.2E.html#495546747">(Jan 23 2025 at 17:00)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2610426979">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9667">issue #9667</a>:</p>
<blockquote>
<p>That'd be most welcome, thank you!</p>
</blockquote>



<a name="495847449"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%239667%20wasmtime-wasi%3A%20Unexpected%20tcp%20stre.../near/495847449" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.239667.20wasmtime-wasi.3A.20Unexpected.20tcp.20stre.2E.2E.2E.html#495847449">(Jan 25 2025 at 07:52)</a>:</h4>
<p>Heap-Hop <a href="https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2613830631">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/9667">issue #9667</a>:</p>
<blockquote>
<p>#10113 <br>
Sorry, I haven't found an easy way to write a test that might block the process, as there isn’t a <code>_until</code> function for <code>blocking_</code>.<br>
Is there an existing test case for this? The only approach I can think of is externally controlling the timeout for Wasmtime.</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>