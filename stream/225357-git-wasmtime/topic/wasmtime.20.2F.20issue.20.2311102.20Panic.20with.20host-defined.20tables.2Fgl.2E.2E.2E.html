<html>
<head><meta charset="utf-8"><title>wasmtime / issue #11102 Panic with host-defined tables/gl... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311102.20Panic.20with.20host-defined.20tables.2Fgl.2E.2E.2E.html">wasmtime / issue #11102 Panic with host-defined tables/gl...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="525366463"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311102%20Panic%20with%20host-defined%20tables/gl.../near/525366463" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311102.20Panic.20with.20host-defined.20tables.2Fgl.2E.2E.2E.html#525366463">(Jun 23 2025 at 16:13)</a>:</h4>
<p>alexcrichton opened <a href="https://github.com/bytecodealliance/wasmtime/issues/11102">issue #11102</a>:</p>
<blockquote>
<p>In at least Wasmtime 24+, possibly more versions too (haven't checked) this test will panic:</p>
<p>&lt;details&gt;</p>
<p>&lt;summary&gt;Table test&lt;/summary&gt;</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">engine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Engine</span><span class="p">::</span><span class="n">default</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">());</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FuncType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[]);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Table</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span>
<span class="w">        </span><span class="n">TableType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">RefType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">HeapType</span><span class="p">::</span><span class="n">ConcreteFunc</span><span class="p">(</span><span class="n">ty</span><span class="p">)),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">),</span>
<span class="w">        </span><span class="n">Ref</span><span class="p">::</span><span class="n">Func</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
<span class="w">    </span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_ty2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FuncType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">ValType</span><span class="p">::</span><span class="n">I32</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="n">ValType</span><span class="p">::</span><span class="n">I32</span><span class="p">]);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">ty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">store</span><span class="p">);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">fty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ty</span><span class="p">.</span><span class="n">element</span><span class="p">().</span><span class="n">heap_type</span><span class="p">().</span><span class="n">unwrap_concrete_func</span><span class="p">();</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">params</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">results</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">ty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">store</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ty</span><span class="p">.</span><span class="n">element</span><span class="p">().</span><span class="n">heap_type</span><span class="p">().</span><span class="n">unwrap_concrete_func</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">params</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">results</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>&lt;/details&gt;</p>
<p>In Wasmtime 34 this test also panics (very similar to the above, just for globals).</p>
<p>&lt;details&gt;</p>
<p>&lt;summary&gt;Global test&lt;/summary&gt;</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">engine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Engine</span><span class="p">::</span><span class="n">default</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">());</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FuncType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[]);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Global</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span>
<span class="w">        </span><span class="n">GlobalType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">            </span><span class="n">RefType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">HeapType</span><span class="p">::</span><span class="n">ConcreteFunc</span><span class="p">(</span><span class="n">ty</span><span class="p">)).</span><span class="n">into</span><span class="p">(),</span>
<span class="w">            </span><span class="n">Mutability</span><span class="p">::</span><span class="n">Const</span><span class="p">,</span>
<span class="w">        </span><span class="p">),</span>
<span class="w">        </span><span class="n">Val</span><span class="p">::</span><span class="n">FuncRef</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
<span class="w">    </span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_ty2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FuncType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">ValType</span><span class="p">::</span><span class="n">I32</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="n">ValType</span><span class="p">::</span><span class="n">I32</span><span class="p">]);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">ty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">store</span><span class="p">);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">fty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ty</span><span class="p">.</span><span class="n">content</span><span class="p">().</span><span class="n">unwrap_ref</span><span class="p">().</span><span class="n">heap_type</span><span class="p">().</span><span class="n">unwrap_concrete_func</span><span class="p">();</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">params</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">results</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">ty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">store</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ty</span><span class="p">.</span><span class="n">content</span><span class="p">().</span><span class="n">unwrap_ref</span><span class="p">().</span><span class="n">heap_type</span><span class="p">().</span><span class="n">unwrap_concrete_func</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">params</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">results</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>&lt;/details&gt;</p>
<p>The root of these issues is that a host-defined global/table are created with a concrete reference type but this reference type isn't kept alive by the host item meaning that after it's created the <code>VMSharedTypeIndex</code> that the item refers to is available for reuse. This can cause internal assertions to trip about "this type should be registered" as it isn't. Additionally, however, this can also cause the type of a table or global to "change" over time as the index is re-used.</p>
<p>This behavior is close to being a security issue and/or a CVE, but after discussion with @fitzgen we have concluded that while scary this isn't actually a security issue. While the type of a table or a global can change in this regard there's a few properties which avoid this being a security issue:</p>
<ul>
<li>None of this is visible to WebAssembly by default because function-references and gc types are <a href="https://docs.wasmtime.dev/stability-wasm-proposals.html">not tier 1 and off-by-default WebAssembly proposals</a></li>
<li>On the host while you can create a "hole" of a table/global which can change type, once a non-null value is inserted then the hole can't change type. Items to fill the "hole", like functions, have a strong reference to their type index meaning that it won't change while it's in the location.</li>
</ul>
<p>This means that panicking is only possible with host-side code and additionally the type confusion can't end up causing an value to be reinterpreted as the wrong type (except for null).</p>
<p>@fitzgen and I have concluded that this is not a security issue as a result. Definitely an issue to fix and one which we'll be making patch releases for (including older supported branches), however. In any case though I wanted to open a dedicated issue for this to have a longer-form description of the problem as well as the rationale/consequences. The summary is basically that this is a bug we feel needs fixing and is "close" to being a security issue, but we were unable to see a way where this could be exploitable by any means so we're going to make this public and issue patch releases but not issue advisories or such.</p>
</blockquote>



<a name="525366464"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311102%20Panic%20with%20host-defined%20tables/gl.../near/525366464" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311102.20Panic.20with.20host-defined.20tables.2Fgl.2E.2E.2E.html#525366464">(Jun 23 2025 at 16:13)</a>:</h4>
<p><a href="https://github.com/alexcrichton">alexcrichton</a> added the fuzz-bug label to <a href="https://github.com/bytecodealliance/wasmtime/issues/11102">Issue #11102</a>.</p>



<a name="525541520"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311102%20Panic%20with%20host-defined%20tables/gl.../near/525541520" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311102.20Panic.20with.20host-defined.20tables.2Fgl.2E.2E.2E.html#525541520">(Jun 24 2025 at 15:14)</a>:</h4>
<p>fitzgen closed <a href="https://github.com/bytecodealliance/wasmtime/issues/11102">issue #11102</a>:</p>
<blockquote>
<p>In at least Wasmtime 24+, possibly more versions too (haven't checked) this test will panic:</p>
<p>&lt;details&gt;</p>
<p>&lt;summary&gt;Table test&lt;/summary&gt;</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">engine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Engine</span><span class="p">::</span><span class="n">default</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">());</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FuncType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[]);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Table</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span>
<span class="w">        </span><span class="n">TableType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">RefType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">HeapType</span><span class="p">::</span><span class="n">ConcreteFunc</span><span class="p">(</span><span class="n">ty</span><span class="p">)),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nb">None</span><span class="p">),</span>
<span class="w">        </span><span class="n">Ref</span><span class="p">::</span><span class="n">Func</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
<span class="w">    </span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_ty2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FuncType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">ValType</span><span class="p">::</span><span class="n">I32</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="n">ValType</span><span class="p">::</span><span class="n">I32</span><span class="p">]);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">ty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">store</span><span class="p">);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">fty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ty</span><span class="p">.</span><span class="n">element</span><span class="p">().</span><span class="n">heap_type</span><span class="p">().</span><span class="n">unwrap_concrete_func</span><span class="p">();</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">params</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">results</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">.</span><span class="n">ty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">store</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ty</span><span class="p">.</span><span class="n">element</span><span class="p">().</span><span class="n">heap_type</span><span class="p">().</span><span class="n">unwrap_concrete_func</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">params</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">results</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>&lt;/details&gt;</p>
<p>In Wasmtime 34 this test also panics (very similar to the above, just for globals).</p>
<p>&lt;details&gt;</p>
<p>&lt;summary&gt;Global test&lt;/summary&gt;</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">engine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Engine</span><span class="p">::</span><span class="n">default</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Store</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">());</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FuncType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">[],</span><span class="w"> </span><span class="p">[]);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Global</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">        </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span>
<span class="w">        </span><span class="n">GlobalType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span>
<span class="w">            </span><span class="n">RefType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="n">HeapType</span><span class="p">::</span><span class="n">ConcreteFunc</span><span class="p">(</span><span class="n">ty</span><span class="p">)).</span><span class="n">into</span><span class="p">(),</span>
<span class="w">            </span><span class="n">Mutability</span><span class="p">::</span><span class="n">Const</span><span class="p">,</span>
<span class="w">        </span><span class="p">),</span>
<span class="w">        </span><span class="n">Val</span><span class="p">::</span><span class="n">FuncRef</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
<span class="w">    </span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">_ty2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FuncType</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">engine</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">ValType</span><span class="p">::</span><span class="n">I32</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="n">ValType</span><span class="p">::</span><span class="n">I32</span><span class="p">]);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">ty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">store</span><span class="p">);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">fty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ty</span><span class="p">.</span><span class="n">content</span><span class="p">().</span><span class="n">unwrap_ref</span><span class="p">().</span><span class="n">heap_type</span><span class="p">().</span><span class="n">unwrap_concrete_func</span><span class="p">();</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">params</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">results</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">.</span><span class="n">ty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">store</span><span class="p">);</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">fty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ty</span><span class="p">.</span><span class="n">content</span><span class="p">().</span><span class="n">unwrap_ref</span><span class="p">().</span><span class="n">heap_type</span><span class="p">().</span><span class="n">unwrap_concrete_func</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">params</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span><span class="n">fty</span><span class="p">.</span><span class="n">results</span><span class="p">().</span><span class="n">len</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
</code></pre></div>
<p>&lt;/details&gt;</p>
<p>The root of these issues is that a host-defined global/table are created with a concrete reference type but this reference type isn't kept alive by the host item meaning that after it's created the <code>VMSharedTypeIndex</code> that the item refers to is available for reuse. This can cause internal assertions to trip about "this type should be registered" as it isn't. Additionally, however, this can also cause the type of a table or global to "change" over time as the index is re-used.</p>
<p>This behavior is close to being a security issue and/or a CVE, but after discussion with @fitzgen we have concluded that while scary this isn't actually a security issue. While the type of a table or a global can change in this regard there's a few properties which avoid this being a security issue:</p>
<ul>
<li>None of this is visible to WebAssembly by default because function-references and gc types are <a href="https://docs.wasmtime.dev/stability-wasm-proposals.html">not tier 1 and off-by-default WebAssembly proposals</a></li>
<li>On the host while you can create a "hole" of a table/global which can change type, once a non-null value is inserted then the hole can't change type. Items to fill the "hole", like functions, have a strong reference to their type index meaning that it won't change while it's in the location.</li>
</ul>
<p>This means that panicking is only possible with host-side code and additionally the type confusion can't end up causing an value to be reinterpreted as the wrong type (except for null).</p>
<p>@fitzgen and I have concluded that this is not a security issue as a result. Definitely an issue to fix and one which we'll be making patch releases for (including older supported branches), however. In any case though I wanted to open a dedicated issue for this to have a longer-form description of the problem as well as the rationale/consequences. The summary is basically that this is a bug we feel needs fixing and is "close" to being a security issue, but we were unable to see a way where this could be exploitable by any means so we're going to make this public and issue patch releases but not issue advisories or such.</p>
</blockquote>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>