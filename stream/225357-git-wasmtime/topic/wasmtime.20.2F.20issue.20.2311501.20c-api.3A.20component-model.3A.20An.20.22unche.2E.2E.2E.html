<html>
<head><meta charset="utf-8"><title>wasmtime / issue #11501 c-api: component-model: An &quot;unche... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311501.20c-api.3A.20component-model.3A.20An.20.22unche.2E.2E.2E.html">wasmtime / issue #11501 c-api: component-model: An &quot;unche...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="535590578"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311501%20c-api%3A%20component-model%3A%20An%20%22unche.../near/535590578" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311501.20c-api.3A.20component-model.3A.20An.20.22unche.2E.2E.2E.html#535590578">(Aug 21 2025 at 23:03)</a>:</h4>
<p>alexcrichton opened <a href="https://github.com/bytecodealliance/wasmtime/issues/11501">issue #11501</a>:</p>
<blockquote>
<p>Currently funciton invocations, both on the host and that of guests, go through <code>wasmtime_component_val_t</code> which is a bit of a heavyweight representation of arguments/results in the component model. Ideally the C API sould support something like <code>wasmtime_func_call_unchecked</code> which places more burden on the caller but is implemented in a much more efficient fashion. Supporting this with the full matrix of types in the component model is unclear how it will be done so this is, to me at least, an open design/research question currently without a solution.</p>
</blockquote>



<a name="535590579"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311501%20c-api%3A%20component-model%3A%20An%20%22unche.../near/535590579" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311501.20c-api.3A.20component-model.3A.20An.20.22unche.2E.2E.2E.html#535590579">(Aug 21 2025 at 23:03)</a>:</h4>
<p><a href="https://github.com/alexcrichton">alexcrichton</a> added the wasmtime:c-api label to <a href="https://github.com/bytecodealliance/wasmtime/issues/11501">Issue #11501</a>.</p>



<a name="535590580"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311501%20c-api%3A%20component-model%3A%20An%20%22unche.../near/535590580" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311501.20c-api.3A.20component-model.3A.20An.20.22unche.2E.2E.2E.html#535590580">(Aug 21 2025 at 23:03)</a>:</h4>
<p><a href="https://github.com/alexcrichton">alexcrichton</a> added the wasm-proposal:component-model label to <a href="https://github.com/bytecodealliance/wasmtime/issues/11501">Issue #11501</a>.</p>



<a name="535667342"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311501%20c-api%3A%20component-model%3A%20An%20%22unche.../near/535667342" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311501.20c-api.3A.20component-model.3A.20An.20.22unche.2E.2E.2E.html#535667342">(Aug 22 2025 at 11:54)</a>:</h4>
<p>Digifox03 <a href="https://github.com/bytecodealliance/wasmtime/issues/11501#issuecomment-3214104913">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11501">issue #11501</a>:</p>
<blockquote>
<p>As far as calling function whose signature is only known at run time, I don't think there is a better approach that the current one. What I'm interested is improving performance in the case of functions whose signature is known at compile time.</p>
<p>Rather than providing a function like <code>wasmtime_func_call_unchecked</code>, the api can provide a way to get a function pointer. The signature of the function pointer depends on the signature of the component function.</p>
<p>For example, a function like <code>func(a: u32, b: u64) -&gt; s8</code> can be mapped to a function pointer with type <code>int8_t (*)(uint32_t a, uint64_t b)</code> or with type <code>int8_t (*)(wasmtime_context_t *context, uint32_t a, uint64_t b)</code>.</p>
<p>This is also compatible with languages that use systems like libffi to call arbitrary c functions.</p>
</blockquote>



<a name="538492990"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311501%20c-api%3A%20component-model%3A%20An%20%22unche.../near/538492990" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311501.20c-api.3A.20component-model.3A.20An.20.22unche.2E.2E.2E.html#538492990">(Sep 09 2025 at 17:31)</a>:</h4>
<p>UserMist <a href="https://github.com/bytecodealliance/wasmtime/issues/11501#issuecomment-3271666374">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11501">issue #11501</a>:</p>
<blockquote>
<p>Maybe there could be two api methods, one for setting binary layout for some sort of adapter function generated at a run-time, and the other method for passing raw data matching this layout.<br>
Probably suggesting nonsense though, since I'm new to this project.</p>
</blockquote>



<a name="546704453"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311501%20c-api%3A%20component-model%3A%20An%20%22unche.../near/546704453" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311501.20c-api.3A.20component-model.3A.20An.20.22unche.2E.2E.2E.html#546704453">(Oct 23 2025 at 15:03)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11501#issuecomment-3437509569">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11501">issue #11501</a>:</p>
<blockquote>
<p>Rough idea: the <a href="https://github.com/bytecodealliance/wasmtime/issues/11501#issuecomment-3214104913">idea above</a> I think would make sense but I'd prefer to avoid dealing with things like libffi to dynamically invoke functions of different type signatures. Instead I'd perfer to invoke functions of a single type signature. The question then is what signature is faster than today but still works for all functions? </p>
<p>The rough idea is that the signature is <code>wasmtime_error_t *(*)(void*, wasmtime_context_t*, void *args_and_results, size_t args_and_results_len)</code> where args/results are "serialized" into an area. This serialization would be somewhat lightweight, for example integers would just push themselves, records would push fields, etc. More-or-less this would be the canonical ABI in-memory format anyway (unsure what to do about alignment). The tricky parts are:</p>
<ul>
<li>Resources - these wouldn't look like the canonical ABI. Probably would look like <code>wasmtime_component_resource_any_t*</code> or something like that.</li>
<li>Strings - I'm imagining that coming from the guest it'd be a raw pointer into linear memory (pre-validated) or host memory (if not utf-8). The thinking is that a <code>post-return</code> operation would be required to be deferred until after arguments were read. Going into the guest I'm thinking these would be raw pointers into host memory. Cleanup... TBD.</li>
<li>Lists - This is the roughest idea part. Instead of raw pointers lists would be a sort of "tombstone" where you'd go back to some sort of Wasmtime context and say "hey give me the contents of the list". This would prevent Wasmtime from allocating anything and the embedder would be the one providing any sort of memory buffers.</li>
</ul>
<p>Not enough to implement things, but wanted to at least write down what I thought were the trickiest bits (resources/strings/lists)</p>
</blockquote>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>