<html>
<head><meta charset="utf-8"><title>wasmtime / PR #10134 Support platforms without 64-bit ato... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html">wasmtime / PR #10134 Support platforms without 64-bit ato...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="496361230"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496361230" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496361230">(Jan 28 2025 at 15:23)</a>:</h4>
<p><strong>alexcrichton</strong> requested <a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers">wasmtime-core-reviewers</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>.</p>



<a name="496361231"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496361231" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496361231">(Jan 28 2025 at 15:23)</a>:</h4>
<p><strong>alexcrichton</strong> requested <a href="https://github.com/dicej">dicej</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>.</p>



<a name="496361232"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496361232" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496361232">(Jan 28 2025 at 15:23)</a>:</h4>
<p>alexcrichton opened <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a> from <code>alexcrichton:riscv32</code> to <code>bytecodealliance:main</code>:</p>
<blockquote>
<p>This commit enables Wasmtime to build on platforms without 64-bit atomic instructions, such as Rust's <code>riscv32imac-unknown-none-elf</code> target. There are only two users of 64-bit atomics right now which are epochs and allocation of <code>StoreId</code>. This commit adds <code>#[cfg]</code> to epoch-related infrastructure in the runtime to turn that all of if 64-bit atomics aren't available. The thinking is that epochs more-or-less don't work without 64-bit atomics so it's easier to just remove them entirely.</p>
<p>Allocation of <code>StoreId</code> is trickier though because it's so core to Wasmtime and it basically can't be removed. I've opted to change the allocator to 32-bit indices instead of 64-bit indices. Note that <code>StoreId</code> requires unique IDs to be allocated for safety which means that while a 64-bit integer won't overflow for a few thousand years a 32-bit integer will overflow in a few hours from quickly creating stores. The rough hope though is that embeddings on platforms like this aren't churning through stores. Regardless if this condition is triggered it'll result in a panic rather than unsoundness, so we hopefully have at least that going for us.</p>
<p>Closes #8768</p>
<p>&lt;!--<br>
Please make sure you include the following information:</p>
<ul>
<li>
<p>If this work has been discussed elsewhere, please include a link to that<br>
  conversation. If it was discussed in an issue, just mention "issue #...".</p>
</li>
<li>
<p>Explain why this change is needed. If the details are in an issue already,<br>
  this can be brief.</p>
</li>
</ul>
<p>Our development process is documented in the Wasmtime book:<br>
<a href="https://docs.wasmtime.dev/contributing-development-process.html">https://docs.wasmtime.dev/contributing-development-process.html</a></p>
<p>Please ensure all communication follows the code of conduct:<br>
<a href="https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>
--&gt;</p>
</blockquote>



<a name="496361233"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496361233" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496361233">(Jan 28 2025 at 15:23)</a>:</h4>
<p><strong>alexcrichton</strong> requested <a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-default-reviewers">wasmtime-default-reviewers</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>.</p>



<a name="496361682"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496361682" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496361682">(Jan 28 2025 at 15:25)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#issuecomment-2619321615">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>:</p>
<blockquote>
<p>On a more abstract note this is part of my quest to "let's port everything everywhere" so I don't have anything specific in mind for the use case here. Instead it's more of "maybe others can do interesting things with this". The bit about <code>StoreId</code> I'm not particularly happy with because it's something where your tiny embedded device will crash after days online and you'll have no way to easily reproduce unless you can easily debug it. That seems like a pretty bad silent failure mode but at the same time I'm not sure what else to do...</p>
<p>Mostly saying that I'm not 100% sold this is a good idea, but I also don't know of a different way to run without 64-bit atomics right now.</p>
</blockquote>



<a name="496388789"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496388789" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496388789">(Jan 28 2025 at 17:34)</a>:</h4>
<p>pchickey submitted <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#pullrequestreview-2578989391">PR review</a>:</p>
<blockquote>
<p>I agree this tradeoff feels a little unsavory but I can't think of a better alternative. We don't want to refuse to support a platform at all because one of the guarantees wasmtime provides isn't well suited to a particularly intense corner case on that platform.</p>
</blockquote>



<a name="496417891"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496417891" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496417891">(Jan 28 2025 at 20:23)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>.</p>



<a name="496418061"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496418061" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496418061">(Jan 28 2025 at 20:24)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#issuecomment-2619985681">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>:</p>
<blockquote>
<p>Ah I forgot a usage in component model resources. The usage there is only intended to have interior mutability and still be Send/Sync so this updates the type to using two <code>AtomicU32</code> values. No atomicity is required in this use case since bigger bugs are afoot if there are concurrent reads/writes to this value. The only thing we're trying to prevent is UB, which two <code>AtomicU32</code> values work just fine for.</p>
</blockquote>



<a name="496418113"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496418113" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496418113">(Jan 28 2025 at 20:24)</a>:</h4>
<p>hanna-kruppe <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#issuecomment-2619986430">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>:</p>
<blockquote>
<p>Would a lock protecting a (non-atomic) <code>u64</code> would be an option? Of course in a general <code>no_std</code> context this would have to be a spinlock, which is bad for all sorts of reasons, but perhaps slightly better than the failure mode of running out of <code>StoreId</code>s after a few days of normal operation.</p>
</blockquote>



<a name="496418152"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496418152" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496418152">(Jan 28 2025 at 20:25)</a>:</h4>
<p>hanna-kruppe edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#issuecomment-2619986430">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>:</p>
<blockquote>
<p>Would a lock protecting a (non-atomic) <code>u64</code> would be an option for <code>StoreId</code>? Of course in a general <code>no_std</code> context this would have to be a spinlock, which is bad for all sorts of reasons, but perhaps slightly better than the failure mode of running out of <code>StoreId</code>s after a few days of normal operation.</p>
</blockquote>



<a name="496418640"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496418640" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496418640">(Jan 28 2025 at 20:28)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#issuecomment-2619992515">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>:</p>
<blockquote>
<p>Yeah if <code>std</code> could be relied on I'd replace it with a <code>Mutex&lt;u64&gt;</code> on non-64-bit platforms. Personally I'd prefer to avoid spin locks or panic-on-contention for something so core as creating a new store. The failure mode here specifically is creating many <code>Store&lt;T&gt;</code> instances and destroying them, where eventually that'll panic. I'm not sure if low-end devices that don't have 64-bit atomics will be doing since since I'd otherwise suspect that they'd probably create a small handful of stores (if more than 1) and use those for their lifetime.</p>
<p>Overall I don't know what the best tradeoff is. As-is <code>Store&lt;T&gt;::new</code> will panic if called rapidly. With a spin-lock you run the risk of long pauses if you get preempted while the lock is held. With panic-on-contention you risk periodic panics if there are multiple threads/actors in the system. None seem like a great option :(</p>
</blockquote>



<a name="496420347"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496420347" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496420347">(Jan 28 2025 at 20:40)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#issuecomment-2620012600">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>:</p>
<blockquote>
<p>Slightly wild idea inspired by number theory that might be close to working:</p>
<p>If we have two atomic u32s, and we increment them by relatively prime amounts (say, 3 and 5) that are also relatively prime to the modulus of the ring we're operating in (2^32), then the periodicity of the pair of them is the product of the periodicity of each. In other words, we walk through 2^64 possible tuples. They're not <em>contiguous</em> in ordinary numeric order but we don't need that -- only uniqueness.</p>
<p>The slight wrinkle is that if we do the atomic increments separately, the two halves of the tuple sequence can "slide" relative to each other -- and this reduces the periodicity / can lead to repeats. I think one can fix that by incrementing the first, the second, then the first again, and using the 3-tuple. My intuition is that that bounds the "slide" / recovers uniqueness, but I'm having some trouble thinking through it at the moment. Maybe it inspires someone else though?</p>
</blockquote>



<a name="496422122"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496422122" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496422122">(Jan 28 2025 at 20:52)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#issuecomment-2620032824">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>:</p>
<blockquote>
<p>Ah, OK, here is something that should work. It's not constant-time (it can retry) but it <em>is</em> non-blocking (in the lockless programming sense): there are no spinloops.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">PairCounter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">AtomicU32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">AtomicU32</span><span class="w"> </span><span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">PairCounter</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="n">x_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">wrapping_add</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x_</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Common case: no one else bumped self.x in the meantime.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nf">next_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
<span class="w">    </span><span class="p">(</span><span class="kt">u64</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">u64</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>relaxing the <code>SeqCst</code> to acquire/release left as an exercise to the (smarter than me) reader...</p>
</blockquote>



<a name="496422268"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496422268" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496422268">(Jan 28 2025 at 20:53)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#issuecomment-2620032824">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>:</p>
<blockquote>
<p>Ah, OK, here is something that should work. It's not constant-time (it can retry) but it <em>is</em> non-blocking (in the lockless programming sense): there are no spinloops.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">PairCounter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">AtomicU32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">AtomicU32</span><span class="w"> </span><span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">PairCounter</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="n">x_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">wrapping_add</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x_</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Common case: no one else bumped self.x in the meantime.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nf">next_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
<span class="w">    </span><span class="p">(</span><span class="kt">u64</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">u64</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>relaxing the <code>SeqCst</code> to acquire/release left as an exercise to the (smarter than me) reader...</p>
</blockquote>



<a name="496422302"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496422302" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496422302">(Jan 28 2025 at 20:53)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#issuecomment-2620032824">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>:</p>
<blockquote>
<p>Ah, OK, here is something that should work. It's not constant-time (it can retry) but it <em>is</em> non-blocking (in the lockless programming sense): there are no spinloops.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">PairCounter</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nc">AtomicU32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nc">AtomicU32</span><span class="w"> </span><span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">PairCounter</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="kt">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">loop</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">y</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="n">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
<span class="w">      </span><span class="kd">let</span><span class="w"> </span><span class="n">x_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">x</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">Ordering</span><span class="p">::</span><span class="n">SeqCst</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">wrapping_add</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x_</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// Common case: no one else bumped self.x in the meantime.</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">fn</span><span class="w"> </span><span class="nf">next_u64</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">u64</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next</span><span class="p">();</span>
<span class="w">    </span><span class="p">(</span><span class="kt">u64</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">u64</span><span class="p">::</span><span class="n">from</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>relaxing the <code>SeqCst</code> to acquire/release left as an exercise to the (smarter than me) reader...</p>
</blockquote>



<a name="496434348"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496434348" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496434348">(Jan 28 2025 at 22:22)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#issuecomment-2620176609">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>:</p>
<blockquote>
<p>@cfallin would you feel confident enough in that to have it be the default algorithm? From a speed perspective I'm not too worried about that being significantly slower than the current allocation (I'd expect <code>Store&lt;T&gt;</code> allocation in general to dwarf the atomic ops). What I would be worried about though is that if something as complex as that is not on-by-default then we won't catch any possible issues with it</p>
</blockquote>



<a name="496438935"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496438935" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496438935">(Jan 28 2025 at 23:05)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#issuecomment-2620239610">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>:</p>
<blockquote>
<p>Maybe? I'm by no means a niche expert in lockless algorithms -- I can try to sketch a correctness proof though. I don't want to block your work here so by all means land with 32-bit atomics and the (unfortunate but best option) "time bomb" panic and I can do this as followup.</p>
</blockquote>



<a name="496441443"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496441443" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496441443">(Jan 28 2025 at 23:28)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>.</p>



<a name="496441665"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496441665" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496441665">(Jan 28 2025 at 23:30)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/10134#issuecomment-2620266927">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>:</p>
<blockquote>
<p>Nah makes sense, but on reflection I've switched this to using <code>crate::sync::RwLock&lt;T&gt;</code> which is basically "put a lock around it". Our <code>no_std</code> locks currently all panic on contention under the assumption that you probably only have on thread in no_std contexts. In any case this is no worse than what Wasmtime had before this change and it's arguably more correct with respect to <code>StoreId</code>. This means that we'll still preserve 64-bit uniqueness guarantees and it'll just be a bit slower without 64-bit atomics.</p>
<p>If the panic-on-contention bit becomes a problem then it's already one we have to solve anyway, so this way if that's a problem we still only have one problem to solve as opposed to two.</p>
</blockquote>



<a name="496441706"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496441706" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496441706">(Jan 28 2025 at 23:31)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>.</p>



<a name="496441740"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496441740" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496441740">(Jan 28 2025 at 23:31)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>.</p>



<a name="496441855"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496441855" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496441855">(Jan 28 2025 at 23:32)</a>:</h4>
<p>alexcrichton has enabled auto merge for <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>.</p>



<a name="496577386"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496577386" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496577386">(Jan 29 2025 at 15:38)</a>:</h4>
<p>alexcrichton updated <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>.</p>



<a name="496577396"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496577396" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496577396">(Jan 29 2025 at 15:38)</a>:</h4>
<p>alexcrichton has enabled auto merge for <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>.</p>



<a name="496585504"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2310134%20Support%20platforms%20without%2064-bit%20ato.../near/496585504" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2310134.20Support.20platforms.20without.2064-bit.20ato.2E.2E.2E.html#496585504">(Jan 29 2025 at 16:14)</a>:</h4>
<p>alexcrichton merged <a href="https://github.com/bytecodealliance/wasmtime/pull/10134">PR #10134</a>.</p>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>