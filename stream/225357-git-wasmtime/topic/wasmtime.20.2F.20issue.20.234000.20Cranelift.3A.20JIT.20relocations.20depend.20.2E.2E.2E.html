<html>
<head><meta charset="utf-8"><title>wasmtime / issue #4000 Cranelift: JIT relocations depend ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html">wasmtime / issue #4000 Cranelift: JIT relocations depend ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="278025198"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/278025198" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#278025198">(Apr 06 2022 at 13:44)</a>:</h4>
<p>Mrmaxmeier opened <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<p>Hey,</p>
<p>I'm seeing crashes during <code>finalize_definitions</code> calls related to x86\_64 <code>call</code> relocations:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">thread</span><span class="w"> </span><span class="o">'</span><span class="na">main</span><span class="o">'</span><span class="w"> </span><span class="n">panicked</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="o">'</span><span class="na">called</span><span class="w"> </span><span class="err">`</span><span class="nb">Result</span>::<span class="n">unwrap</span><span class="p">()</span><span class="err">`</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="err">`</span><span class="nb">Err</span><span class="err">`</span><span class="w"> </span><span class="n">value</span>: <span class="nc">TryFromIntError</span><span class="p">(())</span><span class="o">'</span><span class="p">,</span><span class="w"> </span><span class="n">cranelift</span><span class="o">/</span><span class="n">jit</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">compiled_blob</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">55</span>:<span class="mi">80</span><span class="w"></span>
</code></pre></div>
<p>Cranelift <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/codegen/src/isa/x64/inst/emit.rs#L1196">emits 32-bit relocations for calls on x86\_64</a>, and thus can "only" address in the relative ±2GB range. Code memory is <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/jit/src/memory.rs#L55">allocated</a> with the normal system allocator, which might place different allocations in distant parts of the address space.<br>
I'm seeing irregular crashes in a heavily multithreaded program, but the problem can be reproduced with this abridged <code>jit-minimal.rs</code> example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">cranelift</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">settings</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_jit</span>::<span class="p">{</span><span class="n">JITBuilder</span><span class="p">,</span><span class="w"> </span><span class="n">JITModule</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_module</span>::<span class="p">{</span><span class="n">default_libcall_names</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span><span class="p">,</span><span class="w"> </span><span class="n">Module</span><span class="p">};</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">isa_builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cranelift_native</span>::<span class="n">builder</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">isa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isa_builder</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">finish</span><span class="p">(</span><span class="n">settings</span>::<span class="n">Flags</span>::<span class="n">new</span><span class="p">(</span><span class="n">settings</span>::<span class="n">builder</span><span class="p">()))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JITModule</span>::<span class="n">new</span><span class="p">(</span><span class="n">JITBuilder</span>::<span class="n">with_isa</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span><span class="w"> </span><span class="n">default_libcall_names</span><span class="p">()));</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">make_context</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilderContext</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">func_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">declare_function</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span>::<span class="n">Local</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">make_signature</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">func_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">declare_function</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span>::<span class="n">Local</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">make_signature</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Define a dummy function `func_a`</span>
<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExternalName</span>::<span class="n">user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">func_a</span><span class="p">.</span><span class="n">as_u32</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span>: <span class="nc">FunctionBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilder</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">return_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">seal_all_blocks</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="n">func_a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate a bunch (~4GB) to stretch address space</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">allocations</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">999999</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">allocations</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">4096</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Define `func_b` in a new allocation and reference `func_a`</span>
<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExternalName</span>::<span class="n">user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">func_b</span><span class="p">.</span><span class="n">as_u32</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span>: <span class="nc">FunctionBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilder</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">local_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">declare_func_in_func</span><span class="p">(</span><span class="n">func_a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">func</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Emit a call with a relocation for func_a</span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">(</span><span class="n">local_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Make sure that this function's body is larger than page_size and will require a new allocation.</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">1024</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">(</span><span class="n">local_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">return_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">seal_all_blocks</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="n">func_b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Perform linking</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">finalize_definitions</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It might be possible to trigger this from small-ish WebAssembly modules with glibc's mmap threshold that places <a href="https://www.gnu.org/software/libc/manual/html_node/Malloc-Tunable-Parameters.html#index-M_005fMMAP_005fTHRESHOLD">&gt;128kb allocations outside of the heap</a>, though I haven't had any luck reproducing that because glibc's dynamic threshold scaling raises this limit before code is emitted.</p>
<p>Possible approaches:</p>
<ul>
<li>
<p>Determine the total size of the finalized code page before allocating; allocate one large chunk. It seems like an implementation for this should be doable, though I'm not sure if this is by design. (This would be incompatible with features like hot function replacement.)</p>
</li>
<li>
<p>Don't allocate on the heap. Cranelift's <code>selinux-fix</code> features uses mmap allocations. The underlying issue still persists, though as mmap allocations are separate from the heap, they're mostly sequential and would need &gt;2GB of generated machine code to cause problems.</p>
</li>
<li>
<p>(Change relocation style? There's no 64-bit relative jump in x86\_64 and blowing up code size for this seems like a bad idea.)</p>
</li>
</ul>
<p>Aarch64 runs into a related issue with 26-bit relative jumps: <a href="https://github.com/bytecodealliance/wasmtime/issues/3277">https://github.com/bytecodealliance/wasmtime/issues/3277</a><br>
I'm not sure veneers are applicable for x86\_64, but they seems like an interesting and more general approach to relative jump range limits.</p>
</blockquote>



<a name="278025199"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/278025199" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#278025199">(Apr 06 2022 at 13:44)</a>:</h4>
<p>Mrmaxmeier labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<p>Hey,</p>
<p>I'm seeing crashes during <code>finalize_definitions</code> calls related to x86\_64 <code>call</code> relocations:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">thread</span><span class="w"> </span><span class="o">'</span><span class="na">main</span><span class="o">'</span><span class="w"> </span><span class="n">panicked</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="o">'</span><span class="na">called</span><span class="w"> </span><span class="err">`</span><span class="nb">Result</span>::<span class="n">unwrap</span><span class="p">()</span><span class="err">`</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="err">`</span><span class="nb">Err</span><span class="err">`</span><span class="w"> </span><span class="n">value</span>: <span class="nc">TryFromIntError</span><span class="p">(())</span><span class="o">'</span><span class="p">,</span><span class="w"> </span><span class="n">cranelift</span><span class="o">/</span><span class="n">jit</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">compiled_blob</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">55</span>:<span class="mi">80</span><span class="w"></span>
</code></pre></div>
<p>Cranelift <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/codegen/src/isa/x64/inst/emit.rs#L1196">emits 32-bit relocations for calls on x86\_64</a>, and thus can "only" address in the relative ±2GB range. Code memory is <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/jit/src/memory.rs#L55">allocated</a> with the normal system allocator, which might place different allocations in distant parts of the address space.<br>
I'm seeing irregular crashes in a heavily multithreaded program, but the problem can be reproduced with this abridged <code>jit-minimal.rs</code> example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">cranelift</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">settings</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_jit</span>::<span class="p">{</span><span class="n">JITBuilder</span><span class="p">,</span><span class="w"> </span><span class="n">JITModule</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_module</span>::<span class="p">{</span><span class="n">default_libcall_names</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span><span class="p">,</span><span class="w"> </span><span class="n">Module</span><span class="p">};</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">isa_builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cranelift_native</span>::<span class="n">builder</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">isa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isa_builder</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">finish</span><span class="p">(</span><span class="n">settings</span>::<span class="n">Flags</span>::<span class="n">new</span><span class="p">(</span><span class="n">settings</span>::<span class="n">builder</span><span class="p">()))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JITModule</span>::<span class="n">new</span><span class="p">(</span><span class="n">JITBuilder</span>::<span class="n">with_isa</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span><span class="w"> </span><span class="n">default_libcall_names</span><span class="p">()));</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">make_context</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilderContext</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">func_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">declare_function</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span>::<span class="n">Local</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">make_signature</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">func_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">declare_function</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span>::<span class="n">Local</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">make_signature</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Define a dummy function `func_a`</span>
<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExternalName</span>::<span class="n">user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">func_a</span><span class="p">.</span><span class="n">as_u32</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span>: <span class="nc">FunctionBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilder</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">return_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">seal_all_blocks</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="n">func_a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate a bunch (~4GB) to stretch address space</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">allocations</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">999999</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">allocations</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">4096</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Define `func_b` in a new allocation and reference `func_a`</span>
<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExternalName</span>::<span class="n">user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">func_b</span><span class="p">.</span><span class="n">as_u32</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span>: <span class="nc">FunctionBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilder</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">local_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">declare_func_in_func</span><span class="p">(</span><span class="n">func_a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">func</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Emit a call with a relocation for func_a</span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">(</span><span class="n">local_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Make sure that this function's body is larger than page_size and will require a new allocation.</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">1024</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">(</span><span class="n">local_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">return_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">seal_all_blocks</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="n">func_b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Perform linking</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">finalize_definitions</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It might be possible to trigger this from small-ish WebAssembly modules with glibc's mmap threshold that places <a href="https://www.gnu.org/software/libc/manual/html_node/Malloc-Tunable-Parameters.html#index-M_005fMMAP_005fTHRESHOLD">&gt;128kb allocations outside of the heap</a>, though I haven't had any luck reproducing that because glibc's dynamic threshold scaling raises this limit before code is emitted.</p>
<p>Possible approaches:</p>
<ul>
<li>
<p>Determine the total size of the finalized code page before allocating; allocate one large chunk. It seems like an implementation for this should be doable, though I'm not sure if this is by design. (This would be incompatible with features like hot function replacement.)</p>
</li>
<li>
<p>Don't allocate on the heap. Cranelift's <code>selinux-fix</code> features uses mmap allocations. The underlying issue still persists, though as mmap allocations are separate from the heap, they're mostly sequential and would need &gt;2GB of generated machine code to cause problems.</p>
</li>
<li>
<p>(Change relocation style? There's no 64-bit relative jump in x86\_64 and blowing up code size for this seems like a bad idea.)</p>
</li>
</ul>
<p>Aarch64 runs into a related issue with 26-bit relative jumps: <a href="https://github.com/bytecodealliance/wasmtime/issues/3277">https://github.com/bytecodealliance/wasmtime/issues/3277</a><br>
I'm not sure veneers are applicable for x86\_64, but they seems like an interesting and more general approach to relative jump range limits.</p>
</blockquote>



<a name="278025200"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/278025200" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#278025200">(Apr 06 2022 at 13:44)</a>:</h4>
<p>Mrmaxmeier labeled <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<p>Hey,</p>
<p>I'm seeing crashes during <code>finalize_definitions</code> calls related to x86\_64 <code>call</code> relocations:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">thread</span><span class="w"> </span><span class="o">'</span><span class="na">main</span><span class="o">'</span><span class="w"> </span><span class="n">panicked</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="o">'</span><span class="na">called</span><span class="w"> </span><span class="err">`</span><span class="nb">Result</span>::<span class="n">unwrap</span><span class="p">()</span><span class="err">`</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="err">`</span><span class="nb">Err</span><span class="err">`</span><span class="w"> </span><span class="n">value</span>: <span class="nc">TryFromIntError</span><span class="p">(())</span><span class="o">'</span><span class="p">,</span><span class="w"> </span><span class="n">cranelift</span><span class="o">/</span><span class="n">jit</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">compiled_blob</span><span class="p">.</span><span class="n">rs</span>:<span class="mi">55</span>:<span class="mi">80</span><span class="w"></span>
</code></pre></div>
<p>Cranelift <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/codegen/src/isa/x64/inst/emit.rs#L1196">emits 32-bit relocations for calls on x86\_64</a>, and thus can "only" address in the relative ±2GB range. Code memory is <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/jit/src/memory.rs#L55">allocated</a> with the normal system allocator, which might place different allocations in distant parts of the address space.<br>
I'm seeing irregular crashes in a heavily multithreaded program, but the problem can be reproduced with this abridged <code>jit-minimal.rs</code> example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">cranelift</span>::<span class="n">prelude</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_codegen</span>::<span class="n">settings</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_jit</span>::<span class="p">{</span><span class="n">JITBuilder</span><span class="p">,</span><span class="w"> </span><span class="n">JITModule</span><span class="p">};</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">cranelift_module</span>::<span class="p">{</span><span class="n">default_libcall_names</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span><span class="p">,</span><span class="w"> </span><span class="n">Module</span><span class="p">};</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">isa_builder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cranelift_native</span>::<span class="n">builder</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">isa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">isa_builder</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">finish</span><span class="p">(</span><span class="n">settings</span>::<span class="n">Flags</span>::<span class="n">new</span><span class="p">(</span><span class="n">settings</span>::<span class="n">builder</span><span class="p">()))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JITModule</span>::<span class="n">new</span><span class="p">(</span><span class="n">JITBuilder</span>::<span class="n">with_isa</span><span class="p">(</span><span class="n">isa</span><span class="p">,</span><span class="w"> </span><span class="n">default_libcall_names</span><span class="p">()));</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">make_context</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilderContext</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">func_a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">declare_function</span><span class="p">(</span><span class="s">"a"</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span>::<span class="n">Local</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">make_signature</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">func_b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">declare_function</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span><span class="w"> </span><span class="n">Linkage</span>::<span class="n">Local</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">.</span><span class="n">make_signature</span><span class="p">())</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Define a dummy function `func_a`</span>
<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExternalName</span>::<span class="n">user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">func_a</span><span class="p">.</span><span class="n">as_u32</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span>: <span class="nc">FunctionBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilder</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">return_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">seal_all_blocks</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="n">func_a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Allocate a bunch (~4GB) to stretch address space</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">allocations</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Vec</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">999999</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">allocations</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="nb">Vec</span>::<span class="n">with_capacity</span><span class="p">(</span><span class="mi">4096</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Define `func_b` in a new allocation and reference `func_a`</span>
<span class="w">    </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ExternalName</span>::<span class="n">user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">func_b</span><span class="p">.</span><span class="n">as_u32</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span>: <span class="nc">FunctionBuilder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FunctionBuilder</span>::<span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">.</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">func_ctx</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">create_block</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">switch_to_block</span><span class="p">(</span><span class="n">block</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">local_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">declare_func_in_func</span><span class="p">(</span><span class="n">func_a</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">bcx</span><span class="p">.</span><span class="n">func</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Emit a call with a relocation for func_a</span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">(</span><span class="n">local_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// Make sure that this function's body is larger than page_size and will require a new allocation.</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">1024</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">call</span><span class="p">(</span><span class="n">local_func</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">ins</span><span class="p">().</span><span class="n">return_</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[]);</span><span class="w"></span>

<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">seal_all_blocks</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">bcx</span><span class="p">.</span><span class="n">finalize</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">define_function</span><span class="p">(</span><span class="n">func_b</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">clear_context</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Perform linking</span>
<span class="w">    </span><span class="n">m</span><span class="p">.</span><span class="n">finalize_definitions</span><span class="p">();</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p>It might be possible to trigger this from small-ish WebAssembly modules with glibc's mmap threshold that places <a href="https://www.gnu.org/software/libc/manual/html_node/Malloc-Tunable-Parameters.html#index-M_005fMMAP_005fTHRESHOLD">&gt;128kb allocations outside of the heap</a>, though I haven't had any luck reproducing that because glibc's dynamic threshold scaling raises this limit before code is emitted.</p>
<p>Possible approaches:</p>
<ul>
<li>
<p>Determine the total size of the finalized code page before allocating; allocate one large chunk. It seems like an implementation for this should be doable, though I'm not sure if this is by design. (This would be incompatible with features like hot function replacement.)</p>
</li>
<li>
<p>Don't allocate on the heap. Cranelift's <code>selinux-fix</code> features uses mmap allocations. The underlying issue still persists, though as mmap allocations are separate from the heap, they're mostly sequential and would need &gt;2GB of generated machine code to cause problems.</p>
</li>
<li>
<p>(Change relocation style? There's no 64-bit relative jump in x86\_64 and blowing up code size for this seems like a bad idea.)</p>
</li>
</ul>
<p>Aarch64 runs into a related issue with 26-bit relative jumps: <a href="https://github.com/bytecodealliance/wasmtime/issues/3277">https://github.com/bytecodealliance/wasmtime/issues/3277</a><br>
I'm not sure veneers are applicable for x86\_64, but they seems like an interesting and more general approach to relative jump range limits.</p>
</blockquote>



<a name="278026078"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/278026078" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#278026078">(Apr 06 2022 at 13:50)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/4000#issuecomment-1090297821">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<blockquote>
<p>Don't allocate on the heap. Cranelift's selinux-fix features uses mmap allocations. The underlying issue still persists, though as mmap allocations are separate from the heap, they're mostly sequential and would need &gt;2GB of generated machine code to cause problems.</p>
</blockquote>
<p>I think this is the best fix. Possibly in combination with reserving the full 2GB as PROT_NONE. Allowing the GOT to be split between each such 2GB chunk should also allow more code to be used when PIC is enabled.</p>
</blockquote>



<a name="278054784"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/278054784" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#278054784">(Apr 06 2022 at 17:01)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/4000#issuecomment-1090496744">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<p>This is covered I think by the <code>colocated</code> flag on external function definitions: the intent is to denote that a function is in the same module (hence can use near calls) or elsewhere (hence needs an absolute 64-bit relocation). <a href="https://github.com/bytecodealliance/wasmtime/blob/d147802d513db045406c043740a77e0556d1dfdb/cranelift/codegen/src/ir/extfunc.rs#L369-L382">This</a> flag in the <code>ExtFuncData</code> controls which kind of call is generated. It looks like this may not be surfaced in the <code>JITModule</code> API; we'd be happy to take a PR to fix that if so!</p>
</blockquote>



<a name="278060421"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/278060421" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#278060421">(Apr 06 2022 at 17:44)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/4000#issuecomment-1090551603">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<p>That is not the problem here. The problem is that a function and the GOT or PLT it accesses may end up more than 2GB from each other due to memory fragmentation. All calls already go through the GOT and PLT anyway so for as long as those are within 2GB it doesn't matter where the function is, independent of the <code>colocated</code> flag.</p>
</blockquote>



<a name="569287607"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/569287607" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#569287607">(Jan 21 2026 at 15:40)</a>:</h4>
<p>zackw <a href="https://github.com/bytecodealliance/wasmtime/issues/4000#issuecomment-3778961584">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<p>Right now, the machine code emitted for <code>CallKnown</code> on x86 is simply <code>E8 xx xx yy yy</code>, i.e. near call with 32-bit signed displacement.  If you emitted an 8-byte long NOP after each CALL,</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="n">E8</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">            </span><span class="n">call</span><span class="w"> </span><span class="o">&lt;</span><span class="n">placeholder</span><span class="o">&gt;</span>
<span class="w">    </span><span class="mi">0</span><span class="n">f</span><span class="w"> </span><span class="mi">1</span><span class="n">f</span><span class="w"> </span><span class="mi">84</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w"> </span><span class="mi">00</span><span class="w">   </span><span class="n">nop</span><span class="p">.</span><span class="mi">8</span>
</code></pre></div>
<p>the relocation phase would have enough room to patch in a sequence like</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="mi">49</span><span class="w"> </span><span class="n">bb</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="n">xx</span><span class="w"> </span><span class="n">yy</span><span class="w"> </span><span class="n">yy</span><span class="w"> </span><span class="n">zz</span><span class="w"> </span><span class="n">zz</span><span class="w"> </span><span class="n">ww</span><span class="w"> </span><span class="n">ww</span><span class="w">        </span><span class="n">mov</span><span class="w"> </span><span class="n">r11</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="n">xwwwwzzzzzyyyyxxxx</span>
<span class="w">    </span><span class="mi">41</span><span class="w"> </span><span class="n">ff</span><span class="w"> </span><span class="n">d3</span><span class="w">                             </span><span class="n">call</span><span class="w"> </span><span class="n">r11</span>
</code></pre></div>
<p>when the displacement doesn't fit in i32.  This does require a scratch register, but r11 should always be available, since we're making a call and it's a call-clobbered register that isn't an outgoing argument register.</p>
<p>Similar tactics should be applicable for other supported ISAs.</p>
<p>(Bonus points for squishing out the long NOP when the space isn't needed, but that's significantly harder since it changes the address of everything afterward.)</p>
</blockquote>



<a name="573909578"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%234000%20Cranelift%3A%20JIT%20relocations%20depend%20.../near/573909578" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.234000.20Cranelift.3A.20JIT.20relocations.20depend.20.2E.2E.2E.html#573909578">(Feb 14 2026 at 16:22)</a>:</h4>
<p>zackw <a href="https://github.com/bytecodealliance/wasmtime/issues/4000#issuecomment-3902127408">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/4000">issue #4000</a>:</p>
<blockquote>
<p>I don't have time to work up a full test case, but I believe this outline describes a program which will hit the troublesome limit at least 10% of the time:</p>
<ul>
<li>force use of jemalloc</li>
<li>spawn at least 32 additional threads which idle forever</li>
<li>then, _on the main thread_, JIT-compile some code that needs to call back to the main executable</li>
</ul>
<p>jemalloc creates a 64MB address space reservation for each additional thread, but (it appears) does _not_ make the same large reservation for the main thread.  64MB * 32 = 2GB.  So the overall effect is to make it very likely that the memory allocated by the main thread to hold the JIT-compiled code will be more than 2GB away from the main executable and thus a simple CALL instruction cannot reach it.</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>