<html>
<head><meta charset="utf-8"><title>wasmtime / issue #12561 [wasi-sockets] Inconsistency with... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312561.20.5Bwasi-sockets.5D.20Inconsistency.20with.2E.2E.2E.html">wasmtime / issue #12561 [wasi-sockets] Inconsistency with...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="573142132"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312561%20%5Bwasi-sockets%5D%20Inconsistency%20with.../near/573142132" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312561.20.5Bwasi-sockets.5D.20Inconsistency.20with.2E.2E.2E.html#573142132">(Feb 10 2026 at 20:21)</a>:</h4>
<p>saulecabrera opened <a href="https://github.com/bytecodealliance/wasmtime/issues/12561">issue #12561</a>:</p>
<blockquote>
<p>In the following snippet:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">accept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">listen</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">    </span><span class="n">futures</span><span class="p">::</span><span class="n">join</span><span class="o">!</span><span class="p">(</span>
<span class="w">        </span><span class="k">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kd">let</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">accept</span><span class="p">.</span><span class="n">next</span><span class="p">().</span><span class="k">await</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">get_address_family</span><span class="p">(),</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_address_family</span><span class="p">());</span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">get_keep_alive_enabled</span><span class="p">(),</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_keep_alive_enabled</span><span class="p">());</span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span>
<span class="w">                </span><span class="n">next</span><span class="p">.</span><span class="n">get_keep_alive_idle_time</span><span class="p">(),</span>
<span class="w">                </span><span class="n">sock</span><span class="p">.</span><span class="n">get_keep_alive_idle_time</span><span class="p">()</span>
<span class="w">            </span><span class="p">);</span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span>
<span class="w">                </span><span class="n">next</span><span class="p">.</span><span class="n">get_keep_alive_interval</span><span class="p">(),</span>
<span class="w">                </span><span class="n">sock</span><span class="p">.</span><span class="n">get_keep_alive_interval</span><span class="p">()</span>
<span class="w">            </span><span class="p">);</span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">get_keep_alive_count</span><span class="p">(),</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_keep_alive_count</span><span class="p">());</span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">get_hop_limit</span><span class="p">(),</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_hop_limit</span><span class="p">());</span>

<span class="w">            </span><span class="c1">// The following asserts fail.</span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span>
<span class="w">                </span><span class="n">next</span><span class="p">.</span><span class="n">get_receive_buffer_size</span><span class="p">(),</span>
<span class="w">                </span><span class="n">sock</span><span class="p">.</span><span class="n">get_receive_buffer_size</span><span class="p">()</span>
<span class="w">            </span><span class="p">);</span>
<span class="w">            </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="n">get_send_buffer_size</span><span class="p">(),</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_send_buffer_size</span><span class="p">());</span>
<span class="w">        </span><span class="p">},</span>
<span class="w">        </span><span class="k">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">client</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">local_addr</span><span class="p">).</span><span class="k">await</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">);</span>
</code></pre></div>
<p>The values for <code>get_receive_buffer_size()</code> and <code>get_send_buffer_size()</code> are different between the listener and the handler socket. </p>
<p>According to the spec:</p>
<p>The following properties are inherited from the listener socket:</p>
<ul>
<li><code>address-family</code></li>
<li><code>keep-alive-enabled</code></li>
<li><code>keep-alive-idle-time</code></li>
<li><code>keep-alive-interval</code></li>
<li><code>keep-alive-count</code></li>
<li><code>hop-limit</code></li>
<li><code>receive-buffer-size</code></li>
<li><code>send-buffer-size</code></li>
</ul>
<p>Platform specific information:</p>
<ul>
<li><a href="https://github.com/WebAssembly/wasi-testsuite/actions/runs/21880672593/job/63162311357?pr=208#step:10:106">On ubuntu</a>, only the comparison between <code>get_send_buffer_size</code> is failing. </li>
<li><a href="https://github.com/WebAssembly/wasi-testsuite/actions/runs/21880672593/job/63162311407?pr=208#step:10:127">On macOS</a>, both comparisons are failing (<code>get_receive_buffer_size</code> / <code>get_send_buffer_size</code>)</li>
<li>On Windows the test behaves as expected. </li>
</ul>
</blockquote>



<a name="573142134"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312561%20%5Bwasi-sockets%5D%20Inconsistency%20with.../near/573142134" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312561.20.5Bwasi-sockets.5D.20Inconsistency.20with.2E.2E.2E.html#573142134">(Feb 10 2026 at 20:21)</a>:</h4>
<p><a href="https://github.com/saulecabrera">saulecabrera</a> added the bug label to <a href="https://github.com/bytecodealliance/wasmtime/issues/12561">Issue #12561</a>.</p>



<a name="573142136"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312561%20%5Bwasi-sockets%5D%20Inconsistency%20with.../near/573142136" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312561.20.5Bwasi-sockets.5D.20Inconsistency.20with.2E.2E.2E.html#573142136">(Feb 10 2026 at 20:21)</a>:</h4>
<p><a href="https://github.com/saulecabrera">saulecabrera</a> added the wasi label to <a href="https://github.com/bytecodealliance/wasmtime/issues/12561">Issue #12561</a>.</p>



<a name="573146043"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312561%20%5Bwasi-sockets%5D%20Inconsistency%20with.../near/573146043" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312561.20.5Bwasi-sockets.5D.20Inconsistency.20with.2E.2E.2E.html#573146043">(Feb 10 2026 at 20:43)</a>:</h4>
<p>saulecabrera <a href="https://github.com/bytecodealliance/wasmtime/issues/12561#issuecomment-3880609418">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12561">issue #12561</a>:</p>
<blockquote>
<p>The inconsistency only seems to be happening when the values are not explicitly set by calling the respective setters i.e., if explicitly set, it works as expected, according to this test <a href="https://github.com/bytecodealliance/wasmtime/blob/main/crates/test-programs/src/bin/p3_sockets_tcp_sockopts.rs#L113">https://github.com/bytecodealliance/wasmtime/blob/main/crates/test-programs/src/bin/p3_sockets_tcp_sockopts.rs#L113</a></p>
</blockquote>



<a name="573162603"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312561%20%5Bwasi-sockets%5D%20Inconsistency%20with.../near/573162603" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312561.20.5Bwasi-sockets.5D.20Inconsistency.20with.2E.2E.2E.html#573162603">(Feb 10 2026 at 22:30)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/12561#issuecomment-3881084942">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12561">issue #12561</a>:</p>
<blockquote>
<p>cc @badeend </p>
</blockquote>



<a name="573375526"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312561%20%5Bwasi-sockets%5D%20Inconsistency%20with.../near/573375526" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312561.20.5Bwasi-sockets.5D.20Inconsistency.20with.2E.2E.2E.html#573375526">(Feb 11 2026 at 19:57)</a>:</h4>
<p>badeend <a href="https://github.com/bytecodealliance/wasmtime/issues/12561#issuecomment-3886752006">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12561">issue #12561</a>:</p>
<blockquote>
<p>Heh, nice find ;) </p>
<p>Let me find out why this is happening</p>
</blockquote>



<a name="573976448"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312561%20%5Bwasi-sockets%5D%20Inconsistency%20with.../near/573976448" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312561.20.5Bwasi-sockets.5D.20Inconsistency.20with.2E.2E.2E.html#573976448">(Feb 15 2026 at 13:25)</a>:</h4>
<p>badeend <a href="https://github.com/bytecodealliance/wasmtime/issues/12561#issuecomment-3904444558">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12561">issue #12561</a>:</p>
<blockquote>
<p>I looked at the <code>SO_RCVBUF</code> &amp; <code>SO_SNDBUF</code> implementations of Linux &amp; MacOS.</p>
<p>By default, both platforms use a dynamic buffer capacity feature, which is disabled when the user explicitly sets <code>SO_RCVBUF</code> or <code>SO_SNDBUF</code>. On Linux the relevant search terms are <a href="https://github.com/torvalds/linux/blob/ca4ee40bf13dbd3a4be3b40a00c33a1153d487e5/include/uapi/linux/socket.h#L29-L30"><code>SOCK_SNDBUF_LOCK</code> &amp; <code>SOCK_RCVBUF_LOCK</code></a>. On MacOS this is controlled by <a href="https://github.com/apple-oss-distributions/xnu/blob/f6217f891ac0bb64f3d375211650a4c1ff8ca1ea/bsd/sys/socketvar.h#L207"><code>SB_AUTOSIZE</code></a>.</p>
<p>That explains the behavior observed in this issue.</p>
<p>Also relevant:</p>
<ul>
<li>On MacOS, the socket options reflect the _current_ capacity of the buffer. If not explicitly set, <code>getsockopt</code> may return different values over the lifetime of the connection as the buffer fills &amp; drains.</li>
<li>On Linux, the socket options reflect the _maximum_ buffer capacity. If not explicitly set, Linux <a href="https://github.com/torvalds/linux/blob/ca4ee40bf13dbd3a4be3b40a00c33a1153d487e5/net/ipv4/tcp_input.c#L600-L635">computes</a> a maximum based on connection statistics. This currently occurs only once when the connection is established. This causes the one-time jump in the value returned by getsockopt, which afterwards remains stable.</li>
</ul>
<p>Importantly, this behavior is not specific to listener sockets or inheritance. The same effect occurs on client sockets. Example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">recv_before</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_receive_buffer_size</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="n">send_before</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_send_buffer_size</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="n">sock</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">addr</span><span class="p">).</span><span class="k">await</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="n">recv_after</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_receive_buffer_size</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="n">send_after</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_send_buffer_size</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="fm">println!</span><span class="p">(</span><span class="s">"Recv {recv_before} -&gt; {recv_after}"</span><span class="p">);</span>
<span class="fm">println!</span><span class="p">(</span><span class="s">"Send {send_before} -&gt; {send_after}"</span><span class="p">);</span>
</code></pre></div>
<p>Prints:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">Recv</span><span class="w"> </span><span class="mi">65536</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="mi">65536</span>
<span class="nb">Send</span><span class="w"> </span><span class="mi">8192</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="mi">43520</span>
</code></pre></div>
<hr>
<p>With this in mind, the underlying issue seems less about inheritance and more about the fact that <code>getsockopt(SO_RCVBUF or SO_SNDBUF)</code> returns meaningless values until either:</p>
<ul>
<li>the option has been explicitly set, or</li>
<li>a connection has been established.</li>
</ul>
<p>It's unclear to me how WASI should handle this situation. Automatically calling <code>setsockopt</code> on every accepted socket just to satisfy a single test seems undesirable, as it would add runtime overhead and disable the kernel's dynamic buffer sizing.</p>
<ul>
<li>One option is to leave the behavior as-is and simply document these platform-specific quirks.</li>
<li>Another possibility is to have <code>get_send/receive_buffer_size</code> return an error or 0 until the buffer size has been explicitly set or the socket has been connected. From my current understanding, there is rarely a meaningful use case for reading these values beforehand anyways. But I can't predict how many existing applications might break because of that.</li>
</ul>
<p>In summary, I understand the problem now but I don't know the best way forward yet.</p>
</blockquote>



<a name="573979704"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312561%20%5Bwasi-sockets%5D%20Inconsistency%20with.../near/573979704" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312561.20.5Bwasi-sockets.5D.20Inconsistency.20with.2E.2E.2E.html#573979704">(Feb 15 2026 at 14:16)</a>:</h4>
<p>badeend edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/12561#issuecomment-3904444558">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12561">issue #12561</a>:</p>
<blockquote>
<p>I looked at the <code>SO_RCVBUF</code> &amp; <code>SO_SNDBUF</code> implementations of Linux &amp; MacOS.</p>
<p>By default, both platforms use a dynamic buffer capacity feature, which is disabled when the user explicitly sets <code>SO_RCVBUF</code> or <code>SO_SNDBUF</code>. On Linux the relevant search terms are <a href="https://github.com/torvalds/linux/blob/ca4ee40bf13dbd3a4be3b40a00c33a1153d487e5/include/uapi/linux/socket.h#L29-L30"><code>SOCK_SNDBUF_LOCK</code> &amp; <code>SOCK_RCVBUF_LOCK</code></a>. On MacOS this is controlled by <a href="https://github.com/apple-oss-distributions/xnu/blob/f6217f891ac0bb64f3d375211650a4c1ff8ca1ea/bsd/sys/socketvar.h#L207"><code>SB_AUTOSIZE</code></a>.</p>
<p>That explains the behavior observed in this issue.</p>
<p>Also relevant:</p>
<ul>
<li>On MacOS, the socket options reflect the _current_ capacity of the buffer. If not explicitly set, <code>getsockopt</code> may return different values over the lifetime of the connection as the buffer fills &amp; drains.</li>
<li>On Linux, the socket options reflect the _maximum_ buffer capacity. If not explicitly set, Linux <a href="https://github.com/torvalds/linux/blob/ca4ee40bf13dbd3a4be3b40a00c33a1153d487e5/net/ipv4/tcp_input.c#L600-L635">computes</a> a maximum based on connection statistics. This currently occurs only once when the connection is established. This causes the one-time jump in the value returned by getsockopt, which afterwards remains stable.</li>
</ul>
<p>Importantly, this behavior is not specific to listener sockets or inheritance. The same effect occurs on client sockets. Example:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">recv_before</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_receive_buffer_size</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="n">send_before</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_send_buffer_size</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="n">sock</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">addr</span><span class="p">).</span><span class="k">await</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>

<span class="kd">let</span><span class="w"> </span><span class="n">recv_after</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_receive_buffer_size</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>
<span class="kd">let</span><span class="w"> </span><span class="n">send_after</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sock</span><span class="p">.</span><span class="n">get_send_buffer_size</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span>

<span class="fm">println!</span><span class="p">(</span><span class="s">"Recv {recv_before} -&gt; {recv_after}"</span><span class="p">);</span>
<span class="fm">println!</span><span class="p">(</span><span class="s">"Send {send_before} -&gt; {send_after}"</span><span class="p">);</span>
</code></pre></div>
<p>Prints:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">Recv</span><span class="w"> </span><span class="mi">65536</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="mi">65536</span>
<span class="nb">Send</span><span class="w"> </span><span class="mi">8192</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="mi">43520</span>
</code></pre></div>
<hr>
<p>With this in mind, the underlying issue seems less about inheritance and more about the fact that <code>getsockopt(SO_RCVBUF or SO_SNDBUF)</code> returns meaningless values until either:</p>
<ul>
<li>the option has been explicitly set, or</li>
<li>a connection has been established.</li>
</ul>
<p>It's unclear to me how WASI should handle this situation. Automatically calling <code>setsockopt</code> on every accepted socket just to satisfy a single test seems undesirable, as it would add runtime overhead and disable the kernel's dynamic buffer sizing.</p>
<ul>
<li>One option is to leave the behavior as-is and simply document these platform-specific quirks.</li>
<li>Another possibility is to have <code>get_send/receive_buffer_size</code> return an error until the buffer size has been explicitly set or the socket has been connected. From my current understanding, there is rarely a meaningful use case for reading these values beforehand anyways. But I can't predict how many existing applications might break because of that.<ul>
<li><strong>Edit:</strong> instead of returning an error, maybe returning 0 may not be so bad. Which can be interpreted as: the socket starts out with an empty buffer.</li>
</ul>
</li>
</ul>
<p>In summary, I understand the problem now but I don't know the best way forward yet.</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>