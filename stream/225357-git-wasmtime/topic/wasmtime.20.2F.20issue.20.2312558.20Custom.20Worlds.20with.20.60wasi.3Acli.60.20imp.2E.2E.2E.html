<html>
<head><meta charset="utf-8"><title>wasmtime / issue #12558 Custom Worlds with `wasi:cli` imp... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312558.20Custom.20Worlds.20with.20.60wasi.3Acli.60.20imp.2E.2E.2E.html">wasmtime / issue #12558 Custom Worlds with `wasi:cli` imp...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="573121096"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312558%20Custom%20Worlds%20with%20%60wasi%3Acli%60%20imp.../near/573121096" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312558.20Custom.20Worlds.20with.20.60wasi.3Acli.60.20imp.2E.2E.2E.html#573121096">(Feb 10 2026 at 18:39)</a>:</h4>
<p>luoluoyuyu opened <a href="https://github.com/bytecodealliance/wasmtime/issues/12558">issue #12558</a>:</p>
<blockquote>
<h2>Description</h2>
<p>I am building a plugin system where the Guest components are compiled using <strong>TinyGo</strong>. Since TinyGo's runtime initialization relies heavily on WASI P2, my custom world <strong>must</strong> include <code>include wasi:cli/imports@0.2.0;</code>. Otherwise, the TinyGo component fails to initialize.</p>
<p>However, the current developer experience for this specific (and very common) use case is quite painful. Even with the <code>with</code> mapping in the <code>bindgen!</code> macro and implementing <code>WasiView</code> for my <code>HostState</code>, I am still forced to manually implement all the generated traits for <code>wasi:*</code> interfaces just to "delegate" them back to the <code>wasmtime-wasi</code> implementation.</p>
<h2>The Problem</h2>
<p>If I have a minimalist WIT like this:</p>
<div class="codehilite" data-code-language="wit"><pre><span></span><code>package test:pkg@0.1.0;

interface data {
    resource store {
        constructor(name: string);
    }
}

world processor {
    // Required for TinyGo support
    include wasi:cli/imports@0.2.0;

    import data;
    export process: func(data: list&lt;u8&gt;) -&gt; result&lt;_, string&gt;;
}
</code></pre></div>
<p>Even though <code>wasmtime-wasi</code> already provides a complete implementation for every WASI interface included above, I find myself writing dozens of lines of repetitive boilerplate just to bridge the gap in Rust:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// This feels like unnecessary boilerplate</span>
<span class="k">impl</span><span class="w"> </span><span class="n">test</span><span class="p">::</span><span class="n">pkg</span><span class="p">::</span><span class="n">processor</span><span class="p">::</span><span class="n">wasi</span><span class="p">::</span><span class="n">cli</span><span class="p">::</span><span class="n">stdout</span><span class="p">::</span><span class="n">Host</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyHost</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">get_stdout</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&lt;</span><span class="n">OutputStream</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// I have to manually call the provided implementation</span>
<span class="w">        </span><span class="n">wasmtime_wasi</span><span class="p">::</span><span class="n">bindings</span><span class="p">::</span><span class="n">cli</span><span class="p">::</span><span class="n">stdout</span><span class="p">::</span><span class="n">Host</span><span class="p">::</span><span class="n">get_stdout</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ... and so on for every other WASI interface TinyGo needs (clocks, streams, etc.)</span>
</code></pre></div>
<p>Is there a more "automated" way to handle this? That is, when the Host has already provided WasiCtx and ResourceTable, bindgen! or Linker should be able to automatically identify and fulfill the requirements of these standard WASI imports without the developer having to write a large amount of repetitive boilerplate code.</p>
</blockquote>



<a name="573121263"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312558%20Custom%20Worlds%20with%20%60wasi%3Acli%60%20imp.../near/573121263" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312558.20Custom.20Worlds.20with.20.60wasi.3Acli.60.20imp.2E.2E.2E.html#573121263">(Feb 10 2026 at 18:40)</a>:</h4>
<p>luoluoyuyu edited <a href="https://github.com/bytecodealliance/wasmtime/issues/12558">issue #12558</a>:</p>
<blockquote>
<h2>Description</h2>
<p>I am building a plugin system where the Guest components are compiled using <strong>TinyGo</strong>. Since TinyGo's runtime initialization relies heavily on WASI P2, my custom world <strong>must</strong> include <code>include wasi:cli/imports@0.2.0;</code>. Otherwise, the TinyGo component fails to initialize.</p>
<p>However, the current developer experience for this specific (and very common) use case is quite painful. Even with the <code>with</code> mapping in the <code>bindgen!</code> macro and implementing <code>WasiView</code> for my <code>HostState</code>, I am still forced to manually implement all the generated traits for <code>wasi:*</code> interfaces just to "delegate" them back to the <code>wasmtime-wasi</code> implementation.</p>
<h2>The Problem</h2>
<p>If I have a WIT like this:</p>
<div class="codehilite" data-code-language="wit"><pre><span></span><code>package test:pkg@0.1.0;

interface data {
    resource store {
        constructor(name: string);
    }
}

world processor {
    // Required for TinyGo support
    include wasi:cli/imports@0.2.0;

    import data;
    export process: func(data: list&lt;u8&gt;) -&gt; result&lt;_, string&gt;;
}
</code></pre></div>
<p>Even though <code>wasmtime-wasi</code> already provides a complete implementation for every WASI interface included above, I find myself writing dozens of lines of repetitive boilerplate just to bridge the gap in Rust:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// This feels like unnecessary boilerplate</span>
<span class="k">impl</span><span class="w"> </span><span class="n">test</span><span class="p">::</span><span class="n">pkg</span><span class="p">::</span><span class="n">processor</span><span class="p">::</span><span class="n">wasi</span><span class="p">::</span><span class="n">cli</span><span class="p">::</span><span class="n">stdout</span><span class="p">::</span><span class="n">Host</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyHost</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">get_stdout</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&lt;</span><span class="n">OutputStream</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// I have to manually call the provided implementation</span>
<span class="w">        </span><span class="n">wasmtime_wasi</span><span class="p">::</span><span class="n">bindings</span><span class="p">::</span><span class="n">cli</span><span class="p">::</span><span class="n">stdout</span><span class="p">::</span><span class="n">Host</span><span class="p">::</span><span class="n">get_stdout</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ... and so on for every other WASI interface TinyGo needs (clocks, streams, etc.)</span>
</code></pre></div>
<p>Is there a more "automated" way to handle this? That is, when the Host has already provided WasiCtx and ResourceTable, bindgen! or Linker should be able to automatically identify and fulfill the requirements of these standard WASI imports without the developer having to write a large amount of repetitive boilerplate code.</p>
</blockquote>



<a name="573151690"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312558%20Custom%20Worlds%20with%20%60wasi%3Acli%60%20imp.../near/573151690" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312558.20Custom.20Worlds.20with.20.60wasi.3Acli.60.20imp.2E.2E.2E.html#573151690">(Feb 10 2026 at 21:16)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/12558#issuecomment-3880760496">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12558">issue #12558</a>:</p>
<blockquote>
<p>What I'd recommend here is to have a <code>world</code> that focuses on just your embedding, for example the <code>data</code> interface import and the <code>process</code> export. Wasmtime bindings would be generated using that <code>world</code>, and then there'd be a second world which <code>include</code>s this world and also has the WASI imports. This second world would be used for guest bindings generation, for example.</p>
<p>This is also something we could improve in Wasmtime by souping up the <code>with</code> option, but that can get a bit gnarly sometimes. Would the <code>world</code> split work for your use case?</p>
</blockquote>



<a name="573324280"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312558%20Custom%20Worlds%20with%20%60wasi%3Acli%60%20imp.../near/573324280" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312558.20Custom.20Worlds.20with.20.60wasi.3Acli.60.20imp.2E.2E.2E.html#573324280">(Feb 11 2026 at 15:55)</a>:</h4>
<p>luoluoyuyu <a href="https://github.com/bytecodealliance/wasmtime/issues/12558#issuecomment-3885350298">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12558">issue #12558</a>:</p>
<blockquote>
<blockquote>
<p>What I'd recommend here is to have a <code>world</code> that focuses on just your embedding, for example the <code>data</code> interface import and the <code>process</code> export. Wasmtime bindings would be generated using that <code>world</code>, and then there'd be a second world which <code>include</code>s this world and also has the WASI imports. This second world would be used for guest bindings generation, for example.</p>
<p>This is also something we could improve in Wasmtime by souping up the <code>with</code> option, but that can get a bit gnarly sometimes. Would the <code>world</code> split work for your use case?</p>
</blockquote>
<p>Thank you for your answer, this solution can solve my problem very well.</p>
</blockquote>



<a name="573324287"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312558%20Custom%20Worlds%20with%20%60wasi%3Acli%60%20imp.../near/573324287" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312558.20Custom.20Worlds.20with.20.60wasi.3Acli.60.20imp.2E.2E.2E.html#573324287">(Feb 11 2026 at 15:55)</a>:</h4>
<p>luoluoyuyu closed <a href="https://github.com/bytecodealliance/wasmtime/issues/12558">issue #12558</a>:</p>
<blockquote>
<h2>Description</h2>
<p>I am building a plugin system where the Guest components are compiled using <strong>TinyGo</strong>. Since TinyGo's runtime initialization relies heavily on WASI P2, my custom world <strong>must</strong> include <code>include wasi:cli/imports@0.2.0;</code>. Otherwise, the TinyGo component fails to initialize.</p>
<p>However, the current developer experience for this specific (and very common) use case is quite painful. Even with the <code>with</code> mapping in the <code>bindgen!</code> macro and implementing <code>WasiView</code> for my <code>HostState</code>, I am still forced to manually implement all the generated traits for <code>wasi:*</code> interfaces just to "delegate" them back to the <code>wasmtime-wasi</code> implementation.</p>
<h2>The Problem</h2>
<p>If I have a WIT like this:</p>
<div class="codehilite" data-code-language="wit"><pre><span></span><code>package test:pkg@0.1.0;

interface data {
    resource store {
        constructor(name: string);
    }
}

world processor {
    // Required for TinyGo support
    include wasi:cli/imports@0.2.0;

    import data;
    export process: func(data: list&lt;u8&gt;) -&gt; result&lt;_, string&gt;;
}
</code></pre></div>
<p>Even though <code>wasmtime-wasi</code> already provides a complete implementation for every WASI interface included above, I find myself writing dozens of lines of repetitive boilerplate just to bridge the gap in Rust:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// This feels like unnecessary boilerplate</span>
<span class="k">impl</span><span class="w"> </span><span class="n">test</span><span class="p">::</span><span class="n">pkg</span><span class="p">::</span><span class="n">processor</span><span class="p">::</span><span class="n">wasi</span><span class="p">::</span><span class="n">cli</span><span class="p">::</span><span class="n">stdout</span><span class="p">::</span><span class="n">Host</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">MyHost</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">get_stdout</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">anyhow</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&lt;</span><span class="n">OutputStream</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// I have to manually call the provided implementation</span>
<span class="w">        </span><span class="n">wasmtime_wasi</span><span class="p">::</span><span class="n">bindings</span><span class="p">::</span><span class="n">cli</span><span class="p">::</span><span class="n">stdout</span><span class="p">::</span><span class="n">Host</span><span class="p">::</span><span class="n">get_stdout</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ... and so on for every other WASI interface TinyGo needs (clocks, streams, etc.)</span>
</code></pre></div>
<p>Is there a more "automated" way to handle this? That is, when the Host has already provided WasiCtx and ResourceTable, bindgen! or Linker should be able to automatically identify and fulfill the requirements of these standard WASI imports without the developer having to write a large amount of repetitive boilerplate code.</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>