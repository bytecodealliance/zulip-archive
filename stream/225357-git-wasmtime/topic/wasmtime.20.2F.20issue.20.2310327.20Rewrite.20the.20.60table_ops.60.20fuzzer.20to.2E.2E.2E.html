<html>
<head><meta charset="utf-8"><title>wasmtime / issue #10327 Rewrite the `table_ops` fuzzer to... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2310327.20Rewrite.20the.20.60table_ops.60.20fuzzer.20to.2E.2E.2E.html">wasmtime / issue #10327 Rewrite the `table_ops` fuzzer to...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="503383951"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2310327%20Rewrite%20the%20%60table_ops%60%20fuzzer%20to.../near/503383951" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2310327.20Rewrite.20the.20.60table_ops.60.20fuzzer.20to.2E.2E.2E.html#503383951">(Mar 04 2025 at 23:19)</a>:</h4>
<p>fitzgen edited <a href="https://github.com/bytecodealliance/wasmtime/issues/10327">issue #10327</a>.</p>



<a name="503383967"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2310327%20Rewrite%20the%20%60table_ops%60%20fuzzer%20to.../near/503383967" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2310327.20Rewrite.20the.20.60table_ops.60.20fuzzer.20to.2E.2E.2E.html#503383967">(Mar 04 2025 at 23:19)</a>:</h4>
<p><a href="https://github.com/fitzgen">fitzgen</a> added the fuzzing label to <a href="https://github.com/bytecodealliance/wasmtime/issues/10327">Issue #10327</a>.</p>



<a name="503383968"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2310327%20Rewrite%20the%20%60table_ops%60%20fuzzer%20to.../near/503383968" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2310327.20Rewrite.20the.20.60table_ops.60.20fuzzer.20to.2E.2E.2E.html#503383968">(Mar 04 2025 at 23:19)</a>:</h4>
<p><a href="https://github.com/fitzgen">fitzgen</a> added the wasm-proposal:gc label to <a href="https://github.com/bytecodealliance/wasmtime/issues/10327">Issue #10327</a>.</p>



<a name="503384024"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2310327%20Rewrite%20the%20%60table_ops%60%20fuzzer%20to.../near/503384024" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2310327.20Rewrite.20the.20.60table_ops.60.20fuzzer.20to.2E.2E.2E.html#503384024">(Mar 04 2025 at 23:19)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/issues/10327#issuecomment-2699219871">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/10327">issue #10327</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @fitzgen</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "fuzzing"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>fitzgen: fuzzing</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="535550231"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2310327%20Rewrite%20the%20%60table_ops%60%20fuzzer%20to.../near/535550231" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2310327.20Rewrite.20the.20.60table_ops.60.20fuzzer.20to.2E.2E.2E.html#535550231">(Aug 21 2025 at 17:38)</a>:</h4>
<p>fitzgen edited <a href="https://github.com/bytecodealliance/wasmtime/issues/10327">issue #10327</a>:</p>
<blockquote>
<h1>GC Fuzzing</h1>
<p>This is a sketch of a series of milestones, roughly estimated to be about one PR each, for GC fuzzing. We don't need to do exactly these milestones in exactly this order. It is okay if, in the process of implementing them, we find reason to do milestone X before Y and decide to swap their order. It is okay if one milestone becomes three PRs, or two milestones become one PR. This is just a sketch to provide some light structure. Also, these milestones represent a lot of work, and while the goal is certainly to get everything here finished during your internship, if it turns out that this is more work that can be completed in that amount of time, that is okay.</p>
<p>Milestones:</p>
<ul>
<li>
<p>[X] Port the <code>table_ops</code> fuzzer from <code>arbitrary</code> to <code>mutatis</code><br>
  &lt;details&gt;</p>
<ul>
<li>Replacing <code>arbitrary</code>-based generator with a <code>mutatis</code>-based fuzzer</li>
<li>Oracle should be able to (largely) remain unmodified</li>
<li>Avoid adding new features or changing existing functionality as much as possible</li>
<li>Start handling the scenario where:<ul>
<li>We originally have a valid series of fuzzer ops A,</li>
<li>then a random mutation inserts, removes, or changes an op in A to produce fuzzer ops A',</li>
<li>but A' is now no longer a valid sequence of fuzzer ops (for example, an initial op whose result was the input for a subsequent op was removed, for example).</li>
<li>Now we have to figure out how to handle invalid test cases:<ul>
<li>Do we throw it away and continue to the next one?</li>
<li>Do we "patch up" the test case in a post-processing pass that fixes it up such that it becomes valid?</li>
<li>I'm thinking we probably want to do a fix-up pass to avoid wasting cycles on test cases we won't execute, ultimately hurting our overall fuzzing throughput, but I'm not 100% sure that is the right choice, and I am all ears for counter arguments and alternative ideas.</li>
<li>As far as <code>mutatis</code>-related prior art goes, the allocator fuzzer handled this stuff in the oracle: it simply avoided performing the fuzzer's allocation operations when they did not make sense (i.e. it ignores the "deallocate pointer with id X" operation if there isn't currently a live allocation with id X): <a href="https://github.com/fitzgen/deallocate-zeroed/blob/52c2b9b7305dd1a947b3342128fcf0d03143223e/crates/fuzzing/src/lib.rs#L656">https://github.com/fitzgen/deallocate-zeroed/blob/52c2b9b7305dd1a947b3342128fcf0d03143223e/crates/fuzzing/src/lib.rs#L656</a></li>
<li>We want to always generate valid Wasm, otherwise we can't even execute the subset of ops that are valid, so I think we will need to do the equivalent filtering/fixing up in the generator rather than in the oracle.</li>
<li>This fix-up pass could be its own pass, mutating the fuzzer ops AST structure directly, before we generate a Wasm binary from that AST structure. Or, alternatively, it could be integrated into Wasm-binary-from-AST generation step.</li>
</ul>
</li>
</ul>
</li>
<li>Goal: Become familiar with <code>mutatis</code> and move the fuzzer towards our north star vision for it<br>
&lt;/details&gt;</li>
</ul>
</li>
<li>
<p>[ ] Add support for empty <code>(rec ...)</code> groups containing zero or more empty <code>struct</code> types.<br>
  &lt;details&gt;</p>
<ul>
<li>Add generation support for these <code>(rec ...)</code> groups with zero or more empty <code>struct</code> types</li>
<li>Add a fuzzer op that allocates a random one of our <code>struct</code> types. We should avoid emitting this op when we have not defined any <code>struct</code> types.</li>
<li>Add a function import that takes a <code>structref</code> argument to our Wasm binary skeleton</li>
<li>Add a fuzzer op that calls that new function</li>
<li>Add a function import for each defined <code>struct</code> type that takes a reference of that type of struct specifically</li>
<li>Add a fuzzer op that calls these new typed functions</li>
<li>Add support for generating locals, globals, and tables that contain <code>structref</code>s and concretely typed <code>struct</code> references</li>
<li>Add new or extend existing fuzzer ops for accessing locals/globals/tables of <code>structref</code>s and concretely typed <code>struct</code> references</li>
<li>Define a mutation that adds an empty <code>struct</code> type to an existing <code>(rec ...)</code> group</li>
<li>Define a mutation that removes a <code>struct</code> type from an existing <code>(rec ...)</code>  group</li>
<li>Define a mutation that moves a <code>struct</code> type within an existing <code>(rec ...)</code>  group</li>
<li>Define a mutation that moves a <code>struct</code> type from an existing <code>(rec ...)</code>  group to another</li>
<li>Define a mutation that duplicates a <code>(rec ...)</code> group</li>
<li>Define a mutation that removes a whole <code>(rec ...)</code> group</li>
<li>Define a mutation that merges two <code>(rec ...)</code> groups</li>
<li>Define a mutation that splits a <code>(rec ...)</code> group in two, if possible</li>
<li>Will need to migrate the abstract representation of the value stack from a couner of how many <code>externref</code>s are on the stack to an actual stack of types</li>
<li>Note: there is a whole lot here, even just exercising empty <code>struct</code> definitions, so it may make sense to split this up into a few PRs</li>
<li>Goal: start exercising type canonicalization, lay down initial infrastructure for <code>(rec ...)</code> groups and <code>struct</code> types.<br>
&lt;/details&gt;</li>
</ul>
</li>
<li>
<p>[ ] Add support for exercising subtyping relationships<br>
  &lt;details&gt;</p>
<ul>
<li>Add support for on <code>struct</code> type to be a subtype of another <code>struct</code> type</li>
<li>Subtypes must be defined after their supertypes, so this will require we do some validation/filtering/fixups in the face of mutations that reorder types. (This restriction prevents cyclic subtyping where A subtypes B and B subtypes A.)</li>
<li>Want to think hard about how we represent types, rec groups, and type references in the AST at this point and how we are architecting the program. These choices are going to have a big impact on everything we do from here on out.<ul>
<li>Do we just have a list of rec groups that directly reflect the order we will put them into the Wasm binary?</li>
<li>Do we create arbitrary type graphs and then do a topological sort on them to ensure they are valid? If we do this approach, what happens in the future when we find a cycle that is not within the same rec group? Or do we not even have rec groups here, just types, and then generate rec groups as part of the projection out from the graph?</li>
<li>Do we reference types by id and ignore references when there is not type associated with that id?</li>
<li>Or do we simply reference types by their type index, as in Wasm? And then ignore invalid references?</li>
</ul>
</li>
<li>Goal: Continue to fill out type system features that we exercise, figure out the architecture we want for dealing with references between types.<br>
&lt;/details&gt;</li>
</ul>
</li>
<li>
<p>[ ] Add support for casting and testing references<br>
  &lt;details&gt;</p>
<ul>
<li>Add a fuzzer op for casts that should always succeed (from a subtype to a supertype). This should become a <code>ref.cast</code> instruction in the Wasm binary.</li>
<li>
<p>Add a fuzzer op for fallible downcasts. This should not trap and kill the whole program if the downcast fails. In the fullness of time, we will want to generate blocks that do things with the downcasted value that are only executed if the downcast succeeds, something like this:</p>
<p>```<br>
block (param ...)<br>
  ;; Break out of this block if we fail to cast the reference on top of the<br>
  ;; stack to its subtype.<br>
  ref.br_on_cast_fail ...</p>
<p>;; Do stuff with the subtype reference...<br>
end</p>
<p>;; Control joins again here and the program continues.<br>
```</p>
<p>And we will want to exercise both the <code>br_on_cast_fail</code> and <code>br_on_cast</code> instructions, which will require slightly different shapes of blocks.</p>
<p>Initially, we can simply downcast to a nullable subtype reference, where we get null if the downcast fails:</p>
<p><code>
block (param (ref null $my_super)) (result (ref null $my_sub))
  local.tee $my_temp
  ;; Test if the downcast will succeed.
  ref.test ...
  if (result (ref null $my_sub))
    ;; The downcast will succeed, do a downcast-or-trap operation which we
    ;; know will not trap.
    local.get $my_temp
    ref.cast ...
  else
    ;; The downcast would fail, so just create a null reference instead.
    ref.null ...
  end
end
</code></p>
</li>
<li>
<p>Goal: Exercise subtyping checks and casting logic.<br>
&lt;/details&gt;</p>
</li>
</ul>
</li>
<li>
<p>[ ] Add support for POD and <code>externref</code> fields in <code>struct</code>s<br>
  &lt;details&gt;</p>
<ul>
<li>Add generation and mutation support for <code>i8</code>/<code>i16</code>/<code>i32</code>/<code>i64</code>/<code>f32</code>/<code>f64</code>/<code>v128</code>/<code>externref</code> struct fields. Reference fields will be trickier and can be added in another milestone.</li>
<li>Add fuzzer ops for <code>struct.get</code> and <code>struct.set</code></li>
<li>Maybe: Add fuzzer ops for creating POD constants? Or should we just create zero constants on demand when necessary in the AST-to-Wasm-binary generation step? We aren't trying to exercise arithmetic in this fuzzer, that is well exercised by other fuzzers already, so the only interesting case for POD data is really when it comes from another <code>struct</code>'s field. Other than that interesting case, we just need a <em>some</em> value in order to allocate a struct containing these values.</li>
<li>Add mutators to add, remove, and modify a field in a defined <code>struct</code> type</li>
<li>Goal: start exercising accessing, reading from, and writing to GC objects<br>
&lt;/details&gt;</li>
</ul>
</li>
<li>
<p>[ ] Add support for concretely-typed references as <code>struct</code> fields<br>
  &lt;details&gt;</p>
<ul>
<li>Extend the items from the previous milestone to full type references between different defined <code>struct</code> types</li>
<li>Also add support for abstract <code>structref</code> types</li>
<li>Non-nullable type references will be tricky: if we have a cycle of non-nullable references, then those types are not currently inhabitable.<ul>
<li>Can detect and correct this in our fix-up pass, perhaps</li>
<li>Okay to punt on this in a first PR, but we definitely would want to start handling them in a closely following PR. This is an important corner of the spec, and we perform optimizations based on non-nullability in the compiler, and one that none of our other fuzzers are exercising this right now (wasm-smith does not support non-nullable references yet).</li>
</ul>
</li>
<li>This phase is when we will really start seeing the impact of our architecture choices around how to represent types and references between them in the AST.</li>
<li>Goal: start exercising references bet<br>
[message truncated]</li>
</ul>
</li>
</ul>
</blockquote>



<a name="535551992"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2310327%20Rewrite%20the%20%60table_ops%60%20fuzzer%20to.../near/535551992" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2310327.20Rewrite.20the.20.60table_ops.60.20fuzzer.20to.2E.2E.2E.html#535551992">(Aug 21 2025 at 17:50)</a>:</h4>
<p>fitzgen edited <a href="https://github.com/bytecodealliance/wasmtime/issues/10327">issue #10327</a>:</p>
<blockquote>
<h1>GC Fuzzing</h1>
<p>This is a sketch of a series of milestones, roughly estimated to be about one PR each, for GC fuzzing. We don't need to do exactly these milestones in exactly this order. It is okay if, in the process of implementing them, we find reason to do milestone X before Y and decide to swap their order. It is okay if one milestone becomes three PRs, or two milestones become one PR. This is just a sketch to provide some light structure. Also, these milestones represent a lot of work, and while the goal is certainly to get everything here finished during your internship, if it turns out that this is more work that can be completed in that amount of time, that is okay.</p>
<h3>Incremental Milestones</h3>
<ul>
<li>
<p>[X] Port the <code>table_ops</code> fuzzer from <code>arbitrary</code> to <code>mutatis</code><br>
  &lt;details&gt;</p>
<ul>
<li>Replacing <code>arbitrary</code>-based generator with a <code>mutatis</code>-based fuzzer</li>
<li>Oracle should be able to (largely) remain unmodified</li>
<li>Avoid adding new features or changing existing functionality as much as possible</li>
<li>Start handling the scenario where:<ul>
<li>We originally have a valid series of fuzzer ops A,</li>
<li>then a random mutation inserts, removes, or changes an op in A to produce fuzzer ops A',</li>
<li>but A' is now no longer a valid sequence of fuzzer ops (for example, an initial op whose result was the input for a subsequent op was removed, for example).</li>
<li>Now we have to figure out how to handle invalid test cases:<ul>
<li>Do we throw it away and continue to the next one?</li>
<li>Do we "patch up" the test case in a post-processing pass that fixes it up such that it becomes valid?</li>
<li>I'm thinking we probably want to do a fix-up pass to avoid wasting cycles on test cases we won't execute, ultimately hurting our overall fuzzing throughput, but I'm not 100% sure that is the right choice, and I am all ears for counter arguments and alternative ideas.</li>
<li>As far as <code>mutatis</code>-related prior art goes, the allocator fuzzer handled this stuff in the oracle: it simply avoided performing the fuzzer's allocation operations when they did not make sense (i.e. it ignores the "deallocate pointer with id X" operation if there isn't currently a live allocation with id X): <a href="https://github.com/fitzgen/deallocate-zeroed/blob/52c2b9b7305dd1a947b3342128fcf0d03143223e/crates/fuzzing/src/lib.rs#L656">https://github.com/fitzgen/deallocate-zeroed/blob/52c2b9b7305dd1a947b3342128fcf0d03143223e/crates/fuzzing/src/lib.rs#L656</a></li>
<li>We want to always generate valid Wasm, otherwise we can't even execute the subset of ops that are valid, so I think we will need to do the equivalent filtering/fixing up in the generator rather than in the oracle.</li>
<li>This fix-up pass could be its own pass, mutating the fuzzer ops AST structure directly, before we generate a Wasm binary from that AST structure. Or, alternatively, it could be integrated into Wasm-binary-from-AST generation step.</li>
</ul>
</li>
</ul>
</li>
<li>Goal: Become familiar with <code>mutatis</code> and move the fuzzer towards our north star vision for it<br>
&lt;/details&gt;</li>
</ul>
</li>
<li>
<p>[ ] Add support for empty <code>(rec ...)</code> groups containing zero or more empty <code>struct</code> types.<br>
  &lt;details&gt;</p>
<ul>
<li>Add generation support for these <code>(rec ...)</code> groups with zero or more empty <code>struct</code> types</li>
<li>Add a fuzzer op that allocates a random one of our <code>struct</code> types. We should avoid emitting this op when we have not defined any <code>struct</code> types.</li>
<li>Add a function import that takes a <code>structref</code> argument to our Wasm binary skeleton</li>
<li>Add a fuzzer op that calls that new function</li>
<li>Add a function import for each defined <code>struct</code> type that takes a reference of that type of struct specifically</li>
<li>Add a fuzzer op that calls these new typed functions</li>
<li>Add support for generating locals, globals, and tables that contain <code>structref</code>s and concretely typed <code>struct</code> references</li>
<li>Add new or extend existing fuzzer ops for accessing locals/globals/tables of <code>structref</code>s and concretely typed <code>struct</code> references</li>
<li>Define a mutation that adds an empty <code>struct</code> type to an existing <code>(rec ...)</code> group</li>
<li>Define a mutation that removes a <code>struct</code> type from an existing <code>(rec ...)</code>  group</li>
<li>Define a mutation that moves a <code>struct</code> type within an existing <code>(rec ...)</code>  group</li>
<li>Define a mutation that moves a <code>struct</code> type from an existing <code>(rec ...)</code>  group to another</li>
<li>Define a mutation that duplicates a <code>(rec ...)</code> group</li>
<li>Define a mutation that removes a whole <code>(rec ...)</code> group</li>
<li>Define a mutation that merges two <code>(rec ...)</code> groups</li>
<li>Define a mutation that splits a <code>(rec ...)</code> group in two, if possible</li>
<li>Will need to migrate the abstract representation of the value stack from a couner of how many <code>externref</code>s are on the stack to an actual stack of types</li>
<li>Note: there is a whole lot here, even just exercising empty <code>struct</code> definitions, so it may make sense to split this up into a few PRs</li>
<li>Goal: start exercising type canonicalization, lay down initial infrastructure for <code>(rec ...)</code> groups and <code>struct</code> types.<br>
&lt;/details&gt;</li>
</ul>
</li>
<li>
<p>[ ] Add support for exercising subtyping relationships<br>
  &lt;details&gt;</p>
<ul>
<li>Add support for on <code>struct</code> type to be a subtype of another <code>struct</code> type</li>
<li>Subtypes must be defined after their supertypes, so this will require we do some validation/filtering/fixups in the face of mutations that reorder types. (This restriction prevents cyclic subtyping where A subtypes B and B subtypes A.)</li>
<li>Want to think hard about how we represent types, rec groups, and type references in the AST at this point and how we are architecting the program. These choices are going to have a big impact on everything we do from here on out.<ul>
<li>Do we just have a list of rec groups that directly reflect the order we will put them into the Wasm binary?</li>
<li>Do we create arbitrary type graphs and then do a topological sort on them to ensure they are valid? If we do this approach, what happens in the future when we find a cycle that is not within the same rec group? Or do we not even have rec groups here, just types, and then generate rec groups as part of the projection out from the graph?</li>
<li>Do we reference types by id and ignore references when there is not type associated with that id?</li>
<li>Or do we simply reference types by their type index, as in Wasm? And then ignore invalid references?</li>
</ul>
</li>
<li>Goal: Continue to fill out type system features that we exercise, figure out the architecture we want for dealing with references between types.<br>
&lt;/details&gt;</li>
</ul>
</li>
<li>
<p>[ ] Add support for casting and testing references<br>
  &lt;details&gt;</p>
<ul>
<li>Add a fuzzer op for casts that should always succeed (from a subtype to a supertype). This should become a <code>ref.cast</code> instruction in the Wasm binary.</li>
<li>
<p>Add a fuzzer op for fallible downcasts. This should not trap and kill the whole program if the downcast fails. In the fullness of time, we will want to generate blocks that do things with the downcasted value that are only executed if the downcast succeeds, something like this:</p>
<p>```<br>
block (param ...)<br>
  ;; Break out of this block if we fail to cast the reference on top of the<br>
  ;; stack to its subtype.<br>
  ref.br_on_cast_fail ...</p>
<p>;; Do stuff with the subtype reference...<br>
end</p>
<p>;; Control joins again here and the program continues.<br>
```</p>
<p>And we will want to exercise both the <code>br_on_cast_fail</code> and <code>br_on_cast</code> instructions, which will require slightly different shapes of blocks.</p>
<p>Initially, we can simply downcast to a nullable subtype reference, where we get null if the downcast fails:</p>
<p><code>
block (param (ref null $my_super)) (result (ref null $my_sub))
  local.tee $my_temp
  ;; Test if the downcast will succeed.
  ref.test ...
  if (result (ref null $my_sub))
    ;; The downcast will succeed, do a downcast-or-trap operation which we
    ;; know will not trap.
    local.get $my_temp
    ref.cast ...
  else
    ;; The downcast would fail, so just create a null reference instead.
    ref.null ...
  end
end
</code></p>
</li>
<li>
<p>Goal: Exercise subtyping checks and casting logic.<br>
&lt;/details&gt;</p>
</li>
</ul>
</li>
<li>
<p>[ ] Add support for POD and <code>externref</code> fields in <code>struct</code>s<br>
  &lt;details&gt;</p>
<ul>
<li>Add generation and mutation support for <code>i8</code>/<code>i16</code>/<code>i32</code>/<code>i64</code>/<code>f32</code>/<code>f64</code>/<code>v128</code>/<code>externref</code> struct fields. Reference fields will be trickier and can be added in another milestone.</li>
<li>Add fuzzer ops for <code>struct.get</code> and <code>struct.set</code></li>
<li>Maybe: Add fuzzer ops for creating POD constants? Or should we just create zero constants on demand when necessary in the AST-to-Wasm-binary generation step? We aren't trying to exercise arithmetic in this fuzzer, that is well exercised by other fuzzers already, so the only interesting case for POD data is really when it comes from another <code>struct</code>'s field. Other than that interesting case, we just need a <em>some</em> value in order to allocate a struct containing these values.</li>
<li>Add mutators to add, remove, and modify a field in a defined <code>struct</code> type</li>
<li>Goal: start exercising accessing, reading from, and writing to GC objects<br>
&lt;/details&gt;</li>
</ul>
</li>
<li>
<p>[ ] Add support for concretely-typed references as <code>struct</code> fields<br>
  &lt;details&gt;</p>
<ul>
<li>Extend the items from the previous milestone to full type references between different defined <code>struct</code> types</li>
<li>Also add support for abstract <code>structref</code> types</li>
<li>Non-nullable type references will be tricky: if we have a cycle of non-nullable references, then those types are not currently inhabitable.<ul>
<li>Can detect and correct this in our fix-up pass, perhaps</li>
<li>Okay to punt on this in a first PR, but we definitely would want to start handling them in a closely following PR. This is an important corner of the spec, and we perform optimizations based on non-nullability in the compiler, and one that none of our other fuzzers are exercising this right now (wasm-smith does not support non-nullable references yet).</li>
</ul>
</li>
<li>This phase is when we will really start seeing the impact of our architecture choices around how to represent types and references between them in the AST.</li>
<li>Goal: start exercising<br>
[message truncated]</li>
</ul>
</li>
</ul>
</blockquote>



<a name="535552186"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2310327%20Rewrite%20the%20%60table_ops%60%20fuzzer%20to.../near/535552186" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2310327.20Rewrite.20the.20.60table_ops.60.20fuzzer.20to.2E.2E.2E.html#535552186">(Aug 21 2025 at 17:51)</a>:</h4>
<p>fitzgen edited <a href="https://github.com/bytecodealliance/wasmtime/issues/10327">issue #10327</a>:</p>
<blockquote>
<h1>GC Fuzzing</h1>
<p>This is a sketch of a series of milestones, roughly estimated to be about one PR each, for GC fuzzing. We don't need to do exactly these milestones in exactly this order. It is okay if, in the process of implementing them, we find reason to do milestone X before Y and decide to swap their order. It is okay if one milestone becomes three PRs, or two milestones become one PR. This is just a sketch to provide some light structure. Also, these milestones represent a lot of work, and while the goal is certainly to get everything here finished during your internship, if it turns out that this is more work that can be completed in that amount of time, that is okay.</p>
<h3>Incremental Milestones</h3>
<ul>
<li>
<p>[X] Port the <code>table_ops</code> fuzzer from <code>arbitrary</code> to <code>mutatis</code><br>
  &lt;details&gt;</p>
<ul>
<li>Replacing <code>arbitrary</code>-based generator with a <code>mutatis</code>-based fuzzer</li>
<li>Oracle should be able to (largely) remain unmodified</li>
<li>Avoid adding new features or changing existing functionality as much as possible</li>
<li>Start handling the scenario where:<ul>
<li>We originally have a valid series of fuzzer ops A,</li>
<li>then a random mutation inserts, removes, or changes an op in A to produce fuzzer ops A',</li>
<li>but A' is now no longer a valid sequence of fuzzer ops (for example, an initial op whose result was the input for a subsequent op was removed, for example).</li>
<li>Now we have to figure out how to handle invalid test cases:<ul>
<li>Do we throw it away and continue to the next one?</li>
<li>Do we "patch up" the test case in a post-processing pass that fixes it up such that it becomes valid?</li>
<li>I'm thinking we probably want to do a fix-up pass to avoid wasting cycles on test cases we won't execute, ultimately hurting our overall fuzzing throughput, but I'm not 100% sure that is the right choice, and I am all ears for counter arguments and alternative ideas.</li>
<li>As far as <code>mutatis</code>-related prior art goes, the allocator fuzzer handled this stuff in the oracle: it simply avoided performing the fuzzer's allocation operations when they did not make sense (i.e. it ignores the "deallocate pointer with id X" operation if there isn't currently a live allocation with id X): <a href="https://github.com/fitzgen/deallocate-zeroed/blob/52c2b9b7305dd1a947b3342128fcf0d03143223e/crates/fuzzing/src/lib.rs#L656">https://github.com/fitzgen/deallocate-zeroed/blob/52c2b9b7305dd1a947b3342128fcf0d03143223e/crates/fuzzing/src/lib.rs#L656</a></li>
<li>We want to always generate valid Wasm, otherwise we can't even execute the subset of ops that are valid, so I think we will need to do the equivalent filtering/fixing up in the generator rather than in the oracle.</li>
<li>This fix-up pass could be its own pass, mutating the fuzzer ops AST structure directly, before we generate a Wasm binary from that AST structure. Or, alternatively, it could be integrated into Wasm-binary-from-AST generation step.</li>
</ul>
</li>
</ul>
</li>
<li>Goal: Become familiar with <code>mutatis</code> and move the fuzzer towards our north star vision for it</li>
</ul>
<p>&lt;/details&gt;</p>
</li>
<li>
<p>[ ] Add support for empty <code>(rec ...)</code> groups containing zero or more empty <code>struct</code> types.<br>
  &lt;details&gt;</p>
<ul>
<li>Add generation support for these <code>(rec ...)</code> groups with zero or more empty <code>struct</code> types</li>
<li>Add a fuzzer op that allocates a random one of our <code>struct</code> types. We should avoid emitting this op when we have not defined any <code>struct</code> types.</li>
<li>Add a function import that takes a <code>structref</code> argument to our Wasm binary skeleton</li>
<li>Add a fuzzer op that calls that new function</li>
<li>Add a function import for each defined <code>struct</code> type that takes a reference of that type of struct specifically</li>
<li>Add a fuzzer op that calls these new typed functions</li>
<li>Add support for generating locals, globals, and tables that contain <code>structref</code>s and concretely typed <code>struct</code> references</li>
<li>Add new or extend existing fuzzer ops for accessing locals/globals/tables of <code>structref</code>s and concretely typed <code>struct</code> references</li>
<li>Define a mutation that adds an empty <code>struct</code> type to an existing <code>(rec ...)</code> group</li>
<li>Define a mutation that removes a <code>struct</code> type from an existing <code>(rec ...)</code>  group</li>
<li>Define a mutation that moves a <code>struct</code> type within an existing <code>(rec ...)</code>  group</li>
<li>Define a mutation that moves a <code>struct</code> type from an existing <code>(rec ...)</code>  group to another</li>
<li>Define a mutation that duplicates a <code>(rec ...)</code> group</li>
<li>Define a mutation that removes a whole <code>(rec ...)</code> group</li>
<li>Define a mutation that merges two <code>(rec ...)</code> groups</li>
<li>Define a mutation that splits a <code>(rec ...)</code> group in two, if possible</li>
<li>Will need to migrate the abstract representation of the value stack from a couner of how many <code>externref</code>s are on the stack to an actual stack of types</li>
<li>Note: there is a whole lot here, even just exercising empty <code>struct</code> definitions, so it may make sense to split this up into a few PRs</li>
<li>Goal: start exercising type canonicalization, lay down initial infrastructure for <code>(rec ...)</code> groups and <code>struct</code> types.</li>
</ul>
<p>&lt;/details&gt;</p>
</li>
<li>
<p>[ ] Add support for exercising subtyping relationships<br>
  &lt;details&gt;</p>
<ul>
<li>Add support for on <code>struct</code> type to be a subtype of another <code>struct</code> type</li>
<li>Subtypes must be defined after their supertypes, so this will require we do some validation/filtering/fixups in the face of mutations that reorder types. (This restriction prevents cyclic subtyping where A subtypes B and B subtypes A.)</li>
<li>Want to think hard about how we represent types, rec groups, and type references in the AST at this point and how we are architecting the program. These choices are going to have a big impact on everything we do from here on out.<ul>
<li>Do we just have a list of rec groups that directly reflect the order we will put them into the Wasm binary?</li>
<li>Do we create arbitrary type graphs and then do a topological sort on them to ensure they are valid? If we do this approach, what happens in the future when we find a cycle that is not within the same rec group? Or do we not even have rec groups here, just types, and then generate rec groups as part of the projection out from the graph?</li>
<li>Do we reference types by id and ignore references when there is not type associated with that id?</li>
<li>Or do we simply reference types by their type index, as in Wasm? And then ignore invalid references?</li>
</ul>
</li>
<li>Goal: Continue to fill out type system features that we exercise, figure out the architecture we want for dealing with references between types.</li>
</ul>
<p>&lt;/details&gt;</p>
</li>
<li>
<p>[ ] Add support for casting and testing references<br>
  &lt;details&gt;</p>
<ul>
<li>Add a fuzzer op for casts that should always succeed (from a subtype to a supertype). This should become a <code>ref.cast</code> instruction in the Wasm binary.</li>
<li>
<p>Add a fuzzer op for fallible downcasts. This should not trap and kill the whole program if the downcast fails. In the fullness of time, we will want to generate blocks that do things with the downcasted value that are only executed if the downcast succeeds, something like this:</p>
<p>```<br>
block (param ...)<br>
  ;; Break out of this block if we fail to cast the reference on top of the<br>
  ;; stack to its subtype.<br>
  ref.br_on_cast_fail ...</p>
<p>;; Do stuff with the subtype reference...<br>
end</p>
<p>;; Control joins again here and the program continues.<br>
```</p>
<p>And we will want to exercise both the <code>br_on_cast_fail</code> and <code>br_on_cast</code> instructions, which will require slightly different shapes of blocks.</p>
<p>Initially, we can simply downcast to a nullable subtype reference, where we get null if the downcast fails:</p>
<p><code>
block (param (ref null $my_super)) (result (ref null $my_sub))
  local.tee $my_temp
  ;; Test if the downcast will succeed.
  ref.test ...
  if (result (ref null $my_sub))
    ;; The downcast will succeed, do a downcast-or-trap operation which we
    ;; know will not trap.
    local.get $my_temp
    ref.cast ...
  else
    ;; The downcast would fail, so just create a null reference instead.
    ref.null ...
  end
end
</code></p>
</li>
<li>
<p>Goal: Exercise subtyping checks and casting logic.</p>
</li>
</ul>
<p>&lt;/details&gt;</p>
</li>
<li>
<p>[ ] Add support for POD and <code>externref</code> fields in <code>struct</code>s<br>
  &lt;details&gt;</p>
<ul>
<li>Add generation and mutation support for <code>i8</code>/<code>i16</code>/<code>i32</code>/<code>i64</code>/<code>f32</code>/<code>f64</code>/<code>v128</code>/<code>externref</code> struct fields. Reference fields will be trickier and can be added in another milestone.</li>
<li>Add fuzzer ops for <code>struct.get</code> and <code>struct.set</code></li>
<li>Maybe: Add fuzzer ops for creating POD constants? Or should we just create zero constants on demand when necessary in the AST-to-Wasm-binary generation step? We aren't trying to exercise arithmetic in this fuzzer, that is well exercised by other fuzzers already, so the only interesting case for POD data is really when it comes from another <code>struct</code>'s field. Other than that interesting case, we just need a <em>some</em> value in order to allocate a struct containing these values.</li>
<li>Add mutators to add, remove, and modify a field in a defined <code>struct</code> type</li>
<li>Goal: start exercising accessing, reading from, and writing to GC objects</li>
</ul>
<p>&lt;/details&gt;</p>
</li>
<li>
<p>[ ] Add support for concretely-typed references as <code>struct</code> fields<br>
  &lt;details&gt;</p>
<ul>
<li>Extend the items from the previous milestone to full type references between different defined <code>struct</code> types</li>
<li>Also add support for abstract <code>structref</code> types</li>
<li>Non-nullable type references will be tricky: if we have a cycle of non-nullable references, then those types are not currently inhabitable.<ul>
<li>Can detect and correct this in our fix-up pass, perhaps</li>
<li>Okay to punt on this in a first PR, but we definitely would want to start handling them in a closely following PR. This is an important corner of the spec, and we perform optimizations based on non-nullability in the compiler, and one that none of our other fuzzers are exercising this right now (wasm-smith does not support non-nullable references yet).</li>
</ul>
</li>
<li>This phase is when we will really start seeing the impact of our architecture choices around how to represent types and references between them in the AST.</li>
<li>Goal: s<br>
[message truncated]</li>
</ul>
</li>
</ul>
</blockquote>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>