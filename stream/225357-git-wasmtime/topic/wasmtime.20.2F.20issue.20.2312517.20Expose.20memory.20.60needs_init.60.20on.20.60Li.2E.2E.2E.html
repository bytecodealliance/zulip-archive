<html>
<head><meta charset="utf-8"><title>wasmtime / issue #12517 Expose memory `needs_init` on `Li... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312517.20Expose.20memory.20.60needs_init.60.20on.20.60Li.2E.2E.2E.html">wasmtime / issue #12517 Expose memory `needs_init` on `Li...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="571956063"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312517%20Expose%20memory%20%60needs_init%60%20on%20%60Li.../near/571956063" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312517.20Expose.20memory.20.60needs_init.60.20on.20.60Li.2E.2E.2E.html#571956063">(Feb 04 2026 at 16:25)</a>:</h4>
<p>d-sonuga opened <a href="https://github.com/bytecodealliance/wasmtime/issues/12517">issue #12517</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>Need to have control over whether or not a linear memory is reinitialized when a module is instantiated.</p>
<h4>Benefit</h4>
<p>The use-case for this is to have persistent memory that does not get wiped out across runs.</p>
<h4>Implementation</h4>
<p>Expose a <code>needs_init</code> function on the <code>LinearMemory</code> trait. It can default to true, which will resort to the<br>
current behavior of always reinitializing the memory when a module is instantiated.</p>
</blockquote>



<a name="572222738"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312517%20Expose%20memory%20%60needs_init%60%20on%20%60Li.../near/572222738" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312517.20Expose.20memory.20.60needs_init.60.20on.20.60Li.2E.2E.2E.html#572222738">(Feb 05 2026 at 18:33)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/12517#issuecomment-3855454102">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12517">issue #12517</a>:</p>
<blockquote>
<p>The intention of custom linear memories is to enable customization of how it's allocated while still enforcing WebAssembly's semantics. Given that I don't think we'll expose a knob like this if it enables subverting WebAssembly's semantics or breaking the encapsulation of modules. Instantiating a WebAssembly module, for example, is a well-defined operation in terms of how exactly a memory should appear after instantiation.</p>
<p>Can you elaborate more on your use case and how you want to use this? For example what is the shape of the module that you are instantiating? How are you looking to reuse data between instantiations?</p>
</blockquote>



<a name="572347331"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312517%20Expose%20memory%20%60needs_init%60%20on%20%60Li.../near/572347331" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312517.20Expose.20memory.20.60needs_init.60.20on.20.60Li.2E.2E.2E.html#572347331">(Feb 06 2026 at 10:59)</a>:</h4>
<p>d-sonuga <a href="https://github.com/bytecodealliance/wasmtime/issues/12517#issuecomment-3859721509">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12517">issue #12517</a>:</p>
<blockquote>
<p>The use case is there are webassembly modules whose memories represent state that must not be reset. So, whenever some wasm operation mutates that state, say some static variable is set to some new value, it must stay the same across runs.<br>
Effectively, it's a resume VM thing, where conceptually, it should be like execution never ended.</p>
<p>As for the shape, each module has its own exported memory, defined in the module, with data segments intended to be applied once, no shared memory between modules and no concurrent instances alive at the same time.</p>
<p>Currently, we have our own fork of Wasmtime that adds this <code>needs_init</code> to the memory so that it does not get re-initialized on every instantiation, to get it to behave like a reattachment to existing state, not as a reset.</p>
<p>I guess, in light of the wasm spec thing, this is sort of a hack. I'd be very interested in your perspective on whether there's a more spec-aligned way of doing this?</p>
</blockquote>



<a name="572433176"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312517%20Expose%20memory%20%60needs_init%60%20on%20%60Li.../near/572433176" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312517.20Expose.20memory.20.60needs_init.60.20on.20.60Li.2E.2E.2E.html#572433176">(Feb 06 2026 at 17:41)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/12517#issuecomment-3861772348">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12517">issue #12517</a>:</p>
<blockquote>
<p>One possibility, which is similar to how threads originally worked, is to import a memory instead of exporting a memory. The module would then expose an initialization function for applying the data segments the first time, and the engine would then orchestrate calling that once but not for future runs.</p>
<p>Alternatively you could post-process wasm modules to do this sort of manually. For example you could rewrite a memory-export-with-data-segments to a memory-import-with-initialization-function. You may wish to do this sort of post-processing to export other state from the module, such as globals/tables, too</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>