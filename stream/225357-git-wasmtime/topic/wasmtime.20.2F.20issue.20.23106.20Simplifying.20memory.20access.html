<html>
<head><meta charset="utf-8"><title>wasmtime / issue #106 Simplifying memory access · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23106.20Simplifying.20memory.20access.html">wasmtime / issue #106 Simplifying memory access</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="446777774"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%23106%20Simplifying%20memory%20access/near/446777774" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23106.20Simplifying.20memory.20access.html#446777774">(Jun 25 2024 at 05:01)</a>:</h4>
<p>vados-cosmonic <a href="https://github.com/bytecodealliance/wasmtime/issues/106#issuecomment-2187982702">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/106">issue #106</a>:</p>
<blockquote>
<p>Hey @sapessi there's a bunch of work going on on the <a href="https://github.com/WebAssembly/gc">GC proposal</a> -- maybe the information there would be useful? A lot has happened in the last 4 years that may help answer the allocation management question! </p>
<p>As far as the API goes, are you still interested in pages/bytes types or does the <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html#method.read">Memory API as it stands today</a> work well enough to resolve the issue?</p>
</blockquote>



<a name="568278744"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%23106%20Simplifying%20memory%20access/near/568278744" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23106.20Simplifying.20memory.20access.html#568278744">(Jan 15 2026 at 17:52)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/issues/106#issuecomment-3756144986">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/106">issue #106</a>:</p>
<blockquote>
<p>I think this issue is out of date. We now have slice-returning accessors for linear memory, e.g. <a href="https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html#method.data">https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html#method.data</a></p>
</blockquote>



<a name="568278747"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%23106%20Simplifying%20memory%20access/near/568278747" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.23106.20Simplifying.20memory.20access.html#568278747">(Jan 15 2026 at 17:52)</a>:</h4>
<p>fitzgen closed <a href="https://github.com/bytecodealliance/wasmtime/issues/106">issue #106</a>:</p>
<blockquote>
<p>I'm using wasmtime on a project that requires me to write to linear memory directly before invoking the wasm function. While this is possible today, the APIs are not easy to use. Below is a proposal  to simplify memory interaction for discussion.</p>
<ul>
<li>Add a method to directly access the exported <code>VMMemoryDefinition</code> to <code>InstanceHandle</code>:</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// Returns the exported module memory for the given name.</span>
<span class="sd">/// When the export_name parameter is not passed defaults to "memory".</span>
<span class="sd">/// Returns None if the memory export could not be found</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">memory</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">export_name</span><span class="p">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="kt">str</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">VMMemoryDefinition</span><span class="o">&gt;</span>
</code></pre></div>
<ul>
<li>Add a <code>as_slice</code> and <code>as_mut_slice</code> to the <code>VMMemoryDefintion</code> object</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// Converts the raw pointer to a u8 slice</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{}</span>

<span class="sd">/// Returns a mutable u8 slice pointing to the VMMemoryDefinition index.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">as_mut_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{}</span>
</code></pre></div>
<p>With these basic changes in place, after initializing a module, developers can quickly access its linear memory for reading and doing a lot of "unsafe" writing. </p>
<p>The next evolution of this would be to encapsulate all unsafe code in wasmtime's memory objects and give high-level abstractions for developers to use. The proposal below is informed by my use-case and I would like to hear others thoughts on what I'm missing or not understanding correctly. My objectives are:<br>
1. Make allocations easy and, whenever possible, automatically zero out the memory once the object is out of scope<br>
2. Make it easy to find the next available memory location and grow the memory when necessary<br>
3. Make it easy to read return values from functions</p>
<blockquote>
<p>I'm using <code>Box&lt;Error&gt;</code> in the examples below for the sake of simplicity. We may want to go with specific error types</p>
</blockquote>
<ul>
<li>Introduce a new <code>Allocation</code> type which has fundamentally the same properties as <code>VMMemoryDefintion</code> with additional utility methods. I'm thinking of creating a separate object instead of re-using <code>VMMemoryDefinition</code> to prevent developers from calling potentially destructive new operations such as <code>zero</code> on the entire instance memory.</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">Allocation</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">base</span><span class="p">:</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="kt">u8</span><span class="p">,</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">current_length</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span>

<span class="w">    </span><span class="sd">/// The index in linear memory where the allocation occurred</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="n">idx</span><span class="p">:</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Tells whether the Drop trait should execute the zero operation on this object.</span>
<span class="w">    </span><span class="c1">// See VMMemoryDefinition changes for the purpose of this flag.</span>
<span class="w">    </span><span class="n">auto_deallocate</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>The allocation method exposes an <code>as_slice</code> method to easily read the value as well as a <code>zero</code> method to zero out the memory.</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="n">Allocation</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Returns a slice containing the allocation data</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">as_slice</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span><span class="w"> </span><span class="p">{}</span>
<span class="w">    </span><span class="sd">/// Zeros out the memory this aloocation points to</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">zero</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="nb">Into</span><span class="o">&lt;</span><span class="n">DefinedMemoryIndex</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Allocation</span><span class="w"> </span><span class="p">{}</span>
<span class="k">impl</span><span class="w"> </span><span class="nb">Into</span><span class="o">&lt;</span><span class="n">RuntimeValue</span><span class="p">::</span><span class="n">I32</span><span class="o">&gt;</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Allocation</span><span class="w"> </span><span class="p">{}</span>
<span class="k">impl</span><span class="w"> </span><span class="nb">Drop</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Allocation</span><span class="w"> </span><span class="p">{}</span>
</code></pre></div>
<ul>
<li>Add an alloc method to the VMMemoryDefinition that finds the next available memory location for the given value and copies the data to memroy. The output of this operation is an <code>Allocation</code> object, </li>
</ul>
<p><div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">impl</span><span class="w"> </span><span class="n">VMMemoryDefintion</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="sd">/// Writes the given u8 slice in the first available location in linear memory.</span>
<span class="w">    </span><span class="sd">/// When the grow parameter is set to true the method automatically grows the instance memory</span>
<span class="w">    </span><span class="sd">/// if it cannot find an appropriate location for the data.</span>
<span class="w">    </span><span class="sd">/// The auto_deallocate parameter activates the `Drop` trait implementation for the returned</span>
<span class="w">    </span><span class="sd">/// `Allocation` object. `drop` automatically zeroes out the memory when the object goes out of scope.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">alloc</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">],</span><span class="w"> </span><span class="n">grow</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="n">auto_deallocate</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Allocation</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="sd">/// Returns a raw pointer to the next available memory location of the given length. None if there isn't one.</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">next_available</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">data_len</span><span class="p">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;*</span><span class="k">mut</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="sd">/// Grows the instance memory by the given number of pages</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">grow</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">pages</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="sd">/// Grows the instnace memory by a number of pages sufficient to contain the given byte length</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">grow_by_bytes</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">bytes</span><span class="p">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="sd">/// Returns an allocation object that points to the value returned in the given ActionOutcome</span>
<span class="w">    </span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">get_output</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">out_value</span><span class="p">:</span><span class="w"> </span><span class="nc">ActionOutcome</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Allocation</span><span class="p">,</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></div><br>
</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>