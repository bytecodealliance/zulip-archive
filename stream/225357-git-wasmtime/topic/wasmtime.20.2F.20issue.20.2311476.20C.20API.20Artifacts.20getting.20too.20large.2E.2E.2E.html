<html>
<head><meta charset="utf-8"><title>wasmtime / issue #11476 C API Artifacts getting too large... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311476.20C.20API.20Artifacts.20getting.20too.20large.2E.2E.2E.html">wasmtime / issue #11476 C API Artifacts getting too large...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="535389947"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311476%20C%20API%20Artifacts%20getting%20too%20large.../near/535389947" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311476.20C.20API.20Artifacts.20getting.20too.20large.2E.2E.2E.html#535389947">(Aug 20 2025 at 21:06)</a>:</h4>
<p>alexcrichton opened <a href="https://github.com/bytecodealliance/wasmtime/issues/11476">issue #11476</a>:</p>
<blockquote>
<p>The current motivation for this issue is that the wasmtime-go repository <a href="https://github.com/bytecodealliance/wasmtime-go/issues/250">cannot make a 36.0.0 release</a> because the C API artifacts have gotten too large. A rough overview of what's happening there is that the only way I know of to distribute the C API in Go is to literally check the binaries themselves (for all architectures no less) into the repository at the published tags. GitHub has a 100M file size limit for files in git repositories Wasmtime has been steadily growing large and larger over time (as GitHub prints warnings when I push the tag on the CLI) and the x86_64 linux C API is now above this threshold.</p>
<p>On one hand this is expected, we slowly add things over time and binaries are expected to get larger. This is why we have conditional compile-time features to reduce the size of artifacts. In the wasmtime-go repository, though, it's trying to reuse the exact artifacts that Wasmtime publishes as I'd really rather avoid duplicating the build process just for a slightly reduced feature set. Thus, this issue.</p>
<p>If we accept this as an issue that should be addressed, then the question remains of what to do about it. We've got a <a href="https://docs.wasmtime.dev/examples-minimal.html">well-documented series of steps</a> of how to build a minimal embedding of Wasmtime which gives a whole bunch of knobs of how to shrink the size of the compiled artifact, and it's a question of how best to apply them.</p>
<h2>Why is <code>libwasmtime.a</code> big?</h2>
<p>The current state of the world is that wasmtime-go checks in <code>libwasmtime.a</code> static archives. It avoids <code>*.so</code> or dynamic library artifacts to avoid adding new dependencies to executables produced (I don't even know how we'd communicate to users how to copy around the library). The <a href="https://github.com/bytecodealliance/wasmtime/releases/download/v36.0.0/wasmtime-v36.0.0-x86_64-linux-c-api.tar.xz"><code>libwasmtime.a</code> artifact for x86_64-linux</a> is 104M. The <code>libwasmtime.so</code> artifact, however, is only 26M. I would consider the <code>libwasmtime.so</code> artifact the "lower bound" of what we would ideally be able to achieve.</p>
<p>So first off: why is <code>libwasmtime.so</code> so much smaller? The main reason for this is that <code>*.a</code> is just a huge collection of <code>*.o</code> files internally. These object files are not all 100% used in the final artifact (e.g. <code>--gc-sections</code> would remove a lot) and they're just raw copied from rlibs. The <code>*.so</code> is much smaller as it's a fully linked artifact that has all dead code removed. There's also "linking metadata" such as relocation sections, big symbols tables, llvm bitcode, etc, which is all present in <code>*.a</code> but not in <code>*.so</code>.</p>
<h2>Shrinking <code>libwasmtime.a</code></h2>
<p>Ok that's enough intro, what to do about this</p>
<ul>
<li>Turn on LTO. This cuts the <code>*.a</code> size in half because it's effectively DCE at compile time. The optimization side of things ends up making it really slow though. Testing in <a href="https://github.com/bytecodealliance/wasmtime/pull/11475">https://github.com/bytecodealliance/wasmtime/pull/11475</a> the Windows release builds clock in at 20m where they were previously  15, which would make them the slowest builder. (not a problem for Linux/macOS builds though...)</li>
<li>Turn on ThinLTO. Similar to above but faster as it's more parallelizable. Only shaves ~10-15M locally though so not really enough to buy much runway.</li>
<li>Turn off some features. This is here for completeness but I don't think this is really viable since the point of these artifacts is to be the "default featureful artifacts".</li>
<li>Turn on panic=abort. Alas this is already done.</li>
<li>Turn on <code>opt-level=s</code> or <code>z</code>. Measured locally to basically have no effect (this is good for micro-optimizing, but bad for macro-optimizing in my experience)</li>
<li>Use <code>CARGO_PROFILE_RELEASE_CODEGEN_UNITS=1</code>. Shaves 20-30M off locally. (possible!)</li>
<li>Some how use the <code>-r</code> flag to <code>ld</code>. This is in theory "apply <code>--gc-sections</code> ahead of time" AFAIK, but I've never used this option successfully nor have I seen anyone else use it successfully. Trying naively locally requires knowledge of symbols which we do not have.</li>
</ul>
<p>Well I at least wanted to open an issue about this. I don't think much will come of opening the issue here, but maybe someone can swoop in with That One Easy Trick which makes the binary tiny.</p>
</blockquote>



<a name="535393651"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311476%20C%20API%20Artifacts%20getting%20too%20large.../near/535393651" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311476.20C.20API.20Artifacts.20getting.20too.20large.2E.2E.2E.html#535393651">(Aug 20 2025 at 21:41)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11476#issuecomment-3208168220">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11476">issue #11476</a>:</p>
<blockquote>
<p>Another option: build non-Windows with LTO since we have time budget, don't built Windows with LTO. I don't know why Windows is so much slower on CI, but Linux binaries are the current ones exceeding the threshold.</p>
</blockquote>



<a name="535408025"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311476%20C%20API%20Artifacts%20getting%20too%20large.../near/535408025" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311476.20C.20API.20Artifacts.20getting.20too.20large.2E.2E.2E.html#535408025">(Aug 21 2025 at 00:25)</a>:</h4>
<p>alexcrichton closed <a href="https://github.com/bytecodealliance/wasmtime/issues/11476">issue #11476</a>:</p>
<blockquote>
<p>The current motivation for this issue is that the wasmtime-go repository <a href="https://github.com/bytecodealliance/wasmtime-go/issues/250">cannot make a 36.0.0 release</a> because the C API artifacts have gotten too large. A rough overview of what's happening there is that the only way I know of to distribute the C API in Go is to literally check the binaries themselves (for all architectures no less) into the repository at the published tags. GitHub has a 100M file size limit for files in git repositories Wasmtime has been steadily growing large and larger over time (as GitHub prints warnings when I push the tag on the CLI) and the x86_64 linux C API is now above this threshold.</p>
<p>On one hand this is expected, we slowly add things over time and binaries are expected to get larger. This is why we have conditional compile-time features to reduce the size of artifacts. In the wasmtime-go repository, though, it's trying to reuse the exact artifacts that Wasmtime publishes as I'd really rather avoid duplicating the build process just for a slightly reduced feature set. Thus, this issue.</p>
<p>If we accept this as an issue that should be addressed, then the question remains of what to do about it. We've got a <a href="https://docs.wasmtime.dev/examples-minimal.html">well-documented series of steps</a> of how to build a minimal embedding of Wasmtime which gives a whole bunch of knobs of how to shrink the size of the compiled artifact, and it's a question of how best to apply them.</p>
<h2>Why is <code>libwasmtime.a</code> big?</h2>
<p>The current state of the world is that wasmtime-go checks in <code>libwasmtime.a</code> static archives. It avoids <code>*.so</code> or dynamic library artifacts to avoid adding new dependencies to executables produced (I don't even know how we'd communicate to users how to copy around the library). The <a href="https://github.com/bytecodealliance/wasmtime/releases/download/v36.0.0/wasmtime-v36.0.0-x86_64-linux-c-api.tar.xz"><code>libwasmtime.a</code> artifact for x86_64-linux</a> is 104M. The <code>libwasmtime.so</code> artifact, however, is only 26M. I would consider the <code>libwasmtime.so</code> artifact the "lower bound" of what we would ideally be able to achieve.</p>
<p>So first off: why is <code>libwasmtime.so</code> so much smaller? The main reason for this is that <code>*.a</code> is just a huge collection of <code>*.o</code> files internally. These object files are not all 100% used in the final artifact (e.g. <code>--gc-sections</code> would remove a lot) and they're just raw copied from rlibs. The <code>*.so</code> is much smaller as it's a fully linked artifact that has all dead code removed. There's also "linking metadata" such as relocation sections, big symbols tables, llvm bitcode, etc, which is all present in <code>*.a</code> but not in <code>*.so</code>.</p>
<h2>Shrinking <code>libwasmtime.a</code></h2>
<p>Ok that's enough intro, what to do about this</p>
<ul>
<li>Turn on LTO. This cuts the <code>*.a</code> size in half because it's effectively DCE at compile time. The optimization side of things ends up making it really slow though. Testing in <a href="https://github.com/bytecodealliance/wasmtime/pull/11475">https://github.com/bytecodealliance/wasmtime/pull/11475</a> the Windows release builds clock in at 20m where they were previously  15, which would make them the slowest builder. (not a problem for Linux/macOS builds though...)</li>
<li>Turn on ThinLTO. Similar to above but faster as it's more parallelizable. Only shaves ~10-15M locally though so not really enough to buy much runway.</li>
<li>Turn off some features. This is here for completeness but I don't think this is really viable since the point of these artifacts is to be the "default featureful artifacts".</li>
<li>Turn on panic=abort. Alas this is already done.</li>
<li>Turn on <code>opt-level=s</code> or <code>z</code>. Measured locally to basically have no effect (this is good for micro-optimizing, but bad for macro-optimizing in my experience)</li>
<li>Use <code>CARGO_PROFILE_RELEASE_CODEGEN_UNITS=1</code>. Shaves 20-30M off locally. (possible!)</li>
<li>Some how use the <code>-r</code> flag to <code>ld</code>. This is in theory "apply <code>--gc-sections</code> ahead of time" AFAIK, but I've never used this option successfully nor have I seen anyone else use it successfully. Trying naively locally requires knowledge of symbols which we do not have.</li>
</ul>
<p>Well I at least wanted to open an issue about this. I don't think much will come of opening the issue here, but maybe someone can swoop in with That One Easy Trick which makes the binary tiny.</p>
</blockquote>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>