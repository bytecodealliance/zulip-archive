<html>
<head><meta charset="utf-8"><title>wasmtime / issue #11170 Single-threaded async runtime · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html">wasmtime / issue #11170 Single-threaded async runtime</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="526604547"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/526604547" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#526604547">(Jul 01 2025 at 13:09)</a>:</h4>
<p>HoKim98 opened <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<p>Thanks for filing a feature request! Please fill out the TODOs below.</p>
<h4>Feature</h4>
<p>I want to use <code>wasmtime</code> in <code>actix-web</code>, which uses <code>!Send</code> runtime and resources such as <code>HTTPRequest</code> and <code>web::Payload</code>.</p>
<p>But the current runtime requires functions and states to be <code>Send</code>able.</p>
<p>I thought it's not mandatory to enforce <code>Send</code> trait.<br>
So I have tested on my local without <code>Send</code> and found no problem.</p>
<h4>Benefit</h4>
<p>We can use <code>wasmtime</code> in the thread-bounded (single-threaded) async runtimes.</p>
<p>It's essential to use <code>wasmtime</code> within <code>actix</code> ecosystem, which provides the input parameters as <code>!Send</code>.</p>
<h4>Implementation</h4>
<p>My current(initial) idea is to create a buddy methods like below:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// Original method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span>
<span class="k">where</span>
<span class="w">    </span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nb">Send</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span><span class="p">.</span><span class="n">on_fiber</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl</span><span class="p">(</span><span class="n">store</span><span class="p">)).</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>

<span class="sd">/// (New) buddy method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async_single_rt</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span>
<span class="w">        </span><span class="p">.</span><span class="n">on_fiber_single_rt</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl_single_rt</span><span class="p">(</span><span class="n">store</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>
</code></pre></div>
<h4>Alternatives</h4>
<p>My another idea is to use cargo features like <code>async-send</code>.<br>
But I think it may break the ecosystem (side-effect).<br>
</p>
</blockquote>



<a name="526604602"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/526604602" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#526604602">(Jul 01 2025 at 13:09)</a>:</h4>
<p>HoKim98 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>I want to use <code>wasmtime</code> in <code>actix-web</code>, which uses <code>!Send</code> runtime and resources such as <code>HTTPRequest</code> and <code>web::Payload</code>.</p>
<p>But the current runtime requires functions and states to be <code>Send</code>able.</p>
<p>I thought it's not mandatory to enforce <code>Send</code> trait.<br>
So I have tested on my local without <code>Send</code> and found no problem.</p>
<h4>Benefit</h4>
<p>We can use <code>wasmtime</code> in the thread-bounded (single-threaded) async runtimes.</p>
<p>It's essential to use <code>wasmtime</code> within <code>actix</code> ecosystem, which provides the input parameters as <code>!Send</code>.</p>
<h4>Implementation</h4>
<p>My current(initial) idea is to create a buddy methods like below:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// Original method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span>
<span class="k">where</span>
<span class="w">    </span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nb">Send</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span><span class="p">.</span><span class="n">on_fiber</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl</span><span class="p">(</span><span class="n">store</span><span class="p">)).</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>

<span class="sd">/// (New) buddy method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async_single_rt</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span>
<span class="w">        </span><span class="p">.</span><span class="n">on_fiber_single_rt</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl_single_rt</span><span class="p">(</span><span class="n">store</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>
</code></pre></div>
<h4>Alternatives</h4>
<p>My another idea is to use cargo features like <code>async-send</code>.<br>
But I think it may break the ecosystem (side-effect).<br>
</p>
</blockquote>



<a name="526605172"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/526605172" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#526605172">(Jul 01 2025 at 13:12)</a>:</h4>
<p>HoKim98 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>I want to use <code>wasmtime</code> in <code>actix-web</code>, which uses <code>!Send</code> runtime and resources such as <code>HTTPRequest</code> and <code>web::Payload</code>.</p>
<p>But the current runtime requires functions and states to be <code>Send</code>able.</p>
<p>I thought it's not mandatory to enforce <code>Send</code> trait.<br>
So I have tested on my local without <code>Send</code> and found no problem.</p>
<h4>Benefit</h4>
<p>We can use <code>wasmtime</code> in the thread-bounded (single-threaded) async runtimes.</p>
<p>It's essential to use <code>wasmtime</code> within <code>actix</code> ecosystem, which provides the input parameters as <code>!Send</code>.</p>
<h4>Implementation</h4>
<p>My current(initial) idea is to create a buddy methods like below:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// Original method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span>
<span class="k">where</span>
<span class="w">    </span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nb">Send</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span><span class="p">.</span><span class="n">on_fiber</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl</span><span class="p">(</span><span class="n">store</span><span class="p">)).</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>

<span class="sd">/// (New) buddy method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async_single_rt</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span>
<span class="w">        </span><span class="p">.</span><span class="n">on_fiber_single_rt</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl_single_rt</span><span class="p">(</span><span class="n">store</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>
</code></pre></div>
<p>The estimated number of lines: 100~300</p>
<h4>Alternatives</h4>
<p>My another idea is to use cargo features like <code>async-send</code>.<br>
But I think it may break the ecosystem (side-effect).<br>
</p>
</blockquote>



<a name="526605207"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/526605207" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#526605207">(Jul 01 2025 at 13:12)</a>:</h4>
<p>HoKim98 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>I want to use <code>wasmtime</code> in <code>actix-web</code>, which uses <code>!Send</code> runtime and resources such as <code>HTTPRequest</code> and <code>web::Payload</code>.</p>
<p>But the current runtime requires functions and states to be <code>Send</code>able.</p>
<p>I thought it's not mandatory to enforce <code>Send</code> trait.<br>
So I have tested on my local without <code>Send</code> and found no problem.</p>
<h4>Benefit</h4>
<p>We can use <code>wasmtime</code> in the thread-bounded (single-threaded) async runtimes.</p>
<p>It's essential to use <code>wasmtime</code> within <code>actix</code> ecosystem, which provides the input parameters as <code>!Send</code>.</p>
<h4>Implementation</h4>
<p>My current(initial) idea is to create a buddy methods like below:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// Original method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span>
<span class="k">where</span>
<span class="w">    </span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nb">Send</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span><span class="p">.</span><span class="n">on_fiber</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl</span><span class="p">(</span><span class="n">store</span><span class="p">)).</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>

<span class="sd">/// (New) buddy method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async_single_rt</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span>
<span class="w">        </span><span class="p">.</span><span class="n">on_fiber_single_rt</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl_single_rt</span><span class="p">(</span><span class="n">store</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>
</code></pre></div>
<p>The estimated number of new lines: 100~300</p>
<h4>Alternatives</h4>
<p>My another idea is to use cargo features like <code>async-send</code>.<br>
But I think it may break the ecosystem (side-effect).<br>
</p>
</blockquote>



<a name="526605243"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/526605243" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#526605243">(Jul 01 2025 at 13:12)</a>:</h4>
<p>HoKim98 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>I want to use <code>wasmtime</code> in <code>actix-web</code>, which uses <code>!Send</code> runtime and resources such as <code>HTTPRequest</code> and <code>web::Payload</code>.</p>
<p>But the current runtime requires functions and states to be <code>Send</code>able.</p>
<p>I thought it's not mandatory to enforce <code>Send</code> trait.<br>
So I have tested on my local without <code>Send</code> and found no problem.</p>
<h4>Benefit</h4>
<p>We can use <code>wasmtime</code> in the thread-bounded (single-threaded) async runtimes.</p>
<p>It's essential to use <code>wasmtime</code> within <code>actix</code> ecosystem, which provides the input parameters as <code>!Send</code>.</p>
<h4>Implementation</h4>
<p>My current(initial) idea is to create a buddy methods like below:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// Original method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span>
<span class="k">where</span>
<span class="w">    </span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nb">Send</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span><span class="p">.</span><span class="n">on_fiber</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl</span><span class="p">(</span><span class="n">store</span><span class="p">)).</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>

<span class="sd">/// (New) buddy method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async_single_rt</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span>
<span class="w">        </span><span class="p">.</span><span class="n">on_fiber_single_rt</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl_single_rt</span><span class="p">(</span><span class="n">store</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>
</code></pre></div>
<p>The estimated number of new lines: 100~500</p>
<h4>Alternatives</h4>
<p>My another idea is to use cargo features like <code>async-send</code>.<br>
But I think it may break the ecosystem (side-effect).<br>
</p>
</blockquote>



<a name="526605326"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/526605326" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#526605326">(Jul 01 2025 at 13:13)</a>:</h4>
<p>HoKim98 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>I want to use <code>wasmtime</code> in <code>actix-web</code>, which uses <code>!Send</code> runtime and resources such as <code>HTTPRequest</code> and <code>web::Payload</code>.</p>
<p>But the current runtime requires functions and states to be <code>Send</code>able.</p>
<p>I thought it's not mandatory to enforce <code>Send</code> trait.<br>
So I have tested on my local without <code>Send</code> and found no problem.</p>
<h4>Benefit</h4>
<p>We can use <code>wasmtime</code> in the thread-bounded (single-threaded) async runtimes.</p>
<p>It's essential to use <code>wasmtime</code> within <code>actix</code> ecosystem, which provides the input parameters as <code>!Send</code>.</p>
<h4>Implementation</h4>
<p>My current(initial) idea is to create a buddy methods like below:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// Original method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span>
<span class="k">where</span>
<span class="w">    </span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nb">Send</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span><span class="p">.</span><span class="n">on_fiber</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl</span><span class="p">(</span><span class="n">store</span><span class="p">)).</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>

<span class="sd">/// (New) buddy method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async_single_rt</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span>
<span class="w">        </span><span class="p">.</span><span class="n">on_fiber_single_rt</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl_single_rt</span><span class="p">(</span><span class="n">store</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>The estimated number of new lines: 100~500</li>
<li>Side-effect: no</li>
</ul>
<h4>Alternatives</h4>
<p>My another idea is to use cargo features like <code>async-send</code>.<br>
But I think it may break the ecosystem (side-effect).<br>
</p>
</blockquote>



<a name="526605547"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/526605547" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#526605547">(Jul 01 2025 at 13:14)</a>:</h4>
<p>HoKim98 edited <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>I want to use <code>wasmtime</code> in <code>actix-web</code>, which uses <code>!Send</code> runtime and resources such as <code>HTTPRequest</code> and <code>web::Payload</code>.</p>
<p>But the current runtime requires functions and states to be <code>Send</code>able.</p>
<p>I thought it's not mandatory to enforce <code>Send</code> trait.<br>
So I have tested on my local without <code>Send</code> and found no problem.</p>
<h4>Benefit</h4>
<p>We can use <code>wasmtime</code> in the thread-bounded (single-threaded) async runtimes.</p>
<p>It's essential to use <code>wasmtime</code> within <code>actix</code> ecosystem, which provides the input parameters as <code>!Send</code>.</p>
<h4>Implementation</h4>
<p>My current(initial) idea is to create buddy methods like below:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// Original method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span>
<span class="k">where</span>
<span class="w">    </span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nb">Send</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span><span class="p">.</span><span class="n">on_fiber</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl</span><span class="p">(</span><span class="n">store</span><span class="p">)).</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>

<span class="sd">/// (New) buddy method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async_single_rt</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span>
<span class="w">        </span><span class="p">.</span><span class="n">on_fiber_single_rt</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl_single_rt</span><span class="p">(</span><span class="n">store</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>The estimated number of new lines: 100~500</li>
<li>Side-effect: no</li>
</ul>
<h4>Alternatives</h4>
<p>My another idea is to use cargo features like <code>async-send</code>.<br>
But I think it may break the ecosystem (side-effect).<br>
</p>
</blockquote>



<a name="526648873"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/526648873" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#526648873">(Jul 01 2025 at 16:51)</a>:</h4>
<p>pchickey <a href="https://github.com/bytecodealliance/wasmtime/issues/11170#issuecomment-3024803731">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<p>Sorry - we have had this discussion in the past, and concluded that, with the current features available in the Rust type system, wasmtime's Send bounds are unfortunately infectious and will be used throughout the public API.</p>
<p>After maintaining wasmtime in tokio embeddings for many years, I'm now maintaining a single-threaded web server embedding for wasmtime where Send is a burden. Unfortunately I have solved this by adding a lot of blatantly false <code>unsafe impl Send for &lt;my types&gt; {}</code> throughout my codebase. But, we've balanced that against all of the known approaches to manage Send's infectiousness in wasmtime, and decided that its the best of the difficult options.</p>
<p>I won't rule out changing the design of wasmtime completely, but its a big project that requires a lot of time and attention from a skilled contributor, and will require a working prototype and <a href="https://github.com/bytecodealliance/rfcs">RFC</a> in order to land. If you are up for that project, lets talk about it more, but if not, we'll have to suffer together with the way it is now.</p>
</blockquote>



<a name="527104559"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/527104559" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#527104559">(Jul 04 2025 at 04:25)</a>:</h4>
<p>HoKim98 <a href="https://github.com/bytecodealliance/wasmtime/issues/11170#issuecomment-3034427851">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<p>In my case, specifically when using the <code>wasm32-wasip2</code> target (i.e., the version that doesn't explicitly depend on the <code>tokio</code> runtime), I haven't actually run into the issue you described.</p>
<p>In particular, I found that the core <code>on_fiber</code> method has evolved over the past year to the point where it has no real dependency on <code>Send</code>. That said, in environments like the <code>tokio</code> runtime where async tasks may be executed across threads, the "infectious" nature of Send often forces us to inject an otherwise void dependency.</p>
<p>To address this, <a href="https://github.com/ulagbulag/wasmtime/commit/cfcd2c2b0510e9d5204a76c72511d8e7bb94437b#diff-630bd5721d6bf4bf6207421fdc136ec68af4fe9182940ec5268dbe4379209d2eR913">I implemented buddy methods like the one</a> that work correctly even in <code>!Send</code> environments. It's less of a new invention and more of a clone of the existing code adapted for <code>!Send</code>.</p>
<ul>
<li><a href="https://github.com/ulagbulag/wasmtime/commit/cfcd2c2b0510e9d5204a76c72511d8e7bb94437b">https://github.com/ulagbulag/wasmtime/commit/cfcd2c2b0510e9d5204a76c72511d8e7bb94437b</a></li>
</ul>
<p>Finally, for types like <code>trait Stream</code>, the <code>Send</code> constraint isn't tied to the struct itself but to its implementation, which makes workarounds like <code>unsafe impl Send for &lt;my types&gt;</code> fundamentally impossible. While this is arguably a positive side effect of <code>Send</code>’s strictness, it also means we can’t bypass it even when we're sure the code will never leave the current thread.</p>
<p>Just to share a personal thought: I believe the implementation is fairly straightforward and easy to follow. A prototype is available at the link above, and buddy versions of the multi-stage test code are also planned. I’d love your take on whether you think this should go through an RFC, or if it’s fine to submit as a plain PR.</p>
</blockquote>



<a name="527518435"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/527518435" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#527518435">(Jul 07 2025 at 16:42)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11170#issuecomment-3045880805">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<p>Personally I feel that duplicating Wasmtime's API surface area needs to be very well motivated and ideally is something we can avoid. To that end I'd agree with @pchickey that, while not great, <code>unsafe impl Send</code> is hopefully the way to go. To that ened @HoKim98 I'd like to dig in to why this workaround does not work. Can you share example code?</p>
<p>I agree that your patch is relatively small and looks easy to apply. Where I would disagree I think is how that would be maintained over time:</p>
<ul>
<li>Wasmtime already has a 2x API surface area with sync and async, and this would become 3x with sync, async, and async-send.</li>
<li>Your patch does not include any tests, and extensively testing both sync and async is not trivial (e.g. adding async + async-send tests would not be trivial).</li>
<li>The correctness of your change relies on the two async methods being basically the same over time, and there is no guarantee that this is the case. There's a likely possibility that they diverge over time and there are little protections against this.</li>
</ul>
<p>These are not necessarily showstoppers but to me this is a high bar to clear, possibly higher than you're anticipating. Maintenance over time is an important factor to deciding on API surface area and that's one of my chief concerns here.</p>
<blockquote>
<p>I found that the core on_fiber method has evolved over the past year to the point where it has no real dependency on Send</p>
</blockquote>
<p>There is a long comment <a href="https://github.com/bytecodealliance/wasmtime/blob/5bb5d0080c97d291a7127436884cc50cce084716/crates/wasmtime/src/runtime/fiber.rs#L489-L542">here</a> about this. Yes <code>Send</code> can be removed, no it is not sound to remove it.</p>
</blockquote>



<a name="528773338"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/528773338" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#528773338">(Jul 15 2025 at 03:31)</a>:</h4>
<p>HoKim98 <a href="https://github.com/bytecodealliance/wasmtime/issues/11170#issuecomment-3071771109">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<p>Hello @alexcrichton , thanks for sharing a great inspection.</p>
<p>I have actively reviewed your suggestion. I completely agree that each of the three milestones you suggested is a big deal and difficult to maintain.</p>
<blockquote>
<p>Can you share example code?</p>
</blockquote>
<p>I create a sample project that I suffer from: <a href="https://github.com/HoKim98/my-actix-wasm-project">https://github.com/HoKim98/my-actix-wasm-project</a></p>
<ul>
<li>Especially: <a href="https://github.com/HoKim98/my-actix-wasm-project/blob/3916e63ff067bb6c46f700c5179f93ca91e68ed0/src/main.rs#L67">https://github.com/HoKim98/my-actix-wasm-project/blob/3916e63ff067bb6c46f700c5179f93ca91e68ed0/src/main.rs#L67</a></li>
</ul>
<p>If this problem could be solved simply, at least for me, I would no longer need this issue.</p>
</blockquote>



<a name="528773344"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/528773344" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#528773344">(Jul 15 2025 at 03:31)</a>:</h4>
<p>HoKim98 edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/11170#issuecomment-3071771109">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<p>Hello @alexcrichton , thanks for sharing a great inspection.</p>
<p>I have actively reviewed your suggestion. I completely agree that each of the three milestones you suggested is a big deal and difficult to maintain.</p>
<blockquote>
<p>Can you share example code?</p>
</blockquote>
<p>I created a sample project that I suffer from: <a href="https://github.com/HoKim98/my-actix-wasm-project">https://github.com/HoKim98/my-actix-wasm-project</a></p>
<ul>
<li>Especially: <a href="https://github.com/HoKim98/my-actix-wasm-project/blob/3916e63ff067bb6c46f700c5179f93ca91e68ed0/src/main.rs#L67">https://github.com/HoKim98/my-actix-wasm-project/blob/3916e63ff067bb6c46f700c5179f93ca91e68ed0/src/main.rs#L67</a></li>
</ul>
<p>If this problem could be solved simply, at least for me, I would no longer need this issue.</p>
</blockquote>



<a name="528882420"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/528882420" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#528882420">(Jul 15 2025 at 15:02)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11170#issuecomment-3073987908">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<p>For any variables live over that <code>.await</code> point, you'll need to use something like:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">UnsafeSend</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="k">unsafe</span><span class="w"> </span><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">Send</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">UnsafeSend</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{}</span>
</code></pre></div>
<p>and wrap live variables in <code>UnsafeSend</code> followed by accessing them through the <code>UnsafeSend</code> afterwards. In theory that should resolve the issue.</p>
</blockquote>



<a name="529859341"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/529859341" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#529859341">(Jul 21 2025 at 11:00)</a>:</h4>
<p>HoKim98 closed <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<h4>Feature</h4>
<p>I want to use <code>wasmtime</code> in <code>actix-web</code>, which uses <code>!Send</code> runtime and resources such as <code>HTTPRequest</code> and <code>web::Payload</code>.</p>
<p>But the current runtime requires functions and states to be <code>Send</code>able.</p>
<p>I thought it's not mandatory to enforce <code>Send</code> trait.<br>
So I have tested on my local without <code>Send</code> and found no problem.</p>
<h4>Benefit</h4>
<p>We can use <code>wasmtime</code> in the thread-bounded (single-threaded) async runtimes.</p>
<p>It's essential to use <code>wasmtime</code> within <code>actix</code> ecosystem, which provides the input parameters as <code>!Send</code>.</p>
<h4>Implementation</h4>
<p>My current(initial) idea is to create buddy methods like below:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="sd">/// Original method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span>
<span class="k">where</span>
<span class="w">    </span><span class="n">T</span><span class="p">:</span><span class="w"> </span><span class="nb">Send</span><span class="p">,</span>
<span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span><span class="p">.</span><span class="n">on_fiber</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl</span><span class="p">(</span><span class="n">store</span><span class="p">)).</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>

<span class="sd">/// (New) buddy method</span>
<span class="k">pub</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">instantiate_async_single_rt</span><span class="p">(</span>
<span class="w">    </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span>
<span class="w">    </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="n">AsContextMut</span><span class="o">&lt;</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Instance</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span><span class="p">.</span><span class="n">as_context_mut</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert!</span><span class="p">(</span>
<span class="w">        </span><span class="n">store</span><span class="p">.</span><span class="mf">0.</span><span class="n">async_support</span><span class="p">(),</span>
<span class="w">        </span><span class="s">"must use sync instantiation when async support is disabled"</span>
<span class="w">    </span><span class="p">);</span>
<span class="w">    </span><span class="n">store</span>
<span class="w">        </span><span class="p">.</span><span class="n">on_fiber_single_rt</span><span class="p">(</span><span class="o">|</span><span class="n">store</span><span class="o">|</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">instantiate_impl_single_rt</span><span class="p">(</span><span class="n">store</span><span class="p">))</span>
<span class="w">        </span><span class="p">.</span><span class="k">await</span><span class="o">?</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>The estimated number of new lines: 100~500</li>
<li>Side-effect: no</li>
</ul>
<h4>Alternatives</h4>
<p>My another idea is to use cargo features like <code>async-send</code>.<br>
But I think it may break the ecosystem (side-effect).<br>
</p>
</blockquote>



<a name="529859351"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311170%20Single-threaded%20async%20runtime/near/529859351" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311170.20Single-threaded.20async.20runtime.html#529859351">(Jul 21 2025 at 11:00)</a>:</h4>
<p>HoKim98 <a href="https://github.com/bytecodealliance/wasmtime/issues/11170#issuecomment-3096213247">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11170">issue #11170</a>:</p>
<blockquote>
<p>Thank you @alexcrichton it helped me a lot!</p>
</blockquote>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>