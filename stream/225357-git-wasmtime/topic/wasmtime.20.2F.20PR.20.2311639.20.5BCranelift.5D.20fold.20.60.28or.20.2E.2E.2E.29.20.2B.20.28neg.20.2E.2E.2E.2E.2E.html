<html>
<head><meta charset="utf-8"><title>wasmtime / PR #11639 [Cranelift] fold `(or ...) + (neg ..... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311639.20.5BCranelift.5D.20fold.20.60.28or.20.2E.2E.2E.29.20.2B.20.28neg.20.2E.2E.2E.2E.2E.html">wasmtime / PR #11639 [Cranelift] fold `(or ...) + (neg .....</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="538222551"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311639%20%5BCranelift%5D%20fold%20%60%28or%20...%29%20%2B%20%28neg%20...../near/538222551" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311639.20.5BCranelift.5D.20fold.20.60.28or.20.2E.2E.2E.29.20.2B.20.28neg.20.2E.2E.2E.2E.2E.html#538222551">(Sep 08 2025 at 13:11)</a>:</h4>
<p>bongjunj opened <a href="https://github.com/bytecodealliance/wasmtime/pull/11639">PR #11639</a> from <code>bongjunj:fold-add-or-neg</code> to <code>bytecodealliance:main</code>:</p>
<blockquote>
<p>&lt;!--<br>
Please make sure you include the following information:</p>
<ul>
<li>
<p>If this work has been discussed elsewhere, please include a link to that<br>
  conversation. If it was discussed in an issue, just mention "issue #...".</p>
</li>
<li>
<p>Explain why this change is needed. If the details are in an issue already,<br>
  this can be brief.</p>
</li>
</ul>
<p>Our development process is documented in the Wasmtime book:<br>
<a href="https://docs.wasmtime.dev/contributing-development-process.html">https://docs.wasmtime.dev/contributing-development-process.html</a></p>
<p>Please ensure all communication follows the code of conduct:<br>
<a href="https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>
--&gt;</p>
<p>This adds <code>(rule (simplify (iadd ty (bor ty x y) (ineg ty y))) (band ty x (bnot ty y)))</code></p>
</blockquote>



<a name="538222553"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311639%20%5BCranelift%5D%20fold%20%60%28or%20...%29%20%2B%20%28neg%20...../near/538222553" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311639.20.5BCranelift.5D.20fold.20.60.28or.20.2E.2E.2E.29.20.2B.20.28neg.20.2E.2E.2E.2E.2E.html#538222553">(Sep 08 2025 at 13:11)</a>:</h4>
<p><strong>bongjunj</strong> requested <a href="https://github.com/alexcrichton">alexcrichton</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/11639">PR #11639</a>.</p>



<a name="538222554"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311639%20%5BCranelift%5D%20fold%20%60%28or%20...%29%20%2B%20%28neg%20...../near/538222554" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311639.20.5BCranelift.5D.20fold.20.60.28or.20.2E.2E.2E.29.20.2B.20.28neg.20.2E.2E.2E.2E.2E.html#538222554">(Sep 08 2025 at 13:11)</a>:</h4>
<p><strong>bongjunj</strong> requested <a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers">wasmtime-compiler-reviewers</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/11639">PR #11639</a>.</p>



<a name="538224951"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311639%20%5BCranelift%5D%20fold%20%60%28or%20...%29%20%2B%20%28neg%20...../near/538224951" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311639.20.5BCranelift.5D.20fold.20.60.28or.20.2E.2E.2E.29.20.2B.20.28neg.20.2E.2E.2E.2E.2E.html#538224951">(Sep 08 2025 at 13:21)</a>:</h4>
<p>bongjunj <a href="https://github.com/bytecodealliance/wasmtime/pull/11639#issuecomment-3266285294">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/11639">PR #11639</a>:</p>
<blockquote>
<p>Seems like <code>iadd ... (ineg ty y)</code> -&gt; <code>isub ... y</code> wins over this rule.</p>
</blockquote>



<a name="538244325"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311639%20%5BCranelift%5D%20fold%20%60%28or%20...%29%20%2B%20%28neg%20...../near/538244325" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311639.20.5BCranelift.5D.20fold.20.60.28or.20.2E.2E.2E.29.20.2B.20.28neg.20.2E.2E.2E.2E.2E.html#538244325">(Sep 08 2025 at 14:39)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/pull/11639#issuecomment-3266649251">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/11639">PR #11639</a>:</p>
<blockquote>
<p>That might be fixable by adjusting the per-opcode costs perhaps? We could make arithmetic operations like iadd/isub slightly more costly than bitwise operations like band/bnot perhaps</p>
</blockquote>



<a name="538260534"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311639%20%5BCranelift%5D%20fold%20%60%28or%20...%29%20%2B%20%28neg%20...../near/538260534" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311639.20.5BCranelift.5D.20fold.20.60.28or.20.2E.2E.2E.29.20.2B.20.28neg.20.2E.2E.2E.2E.2E.html#538260534">(Sep 08 2025 at 15:43)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/11639#issuecomment-3266902300">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/11639">PR #11639</a>:</p>
<blockquote>
<p>I'll note that the mid-end does keep both around, rather than destructively rewriting (because egraphs!), so in the future if we have a more sophisticated cost function extractor there may be cases for both -- e.g. if the slightly more expensive form uses partial results that are already computed somewhere else. Perhaps different ISAs will have different cost functions too (they should all be 1-cycle ALU ops on any reasonable machine, but maybe some combinations of instructions fold together or compressed instruction forms are available or ...).</p>
<p>All that said, I'm curious @bongjunj -- are you driving your exploration with some sort of overall goodness metric? In other words, are you finding any and all equivalences, or is your goal to find those that seem to simplify somehow? And for this particular one, did you see instances where it leads to useful simplifications?</p>
<p>(I'm not opposed at all to building up a nice database of simplifications in general; as we've sometimes said, "rules are cheap" with ISLE's DSL compiler combining their matching. Just curious where all this is going.)</p>
</blockquote>



<a name="538261354"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311639%20%5BCranelift%5D%20fold%20%60%28or%20...%29%20%2B%20%28neg%20...../near/538261354" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311639.20.5BCranelift.5D.20fold.20.60.28or.20.2E.2E.2E.29.20.2B.20.28neg.20.2E.2E.2E.2E.2E.html#538261354">(Sep 08 2025 at 15:45)</a>:</h4>
<p>github-actions[bot] <a href="https://github.com/bytecodealliance/wasmtime/pull/11639#issuecomment-3266913633">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/11639">PR #11639</a>:</p>
<blockquote>
<h4>Subscribe to Label Action</h4>
<p>cc @cfallin, @fitzgen</p>
<p>&lt;details&gt;<br>
This issue or pull request has been labeled: "cranelift", "isle"</p>
<p>Thus the following users have been cc'd because of the following labels:</p>
<ul>
<li>cfallin: isle</li>
<li>fitzgen: isle</li>
</ul>
<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>
<p><a href="https://github.com/bytecodealliance/subscribe-to-label-action">Learn more.</a><br>
&lt;/details&gt;</p>
</blockquote>



<a name="538333129"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311639%20%5BCranelift%5D%20fold%20%60%28or%20...%29%20%2B%20%28neg%20...../near/538333129" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311639.20.5BCranelift.5D.20fold.20.60.28or.20.2E.2E.2E.29.20.2B.20.28neg.20.2E.2E.2E.2E.2E.html#538333129">(Sep 09 2025 at 00:34)</a>:</h4>
<p>bongjunj <a href="https://github.com/bytecodealliance/wasmtime/pull/11639#issuecomment-3268452107">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/11639">PR #11639</a>:</p>
<blockquote>
<p>Just realized that this is another version of the simplification of <a href="https://github.com/bytecodealliance/wasmtime/pull/10979">https://github.com/bytecodealliance/wasmtime/pull/10979</a></p>
<p>In addition, to @cfallin's comment, all my simplification rules are inspired by LLVM InstCombine rules.<br>
For example, this particular rule resembles the LLVM optimization of the following:</p>
<div class="codehilite" data-code-language="LLVM"><pre><span></span><code><span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@src</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%A</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%B</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%A</span><span class="p">,</span><span class="w"> </span><span class="m">123</span>
<span class="w">  </span><span class="nv">%C</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%B</span><span class="p">,</span><span class="w"> </span><span class="m">-123</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%C</span>
<span class="p">}</span>

<span class="k">define</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="vg">@tgt</span><span class="p">(</span><span class="kt">i32</span><span class="w"> </span><span class="nv">%A</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">%C</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%A</span><span class="p">,</span><span class="w"> </span><span class="m">-124</span>
<span class="w">  </span><span class="k">ret</span><span class="w"> </span><span class="kt">i32</span><span class="w"> </span><span class="nv">%C</span>
<span class="p">}</span>
</code></pre></div>
<p>(<a href="https://alive2.llvm.org/ce/z/QY4j7V">https://alive2.llvm.org/ce/z/QY4j7V</a>)</p>
<p>So basically, what I'm doing now is observe the discrepancy between the LLVM InstCombine pass and Cranelift's mid-end optimizer and then add rules to Cranelift for such missed optimization opportunities. In other words, the good metric we are looking for here is kind of "LLVM-ness". But I'm not sure how we can measure the usefulness of (with a well-established metric), or find an instance of this particular rule.</p>
</blockquote>



<a name="538467753"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311639%20%5BCranelift%5D%20fold%20%60%28or%20...%29%20%2B%20%28neg%20...../near/538467753" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311639.20.5BCranelift.5D.20fold.20.60.28or.20.2E.2E.2E.29.20.2B.20.28neg.20.2E.2E.2E.2E.2E.html#538467753">(Sep 09 2025 at 15:38)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/11639#issuecomment-3271274159">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/11639">PR #11639</a>:</p>
<blockquote>
<blockquote>
<p>So basically, what I'm doing now is observe the discrepancy between the LLVM InstCombine pass and Cranelift's mid-end optimizer and then add rules to Cranelift for such missed optimization opportunities. In other words, the good metric we are looking for here is kind of "LLVM-ness". </p>
</blockquote>
<p>That sounds great, then! I wanted to make sure we had some ground truth indicating these rewrites could be useful, and "LLVM does it" is a very strong argument for that. Thanks for putting in this effort!</p>
</blockquote>



<a name="538468693"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311639%20%5BCranelift%5D%20fold%20%60%28or%20...%29%20%2B%20%28neg%20...../near/538468693" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311639.20.5BCranelift.5D.20fold.20.60.28or.20.2E.2E.2E.29.20.2B.20.28neg.20.2E.2E.2E.2E.2E.html#538468693">(Sep 09 2025 at 15:42)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/pull/11639#issuecomment-3271294569">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/11639">PR #11639</a>:</p>
<blockquote>
<p>To the immediate question of making this rule actually fire: since we already rewrite <code>(iadd _ x (ineg _ y))</code> to <code>(isub _ x y)</code>, could you rewrite the left-hand side to cascade on that, and match on <code>(isub _ (bor _ x y) y)</code>?</p>
</blockquote>



<a name="538497423"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2311639%20%5BCranelift%5D%20fold%20%60%28or%20...%29%20%2B%20%28neg%20...../near/538497423" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2311639.20.5BCranelift.5D.20fold.20.60.28or.20.2E.2E.2E.29.20.2B.20.28neg.20.2E.2E.2E.2E.2E.html#538497423">(Sep 09 2025 at 17:54)</a>:</h4>
<p>fitzgen <a href="https://github.com/bytecodealliance/wasmtime/pull/11639#issuecomment-3271729506">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/11639">PR #11639</a>:</p>
<blockquote>
<p>Small clarification on the following, because I think it is pretty important when we are talking about rewrites that aren't necessarily beneficial on their own:</p>
<blockquote>
<p>I'm not opposed at all to building up a nice database of simplifications in general; as we've sometimes said, "rules are cheap" with ISLE's DSL compiler combining their matching.</p>
</blockquote>
<p>Rules are cheap, <em>but e-nodes are expensive</em>. (At least, expensive relative to rules, and there is always the risk of accidentally expanding to exponential numbers of e-nodes, which can be subtly easy to do.)</p>
<p>So adding all the commutative versions of a beneficial simplification is cheap, but adding basic commutation rules for every commutative operation (e.g. <code>a+b --&gt; b+a</code> and <code>a|b --&gt; b|a</code>) is expensive.</p>
<p>Similarly, if we have an input <code>A</code> that matches rule <code>r</code> to produce <code>B</code> which then matches rule <code>s</code> to produce the final output <code>C</code> (<code>A --r--&gt; B --s--&gt; C</code>) then creating a "macro rule" that composes <code>r</code> and <code>s</code> (<code>A --rs--&gt; C</code>) is a win in our system (from a cost perspective) since we are trading away an intermediate e-node (expensive) for an additional rule (cheap).[^0]</p>
<p>[^0]: It would be <em>super</em> cool if, given an input set of basic rules, the ISLE compiler automatically derived a set of macro rules based on them. Seems like a potentially fun/fruitful research project.</p>
<p>So adding rules that create new e-nodes because <em>maybe</em> they will be useful for some other beneficial rewrite, but aren't beneficial on their own, is something that should ultimately be approached with care. That doesn't mean we shouldn't ever do it, but we should at least put in the effort to check that there actually exists another beneficial rewrite that could fire afterwards, and make sure it isn't too general such that it will result in tons of intermediate e-nodes that might not actually lead to some other beneficial rule firing.</p>
</blockquote>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>