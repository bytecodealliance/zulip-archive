<html>
<head><meta charset="utf-8"><title>wasmtime / issue #12458 `wasi-http` not handling 0-length... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312458.20.60wasi-http.60.20not.20handling.200-length.2E.2E.2E.html">wasmtime / issue #12458 `wasi-http` not handling 0-length...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="570461026"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312458%20%60wasi-http%60%20not%20handling%200-length.../near/570461026" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312458.20.60wasi-http.60.20not.20handling.200-length.2E.2E.2E.html#570461026">(Jan 28 2026 at 03:11)</a>:</h4>
<p><a href="https://github.com/karthik-phl">karthik-phl</a> added the bug label to <a href="https://github.com/bytecodealliance/wasmtime/issues/12458">Issue #12458</a>.</p>



<a name="570461027"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312458%20%60wasi-http%60%20not%20handling%200-length.../near/570461027" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312458.20.60wasi-http.60.20not.20handling.200-length.2E.2E.2E.html#570461027">(Jan 28 2026 at 03:11)</a>:</h4>
<p>karthik-phl opened <a href="https://github.com/bytecodealliance/wasmtime/issues/12458">issue #12458</a>:</p>
<blockquote>
<p>Thanks for filing a bug report! Please fill out the TODOs below.</p>
<p><strong>Note: if you want to report a security issue, please read our <a href="https://bytecodealliance.org/security">security policy</a>!</strong></p>
<h3>Test Case</h3>
<p>Use <code>Reqwest</code> for outbound HTTP calls that are sent by the <code>wasi-http</code> host </p>
<h3>Steps to Reproduce</h3>
<ul>
<li>
<p>We've created an implementation of the <code>wasi-http</code> host that uses <code>Reqwest 0.13</code> for outbound calls. When using <code>wit-bindgen's</code>  async-stream support to process the response of an outbound call through the host, we found that wasmtime encounters a situation that causes the guest module to crash.</p>
</li>
<li>
<p>Upon further investigation, we found that Reqwest sends a 0-length frame when the end of stream is reached, which is not handled by the <code>poll_produce</code> method of <code>StreamProducer</code>. I think wasmtime should handle this case explicitly and prevent the guest from crashing, and I'm happy to create a PR with this change.</p>
</li>
</ul>
<h3>Expected Results</h3>
<p>The WASM guest should be able to <code>collect</code> the <code>stream</code> results and continue processing</p>
<h3>Actual Results</h3>
<p>The WASM guest crashes abruptly</p>
<h3>Versions and Environment</h3>
<p>Wasmtime version or commit: 41.0.x</p>
</blockquote>



<a name="570494289"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312458%20%60wasi-http%60%20not%20handling%200-length.../near/570494289" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312458.20.60wasi-http.60.20not.20handling.200-length.2E.2E.2E.html#570494289">(Jan 28 2026 at 08:18)</a>:</h4>
<p>karthik-phl edited <a href="https://github.com/bytecodealliance/wasmtime/issues/12458">issue #12458</a>:</p>
<blockquote>
<p>Thanks for filing a bug report! Please fill out the TODOs below.</p>
<p><strong>Note: if you want to report a security issue, please read our <a href="https://bytecodealliance.org/security">security policy</a>!</strong></p>
<h3>Test Case</h3>
<p>Use <code>Reqwest</code> for outbound HTTP calls that are sent by the <code>wasi-http</code> host </p>
<h3>Steps to Reproduce</h3>
<ul>
<li>
<p>We've created an implementation of the <code>wasi-http</code> host that uses <code>Reqwest 0.13</code> for outbound calls. When using <code>wit-bindgen's</code>  async-stream support to process the response of an outbound call through the host, we found that wasmtime encounters a situation that causes the guest module to crash.</p>
</li>
<li>
<p>Upon further investigation, we found that Reqwest sends a 0-length frame when the end of stream is reached, which is not handled by the <code>poll_produce</code> method of <code>StreamProducer</code>. I think wasmtime should handle this case explicitly and prevent the guest from crashing, and I'm happy to create a PR with this change.</p>
</li>
<li>
<p>The following <code>test</code> that can be added to <code>wasi-http/tests/all/p3/mod.rs</code> to simulate the condition that's triggered by the use of a library like <code>Reqwest</code>. Running the test with <code>cargo test -p wasmtime-wasi-http --features p3 --test all p3_http_empty_frame_at_end_of_stream -- --nocapture</code> should indicate the error.</p>
</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">pin</span><span class="p">::</span><span class="n">Pin</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span><span class="w"> </span><span class="n">Poll</span><span class="p">};</span>

<span class="c1">// Custom body wrapper that sends an empty frame at EOS while reporting is_end_stream() = true</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BodyWithEmptyFrameAtEos</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">inner</span><span class="p">:</span><span class="w"> </span><span class="nc">http_body_util</span><span class="p">::</span><span class="n">StreamBody</span><span class="o">&lt;</span>
<span class="w">        </span><span class="n">futures</span><span class="p">::</span><span class="n">channel</span><span class="p">::</span><span class="n">mpsc</span><span class="p">::</span><span class="n">Receiver</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">http_body</span><span class="p">::</span><span class="n">Frame</span><span class="o">&lt;</span><span class="n">Bytes</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">ErrorCode</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">sent_empty</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span>
<span class="w">    </span><span class="n">at_eos</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">http_body</span><span class="p">::</span><span class="n">Body</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BodyWithEmptyFrameAtEos</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bytes</span><span class="p">;</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ErrorCode</span><span class="p">;</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">poll_frame</span><span class="p">(</span>
<span class="w">        </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">:</span><span class="w"> </span><span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">        </span><span class="n">cx</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">http_body</span><span class="p">::</span><span class="n">Frame</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">::</span><span class="n">Data</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// First, poll the underlying body</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="p">;</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">Pin</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">inner</span><span class="p">).</span><span class="n">poll_frame</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Poll</span><span class="p">::</span><span class="n">Ready</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">this</span><span class="p">.</span><span class="n">sent_empty</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// When the underlying body ends, send an empty frame</span>
<span class="w">                </span><span class="c1">// This simulates HTTP implementations that send empty frames at EOS</span>
<span class="w">                </span><span class="n">this</span><span class="p">.</span><span class="n">sent_empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">                </span><span class="n">this</span><span class="p">.</span><span class="n">at_eos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">                </span><span class="n">Poll</span><span class="p">::</span><span class="n">Ready</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="nb">Ok</span><span class="p">(</span><span class="n">http_body</span><span class="p">::</span><span class="n">Frame</span><span class="p">::</span><span class="n">data</span><span class="p">(</span><span class="n">Bytes</span><span class="p">::</span><span class="n">new</span><span class="p">()))))</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">other</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_end_stream</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Report end of stream once we've reached it</span>
<span class="w">        </span><span class="c1">// This ensures is_end_stream() = true when we send the empty frame</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">at_eos</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test_log::test(tokio::test(flavor = </span><span class="s">"multi_thread"</span><span class="cp">))]</span>
<span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">p3_http_empty_frame_at_end_of_stream</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env_logger</span><span class="p">::</span><span class="n">try_init</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// This test verifies the fix which handles the case where a zero-length frame is</span>
<span class="w">    </span><span class="c1">// received when is_end_stream() is true. Without the fix, the StreamProducer would</span>
<span class="w">    </span><span class="c1">// crash when the WASM guest tries to read such a frame.</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b"test"</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">raw_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bytes</span><span class="p">::</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">body_tx</span><span class="p">,</span><span class="w"> </span><span class="n">body_rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">futures</span><span class="p">::</span><span class="n">channel</span><span class="p">::</span><span class="n">mpsc</span><span class="p">::</span><span class="n">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">ErrorCode</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapped_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BodyWithEmptyFrameAtEos</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">inner</span><span class="p">:</span><span class="w"> </span><span class="nc">http_body_util</span><span class="p">::</span><span class="n">StreamBody</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">body_rx</span><span class="p">),</span>
<span class="w">        </span><span class="n">sent_empty</span><span class="p">:</span><span class="w"> </span><span class="nc">false</span><span class="p">,</span>
<span class="w">        </span><span class="n">at_eos</span><span class="p">:</span><span class="w"> </span><span class="nc">false</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">http</span><span class="p">::</span><span class="n">Request</span><span class="p">::</span><span class="n">builder</span><span class="p">()</span>
<span class="w">        </span><span class="p">.</span><span class="n">uri</span><span class="p">(</span><span class="s">"http://localhost/"</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">method</span><span class="p">(</span><span class="n">http</span><span class="p">::</span><span class="n">Method</span><span class="p">::</span><span class="n">GET</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Use the echo component which actually reads from the stream</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">futures</span><span class="p">::</span><span class="n">join</span><span class="o">!</span><span class="p">(</span>
<span class="w">        </span><span class="n">run_http</span><span class="p">(</span>
<span class="w">            </span><span class="n">P3_HTTP_ECHO_COMPONENT</span><span class="p">,</span>
<span class="w">            </span><span class="n">request</span><span class="p">.</span><span class="n">body</span><span class="p">(</span><span class="n">wrapped_body</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
<span class="w">            </span><span class="n">oneshot</span><span class="p">::</span><span class="n">channel</span><span class="p">().</span><span class="mi">0</span>
<span class="w">        </span><span class="p">),</span>
<span class="w">        </span><span class="k">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">body_tx</span>
<span class="w">                </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="nb">Ok</span><span class="p">(</span><span class="n">http_body</span><span class="p">::</span><span class="n">Frame</span><span class="p">::</span><span class="n">data</span><span class="p">(</span><span class="n">raw_body</span><span class="p">)))</span>
<span class="w">                </span><span class="p">.</span><span class="k">await</span>
<span class="w">                </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">            </span><span class="nb">drop</span><span class="p">(</span><span class="n">body_tx</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="mi">0</span><span class="o">?</span>
<span class="w">    </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">status</span><span class="p">().</span><span class="n">as_u16</span><span class="p">(),</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Verify the body was echoed correctly (empty frames should be filtered out by the fix)</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">collected_body</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">response</span><span class="p">.</span><span class="n">into_parts</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">collected_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collected_body</span><span class="p">.</span><span class="n">to_bytes</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">collected_body</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">.</span><span class="n">as_slice</span><span class="p">());</span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div>
<h3>Expected Results</h3>
<p>The WASM guest should be able to <code>collect</code> the <code>stream</code> results and continue processing</p>
<h3>Actual Results</h3>
<p>The WASM guest crashes abruptly</p>
<h3>Versions and Environment</h3>
<p>Wasmtime version or commit: 41.0.x</p>
</blockquote>



<a name="570508048"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312458%20%60wasi-http%60%20not%20handling%200-length.../near/570508048" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312458.20.60wasi-http.60.20not.20handling.200-length.2E.2E.2E.html#570508048">(Jan 28 2026 at 09:32)</a>:</h4>
<p>karthik-phl edited <a href="https://github.com/bytecodealliance/wasmtime/issues/12458">issue #12458</a>:</p>
<blockquote>
<p>Thanks for filing a bug report! Please fill out the TODOs below.</p>
<p><strong>Note: if you want to report a security issue, please read our <a href="https://bytecodealliance.org/security">security policy</a>!</strong></p>
<h3>Test Case</h3>
<p>Use <code>Reqwest</code> for outbound HTTP calls that are sent by the <code>wasi-http</code> host </p>
<h3>Steps to Reproduce</h3>
<ul>
<li>
<p>We've created an implementation of the <code>wasi-http</code> host that uses <code>Reqwest 0.13</code> for outbound calls. When using <code>wit-bindgen's</code>  async-stream support to process the response of an outbound call through the host, we found that wasmtime encounters a situation that causes the guest module to crash.</p>
</li>
<li>
<p>Upon further investigation, we found that Reqwest sends a 0-length frame when the end of stream is reached, which is not handled by the <code>poll_produce</code> method of <code>StreamProducer</code>. I think wasmtime should handle this case explicitly and prevent the guest from crashing, and I'm happy to create a PR with this change.</p>
</li>
<li>
<p>The following <code>test</code> that can be added to <code>wasi-http/tests/all/p3/mod.rs</code> to simulate the condition that's triggered by the use of a library like <code>Reqwest</code>. Running the test with <code>cargo test -p wasmtime-wasi-http --features p3 --test all p3_http_empty_frame_at_end_of_stream -- --nocapture</code> should indicate the error.</p>
</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">pin</span><span class="p">::</span><span class="n">Pin</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span><span class="w"> </span><span class="n">Poll</span><span class="p">};</span>

<span class="c1">// Custom body wrapper that sends an empty frame at EOS while reporting is_end_stream() = true</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BodyWithEmptyFrameAtEos</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">inner</span><span class="p">:</span><span class="w"> </span><span class="nc">http_body_util</span><span class="p">::</span><span class="n">StreamBody</span><span class="o">&lt;</span>
<span class="w">        </span><span class="n">futures</span><span class="p">::</span><span class="n">channel</span><span class="p">::</span><span class="n">mpsc</span><span class="p">::</span><span class="n">Receiver</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">http_body</span><span class="p">::</span><span class="n">Frame</span><span class="o">&lt;</span><span class="n">Bytes</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">ErrorCode</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">sent_empty</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span>
<span class="w">    </span><span class="n">at_eos</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">http_body</span><span class="p">::</span><span class="n">Body</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BodyWithEmptyFrameAtEos</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bytes</span><span class="p">;</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ErrorCode</span><span class="p">;</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">poll_frame</span><span class="p">(</span>
<span class="w">        </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">:</span><span class="w"> </span><span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">        </span><span class="n">cx</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">http_body</span><span class="p">::</span><span class="n">Frame</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">::</span><span class="n">Data</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// First, poll the underlying body</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="p">;</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">Pin</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">inner</span><span class="p">).</span><span class="n">poll_frame</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Poll</span><span class="p">::</span><span class="n">Ready</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">this</span><span class="p">.</span><span class="n">sent_empty</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// When the underlying body ends, send an empty frame</span>
<span class="w">                </span><span class="c1">// This simulates HTTP implementations that send empty frames at EOS</span>
<span class="w">                </span><span class="n">this</span><span class="p">.</span><span class="n">sent_empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">                </span><span class="n">this</span><span class="p">.</span><span class="n">at_eos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">                </span><span class="n">Poll</span><span class="p">::</span><span class="n">Ready</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="nb">Ok</span><span class="p">(</span><span class="n">http_body</span><span class="p">::</span><span class="n">Frame</span><span class="p">::</span><span class="n">data</span><span class="p">(</span><span class="n">Bytes</span><span class="p">::</span><span class="n">new</span><span class="p">()))))</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">other</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_end_stream</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Report end of stream once we've reached it</span>
<span class="w">        </span><span class="c1">// This ensures is_end_stream() = true when we send the empty frame</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">at_eos</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test_log::test(tokio::test(flavor = </span><span class="s">"multi_thread"</span><span class="cp">))]</span>
<span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">p3_http_empty_frame_at_end_of_stream</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env_logger</span><span class="p">::</span><span class="n">try_init</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// This test verifies the fix which handles the case where a zero-length frame is</span>
<span class="w">    </span><span class="c1">// received when is_end_stream() is true. Without the fix, the StreamProducer would</span>
<span class="w">    </span><span class="c1">// crash when the WASM guest tries to read such a frame.</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b"test"</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">raw_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bytes</span><span class="p">::</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">body_tx</span><span class="p">,</span><span class="w"> </span><span class="n">body_rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">futures</span><span class="p">::</span><span class="n">channel</span><span class="p">::</span><span class="n">mpsc</span><span class="p">::</span><span class="n">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">ErrorCode</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapped_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BodyWithEmptyFrameAtEos</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">inner</span><span class="p">:</span><span class="w"> </span><span class="nc">http_body_util</span><span class="p">::</span><span class="n">StreamBody</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">body_rx</span><span class="p">),</span>
<span class="w">        </span><span class="n">sent_empty</span><span class="p">:</span><span class="w"> </span><span class="nc">false</span><span class="p">,</span>
<span class="w">        </span><span class="n">at_eos</span><span class="p">:</span><span class="w"> </span><span class="nc">false</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">http</span><span class="p">::</span><span class="n">Request</span><span class="p">::</span><span class="n">builder</span><span class="p">()</span>
<span class="w">        </span><span class="p">.</span><span class="n">uri</span><span class="p">(</span><span class="s">"http://localhost/"</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">method</span><span class="p">(</span><span class="n">http</span><span class="p">::</span><span class="n">Method</span><span class="p">::</span><span class="n">GET</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Use the echo component which actually reads from the stream</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">futures</span><span class="p">::</span><span class="n">join</span><span class="o">!</span><span class="p">(</span>
<span class="w">        </span><span class="n">run_http</span><span class="p">(</span>
<span class="w">            </span><span class="n">P3_HTTP_ECHO_COMPONENT</span><span class="p">,</span>
<span class="w">            </span><span class="n">request</span><span class="p">.</span><span class="n">body</span><span class="p">(</span><span class="n">wrapped_body</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
<span class="w">            </span><span class="n">oneshot</span><span class="p">::</span><span class="n">channel</span><span class="p">().</span><span class="mi">0</span>
<span class="w">        </span><span class="p">),</span>
<span class="w">        </span><span class="k">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">body_tx</span>
<span class="w">                </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="nb">Ok</span><span class="p">(</span><span class="n">http_body</span><span class="p">::</span><span class="n">Frame</span><span class="p">::</span><span class="n">data</span><span class="p">(</span><span class="n">raw_body</span><span class="p">)))</span>
<span class="w">                </span><span class="p">.</span><span class="k">await</span>
<span class="w">                </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">            </span><span class="nb">drop</span><span class="p">(</span><span class="n">body_tx</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="mi">0</span><span class="o">?</span>
<span class="w">    </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">status</span><span class="p">().</span><span class="n">as_u16</span><span class="p">(),</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Verify the body was echoed correctly (empty frames should be filtered out by the fix)</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">collected_body</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">response</span><span class="p">.</span><span class="n">into_parts</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">collected_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collected_body</span><span class="p">.</span><span class="n">to_bytes</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">collected_body</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">.</span><span class="n">as_slice</span><span class="p">());</span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div>
<p>Thanks for looking into this!</p>
<h3>Expected Results</h3>
<p>The WASM guest should be able to <code>collect</code> the <code>stream</code> results and continue processing</p>
<h3>Actual Results</h3>
<p>The WASM guest crashes abruptly</p>
<h3>Versions and Environment</h3>
<p>Wasmtime version or commit: 41.0.x</p>
</blockquote>



<a name="570853459"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312458%20%60wasi-http%60%20not%20handling%200-length.../near/570853459" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312458.20.60wasi-http.60.20not.20handling.200-length.2E.2E.2E.html#570853459">(Jan 29 2026 at 17:17)</a>:</h4>
<p><a href="https://github.com/fitzgen">fitzgen</a> added the wasi-http label to <a href="https://github.com/bytecodealliance/wasmtime/issues/12458">Issue #12458</a>.</p>



<a name="571115216"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312458%20%60wasi-http%60%20not%20handling%200-length.../near/571115216" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312458.20.60wasi-http.60.20not.20handling.200-length.2E.2E.2E.html#571115216">(Jan 30 2026 at 20:09)</a>:</h4>
<p>alexcrichton closed <a href="https://github.com/bytecodealliance/wasmtime/issues/12458">issue #12458</a>:</p>
<blockquote>
<p>Thanks for filing a bug report! Please fill out the TODOs below.</p>
<p><strong>Note: if you want to report a security issue, please read our <a href="https://bytecodealliance.org/security">security policy</a>!</strong></p>
<h3>Test Case</h3>
<p>Use <code>Reqwest</code> for outbound HTTP calls that are sent by the <code>wasi-http</code> host </p>
<h3>Steps to Reproduce</h3>
<ul>
<li>
<p>We've created an implementation of the <code>wasi-http</code> host that uses <code>Reqwest 0.13</code> for outbound calls. When using <code>wit-bindgen's</code>  async-stream support to process the response of an outbound call through the host, we found that wasmtime encounters a situation that causes the guest module to crash.</p>
</li>
<li>
<p>Upon further investigation, we found that Reqwest sends a 0-length frame when the end of stream is reached, which is not handled by the <code>poll_produce</code> method of <code>StreamProducer</code>. I think wasmtime should handle this case explicitly and prevent the guest from crashing, and I'm happy to create a PR with this change.</p>
</li>
<li>
<p>The following <code>test</code> that can be added to <code>wasi-http/tests/all/p3/mod.rs</code> to simulate the condition that's triggered by the use of a library like <code>Reqwest</code>. Running the test with <code>cargo test -p wasmtime-wasi-http --features p3 --test all p3_http_empty_frame_at_end_of_stream -- --nocapture</code> should indicate the error.</p>
</li>
</ul>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">pin</span><span class="p">::</span><span class="n">Pin</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span><span class="w"> </span><span class="n">Poll</span><span class="p">};</span>

<span class="c1">// Custom body wrapper that sends an empty frame at EOS while reporting is_end_stream() = true</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">BodyWithEmptyFrameAtEos</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">inner</span><span class="p">:</span><span class="w"> </span><span class="nc">http_body_util</span><span class="p">::</span><span class="n">StreamBody</span><span class="o">&lt;</span>
<span class="w">        </span><span class="n">futures</span><span class="p">::</span><span class="n">channel</span><span class="p">::</span><span class="n">mpsc</span><span class="p">::</span><span class="n">Receiver</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">http_body</span><span class="p">::</span><span class="n">Frame</span><span class="o">&lt;</span><span class="n">Bytes</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">ErrorCode</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="n">sent_empty</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span>
<span class="w">    </span><span class="n">at_eos</span><span class="p">:</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="w"> </span><span class="n">http_body</span><span class="p">::</span><span class="n">Body</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">BodyWithEmptyFrameAtEos</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bytes</span><span class="p">;</span>
<span class="w">    </span><span class="k">type</span><span class="w"> </span><span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ErrorCode</span><span class="p">;</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">poll_frame</span><span class="p">(</span>
<span class="w">        </span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">:</span><span class="w"> </span><span class="nc">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">Self</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">        </span><span class="n">cx</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="nc">mut</span><span class="w"> </span><span class="n">Context</span><span class="o">&lt;'</span><span class="nb">_</span><span class="o">&gt;</span><span class="p">,</span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Poll</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">http_body</span><span class="p">::</span><span class="n">Frame</span><span class="o">&lt;</span><span class="bp">Self</span><span class="p">::</span><span class="n">Data</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="bp">Self</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// First, poll the underlying body</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="o">*</span><span class="bp">self</span><span class="p">;</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">Pin</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">this</span><span class="p">.</span><span class="n">inner</span><span class="p">).</span><span class="n">poll_frame</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">Poll</span><span class="p">::</span><span class="n">Ready</span><span class="p">(</span><span class="nb">None</span><span class="p">)</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">!</span><span class="n">this</span><span class="p">.</span><span class="n">sent_empty</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// When the underlying body ends, send an empty frame</span>
<span class="w">                </span><span class="c1">// This simulates HTTP implementations that send empty frames at EOS</span>
<span class="w">                </span><span class="n">this</span><span class="p">.</span><span class="n">sent_empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">                </span><span class="n">this</span><span class="p">.</span><span class="n">at_eos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span>
<span class="w">                </span><span class="n">Poll</span><span class="p">::</span><span class="n">Ready</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="nb">Ok</span><span class="p">(</span><span class="n">http_body</span><span class="p">::</span><span class="n">Frame</span><span class="p">::</span><span class="n">data</span><span class="p">(</span><span class="n">Bytes</span><span class="p">::</span><span class="n">new</span><span class="p">()))))</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">other</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">other</span><span class="p">,</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="nf">is_end_stream</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Report end of stream once we've reached it</span>
<span class="w">        </span><span class="c1">// This ensures is_end_stream() = true when we send the empty frame</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">at_eos</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="cp">#[test_log::test(tokio::test(flavor = </span><span class="s">"multi_thread"</span><span class="cp">))]</span>
<span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">p3_http_empty_frame_at_end_of_stream</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env_logger</span><span class="p">::</span><span class="n">try_init</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// This test verifies the fix which handles the case where a zero-length frame is</span>
<span class="w">    </span><span class="c1">// received when is_end_stream() is true. Without the fix, the StreamProducer would</span>
<span class="w">    </span><span class="c1">// crash when the WASM guest tries to read such a frame.</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b"test"</span><span class="p">;</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">raw_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Bytes</span><span class="p">::</span><span class="n">copy_from_slice</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">body_tx</span><span class="p">,</span><span class="w"> </span><span class="n">body_rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">futures</span><span class="p">::</span><span class="n">channel</span><span class="p">::</span><span class="n">mpsc</span><span class="p">::</span><span class="n">channel</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">ErrorCode</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">wrapped_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BodyWithEmptyFrameAtEos</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">inner</span><span class="p">:</span><span class="w"> </span><span class="nc">http_body_util</span><span class="p">::</span><span class="n">StreamBody</span><span class="p">::</span><span class="n">new</span><span class="p">(</span><span class="n">body_rx</span><span class="p">),</span>
<span class="w">        </span><span class="n">sent_empty</span><span class="p">:</span><span class="w"> </span><span class="nc">false</span><span class="p">,</span>
<span class="w">        </span><span class="n">at_eos</span><span class="p">:</span><span class="w"> </span><span class="nc">false</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">request</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">http</span><span class="p">::</span><span class="n">Request</span><span class="p">::</span><span class="n">builder</span><span class="p">()</span>
<span class="w">        </span><span class="p">.</span><span class="n">uri</span><span class="p">(</span><span class="s">"http://localhost/"</span><span class="p">)</span>
<span class="w">        </span><span class="p">.</span><span class="n">method</span><span class="p">(</span><span class="n">http</span><span class="p">::</span><span class="n">Method</span><span class="p">::</span><span class="n">GET</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Use the echo component which actually reads from the stream</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">response</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">futures</span><span class="p">::</span><span class="n">join</span><span class="o">!</span><span class="p">(</span>
<span class="w">        </span><span class="n">run_http</span><span class="p">(</span>
<span class="w">            </span><span class="n">P3_HTTP_ECHO_COMPONENT</span><span class="p">,</span>
<span class="w">            </span><span class="n">request</span><span class="p">.</span><span class="n">body</span><span class="p">(</span><span class="n">wrapped_body</span><span class="p">)</span><span class="o">?</span><span class="p">,</span>
<span class="w">            </span><span class="n">oneshot</span><span class="p">::</span><span class="n">channel</span><span class="p">().</span><span class="mi">0</span>
<span class="w">        </span><span class="p">),</span>
<span class="w">        </span><span class="k">async</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">body_tx</span>
<span class="w">                </span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="nb">Ok</span><span class="p">(</span><span class="n">http_body</span><span class="p">::</span><span class="n">Frame</span><span class="p">::</span><span class="n">data</span><span class="p">(</span><span class="n">raw_body</span><span class="p">)))</span>
<span class="w">                </span><span class="p">.</span><span class="k">await</span>
<span class="w">                </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>
<span class="w">            </span><span class="nb">drop</span><span class="p">(</span><span class="n">body_tx</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">    </span><span class="p">.</span><span class="mi">0</span><span class="o">?</span>
<span class="w">    </span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">status</span><span class="p">().</span><span class="n">as_u16</span><span class="p">(),</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Verify the body was echoed correctly (empty frames should be filtered out by the fix)</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">collected_body</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">response</span><span class="p">.</span><span class="n">into_parts</span><span class="p">();</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">collected_body</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collected_body</span><span class="p">.</span><span class="n">to_bytes</span><span class="p">();</span>
<span class="w">    </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">collected_body</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">.</span><span class="n">as_slice</span><span class="p">());</span>
<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div>
<p>Thanks for looking into this!</p>
<h3>Expected Results</h3>
<p>The WASM guest should be able to <code>collect</code> the <code>stream</code> results and continue processing</p>
<h3>Actual Results</h3>
<p>The WASM guest crashes abruptly</p>
<h3>Versions and Environment</h3>
<p>Wasmtime version or commit: 41.0.x</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>