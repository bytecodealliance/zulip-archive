<html>
<head><meta charset="utf-8"><title>wasmtime / PR #12496 ComponentType: add as_val method to ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2312496.20ComponentType.3A.20add.20as_val.20method.20to.20.2E.2E.2E.html">wasmtime / PR #12496 ComponentType: add as_val method to ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="571517586"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2312496%20ComponentType%3A%20add%20as_val%20method%20to%20.../near/571517586" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2312496.20ComponentType.3A.20add.20as_val.20method.20to.20.2E.2E.2E.html#571517586">(Feb 02 2026 at 20:20)</a>:</h4>
<p>pchickey opened <a href="https://github.com/bytecodealliance/wasmtime/pull/12496">PR #12496</a> from <code>pchickey:component_type_to_val</code> to <code>bytecodealliance:main</code>:</p>
<blockquote>
<p>&lt;!--<br>
Please make sure you include the following information:</p>
<ul>
<li>
<p>If this work has been discussed elsewhere, please include a link to that<br>
  conversation. If it was discussed in an issue, just mention "issue #...".</p>
</li>
<li>
<p>Explain why this change is needed. If the details are in an issue already,<br>
  this can be brief.</p>
</li>
</ul>
<p>Our development process is documented in the Wasmtime book:<br>
<a href="https://docs.wasmtime.dev/contributing-development-process.html">https://docs.wasmtime.dev/contributing-development-process.html</a></p>
<p>Please ensure all communication follows the code of conduct:<br>
<a href="https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>
--&gt;</p>
</blockquote>



<a name="571517591"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2312496%20ComponentType%3A%20add%20as_val%20method%20to%20.../near/571517591" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2312496.20ComponentType.3A.20add.20as_val.20method.20to.20.2E.2E.2E.html#571517591">(Feb 02 2026 at 20:20)</a>:</h4>
<p><strong>pchickey</strong> requested <a href="https://github.com/alexcrichton">alexcrichton</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/12496">PR #12496</a>.</p>



<a name="571517593"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2312496%20ComponentType%3A%20add%20as_val%20method%20to%20.../near/571517593" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2312496.20ComponentType.3A.20add.20as_val.20method.20to.20.2E.2E.2E.html#571517593">(Feb 02 2026 at 20:20)</a>:</h4>
<p><strong>pchickey</strong> requested <a href="https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers">wasmtime-core-reviewers</a> for a review on <a href="https://github.com/bytecodealliance/wasmtime/pull/12496">PR #12496</a>.</p>



<a name="572038248"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2312496%20ComponentType%3A%20add%20as_val%20method%20to%20.../near/572038248" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2312496.20ComponentType.3A.20add.20as_val.20method.20to.20.2E.2E.2E.html#572038248">(Feb 05 2026 at 00:36)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/12496">PR #12496</a>.</p>



<a name="572044998"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2312496%20ComponentType%3A%20add%20as_val%20method%20to%20.../near/572044998" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2312496.20ComponentType.3A.20add.20as_val.20method.20to.20.2E.2E.2E.html#572044998">(Feb 05 2026 at 01:53)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/12496">PR #12496</a>:</p>
<blockquote>
<p>This PR adds the method <code>fn to_val&lt;S&gt;(&amp;self, store: StoreContextMut&lt;S&gt;) -&gt; Result&lt;Val&gt;</code> to wasmtime's <code>ComponentType</code> trait. This is a first step in a bigger project to provide better debugging facilities for wasmtime component model execution.</p>
<h2>Context</h2>
<p>Wasmtime separates component model values into two separate worlds:</p>
<ul>
<li>a typed representation, where Rust datatypes corresponding to component model types derive or impl the <code>ComponentType</code> trait, plus optionally the <code>Lift</code> and <code>Lower</code> traits (required to be used in arguments and return values of import functions, respectively) which provide wasmtime the means to convert to/from each Rust type and its canonical ABI representations. To use this representation for an import function wasmtime users use <code>wasmtime::component::Linker::func_wrap</code> and friends, and on an export function use <code>wasmtime::component::Instance::typed_func</code> and friends.</li>
<li>a tagged representation, where all component model types are represented using the different variants of the <code>wasmtime::component::Val</code> enum. To use this representation for an import function, wasmtime users use <code>wasmtime::component::Linker::func_new</code> and on an export <code>wasmtime::component::Instance::func</code>.</li>
</ul>
<p>Prior to this PR, users have to choose whether to opt into the typed representation or the tagged representation based on what their application needs, and we (the wasmtime developers) focused most of our efforts on the typed representation because that ends up being the right choice for most embedders.</p>
<p>Users of the typed representation do so almost exclusively through the use of <code>wasmtime::component::bindgen!</code>, a proc macro which generates Rust structs and enums corresponding to component model types it parses from wit, and delegates to the <code>#[derive(ComponentType, Lift, Lower)]</code> derive proc-macros in those generated types (which themselves also are provided by the wasmtime crate). This bindings generation typically takes place in library code, e.g. <code>wasmtime-wasi</code>, <code>wasmtime-wasi-http</code> and related crates, and <code>bindgen</code> takes a variety of options that influence exactly what sort of Rust representation to use for wit types - the <code>ComponentType</code> derive macros permit flexibility in various ways.</p>
<p>On the other hand, the tagged representation is useful for library code that exists independently from a given wit description. The library for a human-friendly serialization format for component model values <code>https://crates.io/crates/wasm-wave</code> exports some traits which wasmtime provides impls for in terms of <code>wasmtime::component::Val</code>.  Wave ends up being useful for features in <code>wasmtime-cli</code> like <code>wasmtime run --invoke ...</code>, which I introduced in <a href="https://github.com/bytecodealliance/wasmtime/pull/10054">https://github.com/bytecodealliance/wasmtime/pull/10054</a>. The C API, which is used for bindings to other languages, also uses the Val representation</p>
<p>In most Rust wasmtime embeddings the tagged representation isn't actually used much, because "serious" embeddings are all written in terms of the typed representation.</p>
<p>My goal is to create better debugging tools for wasmtime component model programs, providing wasmtime embedders and cli users with the capability to inspect, and eventually record/replay or modify component model values. Like the wave crate and invoke integration, debugging tools benefit from being independent of a given wit description. Debugging tools must integrate with wasmtime embeddings regardless of whether they use the typed or tagged representation to implement import funcs and call export funcs, and since most embeddings are making substantial use of <code>bindgen!</code> in public and private crates against public and private wits, my approach is to provide a bridge where a debugging library can operate on just the tagged representation of values, using a new mechanism built into all typed representations to convert to tagged representation. Further mechanisms in wasmtime to hook into library code using the typed representation will come in future PRs, see <a href="https://github.com/bytecodealliance/wasmtime/pull/12532">https://github.com/bytecodealliance/wasmtime/pull/12532</a> for work in progress.</p>
<h2>Converting typed to tagged</h2>
<p>For every value in a typed component model value representation (i.e. any value of a type which has an <code>impl ComponentType</code>), there also exists an equivalent component model value in <code>wasmtime::component::Val</code> (tagged) representation. Prior to this PR, there was no mechanism to convert a typed value to a tagged one.</p>
<p>This PR adds a method <code>to_val</code> to <code>ComponentType</code> to convert to a Val:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">to_val</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">StoreContextMut</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Val</span><span class="o">&gt;</span>
</code></pre></div>
<p>The design choices in this signature are:<br>
* The method takes <code>&amp;self</code>, not <code>self</code>, because the reverse conversion does not exist, and in the context of adding debugging hooks to existing code using the typed representation, we don't want to destroy the typed representation in order to observe it.<br>
* The method gives the owned representation <code>Val</code>, which means making a structural clone of the value. For a wit <code>list&lt;u8&gt;</code> this ends up having some fairly ugly overhead: the typical <code>Vec&lt;u8&gt;</code>, which impls <code>ComponentType, Lift, Lower</code>, converts to the <code>Val::List(Vec&lt;Val&gt;)</code> variant, where each vec element is then a <code>Val::U8(u8)</code> variant. Other variants, like <code>Val::Record</code>, <code>Val::Variant</code>, <code>Val::Enum</code>, and <code>Val::Flags</code> end up using <code>String</code> representations of the various wit identifiers used for record rows, variant and enum tags, and each flag value. This requires substantially more memory to represent, and is substantially less efficient to traverse!<br>
* The owned representation of <code>Val</code> has further caveats where it does not provide the same safety guarantees as the typed representation for resource, future, and stream representations, see <a href="https://docs.rs/wasmtime/latest/wasmtime/component/struct.ResourceAny.html">https://docs.rs/wasmtime/latest/wasmtime/component/struct.ResourceAny.html</a> for information on the requirements for dropping a resource, which also apply when in a leaf node of a <code>Val</code>. When <code>Resource&lt;T&gt;::to_val(&amp;self)</code> is invoked, <strong>FIXME FIGURE OUT WHAT HAPPENS HERE AND WHAT THE USER NEEDS TO DO TO HANDLE IT. DOES VAL NEED A <code>drop{,_async}(self,StoreContextMut)</code> METHOD? and put whatever i learn in the proper docs</strong><br>
* The conversion requires a store. I originally used <code>impl AsContextMut</code> for the store, but Alex suggested I switch to use <code>StoreContextMut</code>, which then requires the function to be generic on the type in the store. For this type variable I use <code>S</code> instead of the usual <code>T</code> because <code>T</code> is often already in use in the impl.<br>
* The conversion is fallible. The conversion can fail if you use the wrong store for a resource type. Soon, when Nick gets around to changing the Val representation to the new fallible allocation types, it will also be fallible due to OOM, so its nice that the general shape of things is there.</p>
<p>The <code>ComponentType</code> derive macro fills out a definition of to_val mechanically - this was the only aspect of the PR that was subtle to figure out. All of the <code>impl ComponentType</code> for Rust types provided by wasmtime get a straightforward mechanical implementation.</p>
<h2>TODO before this PR can land:</h2>
<ul>
<li>[ ] literally any testing at all. im confident that at the time of writing not a single invocation of to_val has ever been executed. whatever it typechecked</li>
<li>[ ]  rust docs need better</li>
<li>[ ] Alex gets another pass at the design, which his feedback already substantially improved.</li>
</ul>
</blockquote>



<a name="572045345"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2312496%20ComponentType%3A%20add%20as_val%20method%20to%20.../near/572045345" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2312496.20ComponentType.3A.20add.20as_val.20method.20to.20.2E.2E.2E.html#572045345">(Feb 05 2026 at 01:58)</a>:</h4>
<p>pchickey edited <a href="https://github.com/bytecodealliance/wasmtime/pull/12496">PR #12496</a>:</p>
<blockquote>
<p>This PR adds the method <code>fn to_val&lt;S&gt;(&amp;self, store: StoreContextMut&lt;S&gt;) -&gt; Result&lt;Val&gt;</code> to wasmtime's <code>ComponentType</code> trait. This is a first step in a bigger project to provide better debugging facilities for wasmtime component model execution.</p>
<h2>Context</h2>
<p>Wasmtime separates component model values into two separate worlds:</p>
<ul>
<li>a typed representation, where Rust datatypes corresponding to component model types derive or impl the <code>ComponentType</code> trait, plus optionally the <code>Lift</code> and <code>Lower</code> traits (required to be used in arguments and return values of import functions, respectively) which provide wasmtime the means to convert to/from each Rust type and its canonical ABI representations. To use this representation for an import function wasmtime users use <code>wasmtime::component::Linker::func_wrap</code> and friends, and on an export function use <code>wasmtime::component::Instance::typed_func</code> and friends.</li>
<li>a tagged representation, where all component model types are represented using the different variants of the <code>wasmtime::component::Val</code> enum. To use this representation for an import function, wasmtime users use <code>wasmtime::component::Linker::func_new</code> and on an export <code>wasmtime::component::Instance::func</code>.</li>
</ul>
<p>Prior to this PR, users have to choose whether to opt into the typed representation or the tagged representation based on what their application needs, and we (the wasmtime developers) focused most of our efforts on the typed representation because that ends up being the right choice for most embedders.</p>
<p>Users of the typed representation do so almost exclusively through the use of <code>wasmtime::component::bindgen!</code>, a proc macro which generates Rust structs and enums corresponding to component model types it parses from wit, and delegates to the <code>#[derive(ComponentType, Lift, Lower)]</code> derive proc-macros in those generated types (which themselves also are provided by the wasmtime crate). This bindings generation typically takes place in library code, e.g. <code>wasmtime-wasi</code>, <code>wasmtime-wasi-http</code> and related crates, and <code>bindgen</code> takes a variety of options that influence exactly what sort of Rust representation to use for wit types - the <code>ComponentType</code> derive macros permit flexibility in various ways. But, at any rate, to my knowledge every "serious" embedding of wasmtime (rough definition: engineers ship it to prod at dayjob) is written in Rust and uses <code>bindgen</code> exclusively or very close to it.</p>
<p>On the other hand, the tagged representation is useful for library code that exists independently from a given wit description. The library for a human-friendly serialization format for component model values <code>https://crates.io/crates/wasm-wave</code> exports some traits which wasmtime provides impls for in terms of <code>wasmtime::component::Val</code>.  Wave ends up being useful for features in <code>wasmtime-cli</code> like <code>wasmtime run --invoke ...</code>, which I introduced in <a href="https://github.com/bytecodealliance/wasmtime/pull/10054">https://github.com/bytecodealliance/wasmtime/pull/10054</a>. The C API, which is used for bindings to other languages, also uses the Val representation, because C APIs and the bindgen proc macro are oil and water.</p>
<p>My goal is to create better debugging tools for wasmtime component model programs, providing wasmtime embedders and cli users with the capability to inspect, and eventually record/replay or modify component model values. Like the wave crate and invoke integration, debugging tools benefit from being independent of a given wit description. Debugging tools must integrate with wasmtime embeddings regardless of whether they use the typed or tagged representation to implement import funcs and call export funcs, and since most embeddings are making substantial use of <code>bindgen!</code> in public and private crates against public and private wits, my approach is to provide a bridge where a debugging library can operate on just the tagged representation of values, using a new mechanism built into all typed representations to convert to tagged representation. Further mechanisms in wasmtime to hook into library code using the typed representation will come in future PRs, see <a href="https://github.com/bytecodealliance/wasmtime/pull/12532">https://github.com/bytecodealliance/wasmtime/pull/12532</a> for work in progress.</p>
<h2>Converting typed to tagged</h2>
<p>For every value in a typed component model value representation (i.e. any value of a type which has an <code>impl ComponentType</code>), there also exists an equivalent component model value in <code>wasmtime::component::Val</code> (tagged) representation. Prior to this PR, there was no mechanism to convert a typed value to a tagged one.</p>
<p>This PR adds a method <code>to_val</code> to <code>ComponentType</code> to convert to a Val:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">fn</span><span class="w"> </span><span class="nf">to_val</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">store</span><span class="p">:</span><span class="w"> </span><span class="nc">StoreContextMut</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">Val</span><span class="o">&gt;</span>
</code></pre></div>
<p>The design choices in this signature are:<br>
* The method takes <code>&amp;self</code>, not <code>self</code>, because the reverse conversion does not exist, and in the context of adding debugging hooks to existing code using the typed representation, we don't want to destroy the typed representation in order to observe it.<br>
* The method gives the owned representation <code>Val</code>, which means making a structural clone of the value. For a wit <code>list&lt;u8&gt;</code> this ends up having some fairly ugly overhead: the typical <code>Vec&lt;u8&gt;</code>, which impls <code>ComponentType, Lift, Lower</code>, converts to the <code>Val::List(Vec&lt;Val&gt;)</code> variant, where each vec element is then a <code>Val::U8(u8)</code> variant. Other variants, like <code>Val::Record</code>, <code>Val::Variant</code>, <code>Val::Enum</code>, and <code>Val::Flags</code> end up using <code>String</code> representations of the various wit identifiers used for record rows, variant and enum tags, and each flag value. This requires substantially more memory to represent, and is substantially less efficient to traverse!<br>
* The owned representation of <code>Val</code> has further caveats where it does not provide the same safety guarantees as the typed representation for resource, future, and stream representations, see <a href="https://docs.rs/wasmtime/latest/wasmtime/component/struct.ResourceAny.html">https://docs.rs/wasmtime/latest/wasmtime/component/struct.ResourceAny.html</a> for information on the requirements for dropping a resource, which also apply when in a leaf node of a <code>Val</code>. When <code>Resource&lt;T&gt;::to_val(&amp;self)</code> is invoked, <strong>FIXME FIGURE OUT WHAT HAPPENS HERE AND WHAT THE USER NEEDS TO DO TO HANDLE IT. DOES VAL NEED A <code>drop{,_async}(self,StoreContextMut)</code> METHOD? and put whatever i learn in the proper docs</strong><br>
* The conversion requires a store. I originally used <code>impl AsContextMut</code> for the store, but Alex suggested I switch to use <code>StoreContextMut</code>, which then requires the function to be generic on the type in the store. For this type variable I use <code>S</code> instead of the usual <code>T</code> because <code>T</code> is often already in use in the impl.<br>
* The conversion is fallible. The conversion can fail if you use the wrong store for a resource type. Soon, when Nick gets around to changing the Val representation to the new fallible allocation types, it will also be fallible due to OOM, so its nice that the general shape of things is there.</p>
<p>The <code>ComponentType</code> derive macro fills out a definition of to_val mechanically - this was the only aspect of the PR that was subtle to figure out. All of the <code>impl ComponentType</code> for Rust types provided by wasmtime get a straightforward mechanical implementation.</p>
<h2>TODO before this PR can land:</h2>
<ul>
<li>[ ] literally any testing at all. im confident that at the time of writing not a single invocation of to_val has ever been executed. whatever it typechecked</li>
<li>[ ]  rust docs need better</li>
<li>[ ] Alex gets another pass at the design, which his feedback already substantially improved.</li>
</ul>
</blockquote>



<a name="572448047"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2312496%20ComponentType%3A%20add%20as_val%20method%20to%20.../near/572448047" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2312496.20ComponentType.3A.20add.20as_val.20method.20to.20.2E.2E.2E.html#572448047">(Feb 06 2026 at 19:10)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/12496">PR #12496</a>.</p>



<a name="572455878"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2312496%20ComponentType%3A%20add%20as_val%20method%20to%20.../near/572455878" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2312496.20ComponentType.3A.20add.20as_val.20method.20to.20.2E.2E.2E.html#572455878">(Feb 06 2026 at 20:08)</a>:</h4>
<p>pchickey updated <a href="https://github.com/bytecodealliance/wasmtime/pull/12496">PR #12496</a>.</p>



<a name="573138183"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2312496%20ComponentType%3A%20add%20as_val%20method%20to%20.../near/573138183" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2312496.20ComponentType.3A.20add.20as_val.20method.20to.20.2E.2E.2E.html#573138183">(Feb 10 2026 at 20:00)</a>:</h4>
<p>pchickey closed without merge <a href="https://github.com/bytecodealliance/wasmtime/pull/12496">PR #12496</a>.</p>



<a name="573138184"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20PR%20%2312496%20ComponentType%3A%20add%20as_val%20method%20to%20.../near/573138184" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20PR.20.2312496.20ComponentType.3A.20add.20as_val.20method.20to.20.2E.2E.2E.html#573138184">(Feb 10 2026 at 20:00)</a>:</h4>
<p>pchickey <a href="https://github.com/bytecodealliance/wasmtime/pull/12496#issuecomment-3880397319">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/pull/12496">PR #12496</a>:</p>
<blockquote>
<p>@alexcrichton and I just discussed this in depth and we concluded there is no correct way to deal with the fact that Val contains ResourceAny / FutureAny / StreamAny in this context - constructing any of those must be done as a move of the typed version. So, unfortunately, this work is scrapped for now, and I have another completely different approach I will be starting on instead.</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>