<html>
<head><meta charset="utf-8"><title>wasmtime / issue #11506 Compiling wasmtime for the embedd... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html">wasmtime / issue #11506 Compiling wasmtime for the embedd...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="535597234"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535597234" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535597234">(Aug 22 2025 at 00:36)</a>:</h4>
<p>jsturtevant opened <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<h3>Test Case</h3>
<p>a module/component with a simple c function that will trigger this: </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">int</span><span class="w"> </span><span class="n">RoundToNearestInt</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">float</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.331</span><span class="o">*</span><span class="w"> </span><span class="mf">24.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">float</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lrintf</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"rounded answer: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"> </span><span class="c1">// should print 32</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3>Steps to Reproduce</h3>
<ol>
<li>Build wasmtime for an emedding using the <code>x86_64-unknown-none</code>.  Similar to how <a href="https://github.com/bytecodealliance/wasmtime/tree/release-36.0.0/examples/min-platform">https://github.com/bytecodealliance/wasmtime/tree/release-36.0.0/examples/min-platform</a> does it.  <br>
2.Then pre-compile module/component  <a href="https://github.com/bytecodealliance/wasmtime/blob/ebce5d453464d3b5fcc6f9391a9b21fd6307844d/examples/min-platform/src/main.rs#L66-L82">https://github.com/bytecodealliance/wasmtime/blob/ebce5d453464d3b5fcc6f9391a9b21fd6307844d/examples/min-platform/src/main.rs#L66-L82</a></li>
</ol>
<p>run the wasm</p>
<h3>Expected Results</h3>
<p>rounding is completed properly</p>
<h3>Actual Results</h3>
<p>incorrect result. Example above prints 31</p>
<h3>Versions and Environment</h3>
<p>Wasmtime version or commit: was using 34+</p>
<p>Operating system: Linux</p>
<p>Architecture: x86</p>
<h3>Extra Info</h3>
<p>Anything else you'd like to add?<br>
I wasn't able to reproduce this with the <code>min-platform</code> example.  I believe this is because its <a href="https://github.com/bytecodealliance/wasmtime/blob/ebce5d453464d3b5fcc6f9391a9b21fd6307844d/examples/min-platform/build.sh#L51-L58">actually compiling to a platform Linux platform</a>?</p>
</blockquote>



<a name="535597236"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535597236" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535597236">(Aug 22 2025 at 00:36)</a>:</h4>
<p><a href="https://github.com/jsturtevant">jsturtevant</a> added the bug label to <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">Issue #11506</a>.</p>



<a name="535598343"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535598343" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535598343">(Aug 22 2025 at 00:52)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3212595134">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>Is it possible that you have a nonstandard FPU configuration in your embedded environment? (<code>MXCSR</code> settings for example)</p>
<p>That's the only thing I can think of personally -- we otherwise generate exactly the same machine code for Wasm-on-x86_64 whether that's running in a standard Wasmtime on Linux or a <code>no_std</code> build (given the same compiler settings for ISA level, etc., but those are all orthogonal to platform).</p>
</blockquote>



<a name="535709365"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535709365" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535709365">(Aug 22 2025 at 15:40)</a>:</h4>
<p>jsturtevant <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3214809687">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<blockquote>
<p>Is it possible that you have a nonstandard FPU configuration in your embedded environment? (MXCSR settings for example)</p>
</blockquote>
<p>I did initially check this, and we have the setting of <code>0x1f80</code>.</p>
<p>I believe I tracked it down to the fact rustc doesn't generate SSE and SSE2 instructions by default with the target <code>x86_64-unknown-none</code> where are cranelift does.  So when wasmtime transitions through <a href="https://github.com/bytecodealliance/wasmtime/blob/release-36.0.0/crates/wasmtime/src/runtime/vm/libcalls.rs">lib calls</a> the wrong registers are set up when passing floating points arguements to the floating point builtin functions. Adding SSE and SSE2 to features in rustc fixed the issue.</p>
<p>I guess I expected cranelift to generate similar code to rustc when targeting <code>x86_64-unknown-none</code>.  I also thought Cranelift might perform a compatibility check to ensure the target configuration aligns with rustc's assumptions. Or maybe provide some docs on what features should be enabled as a baseline when compiling wasmtime to  <code>x86_64-unknown-none</code> with rustc to match the same target in cranelift.  I realize there needs to be some level of knowledge here when tuning it further, but that initial miss match was hard to detect.</p>
<p>Is there something else I might have missed that causes this mis-match?</p>
</blockquote>



<a name="535711712"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535711712" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535711712">(Aug 22 2025 at 15:52)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3214854791">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>Ah yes there's definitely an ABI mismatch here that I missed with <code>x86_64-unknown-none</code>. Effectively we're not doing proper checking in Wasmtime that SSE/SSE2 are enabled at compile time. Cranelift assumes SSE/SSE2 are enabled, but the <code>x86_64-unknown-none</code> is "soft float" which means that the libcalls aren't matched up in their ABIs.</p>
<p>@jsturtevant questions for you:</p>
<ul>
<li>Do you want to forbid floats in guests? That's a configuration option we don't currently expose today but we could do so. Wasmtime would then only require SSE/SSE2 features if floats are enabled, and otherwise it would reject this module in question since it's using floats.</li>
<li>Do you want to allow floats in guests? To do this I think that the <code>x86_64-unknown-none</code> target may not be suitable for your embedding. That target cannot have SSE/SSE2 enabled due to ABI constraints. You'd have to make a new (probably JSON-based) target which has the features enabled. That would then fix this issue because you'd be compiling for a target that does indeed have SSE/SSE2.</li>
</ul>
<p>The "naive" fix for this is to check that the host has SSE/SSE2 enabled. If we added that to Wasmtime though then all embeddings would cease to work with <code>x86_64-unknown-none</code> because that doesn't have these features enabled. Given that I'd ideally like to make sure there's a path to keeping things working on your end first.</p>
</blockquote>



<a name="535713239"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535713239" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535713239">(Aug 22 2025 at 16:00)</a>:</h4>
<p>jsturtevant <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3214875520">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>We would like to enable floats in the guest and potentially in the future add support for more advance SIMD.  I was able to get this working by setting <code>target-feature=-soft-float,+sse,+sse2</code> in the <code>.cargo/config.toml</code> to add SSE when building wasmtime for the target <code>x86_64-unknown-none</code>.  Is that a valid option or do I need to be going about it differently?</p>
</blockquote>



<a name="535714267"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535714267" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535714267">(Aug 22 2025 at 16:06)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3214888385">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>That technically can work for now but you should be getting warnings along the lines of:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">warning</span><span class="p">:</span><span class="w"> </span><span class="nc">target</span><span class="w"> </span><span class="n">feature</span><span class="w"> </span><span class="err">`</span><span class="n">soft</span><span class="o">-</span><span class="n">float</span><span class="err">`</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">enabled</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">ensure</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">ABI</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">implemented</span><span class="w"> </span><span class="n">correctly</span>
<span class="w">  </span><span class="o">|</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span><span class="p">:</span><span class="w"> </span><span class="nc">this</span><span class="w"> </span><span class="n">was</span><span class="w"> </span><span class="n">previously</span><span class="w"> </span><span class="n">accepted</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">compiler</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">being</span><span class="w"> </span><span class="n">phased</span><span class="w"> </span><span class="n">out</span><span class="p">;</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="kr">become</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">hard</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">future</span><span class="w"> </span><span class="n">release</span><span class="o">!</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span><span class="p">:</span><span class="w"> </span><span class="nc">for</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">information</span><span class="p">,</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">issue</span><span class="w"> </span><span class="p">#</span><span class="mi">116344</span><span class="w"> </span><span class="o">&lt;</span><span class="n">https</span><span class="p">:</span><span class="c1">//github.com/rust-lang/rust/issues/116344&gt;</span>

<span class="n">warning</span><span class="p">:</span><span class="w"> </span><span class="nc">unstable</span><span class="w"> </span><span class="n">feature</span><span class="w"> </span><span class="n">specified</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="err">`</span><span class="o">-</span><span class="n">Ctarget</span><span class="o">-</span><span class="n">feature</span><span class="err">`</span><span class="p">:</span><span class="w"> </span><span class="err">`</span><span class="n">soft</span><span class="o">-</span><span class="n">float</span><span class="err">`</span>
<span class="w">  </span><span class="o">|</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">note</span><span class="p">:</span><span class="w"> </span><span class="nc">this</span><span class="w"> </span><span class="n">feature</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">stably</span><span class="w"> </span><span class="n">supported</span><span class="p">;</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">behavior</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">change</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">future</span>

<span class="n">warning</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">warnings</span><span class="w"> </span><span class="n">emitted</span>
</code></pre></div>
<p>The main problem is that these features affect the ABI which means the entire world needs to agree on that, and the Rust standard library wasn't built with that (unless you're using <code>-Zbuild-std</code>). That's where a custom JSON target spec comes in of, for the entire target, forcibly enabling the SSE2 ABI for floats on the target. I was looking and I don't believe Rust has a pre-baked "bare metal" target which is allowed to use floats</p>
</blockquote>



<a name="535715916"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535715916" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535715916">(Aug 22 2025 at 16:16)</a>:</h4>
<p>jsturtevant <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3214920968">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<blockquote>
<p>That technically can work for now but you should be getting warnings along the lines of:</p>
</blockquote>
<p>I saw that and reading through the issue saw it seem to be related to <code>i686</code> which we currently don't target but maybe I read this wrong or didn't understand all the implications.  Are we going to see other ABI issues with these settings?</p>
</blockquote>



<a name="535718256"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535718256" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535718256">(Aug 22 2025 at 16:30)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3214954402">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>Ah yeah these warnings definitely affect x86_64 as well. This has to do with a thorny set of issues where more-or-less when you change the ABI the whole world has to agree on it. The <code>-Ctarget-feature=-soft-float</code> flag is effectively fundamentally incompatible with this because it means that you're only changing the ABI for part of the world (your crates) and not the whole world (e.g. the precompiled Rust standard library). This will cause issues if a float value is passed between the two, so for example if <code>f32::from_bits</code> or something like that wasn't inlined (e.g. maybe you made it a function pointer) then the standard library would return the value in a GPR while your local compilation would expect it in a XMM register (due to differing ABIs).</p>
<p>Effectively ABI-changing flags shouldn't have existed in the first place and ABI-changing things need to be part of target, not flags to a local compilation unit. Two ideas to solve this:</p>
<ul>
<li>We could add support to the "soft float" ABI to Cranelift. That way Cranelift would use a different ABI for the <code>x86_64-unknown-none</code> target and would match rustc. That would resolve the issue at hand, and Cranelift could still otherwise use floats everywhere to its hearts content. We would still need to perform a runtime check that sse/sse2 are present in Wasmtime, but that wouldn't be hard to add.</li>
<li>You could switch to using a JSON target which enables SSE/SSE2 and disables soft-float. That would mean you'd have to use <code>-Zbuild-std</code> plus a JSON target spec, neither of which are stable in Rust right now. That would update Rust codegen to match Cranelift's ABI, and we would again still need to double-check SSE/SSE2 at runtime in Wasmtime.</li>
</ul>
<p>Ideally what would happen today is we would add a check into Wasmtime about "which float ABI is being used?" and assert that it's not "soft". If it's "soft" we would emit a first-class error preventing a <code>Module</code> from being created that is allowed to use floats because it would mean that Cranelift's ABI is mismatched with Wasmtime's ABI.</p>
<p>@jsturtevant how viable is it to use <code>-Zbuild-std</code> plus a custom JSON target spec? If not it might be worth poking around Cranelift to see how hard it would be to implement a "soft float" variant of the system-v ABI</p>
</blockquote>



<a name="535719403"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535719403" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535719403">(Aug 22 2025 at 16:36)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3214968335">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>Hmm -- I am realizing that we internally have the same issue with our "Wasmtime in weird embedded environment" use-case. We are technically inside a Linux process but need to avoid syscalls, so we build <code>x86_64-unknown-none</code> as well. Hardfloat is fine though -- we expect the full suite of SIMD instructions to work. I had blindly copied the <code>min-platform</code> example previously. We also should really use stable Rust -- nightly for <code>-Zbuild-std</code> is going to be a tough pill to swallow. What do you recommend @alexcrichton ?</p>
</blockquote>



<a name="535721010"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535721010" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535721010">(Aug 22 2025 at 16:48)</a>:</h4>
<p>jsturtevant <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3214994838">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<blockquote>
<p>Ah yeah these warnings definitely affect x86_64 as well. This has to do with a thorny set of issues where more-or-less when you change the ABI the whole world has to agree on it. The -Ctarget-feature=-soft-float flag is effectively fundamentally incompatible with this because it means that you're only changing the ABI for part of the world (your crates) and not the whole world (e.g. the precompiled Rust standard library). This will cause issues if a float value is passed between the two, so for example if f32::from_bits or something like that wasn't inlined (e.g. maybe you made it a function pointer) then the standard library would return the value in a GPR while your local compilation would expect it in a XMM register (due to differing ABIs).</p>
</blockquote>
<p>this makes alot of sense and thanks for taking the time to clearly explain.  I thought <code>-Ctarget-feature=-soft-float</code> was ok because of the comment in <a href="https://doc.rust-lang.org/rustc/targets/known-issues.html">https://doc.rust-lang.org/rustc/targets/known-issues.html</a> which says soft floats are off in rust core:</p>
<blockquote>
<p>Using software emulated floats ("soft-floats") disables usage of xmm registers, but parts of Rust's core libraries (e.g. std::f32 or std::f64) are compiled without soft-floats and expect parameters to be passed in xmm registers. </p>
</blockquote>
</blockquote>



<a name="535722308"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535722308" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535722308">(Aug 22 2025 at 16:56)</a>:</h4>
<p>jsturtevant <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3215013359">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<blockquote>
<p>Ideally what would happen today is we would add a check into Wasmtime about "which float ABI is being used?" and assert that it's not "soft". If it's "soft" we would emit a first-class error preventing a Module from being created that is allowed to use floats because it would mean that Cranelift's ABI is mismatched with Wasmtime's ABI.</p>
</blockquote>
<p>Isn't <code>-Ctarget-feature=-soft-float</code> turning soft-float off? so those abi's would match?</p>
</blockquote>



<a name="535722801"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535722801" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535722801">(Aug 22 2025 at 16:59)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3215021034">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>@jsturtevant ah I think that documentation might be slightly confusing, but what I believe that's trying to say is that libcore uses floats, and for <code>x86_64-unknown-none</code> it's compiled with "soft floats" meaning it's not using xmm registers. If you were then to compile your code with "hard floats" instead, that would result in an ABI mismatch if you tried to call float functions in libcore/libstd.</p>
<blockquote>
<p>Isn't -Ctarget-feature=-soft-float turning soft-float off?</p>
</blockquote>
<p>Sort of, sort of not. The main reason this doesn't work is it only affects your local compilation unit not others. So for example if you tried to communicate with libcore (which wasn't compiled with this) you'd get the same ABI mismatch. Soft float is also weird in LLVM since there's also <code>-Csoft-float=n</code> to rustc and it's specified in "weird ways" other than just <code>-Ctarget-feature</code>. AFAIK there's a few ways to configure it and they're not all quite right. Regardless though you can't escape from "libcore is compiled differently than your code".</p>
<blockquote>
<p>What do you recommend @alexcrichton ?</p>
</blockquote>
<p>Ah good point! Given the constraint of stable Rust here's two possible ideas (one more to add on the one I had above)</p>
<ol>
<li>Implement the soft-float ABI in Cranelift and update Wasmtime to enable this ABI when compiling modules for x86_64-unknown-none. This would only affect the ABI (floats in GPRs, not in XMMs) and wouldn't affect generated code (which would still use XMMs and float-related instructions). Wasmtime would then additionally check at runtime that SSE and SSE2 are detected as otherwise the Cranelift-generated code is invalid.</li>
<li>Update the ABI of libcalls to avoid floats. For example we could pass things on the stack or in GPRs manually. That would be a Wasmtime-local fix and would be sufficient I think since the only time floats are in registers in wasm&lt;-&gt;host transitions is in libcalls. For this we'd probably want to add some sort of assertion in Cranelift that floats aren't actually used on the ABI at all (e.g. still have a "soft float" feature but instead of implementing it we just assert we don't need to implement it)</li>
</ol>
</blockquote>



<a name="535730424"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535730424" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535730424">(Aug 22 2025 at 17:55)</a>:</h4>
<p>jsturtevant <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3215168033">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<blockquote>
<p>Sort of, sort of not. The main reason this doesn't work is it only affects your local compilation unit not others. So for example if you tried to communicate with libcore (which wasn't compiled with this) you'd get the same ABI mismatch. </p>
</blockquote>
<p>Got it, our code has it off but we didn't compile libcore  with those same settings on the <code>x86_64-unknown-none</code> so libcore would have it on.  We would need to compile libcore with the same settings via <code>-Zbuild-std</code>.  Thanks again for the patience and explanations!</p>
<p>We also would like to take advantage of the full suite of SIMD. </p>
<p>I might not have enough understanding of the tradeoff here but my rather naive and initial thought is the option <code>(2) Update the ABI of libcalls to avoid floats.</code> seems reasonable for being able to use Rust stable.</p>
</blockquote>



<a name="535771879"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535771879" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535771879">(Aug 23 2025 at 00:47)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3216031840">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>Ok I've managed to reproduce this by applying the following diff on top of <a href="https://github.com/bytecodealliance/wasmtime/pull/11516">https://github.com/bytecodealliance/wasmtime/pull/11516</a>:</p>
<p>&lt;details&gt;</p>
<div class="codehilite" data-code-language="Diff"><pre><span></span><code>commit b1bf88344905ac4813ec4a7bce58e475678b175f
Author: Alex Crichton &lt;alex@alexcrichton.com&gt;
Date:   Fri Aug 22 17:15:17 2025 -0700

<span class="w"> </span>   wip

<span class="gh">diff --git a/examples/min-platform/embedding/src/lib.rs b/examples/min-platform/embedding/src/lib.rs</span>
<span class="gh">index 460ea5d2c8..9448c3785e 100644</span>
<span class="gd">--- a/examples/min-platform/embedding/src/lib.rs</span>
<span class="gi">+++ b/examples/min-platform/embedding/src/lib.rs</span>
<span class="gu">@@ -4,7 +4,7 @@</span>
<span class="w"> </span>extern crate alloc;

<span class="w"> </span>use alloc::string::ToString;
<span class="gd">-use anyhow::Result;</span>
<span class="gi">+use anyhow::{Result, ensure};</span>
<span class="w"> </span>use core::ptr;
<span class="w"> </span>use wasmtime::{Engine, Instance, Linker, Module, Store};

<span class="gu">@@ -29,6 +29,8 @@ pub unsafe extern "C" fn run(</span>
<span class="w"> </span>    simple_add_size: usize,
<span class="w"> </span>    simple_host_fn_module: *const u8,
<span class="w"> </span>    simple_host_fn_size: usize,
<span class="gi">+    simple_floats_module: *const u8,</span>
<span class="gi">+    simple_floats_size: usize,</span>
<span class="w"> </span>) -&gt; usize {
<span class="w"> </span>    unsafe {
<span class="w"> </span>        let buf = core::slice::from_raw_parts_mut(error_buf, error_size);
<span class="gu">@@ -36,7 +38,8 @@ pub unsafe extern "C" fn run(</span>
<span class="w"> </span>        let simple_add = core::slice::from_raw_parts(simple_add_module, simple_add_size);
<span class="w"> </span>        let simple_host_fn =
<span class="w"> </span>            core::slice::from_raw_parts(simple_host_fn_module, simple_host_fn_size);
<span class="gd">-        match run_result(smoke, simple_add, simple_host_fn) {</span>
<span class="gi">+        let simple_floats = core::slice::from_raw_parts(simple_floats_module, simple_floats_size);</span>
<span class="gi">+        match run_result(smoke, simple_add, simple_host_fn, simple_floats) {</span>
<span class="w"> </span>            Ok(()) =&gt; 0,
<span class="w"> </span>            Err(e) =&gt; {
<span class="w"> </span>                let msg = format!("{e:?}");
<span class="gu">@@ -52,10 +55,12 @@ fn run_result(</span>
<span class="w"> </span>    smoke_module: &amp;[u8],
<span class="w"> </span>    simple_add_module: &amp;[u8],
<span class="w"> </span>    simple_host_fn_module: &amp;[u8],
<span class="gi">+    simple_floats_module: &amp;[u8],</span>
<span class="w"> </span>) -&gt; Result&lt;()&gt; {
<span class="w"> </span>    smoke(smoke_module)?;
<span class="w"> </span>    simple_add(simple_add_module)?;
<span class="w"> </span>    simple_host_fn(simple_host_fn_module)?;
<span class="gi">+    simple_floats(simple_floats_module)?;</span>
<span class="w"> </span>    Ok(())
<span class="w"> </span>}

<span class="gu">@@ -78,7 +83,7 @@ fn simple_add(module: &amp;[u8]) -&gt; Result&lt;()&gt; {</span>
<span class="w"> </span>    let mut store = Store::new(&amp;engine, ());
<span class="w"> </span>    let instance = Linker::new(&amp;engine).instantiate(&amp;mut store, &amp;module)?;
<span class="w"> </span>    let func = instance.get_typed_func::&lt;(u32, u32), u32&gt;(&amp;mut store, "add")?;
<span class="gd">-    assert_eq!(func.call(&amp;mut store, (2, 3))?, 5);</span>
<span class="gi">+    ensure!(func.call(&amp;mut store, (2, 3))? == 5);</span>
<span class="w"> </span>    Ok(())
<span class="w"> </span>}

<span class="gu">@@ -93,7 +98,20 @@ fn simple_host_fn(module: &amp;[u8]) -&gt; Result&lt;()&gt; {</span>
<span class="w"> </span>    let mut store = Store::new(&amp;engine, ());
<span class="w"> </span>    let instance = linker.instantiate(&amp;mut store, &amp;module)?;
<span class="w"> </span>    let func = instance.get_typed_func::&lt;(u32, u32, u32), u32&gt;(&amp;mut store, "add_and_mul")?;
<span class="gd">-    assert_eq!(func.call(&amp;mut store, (2, 3, 4))?, 10);</span>
<span class="gi">+    ensure!(func.call(&amp;mut store, (2, 3, 4))? == 10);</span>
<span class="gi">+    Ok(())</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+fn simple_floats(module: &amp;[u8]) -&gt; Result&lt;()&gt; {</span>
<span class="gi">+    let engine = Engine::default();</span>
<span class="gi">+    let module = match deserialize(&amp;engine, module)? {</span>
<span class="gi">+        Some(module) =&gt; module,</span>
<span class="gi">+        None =&gt; panic!(),</span>
<span class="gi">+    };</span>
<span class="gi">+    let mut store = Store::new(&amp;engine, ());</span>
<span class="gi">+    let instance = Linker::new(&amp;engine).instantiate(&amp;mut store, &amp;module)?;</span>
<span class="gi">+    let func = instance.get_typed_func::&lt;(f32, f32), f32&gt;(&amp;mut store, "frob")?;</span>
<span class="gi">+    ensure!(func.call(&amp;mut store, (1.4, 3.2))? == 5.);</span>
<span class="w"> </span>    Ok(())
<span class="w"> </span>}

<span class="gh">diff --git a/examples/min-platform/src/main.rs b/examples/min-platform/src/main.rs</span>
<span class="gh">index fd1867c6d5..7de14846da 100644</span>
<span class="gd">--- a/examples/min-platform/src/main.rs</span>
<span class="gi">+++ b/examples/min-platform/src/main.rs</span>
<span class="gu">@@ -95,6 +95,16 @@ fn main() -&gt; Result&lt;()&gt; {</span>
<span class="w"> </span>            )
<span class="w"> </span>        "#,
<span class="w"> </span>    )?;
<span class="gi">+    let simple_floats = engine.precompile_module(</span>
<span class="gi">+        br#"</span>
<span class="gi">+            (module</span>
<span class="gi">+                (func (export "frob") (param f32 f32) (result f32)</span>
<span class="gi">+                    (f32.ceil (local.get 0))</span>
<span class="gi">+                    (f32.floor (local.get 0))</span>
<span class="gi">+                    f32.add)</span>
<span class="gi">+            )</span>
<span class="gi">+        "#,</span>
<span class="gi">+    )?;</span>

<span class="w"> </span>    // Next is an example of running this embedding, which also serves as test
<span class="w"> </span>    // that basic functionality actually works.
<span class="gu">@@ -134,6 +144,8 @@ fn main() -&gt; Result&lt;()&gt; {</span>
<span class="w"> </span>                usize,
<span class="w"> </span>                *const u8,
<span class="w"> </span>                usize,
<span class="gi">+                *const u8,</span>
<span class="gi">+                usize,</span>
<span class="w"> </span>            ) -&gt; usize,
<span class="w"> </span>        &gt; = lib
<span class="w"> </span>            .get(b"run")
<span class="gu">@@ -149,6 +161,8 @@ fn main() -&gt; Result&lt;()&gt; {</span>
<span class="w"> </span>            simple_add.len(),
<span class="w"> </span>            simple_host_fn.as_ptr(),
<span class="w"> </span>            simple_host_fn.len(),
<span class="gi">+            simple_floats.as_ptr(),</span>
<span class="gi">+            simple_floats.len(),</span>
<span class="w"> </span>        );
<span class="w"> </span>        error_buf.set_len(len);
</code></pre></div>
<p>&lt;/details&gt;</p>
<p>that yields:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="cp">$</span><span class="w"> </span><span class="n">MIN_PLATFORM_TEST_DISABLE_WASI</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">WASMTIME_SIGNALS_BASED_TRAPS</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">build</span><span class="p">.</span><span class="n">sh</span><span class="w"> </span><span class="n">x86_64</span><span class="o">-</span><span class="n">unknown</span><span class="o">-</span><span class="n">none</span>
<span class="o">..</span><span class="p">.</span>
<span class="n">Error</span><span class="p">:</span><span class="w"> </span><span class="nc">Condition</span><span class="w"> </span><span class="n">failed</span><span class="p">:</span><span class="w"> </span><span class="err">`</span><span class="n">func</span><span class="p">.</span><span class="n">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">store</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="mf">1.4</span><span class="p">,</span><span class="w"> </span><span class="mf">3.2</span><span class="p">))</span><span class="o">?</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">5.</span><span class="err">`</span><span class="w"> </span><span class="p">(</span><span class="mf">2.8</span><span class="w"> </span><span class="n">vs</span><span class="w"> </span><span class="mf">5.0</span><span class="p">)</span>
</code></pre></div>
<p>and some simple debugging shows the libcalls getting invalid arguments.</p>
<hr>
<p>Personally I'm tempted to (a) add a "soft float" feature to Cranelift and assert in ABI code that if this feature is enabled that no floats are used, and then (b) update libcalls to unconditionally use GPR arguments/results instead of XMM args/results. (aka do the mov-xmm-to-gpr in Cranelift). Then Wasmtime would configure this soft float flag for the <code>x86_64-unknown-none</code> target and would additionally add runtime checks for SSE/SSE2 which it lacks today.</p>
<p>That should get everything working between compiled wasm code and Wasmtime. Libcalls are slow but they always are. Libcalls are easily avoided as well by enabling more CPU features (e.g. up to SSE4.1 or even up to AVX). Given that I'm not keen on investing a lot of effort into this when performance is basically secondary.</p>
</blockquote>



<a name="535772860"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535772860" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535772860">(Aug 23 2025 at 01:05)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3216046011">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>A few thoughts on "real softfloat":</p>
<ul>
<li>In our embedding it's looking like we'll actually go the way of a custom target and bite the bullet on a nightly requirement for <code>-Zbuild-std</code> -- the key factor for us is that we're also linking with other code (a bunch of legacy C) that <em>isn't</em> using a softfloat ABI, so our hand is basically forced. I suspect others might be in the same boat...</li>
<li>In a world that <em>does</em> require softfloat, like the Linux kernel, I don't know if it's safe to even use XMMs while still upholding an "ABI at call boundaries" invariant and saving them as clobbers -- at the very least it interacts weirdly with the lazy state-switching stuff that x86 does and the Linux kernel optionally uses. A little experimentation (<a href="https://godbolt.org/z/43EY8fe6W">Godbolt link</a>) shows that Rust compiled to <code>x86_64-unknown-none</code> uses helpers like <code>__addf3</code> even for a simple <code>a + b</code> where <code>a: f64, b: f64</code> (Yikes!) I'm not sure that this is a terribly interesting target configuration for the folks in this thread, at least?</li>
</ul>
<p>I wonder if it would make sense to statically compile-error if the target has softfloat configured?</p>
</blockquote>



<a name="535772877"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535772877" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535772877">(Aug 23 2025 at 01:06)</a>:</h4>
<p>cfallin edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3216046011">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>A few thoughts on "real softfloat":</p>
<ul>
<li>In our embedding it's looking like we'll actually go the way of a custom target and bite the bullet on a nightly requirement for <code>-Zbuild-std</code> -- the key factor for us is that we're also linking with other code (a bunch of legacy C) that <em>isn't</em> using a softfloat ABI, so our hand is basically forced. I suspect others might be in the same boat...</li>
<li>In a world that <em>does</em> require softfloat, like the Linux kernel, I don't know if it's safe to even use XMMs while still upholding an "ABI at call boundaries" invariant and saving them as clobbers -- at the very least it interacts weirdly with the lazy state-switching stuff that x86 does and the Linux kernel optionally uses. A little experimentation (<a href="https://godbolt.org/z/43EY8fe6W">Godbolt link</a>) shows that Rust compiled to <code>x86_64-unknown-none</code> uses helpers like <code>__adddf3</code> even for a simple <code>a + b</code> where <code>a: f64, b: f64</code> (Yikes!) I'm not sure that this is a terribly interesting target configuration for the folks in this thread, at least?</li>
</ul>
<p>I wonder if it would make sense to statically compile-error if the target has softfloat configured?</p>
</blockquote>



<a name="535795639"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/535795639" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#535795639">(Aug 23 2025 at 09:48)</a>:</h4>
<p>bjorn3 <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3216619073">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>For the Linux kernel there are functions you can use to delimit a section of code where using xmm registers are used. This will then handle saving and restoring the registers as needed.</p>
</blockquote>



<a name="536272047"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/536272047" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#536272047">(Aug 26 2025 at 16:15)</a>:</h4>
<p>jsturtevant <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3224863901">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<blockquote>
<p>Libcalls are easily avoided as well by enabling more CPU features (e.g. up to SSE4.1 or even up to AVX). Given that I'm not keen on investing a lot of effort into this when performance is basically secondary.</p>
</blockquote>
<p>This means enabling more cpu features in cranelifts compilation?  So in this case it would mean that the wasm module doesn't transition through a libcall to do the rounding?  This might be an option for us. Is there a way to detect when libcalls are likely to happen? I am wonder if there might be other edge cases that we want to avoid.</p>
<blockquote>
<p>Given that I'm not keen on investing a lot of effort into this when performance is basically secondary.</p>
</blockquote>
<p>This makes sense.</p>
<blockquote>
<p>In our embedding it's looking like we'll actually go the way of a custom target and bite the bullet on a nightly requirement for -Zbuild-std -- the key factor for us is that we're also linking with other code (a bunch of legacy C) that isn't using a softfloat ABI, so our hand is basically forced. I suspect others might be in the same boat...</p>
</blockquote>
<p>Are you linking wasmtime code with c? or the module/component?</p>
</blockquote>



<a name="536273361"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/536273361" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#536273361">(Aug 26 2025 at 16:23)</a>:</h4>
<p>cfallin <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3224891616">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<blockquote>
<p>Are you linking wasmtime code with c?</p>
</blockquote>
<p>Yes! Wasmtime <code>no_std</code> dropped into a big legacy C codebase. It technically runs on a Linux base but avoids all syscalls for Reasons, so we've used all of the embedded platform functionality in Wasmtime (thanks Alex!) to make this work. Thus our interest in this topic!</p>
</blockquote>



<a name="536277576"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/536277576" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#536277576">(Aug 26 2025 at 16:46)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3224969324">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>@jsturtevant correct yeah, if you enable everything up through SSE4.1 it should avoid almost all libcalls with floats. One more feature is FMA as well, but that's only for relaxed-simd support.</p>
</blockquote>



<a name="536396601"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/536396601" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#536396601">(Aug 27 2025 at 11:11)</a>:</h4>
<p>syntactically <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3227777768">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<blockquote>
<p>if you enable everything up through SSE4.1 it should avoid almost all libcalls with floats</p>
</blockquote>
<p>Just to confirm my understanding here---is this ABI mismatch not a problem with normal import/export trampolines (only with the libcall trampolines) because those tend to pass arguments on the Cranelift side in memory?</p>
<blockquote>
<p>I'm not sure that this is a terribly interesting target configuration for the folks in this thread, at least?</p>
</blockquote>
<p>The kernel target configuration for rustc is definitely interesting to us, but that is a different discussion so I won't go further off topic here :)</p>
<blockquote>
<p>Personally I'm tempted to (a) add a "soft float" feature to Cranelift and assert in ABI code that if this feature is enabled that no floats are used, and then (b) update libcalls to unconditionally use GPR arguments/results instead of XMM args/results. (aka do the mov-xmm-to-gpr in Cranelift). Then Wasmtime would configure this soft float flag for the x86_64-unknown-none target and would additionally add runtime checks for SSE/SSE2 which it lacks today.</p>
</blockquote>
<p>I think that broadly makes sense, although where exactly would the new ABI flag make sure that "no floats are used"?</p>
<p>Separately: insofar as the Cranelift ABI ends up being different from the host ABI, do <code>wasmtime_{set,long}jmp()</code> need to preserve the extended cranelift ABI or just the host ABI? I think that currently every longjmp ends up trapping, so perhaps only the latter?</p>
</blockquote>



<a name="536437238"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/536437238" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#536437238">(Aug 27 2025 at 14:47)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3228514465">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<blockquote>
<p>is this ABI mismatch not a problem with normal import/export trampolines</p>
</blockquote>
<p>Correct yeah, they only use GPRs in the ABI and in-memory bits contain floats.</p>
<blockquote>
<p>where exactly would the new ABI flag make sure that "no floats are used"?</p>
</blockquote>
<p>My thinking is that this'd happen somewhere in the ABI code in Cranelift where if the flag was set it'd assert that <code>f32</code> and <code>f64</code> weren't used in the signature of a function at all. So an internal assert in Cranelift which we'd be careful to avoid in Wasmtime (e.g. by reporting an error at compile time or changing things internally)</p>
<blockquote>
<p>do wasmtime_{set,long}jmp() need to preserve the extended cranelift ABI or just the host ABI</p>
</blockquote>
<p>That's a good question! Something I hadn't really considered before but I believe the answer is "both". This adds more fuel to the fire to me of burning down these functions entirely...</p>
</blockquote>



<a name="536486703"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/536486703" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#536486703">(Aug 27 2025 at 19:42)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/11506#issuecomment-3229527624">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<p>I pushed up <a href="https://github.com/bytecodealliance/wasmtime/pull/11553">https://github.com/bytecodealliance/wasmtime/pull/11553</a> to resolve this issue. Basically it'll make loading code on <code>x86_64-unknown-none</code> a hard error by default. The error has an escape hatch which documents some of the hazards embedders need to look out for.</p>
</blockquote>



<a name="536674703"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2311506%20Compiling%20wasmtime%20for%20the%20embedd.../near/536674703" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2311506.20Compiling.20wasmtime.20for.20the.20embedd.2E.2E.2E.html#536674703">(Aug 28 2025 at 19:54)</a>:</h4>
<p>alexcrichton closed <a href="https://github.com/bytecodealliance/wasmtime/issues/11506">issue #11506</a>:</p>
<blockquote>
<h3>Test Case</h3>
<p>a module/component with a simple c function that will trigger this: </p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="n">int</span><span class="w"> </span><span class="n">RoundToNearestInt</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">float</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.331</span><span class="o">*</span><span class="w"> </span><span class="mf">24.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">float</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">lrintf</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"rounded answer: %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"> </span><span class="c1">// should print 32</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3>Steps to Reproduce</h3>
<ol>
<li>Build wasmtime for an emedding using the <code>x86_64-unknown-none</code>.  Similar to how <a href="https://github.com/bytecodealliance/wasmtime/tree/release-36.0.0/examples/min-platform">https://github.com/bytecodealliance/wasmtime/tree/release-36.0.0/examples/min-platform</a> does it.  <br>
2.Then pre-compile module/component  <a href="https://github.com/bytecodealliance/wasmtime/blob/ebce5d453464d3b5fcc6f9391a9b21fd6307844d/examples/min-platform/src/main.rs#L66-L82">https://github.com/bytecodealliance/wasmtime/blob/ebce5d453464d3b5fcc6f9391a9b21fd6307844d/examples/min-platform/src/main.rs#L66-L82</a></li>
</ol>
<p>run the wasm</p>
<h3>Expected Results</h3>
<p>rounding is completed properly</p>
<h3>Actual Results</h3>
<p>incorrect result. Example above prints 31</p>
<h3>Versions and Environment</h3>
<p>Wasmtime version or commit: was using 34+</p>
<p>Operating system: Linux</p>
<p>Architecture: x86</p>
<h3>Extra Info</h3>
<p>Anything else you'd like to add?<br>
I wasn't able to reproduce this with the <code>min-platform</code> example.  I believe this is because its <a href="https://github.com/bytecodealliance/wasmtime/blob/ebce5d453464d3b5fcc6f9391a9b21fd6307844d/examples/min-platform/build.sh#L51-L58">actually compiling to a platform Linux platform</a>?</p>
</blockquote>



<hr><p>Last updated: Oct 25 2025 at 23:03 UTC</p>
</html>