<html>
<head><meta charset="utf-8"><title>wasmtime / issue #12612 [wasi-sockets] Fresh UDP sockets ... · git-wasmtime · Zulip Chat Archive</title></head>
<h2>Stream: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/index.html">git-wasmtime</a></h2>
<h3>Topic: <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html">wasmtime / issue #12612 [wasi-sockets] Fresh UDP sockets ...</a></h3>

<hr>

<base href="https://bytecodealliance.zulipchat.com">

<head><link href="https://bytecodealliance.github.io/zulip-archive/style.css" rel="stylesheet"></head>

<a name="574397901"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312612%20%5Bwasi-sockets%5D%20Fresh%20UDP%20sockets%20.../near/574397901" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html#574397901">(Feb 17 2026 at 22:33)</a>:</h4>
<p>dicej opened <a href="https://github.com/bytecodealliance/wasmtime/issues/12612">issue #12612</a>:</p>
<blockquote>
<p>I'm (still) working to add WASIp2 support to <code>mio</code> and have noticed that several of the UDP tests _usually_ pass but sometimes fail.  When they fail, it's always due to the host returning <code>error-code::would-block</code> from <code>outgoing-datagram-stream.send</code> (which <code>wasi-libc</code> translates to returning <code>EWOULDBLOCK</code> from <code>send(2)</code>).  This can happen even if the socket was just created, has not previously been used to send anything, and for which <code>outgoing-datagram-stream.check-send</code> has returned a non-zero number.  It can also happen when <code>poll.poll</code> has returned just a write-ready event for the <code>pollable</code> representing the <code>outgoing-datagram-stream</code>.</p>
<p>I've simplified the test case somewhat here:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// udp.rs</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::{</span><span class="n">error</span><span class="p">::</span><span class="n">Error</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">::</span><span class="n">ErrorKind</span><span class="p">,</span><span class="w"> </span><span class="n">net</span><span class="p">::</span><span class="n">UdpSocket</span><span class="p">};</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">50</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">socket1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UdpSocket</span><span class="p">::</span><span class="n">bind</span><span class="p">(</span><span class="s">"127.0.0.1:0"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="n">socket1</span><span class="p">.</span><span class="n">set_nonblocking</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">socket2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UdpSocket</span><span class="p">::</span><span class="n">bind</span><span class="p">(</span><span class="s">"127.0.0.1:0"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="n">socket2</span><span class="p">.</span><span class="n">set_nonblocking</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">address1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket1</span><span class="p">.</span><span class="n">local_addr</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">address2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket2</span><span class="p">.</span><span class="n">local_addr</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="n">socket1</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address2</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="n">socket2</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b"foobar"</span><span class="p">;</span>
<span class="w">        </span><span class="n">socket1</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">20</span><span class="p">];</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">socket2</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="o">..</span><span class="n">n</span><span class="p">]);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="fm">assert!</span><span class="p">(</span><span class="fm">matches!</span><span class="p">(</span><span class="n">error</span><span class="p">.</span><span class="n">kind</span><span class="p">(),</span><span class="w"> </span><span class="n">ErrorKind</span><span class="p">::</span><span class="n">WouldBlock</span><span class="p">));</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"success!"</span><span class="p">);</span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div>
<p>If you run e.g. <code>rustc --target=wasm32-wasip2 udp.rs &amp;&amp; while wasmtime run -Sudp,inherit-network udp.wasm; do :; done</code>, sooner or later you'll see <code>Error: Os { code: 6, kind: WouldBlock, message: "Resource temporarily unavailable" }</code>.  However, if you run e.g. <code>rustc udp.rs &amp;&amp; while ./udp; do :; done</code> on Linux, it will succeed indefinitely.</p>
<p>When I dug into this, I found that <code>wasmtime-wasi</code> uses <code>tokio::net::UdpSocket::try_send[_to]</code> to send datagrams, which eventually consults <a href="https://github.com/tokio-rs/tokio/blob/d83921bc5181010be72704d1fe8fb9b6f10cb7e8/tokio/src/runtime/io/scheduled_io.rs#L290-L298">this function</a> from <a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/runtime/io/registration.rs#L188">here</a> to determine whether to even bother trying to send.  Indeed, when I add debug logging to that function and patch Wasmtime to use it, I see that the "not ready" case corresponds to when the host returns <code>would-block</code> to the guest, which indicates that <code>tokio</code> is applying backpressure rather than the OS.</p>
<p>I imagine that in most real-world code, returning spurious <code>would-block</code> errors occasionally wouldn't be a problem; the application can just poll and try again.  However, it makes the <code>mio</code> tests flaky, so I'd like to brainstorm solutions here.</p>
<p>One rather heavy-handed approach could be to bypass Tokio for sending and receiving datagrams, using <code>tokio::net::UdpSocket::{into,from}_std</code> to temporarily convert between the Tokio version and the <code>std</code> version.  I imagine that could have other implications, though.</p>
</blockquote>



<a name="574397904"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312612%20%5Bwasi-sockets%5D%20Fresh%20UDP%20sockets%20.../near/574397904" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html#574397904">(Feb 17 2026 at 22:33)</a>:</h4>
<p><a href="https://github.com/dicej">dicej</a> added the bug label to <a href="https://github.com/bytecodealliance/wasmtime/issues/12612">Issue #12612</a>.</p>



<a name="574397908"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312612%20%5Bwasi-sockets%5D%20Fresh%20UDP%20sockets%20.../near/574397908" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html#574397908">(Feb 17 2026 at 22:33)</a>:</h4>
<p><a href="https://github.com/dicej">dicej</a> added the wasi label to <a href="https://github.com/bytecodealliance/wasmtime/issues/12612">Issue #12612</a>.</p>



<a name="574398259"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312612%20%5Bwasi-sockets%5D%20Fresh%20UDP%20sockets%20.../near/574398259" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html#574398259">(Feb 17 2026 at 22:36)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/12612#issuecomment-3917435290">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12612">issue #12612</a>:</p>
<blockquote>
<p>@badeend your reward for being so helpful with the last issue is that I'm going to tag you on this one also <span aria-label="first place" class="emoji emoji-1f947" role="img" title="first place">:first_place:</span> </p>
</blockquote>



<a name="574398605"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312612%20%5Bwasi-sockets%5D%20Fresh%20UDP%20sockets%20.../near/574398605" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html#574398605">(Feb 17 2026 at 22:38)</a>:</h4>
<p>dicej edited <a href="https://github.com/bytecodealliance/wasmtime/issues/12612">issue #12612</a>:</p>
<blockquote>
<p>I'm (still) working to add WASIp2 support to <code>mio</code> and have noticed that several of the UDP tests _usually_ pass but sometimes fail.  When they fail, it's always due to the host returning <code>error-code::would-block</code> from <code>outgoing-datagram-stream.send</code> (which <code>wasi-libc</code> translates to returning <code>EWOULDBLOCK</code> from <code>send(2)</code>).  This can happen even if the socket was just created, has not previously been used to send anything, and for which <code>outgoing-datagram-stream.check-send</code> has returned a non-zero number.  It can also happen when <code>poll.poll</code> has just returned a write-ready event for the <code>pollable</code> representing the <code>outgoing-datagram-stream</code>.</p>
<p>I've simplified the test case somewhat here:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// udp.rs</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::{</span><span class="n">error</span><span class="p">::</span><span class="n">Error</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">::</span><span class="n">ErrorKind</span><span class="p">,</span><span class="w"> </span><span class="n">net</span><span class="p">::</span><span class="n">UdpSocket</span><span class="p">};</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">50</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">socket1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UdpSocket</span><span class="p">::</span><span class="n">bind</span><span class="p">(</span><span class="s">"127.0.0.1:0"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="n">socket1</span><span class="p">.</span><span class="n">set_nonblocking</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">socket2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UdpSocket</span><span class="p">::</span><span class="n">bind</span><span class="p">(</span><span class="s">"127.0.0.1:0"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="n">socket2</span><span class="p">.</span><span class="n">set_nonblocking</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">address1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket1</span><span class="p">.</span><span class="n">local_addr</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">address2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket2</span><span class="p">.</span><span class="n">local_addr</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="n">socket1</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address2</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="n">socket2</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b"foobar"</span><span class="p">;</span>
<span class="w">        </span><span class="n">socket1</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">20</span><span class="p">];</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">socket2</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="o">..</span><span class="n">n</span><span class="p">]);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="fm">assert!</span><span class="p">(</span><span class="fm">matches!</span><span class="p">(</span><span class="n">error</span><span class="p">.</span><span class="n">kind</span><span class="p">(),</span><span class="w"> </span><span class="n">ErrorKind</span><span class="p">::</span><span class="n">WouldBlock</span><span class="p">));</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"success!"</span><span class="p">);</span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div>
<p>If you run e.g. <code>rustc --target=wasm32-wasip2 udp.rs &amp;&amp; while wasmtime run -Sudp,inherit-network udp.wasm; do :; done</code>, sooner or later you'll see <code>Error: Os { code: 6, kind: WouldBlock, message: "Resource temporarily unavailable" }</code>.  However, if you run e.g. <code>rustc udp.rs &amp;&amp; while ./udp; do :; done</code> on Linux, it will succeed indefinitely.</p>
<p>When I dug into this, I found that <code>wasmtime-wasi</code> uses <code>tokio::net::UdpSocket::try_send[_to]</code> to send datagrams, which eventually consults <a href="https://github.com/tokio-rs/tokio/blob/d83921bc5181010be72704d1fe8fb9b6f10cb7e8/tokio/src/runtime/io/scheduled_io.rs#L290-L298">this function</a> from <a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/runtime/io/registration.rs#L188">here</a> to determine whether to even bother trying to send.  Indeed, when I add debug logging to that function and patch Wasmtime to use it, I see that the "not ready" case corresponds to when the host returns <code>would-block</code> to the guest, which indicates that <code>tokio</code> is applying backpressure rather than the OS.</p>
<p>I imagine that in most real-world code, returning spurious <code>would-block</code> errors occasionally wouldn't be a problem; the application can just poll and try again.  However, it makes the <code>mio</code> tests flaky, so I'd like to brainstorm solutions here.</p>
<p>One rather heavy-handed approach could be to bypass Tokio for sending and receiving datagrams, using <code>tokio::net::UdpSocket::{into,from}_std</code> to temporarily convert between the Tokio version and the <code>std</code> version.  I imagine that could have other implications, though.</p>
</blockquote>



<a name="574621981"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312612%20%5Bwasi-sockets%5D%20Fresh%20UDP%20sockets%20.../near/574621981" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html#574621981">(Feb 18 2026 at 23:18)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/12612#issuecomment-3923714174">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12612">issue #12612</a>:</p>
<blockquote>
<p>My understanding of what's happening here is that this is a race within Tokio. Tokio guards all I/O with ensuring that readiness has actually been signaled before actually doing the I/O, and it looks like all I/O readiness starts out as empty. On most iterations of the test by the time the <code>send</code> is executed the readiness has already been updated to indicate that the socket is writable -- there's a background thread doing <code>epoll_wait</code> which is woken up immediately after the <code>epoll_ctl</code> adding the UDP socket to the set. In some iterations, though, this background thread isn't fast enough so the UDP socket's own internal readiness still says "not ready" so the I/O is blocked.</p>
<p>The call-stack is:</p>
<ul>
<li><a href="https://github.com/tokio-rs/tokio/blob/c23735d43be36d31911dd2c832f36e5e6a6078a1/tokio/src/net/udp.rs#L652"><code>UdpSocket::try_send</code></a> calls <code>try_io</code></li>
<li><a href="https://github.com/tokio-rs/tokio/blob/c23735d43be36d31911dd2c832f36e5e6a6078a1/tokio/src/runtime/io/registration.rs#L188-L193"><code>try_io</code> sees readiness is empty</a> and returns without actually doing anything</li>
</ul>
<p>One fix is to wait for writable-ness in the test itself which would resolve this. Whether that's acceptable, I'm not entirely sure. Short of that I'm not sure how best to fix this. Reaching inside and performing operations manually runs the risk of bypassing Tokio's tracking of the readiness state, which can maybe still work but would require some finesse.</p>
</blockquote>



<a name="574622859"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312612%20%5Bwasi-sockets%5D%20Fresh%20UDP%20sockets%20.../near/574622859" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html#574622859">(Feb 18 2026 at 23:27)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/12612#issuecomment-3923753879">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12612">issue #12612</a>:</p>
<blockquote>
<blockquote>
<p>One fix is to wait for writable-ness in the test itself which would resolve this.</p>
</blockquote>
<p>Where would that happen?  <a href="https://github.com/tokio-rs/mio/blob/66ac9fab79bf191218488c4f35c99d13935b7e12/tests/udp_socket.rs#L901">This mio test</a> calls <code>send</code> on a fresh socket without polling it for writability first, which limits our options.  I suppose we could kick it off in <code>udp-socket.start-bind</code> and only return success from <code>udp-socket.finish-bind</code> once it's ready.</p>
</blockquote>



<a name="574674811"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312612%20%5Bwasi-sockets%5D%20Fresh%20UDP%20sockets%20.../near/574674811" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html#574674811">(Feb 19 2026 at 08:49)</a>:</h4>
<p>badeend <a href="https://github.com/bytecodealliance/wasmtime/issues/12612#issuecomment-3925688007">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12612">issue #12612</a>:</p>
<blockquote>
<p>Every I/O operation is allowed to return <code>would-block</code> at any time, even if the socket was just created or a previous poll indicated readiness. So strictly speaking, the mio test is somewhat naive. That said, since it works as expected on other platforms, this is likely an edge case that mio just do happens to surface first, but they probably won't be the last. Test suites in specific are often less defensive than production code.</p>
<p>If this is easily fixable on our end I think we should.</p>
<hr>
<blockquote>
<p>after the epoll_ctl adding the UDP socket to the set</p>
</blockquote>
<p>Do you know when does this happens? Is it at creation time? If so, maybe we can update our <code>UdpSocket::new</code> method to await readiness immediately E.g.</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="n">socket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">with_ambient_tokio_runtime</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tokio</span><span class="p">::</span><span class="n">net</span><span class="p">::</span><span class="n">UdpSocket</span><span class="p">::</span><span class="n">try_from</span><span class="p">(</span><span class="k">unsafe</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="p">::</span><span class="n">net</span><span class="p">::</span><span class="n">UdpSocket</span><span class="p">::</span><span class="n">from_raw_socketlike</span><span class="p">(</span><span class="n">fd</span><span class="p">.</span><span class="n">into_raw_socketlike</span><span class="p">())</span>
<span class="w">    </span><span class="p">})</span>
<span class="p">})</span><span class="o">?</span><span class="p">;</span>

<span class="n">socket</span><span class="p">.</span><span class="n">readable</span><span class="p">().</span><span class="k">await</span><span class="o">?</span><span class="p">;</span>
<span class="n">socket</span><span class="p">.</span><span class="n">writable</span><span class="p">().</span><span class="k">await</span><span class="o">?</span><span class="p">;</span>
</code></pre></div>
<p>IIUC, that should _usually_ not actually block, correct?<br>
</p>
</blockquote>



<a name="574828860"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312612%20%5Bwasi-sockets%5D%20Fresh%20UDP%20sockets%20.../near/574828860" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html#574828860">(Feb 19 2026 at 21:53)</a>:</h4>
<p>alexcrichton <a href="https://github.com/bytecodealliance/wasmtime/issues/12612#issuecomment-3930343223">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12612">issue #12612</a>:</p>
<blockquote>
<blockquote>
<blockquote>
<p>One fix is to wait for writable-ness in the test itself which would resolve this.</p>
</blockquote>
<p>Where would that happen?</p>
</blockquote>
<p>My thinking is that it'd just be added to the test. The test wouldn't send on a socket immediately, it would await for the socket to become writable first (via poll/epoll/etc) and then it would send data. That'd require changing the test itself.</p>
<hr>
<blockquote>
<blockquote>
<p>after the epoll_ctl adding the UDP socket to the set</p>
</blockquote>
<p>Do you know when does this happens? Is it at creation time?</p>
</blockquote>
<p>Creation time yeah. Construction of a <code>tokio::net::UdpSocket</code>, even from a std-based socket, will register it with the I/O event loop with <code>epoll_ctl</code>. That's a good point that calling <code>socket.writable()</code>  maybe possible. We'd have to make some methods <code>async</code> that aren't currently async, but that's not the end of the world.</p>
<p>Personally though I think the best fix would be to modify the test in question to wait for writable sockets.</p>
<hr>
<p>As an example, also to confirm my thinking, this program will fail on native for me eventually:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span><span class="w"> </span><span class="n">Poll</span><span class="p">};</span>

<span class="cp">#[tokio::main]</span>
<span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">"{i}"</span><span class="p">);</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokio</span><span class="p">::</span><span class="n">net</span><span class="p">::</span><span class="n">UdpSocket</span><span class="p">::</span><span class="n">bind</span><span class="p">(</span><span class="s">"127.0.0.1:0"</span><span class="p">).</span><span class="k">await</span><span class="p">.</span><span class="n">unwrap</span><span class="p">();</span>

<span class="w">        </span><span class="fm">dbg!</span><span class="p">(</span><span class="n">test</span><span class="p">(</span><span class="o">|</span><span class="n">cx</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">poll_recv_ready</span><span class="p">(</span><span class="n">cx</span><span class="p">)).</span><span class="k">await</span><span class="p">);</span>
<span class="w">        </span><span class="fm">dbg!</span><span class="p">(</span><span class="n">test</span><span class="p">(</span><span class="o">|</span><span class="n">cx</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">poll_send_ready</span><span class="p">(</span><span class="n">cx</span><span class="p">)).</span><span class="k">await</span><span class="p">);</span>
<span class="w">        </span><span class="fm">assert!</span><span class="p">(</span><span class="n">test</span><span class="p">(</span><span class="o">|</span><span class="n">cx</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">poll_send_ready</span><span class="p">(</span><span class="n">cx</span><span class="p">)).</span><span class="k">await</span><span class="p">.</span><span class="n">is_some</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">test</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">f</span><span class="p">:</span><span class="w"> </span><span class="nc">impl</span><span class="w"> </span><span class="nb">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">Context</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nc">Poll</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="p">::</span><span class="n">future</span><span class="p">::</span><span class="n">poll_fn</span><span class="p">(</span><span class="o">|</span><span class="n">cx</span><span class="o">|</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Poll</span><span class="p">::</span><span class="n">Ready</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Poll</span><span class="p">::</span><span class="n">Ready</span><span class="p">(</span><span class="nb">Some</span><span class="p">(</span><span class="n">r</span><span class="p">)),</span>
<span class="w">        </span><span class="n">Poll</span><span class="p">::</span><span class="n">Pending</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">Poll</span><span class="p">::</span><span class="n">Ready</span><span class="p">(</span><span class="nb">None</span><span class="p">),</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">    </span><span class="p">.</span><span class="k">await</span>
<span class="p">}</span>
</code></pre></div>
<p>and example output is:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="w"> </span><span class="cp">$</span><span class="w"> </span><span class="n">cargo</span><span class="w"> </span><span class="n">run</span>
<span class="w">    </span><span class="n">Finished</span><span class="w"> </span><span class="err">`</span><span class="n">dev</span><span class="err">`</span><span class="w"> </span><span class="n">profile</span><span class="w"> </span><span class="p">[</span><span class="n">unoptimized</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">debuginfo</span><span class="p">]</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mf">0.01</span><span class="n">s</span>
<span class="w">     </span><span class="n">Running</span><span class="w"> </span><span class="err">`</span><span class="n">target</span><span class="o">/</span><span class="n">debug</span><span class="o">/</span><span class="n">wat</span><span class="err">`</span>
<span class="mi">0</span>
<span class="p">[</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="n">test</span><span class="p">(</span><span class="o">|</span><span class="n">cx</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">poll_recv_ready</span><span class="p">(</span><span class="n">cx</span><span class="p">)).</span><span class="k">await</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span>
<span class="p">[</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="n">test</span><span class="p">(</span><span class="o">|</span><span class="n">cx</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">poll_send_ready</span><span class="p">(</span><span class="n">cx</span><span class="p">)).</span><span class="k">await</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span>
<span class="mi">1</span>
<span class="p">[</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="n">test</span><span class="p">(</span><span class="o">|</span><span class="n">cx</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">poll_recv_ready</span><span class="p">(</span><span class="n">cx</span><span class="p">)).</span><span class="k">await</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span>
<span class="p">[</span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span><span class="w"> </span><span class="n">test</span><span class="p">(</span><span class="o">|</span><span class="n">cx</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">poll_send_ready</span><span class="p">(</span><span class="n">cx</span><span class="p">)).</span><span class="k">await</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">None</span>

<span class="n">thread</span><span class="w"> </span><span class="o">'</span><span class="na">main</span><span class="o">'</span><span class="w"> </span><span class="p">(</span><span class="mi">559208</span><span class="p">)</span><span class="w"> </span><span class="n">panicked</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">src</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="n">rs</span><span class="p">:</span><span class="mi">11</span><span class="p">:</span><span class="mi">9</span><span class="p">:</span>
<span class="nc">assertion</span><span class="w"> </span><span class="n">failed</span><span class="p">:</span><span class="w"> </span><span class="nc">test</span><span class="p">(</span><span class="o">|</span><span class="n">cx</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">poll_send_ready</span><span class="p">(</span><span class="n">cx</span><span class="p">)).</span><span class="k">await</span><span class="p">.</span><span class="n">is_some</span><span class="p">()</span>
<span class="n">note</span><span class="p">:</span><span class="w"> </span><span class="nc">run</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="err">`</span><span class="n">RUST_BACKTRACE</span><span class="o">=</span><span class="mi">1</span><span class="err">`</span><span class="w"> </span><span class="n">environment</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">display</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">backtrace</span>
</code></pre></div>
<p>Here you can see that on the first iteration the <code>poll_send_ready</code> changed between the print and the poll, but on the next iteration it stayed not ready.</p>
</blockquote>



<a name="575004882"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312612%20%5Bwasi-sockets%5D%20Fresh%20UDP%20sockets%20.../near/575004882" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html#575004882">(Feb 20 2026 at 18:23)</a>:</h4>
<p>dicej <a href="https://github.com/bytecodealliance/wasmtime/issues/12612#issuecomment-3936419869">commented</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12612">issue #12612</a>:</p>
<blockquote>
<p>Quick update on this: even after following @alexcrichton's advice and modifying the <code>mio</code> test to poll for write readiness before calling <code>send</code>, the test was _still_ flaky.  I tracked it down to the <code>Pollable</code> impl for <code>OutgoingDatagramStream</code> which currently assumes that a fresh socket will be writable and not bother asking <code>tokio</code> whether that's true.  I've verified that fixing that fixes the (modified) <code>mio</code> test, so I'll post a PR for that and consider that to have fixed this issue.</p>
</blockquote>



<a name="575004996"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312612%20%5Bwasi-sockets%5D%20Fresh%20UDP%20sockets%20.../near/575004996" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html#575004996">(Feb 20 2026 at 18:23)</a>:</h4>
<p>dicej edited a <a href="https://github.com/bytecodealliance/wasmtime/issues/12612#issuecomment-3936419869">comment</a> on <a href="https://github.com/bytecodealliance/wasmtime/issues/12612">issue #12612</a>:</p>
<blockquote>
<p>Quick update on this: even after following @alexcrichton's advice and modifying the <code>mio</code> test to poll for write readiness before calling <code>send</code>, the test was _still_ flaky.  I tracked it down to the <code>Pollable</code> impl for <code>OutgoingDatagramStream</code> which currently assumes that a fresh socket will be writable and doesn't bother asking <code>tokio</code> whether that's true.  I've verified that fixing that fixes the (modified) <code>mio</code> test, so I'll post a PR for that and consider that to have fixed this issue.</p>
</blockquote>



<a name="575026492"></a>
<h4><a href="https://bytecodealliance.zulipchat.com#narrow/stream/225357-git-wasmtime/topic/wasmtime%20/%20issue%20%2312612%20%5Bwasi-sockets%5D%20Fresh%20UDP%20sockets%20.../near/575026492" class="zl"><img src="https://bytecodealliance.github.io/zulip-archive/assets/img/zulip.svg" alt="view this post on Zulip" style="width:20px;height:20px;"></a> Wasmtime GitHub notifications bot <a href="https://bytecodealliance.github.io/zulip-archive/stream/225357-git-wasmtime/topic/wasmtime.20.2F.20issue.20.2312612.20.5Bwasi-sockets.5D.20Fresh.20UDP.20sockets.20.2E.2E.2E.html#575026492">(Feb 20 2026 at 20:53)</a>:</h4>
<p>dicej closed <a href="https://github.com/bytecodealliance/wasmtime/issues/12612">issue #12612</a>:</p>
<blockquote>
<p>I'm (still) working to add WASIp2 support to <code>mio</code> and have noticed that several of the UDP tests _usually_ pass but sometimes fail.  When they fail, it's always due to the host returning <code>error-code::would-block</code> from <code>outgoing-datagram-stream.send</code> (which <code>wasi-libc</code> translates to returning <code>EWOULDBLOCK</code> from <code>send(2)</code>).  This can happen even if the socket was just created, has not previously been used to send anything, and for which <code>outgoing-datagram-stream.check-send</code> has returned a non-zero number.  It can also happen when <code>poll.poll</code> has just returned a write-ready event for the <code>pollable</code> representing the <code>outgoing-datagram-stream</code>.</p>
<p>I've simplified the test case somewhat here:</p>
<div class="codehilite" data-code-language="Rust"><pre><span></span><code><span class="c1">// udp.rs</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::{</span><span class="n">error</span><span class="p">::</span><span class="n">Error</span><span class="p">,</span><span class="w"> </span><span class="n">io</span><span class="p">::</span><span class="n">ErrorKind</span><span class="p">,</span><span class="w"> </span><span class="n">net</span><span class="p">::</span><span class="n">UdpSocket</span><span class="p">};</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">Error</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">50</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">socket1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UdpSocket</span><span class="p">::</span><span class="n">bind</span><span class="p">(</span><span class="s">"127.0.0.1:0"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="n">socket1</span><span class="p">.</span><span class="n">set_nonblocking</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">socket2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UdpSocket</span><span class="p">::</span><span class="n">bind</span><span class="p">(</span><span class="s">"127.0.0.1:0"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="n">socket2</span><span class="p">.</span><span class="n">set_nonblocking</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">address1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket1</span><span class="p">.</span><span class="n">local_addr</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">address2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">socket2</span><span class="p">.</span><span class="n">local_addr</span><span class="p">()</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="n">socket1</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address2</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="w">        </span><span class="n">socket2</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">address1</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">b"foobar"</span><span class="p">;</span>
<span class="w">        </span><span class="n">socket1</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="k">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">20</span><span class="p">];</span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="n">socket2</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">buffer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="nb">Ok</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="fm">assert_eq!</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">[</span><span class="o">..</span><span class="n">n</span><span class="p">]);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="nb">Err</span><span class="p">(</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="fm">assert!</span><span class="p">(</span><span class="fm">matches!</span><span class="p">(</span><span class="n">error</span><span class="p">.</span><span class="n">kind</span><span class="p">(),</span><span class="w"> </span><span class="n">ErrorKind</span><span class="p">::</span><span class="n">WouldBlock</span><span class="p">));</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">"success!"</span><span class="p">);</span>

<span class="w">    </span><span class="nb">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</code></pre></div>
<p>If you run e.g. <code>rustc --target=wasm32-wasip2 udp.rs &amp;&amp; while wasmtime run -Sudp,inherit-network udp.wasm; do :; done</code>, sooner or later you'll see <code>Error: Os { code: 6, kind: WouldBlock, message: "Resource temporarily unavailable" }</code>.  However, if you run e.g. <code>rustc udp.rs &amp;&amp; while ./udp; do :; done</code> on Linux, it will succeed indefinitely.</p>
<p>When I dug into this, I found that <code>wasmtime-wasi</code> uses <code>tokio::net::UdpSocket::try_send[_to]</code> to send datagrams, which eventually consults <a href="https://github.com/tokio-rs/tokio/blob/d83921bc5181010be72704d1fe8fb9b6f10cb7e8/tokio/src/runtime/io/scheduled_io.rs#L290-L298">this function</a> from <a href="https://github.com/tokio-rs/tokio/blob/master/tokio/src/runtime/io/registration.rs#L188">here</a> to determine whether to even bother trying to send.  Indeed, when I add debug logging to that function and patch Wasmtime to use it, I see that the "not ready" case corresponds to when the host returns <code>would-block</code> to the guest, which indicates that <code>tokio</code> is applying backpressure rather than the OS.</p>
<p>I imagine that in most real-world code, returning spurious <code>would-block</code> errors occasionally wouldn't be a problem; the application can just poll and try again.  However, it makes the <code>mio</code> tests flaky, so I'd like to brainstorm solutions here.</p>
<p>One rather heavy-handed approach could be to bypass Tokio for sending and receiving datagrams, using <code>tokio::net::UdpSocket::{into,from}_std</code> to temporarily convert between the Tokio version and the <code>std</code> version.  I imagine that could have other implications, though.</p>
</blockquote>



<hr><p>Last updated: Feb 22 2026 at 11:05 UTC</p>
</html>