[
    {
        "content": "<p>When handling <code>wit-bindgen</code>, I'm aware that import / export follow some specific naming convention. I did see some <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#import-and-export-definitions\">explanations</a> for common interfaces, but I wonder where's the naming convention for the canon abi, such as <code>resource.new</code>? As far as what I've seen from the tests of spec repository, they could be defined as <code>import \"\" \"R1.resource.new\"</code>, but the <a href=\"https://github.com/bytecodealliance/wasm-tools/blob/35f8671bce74190ef0b00ce36c399b053b490374/crates/wit-component/src/validation.rs#L2108\">validation of wasm-tools</a> require them to be named with prefix <code>[resource-new]xxx</code>, and, I presume, the module need to be <code>[export]xxx</code>.</p>\n<p>If I understand correctly, the naming of the original import / export could be arbitrary as long as there's the <code>(canon resource.new $R1' (core func $R1.resource.new))</code> exists to point out that the function in core wasm is calling the canon abi. Which means that the restriction on the naming convention is imposed by wasm-tools to figure out which abi it refers to. If that's the case, I wonder if there's some documentation on how they are defined? Or could that be determined in some embedded metadata?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#import-and-export-definitions\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/6d6c98a48fa36624a1b5289b80cb4a57da02afef/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f613664323831336661393438303662653433626131366436343736613230373933653538343064313464343239313532396362386230623264633164383865622f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Explainer.md#import-and-export-definitions\" title=\"component-model/design/mvp/Explainer.md at main · WebAssembly/component-model\">component-model/design/mvp/Explainer.md at main · WebAssembly/component-model</a></div><div class=\"message_embed_description\">Repository for design and specification of the Component Model - WebAssembly/component-model</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-tools/blob/35f8671bce74190ef0b00ce36c399b053b490374/crates/wit-component/src/validation.rs#L2108\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/253ae56a6b0e71a7a6c59f456e55173b1088c7df/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f653165343132623534303232636237393337623566623035313332316232666334373636633334643732373938656661643638626337383530646336633131622f62797465636f6465616c6c69616e63652f7761736d2d746f6f6c73&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-tools/blob/35f8671bce74190ef0b00ce36c399b053b490374/crates/wit-component/src/validation.rs#L2108\" title=\"wasm-tools/crates/wit-component/src/validation.rs at 35f8671bce74190ef0b00ce36c399b053b490374 · bytecodealliance/wasm-tools\">wasm-tools/crates/wit-component/src/validation.rs at 35f8671bce74190ef0b00ce36c399b053b490374 · bytecodealliance/wasm-tools</a></div><div class=\"message_embed_description\"> CLI and Rust libraries for low-level manipulation of WebAssembly modules  - bytecodealliance/wasm-tools</div></div></div>",
        "id": 538588455,
        "sender_full_name": "Zihang Ye",
        "timestamp": 1757491066
    },
    {
        "content": "<p>Reading through the comments, I wonder why the <code>future-read</code> and <code>future-write</code> needs to be indexed?</p>",
        "id": 538605168,
        "sender_full_name": "Zihang Ye",
        "timestamp": 1757496601
    },
    {
        "content": "<p>I believe this <a href=\"https://github.com/WebAssembly/component-model/pull/378\">https://github.com/WebAssembly/component-model/pull/378</a> could answer some of your questions (I had the same question sind time ago)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/pull/378\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/14614966b406fa08c8bd6932673054f3eb926add/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f393361333064313330633765363362383266616533663635633935343464386463393662303131353730383361333935643562343236323737373561393164612f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f70756c6c2f333738&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/pull/378\" title=\"Add BuildTargets.md by lukewagner · Pull Request #378 · WebAssembly/component-model\">Add BuildTargets.md by lukewagner · Pull Request #378 · WebAssembly/component-model</a></div><div class=\"message_embed_description\">This PR adds BuildTargets.md to define this new concept of &quot;build targets&quot; as presented in both CG-06 and WASI-06-12, which itself was a revision of the earlier &quot;wasit2&quot; idea th...</div></div></div>",
        "id": 538634156,
        "sender_full_name": "Christof Petig",
        "timestamp": 1757506073
    },
    {
        "content": "<p>At a high level you're correct the names don't actually matter here. Once you have a component the names are purely informational and the runtime just follows the links. The problem that wasm-tools is solving is that LLVM today doesn't emit a component, it emits a core module. The process of going from a core module to a component requires some form of convention for naming these imports so tooling can know what connects to what. The naming chosen by <code>wasm-tools</code> today is not standard and nor will it ever be, it's just a loose toolchain convention. The PR <span class=\"user-mention\" data-user-id=\"590366\">@Christof Petig</span> linked to is intended to be the standard way to import things and a defined target for compilers to use (as opposed to whatever wasm-tools does)</p>",
        "id": 538668958,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1757514988
    },
    {
        "content": "<p>I see, thank you for pointing the PR.  I assume that it will be the new naming convention soon?</p>\n<p>But the PR doesn't cover async yet. <span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> Would you mind explaining why the <code>future-read/write</code>and <code>drop-readable/writable</code> need to be indexed per function as <code>\"[{kind}-drop-readable-{index}]{func_name}\"</code> or is there any PR that I can check on?</p>",
        "id": 538771747,
        "sender_full_name": "Zihang Ye",
        "timestamp": 1757566118
    },
    {
        "content": "<p>I forget if there's comments interspersed throughout the codebase but the original PR would require some digging now.</p>\n<p>Basically the problem is that the future/stream read/write intrinsics take a type parameter for what kind of future/stream they're operating on. Somehow <code>wit-component</code> needs to synthesize that which means we have to go from a string module and a string field to a type somehow. The solution we settled on was an indexing approach where we enumerate all the futures/streams in a function type signature and then you say \"this is the read/write for the Nth type in that list\"</p>",
        "id": 538876093,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1757601243
    },
    {
        "content": "<p>It's not a great solution IMO but it's sufficient for now.   It's also one where we're definitely able to change it in the future as necessary</p>",
        "id": 538876307,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1757601291
    },
    {
        "content": "<p>I see, thank you for your explanation. <span class=\"user-mention\" data-user-id=\"957141\">@BigOrangeQWQ</span> is trying to add wasip3 support in wit-bindgen for MoonBit, and we started following the existing wit-bindgen for C impl. So we are curious to see why something like <code>drop-readable</code> which is supposed to be the same for a same <strong>type</strong> has different imports in different function / field.</p>",
        "id": 538969821,
        "sender_full_name": "Zihang Ye",
        "timestamp": 1757642168
    },
    {
        "content": "<p>ah yeah that's true, you only need to pick 1 and any one will  suffice</p>",
        "id": 539081667,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1757687988
    },
    {
        "content": "<p>and it's also true that the current scheme means you can import <code>stream&lt;u8&gt;</code> things through any API that has <code>stream&lt;u8&gt;</code> in its signature</p>",
        "id": 539081756,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1757688016
    },
    {
        "content": "<p>Rust I believe ends up just picking the first</p>",
        "id": 539081814,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1757688032
    },
    {
        "content": "<p>regardless bindgen is indeed a bit awkward</p>",
        "id": 539081834,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1757688038
    },
    {
        "content": "<p>I see. So I think it might be more proper to have the naming as <code>&lt;package&gt;</code> <code>[{kind}-drop-readable]{type}</code>?</p>",
        "id": 539453556,
        "sender_full_name": "Zihang Ye",
        "timestamp": 1757901769
    },
    {
        "content": "<p>In theory yeah, but the hard part about that is parsing <code>{type}</code>. I'd personally prefer to avoid trying to specify WIT type parsing in another place</p>",
        "id": 539567614,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1757944970
    },
    {
        "content": "<p>Sorry but I didn't quite follow. I was thinking about how the resource types were handled. For example, the <code>resource.drop</code> for <code>output-stream</code> was : <code>(import \"wasi:io/streams@0.2.3\" \"[resource-drop]output-stream\" (func xxx))</code></p>\n<p>So in anaglous to it, I thought the future would be <code>(import \"my:test/i\" \"[future-drop-readable][async][future]u32</code> or <code>(import \"$root\" \"[future-drop-readable][async]u32</code> since u32 is primitive.<br>\nDid you mean the hard part was to figure out the whose future type it is, for example it could be a complicated type such as <code>future&lt;(u32, u32)&gt;</code>?</p>",
        "id": 539672260,
        "sender_full_name": "Zihang Ye",
        "timestamp": 1757988886
    },
    {
        "content": "<p>Right yeah, <code>resource</code> is a \"flat\" type with no recursion so naming is pretty easy, but the type parameter on futures makes this much more difficult</p>",
        "id": 539765960,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1758028518
    },
    {
        "content": "<p>I see, thank you.</p>",
        "id": 539917119,
        "sender_full_name": "Zihang Ye",
        "timestamp": 1758074635
    },
    {
        "content": "<p>Just one question, what will happen if there's a type such as <code>future&lt;stream&lt;u8&gt;&gt;</code>, how will we be able to refer to <code>stream&lt;u8&gt;</code> with index? or is that out of consideration at the moment?</p>",
        "id": 541971093,
        "sender_full_name": "Zihang Ye",
        "timestamp": 1759134544
    },
    {
        "content": "<p>IIRC if <code>future&lt;stream&lt;u8&gt;&gt;</code> is index N then <code>stream&lt;u8&gt;</code> is index N+1</p>",
        "id": 542053796,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1759155604
    },
    {
        "content": "<p>the ordering implementation is <a href=\"https://github.com/bytecodealliance/wasm-tools/blob/a64ae8dd009afcea40daba0585b5674bb6694cf3/crates/wit-parser/src/lib.rs#L1160-L1184\">here</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-tools/blob/a64ae8dd009afcea40daba0585b5674bb6694cf3/crates/wit-parser/src/lib.rs#L1160-L1184\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/2d97f181b6bc8ebed602d59efa5559e273abeb5b/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f383366303337306461383937396433656434313033346530623030313232663837316164666337643765646664316138333930376563303938366563636230362f62797465636f6465616c6c69616e63652f7761736d2d746f6f6c73&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-tools/blob/a64ae8dd009afcea40daba0585b5674bb6694cf3/crates/wit-parser/src/lib.rs#L1160-L1184\" title=\"wasm-tools/crates/wit-parser/src/lib.rs at a64ae8dd009afcea40daba0585b5674bb6694cf3 · bytecodealliance/wasm-tools\">wasm-tools/crates/wit-parser/src/lib.rs at a64ae8dd009afcea40daba0585b5674bb6694cf3 · bytecodealliance/wasm-tools</a></div><div class=\"message_embed_description\"> CLI and Rust libraries for low-level manipulation of WebAssembly modules  - bytecodealliance/wasm-tools</div></div></div>",
        "id": 542053942,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1759155632
    },
    {
        "content": "<p>Thank you very much</p>",
        "id": 542214989,
        "sender_full_name": "Zihang Ye",
        "timestamp": 1759221468
    }
]