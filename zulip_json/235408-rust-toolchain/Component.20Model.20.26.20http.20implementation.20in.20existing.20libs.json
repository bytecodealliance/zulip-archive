[
    {
        "content": "<p>Hi all <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> when working with the Component Model (wasip2), how can I use existing Rust libraries and SDKs that perform outgoing http calls?</p>\n<p>Context: usually these libraries/SDKs rely on built-in/standard http interfaces rather than the WASI one (like reqwest in Rust). So you'd need to rewrite/patch existing libraries to use them in your component. I'm hopeful that the Wasm/WASI community has a plan to address this across all the supported languages. It feels unthinkable that each SDK/library needs to be patched or that you can’t reuse any existing library inside a component <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> or am I missing something important?</p>\n<p>Also, I'm quite sure this is not limited to http. But not being able to use existing code sounds like a pretty critical blocker when it comes to reusing existing code/libraries.</p>\n<p>It looks like this effort is currently blocked on the reqwest repo: <a href=\"https://github.com/seanmonstar/reqwest/issues/2294\">https://github.com/seanmonstar/reqwest/issues/2294</a></p>\n<p>Do you already know if it will unblock with wasip3?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/seanmonstar/reqwest/issues/2294\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/53d31059359456ecf854aac4c1839caf60fa1935/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633131666266343131623234333932323163393961343232656633633665333437666466326131313261373463343361366339333132376634626133623663622f7365616e6d6f6e737461722f726571776573742f6973737565732f32323934&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/seanmonstar/reqwest/issues/2294\" title=\"Support WebAssembly Component bindings, aka wasip2, in addition to javascript bindings · Issue #2294 · seanmonstar/reqwest\">Support WebAssembly Component bindings, aka wasip2, in addition to javascript bindings · Issue #2294 · seanmonstar/reqwest</a></div><div class=\"message_embed_description\">The current wasm implementation supports compiling to wasm with wasm_bindgen, which is meant to provide bindings for usage from JavaScript in the browser. This aligns with many of the concepts from...</div></div></div>",
        "id": 533762173,
        "sender_full_name": "Alex Casalboni",
        "timestamp": 1754910254
    },
    {
        "content": "<p>two answers to this. if you just want to write new code that uses wasi-http, use <a href=\"https://docs.rs/wstd/latest/wstd/\">https://docs.rs/wstd/latest/wstd/</a></p>",
        "id": 533828042,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1754929545
    },
    {
        "content": "<p>if you want to use existing code that uses reqwest etc, thats still not possible and is blocked on not having enough labor available to collaborate with contribute to all of the projects upstream. the issue 2294 you see there was a really early prototype that one person put together but needed a lot of work with many different upstream projects in order to land, and ultimately there wasnt the resources to follow through on that, and still isnt.</p>",
        "id": 533828294,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1754929628
    },
    {
        "content": "<p>all of the major http frameworks for rust are built on the assumption that the operating system is providing a tcp (or udp fir h3) socket, and the rest of the http implementation is built in the library, including using linking in (or using OS interfaces that provide it) a TLS impl. wasi-http is designed for a very different use case, which is that the \"operating system\" is providing a pretty complete http implementation, takes care of TLS etc.</p>",
        "id": 533828434,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1754929678
    },
    {
        "content": "<p>so since thats a very architecturally different approach, its going to take time and energy to get it integrated with upstream, and in some cases its going to get pushback because it might break abstractions that upstream considered universal</p>",
        "id": 533829002,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1754929885
    },
    {
        "content": "<p>wasip3 doesnt do anything to change that situation, it makes many improvements to how the guests and hosts of wasi-http can work but not to the fundamental problem where this is a different sort of interface than any other operating system provides, so therefore its a pretty disruptive change to the existing libraries that build on windows-and-unix-like operating systems</p>",
        "id": 533829325,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1754930015
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"253992\">@Pat Hickey</span> <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span>  super useful!</p>\n<p>This sounds like a very intentional architectural decision indeed. My understanding is that such a decision makes 99% of existing code/libraries/sdks (that need to make http calls) incompatible with the WebAssembly Component Model.</p>\n<p>In other words, I can't see developers (or API vendors) maintaining WASI-specific libraries and SDKs to interact with their APIs since they already maintain multiple SDKs for each major programming language. The end result is that building Wasm Components with http access requires reimplementing the http clients from scratch. That's not what developers love doing, in my experience.</p>\n<p>I don't want to be disrespectful, but this sounds like a very critical blocker for the Component Model adoption. And it's quite different from other OS-level functionalities such as the file system. Imagine if all libraries that interact with the file system had to be re-written or patched to work properly with WASI. That would be quite unthinkable. So I struggle to understand why this is considered acceptable for the http interface.</p>",
        "id": 533948846,
        "sender_full_name": "Alex Casalboni",
        "timestamp": 1754993697
    },
    {
        "content": "<p>You're not wrong, these noncompatible things are a barrier to adoption. Like I said above, we do understand we need to work on them, and we will, its for lack of resources that we havent, not that we dont understand the importance of compatibility with the ecosystem.</p>",
        "id": 534010447,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1755014085
    },
    {
        "content": "<p>The way I see wasi-http is not as an interface that all existing software just fits into and you cross-compile to wasm and done. Its instead an interface that allows us to run untrusted software in new places where it was difficult or impossible before. We created wasi-http based on experience at Fastly creating their Compute product, and incorporating a bunch of design suggestions from envoy's proxy-wasm project, and right now I'm employed to work on wasi-http implementations at F5 for both nginx and the BigIP load balancers. In all of those scenarios, we had an engineering problem where we needed sandboxed compute, with the lowest possible overhead and fastest possible startup times, in an HTTP server/proxy setting, where the platform already provides the full http implementation and it would be a severe disadvantage for each wasm program to bring its own http stack and use raw sockets at the sandbox boundary. in all of these scenarios, wasm isnt trying to compete with traditional ways of deploying network servers that talk sockets using containers, using k8s or whatever other cloud technologies.</p>\n<p>Prior to wasi-http the solutions to running code in these http server/proxy scanarios were much less developer friendly and/or less powerful - fastly had their own dialect of VCL, envoy had its own ecosystem of configuration and filters, nginx has its own config language and a pretty challenging environment to write modules in C, or you can use njs and lose a lot of js library compatibility, or you can use lua with lots of performance and language ecosystem drawbacks, and F5's BigIP has its own irules language which is a dialect of TCL - in short, none of these places could accept your 99% of existing code anyway, nor could they support code written for another one of these platforms. the value of wasi-http and components is that we make a compatible interface for all of that sort of proxy/server platform, and allow users to pick what suits them from a much bigger range of general purpose programming languages.</p>",
        "id": 534013200,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1755014952
    },
    {
        "content": "<p>so, if you're looking to components to provide a better way to deploy the stuff you currently use containers and k8s to do, its really not there yet. The whole container ecosystem has on the order of 1000-10,000x more engineering investment in it than wasi, so its not surprising to me that we dont measure up to all the nice things youd expect coming from that world. But there are a wide range of problems that containers arent the sweet spot for solving, the http server situations i cited, or plugin engines for your editor (vscode is using components, zed and nvim are both working on it), or plugin engines for a wide range of other applications (e.g. last year I consulted for cubist on <a href=\"https://cubist.dev/blog/introducing-programmable-key-management-policies\">https://cubist.dev/blog/introducing-programmable-key-management-policies</a>, which also does use wasi-http internally), where components and wasi have tremendous advantages over existing solutions.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://cubist.dev/blog/introducing-programmable-key-management-policies\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/a40452765e647d17e646ff5594882b451de15a5b/68747470733a2f2f63646e2e70726f642e776562736974652d66696c65732e636f6d2f3633386132363933646161663835303030333030363561322f3638353234613661383230663937663739386162666466365f696e74726f647563696e672d70726f6772616d6d61626c652d6b65792d6d616e6167656d656e742d706f6c69636965732d7761736d2e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://cubist.dev/blog/introducing-programmable-key-management-policies\" title=\"Cubist Blog - Introducing programmable key management policies\">Cubist Blog - Introducing programmable key management policies</a></div><div class=\"message_embed_description\">We built the Programmable Policy Engine to run normal programs as signing policies inside a Trusted Execution Environment, so developers can define exactly what conditions must be met for a key to sign—and prove that’s the code being enforced.</div></div></div>",
        "id": 534014346,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1755015334
    },
    {
        "content": "<p>Thank you <span class=\"user-mention\" data-user-id=\"253992\">@Pat Hickey</span>, this context is incredibly useful <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span> </p>\n<p>Coming from an app development background, it's not immediately clear why these tradeoffs were taken, and the initial context of \"why Wasm+WASI were initially designed this way\" can get lost in the public documentation. And the (probably overhyped?) vision of \"Wasm+WASI is becoming the next Docker\" doesn't help either.</p>",
        "id": 534175570,
        "sender_full_name": "Alex Casalboni",
        "timestamp": 1755071291
    },
    {
        "content": "<p>Yeah, that one tweet by the docker guy hasnt really done us any favors.</p>",
        "id": 534249315,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1755097204
    }
]