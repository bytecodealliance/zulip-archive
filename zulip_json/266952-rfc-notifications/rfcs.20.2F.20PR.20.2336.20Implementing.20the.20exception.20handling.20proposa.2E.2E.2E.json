[
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2655187315\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<p>Chris, Nick, and I talked about this in-person at the CG meeting over dinner yesterday so I wanted to drop some notes here from what we talked about so we don't forget:</p>\n<ul>\n<li>We probably don't actually want to do the \"set flags on exception\" ABI. That means it's (a) a new ABI to maintain and (b) we can't ever turn it on by default. In some sense \"wasted work\" but also it's a lot more to maintain over time.</li>\n<li>To assist with unwinding we say that an \"invoke\" will always spill all registers (everything is caller-saved) initially. That way we don't have to recover registers during unwinding.</li>\n<li>We won't remove setjmp/longjmp yet, so that'll stay for traps (although it would be good to do it with instructions in Cranelift instead one day)</li>\n<li>As a first stepping stone it might be interesting to add a mode where we just trap on throws. Non-exceptional programs could then be run/benchmarked which might help some early users dogfood.</li>\n</ul>\n</blockquote>",
        "id": 499356702,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1739408066
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2686060386\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<p>@dhil is it okay if I take over this RFC to get it across the finish line?</p>\n</blockquote>",
        "id": 502132934,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1740599919
    },
    {
        "content": "<p>dhil <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2686216352\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<blockquote>\n<p>@dhil is it okay if I take over this RFC to get it across the finish line?</p>\n</blockquote>\n<p>Yes absolutely!</p>\n</blockquote>",
        "id": 502145896,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1740604592
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>.</p>",
        "id": 503377098,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741127241
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2699105777\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<p>Just pushed a pretty major overhaul to this RFC, incorporating changes from this discussion and others:</p>\n<ul>\n<li><code>try_call</code> now have multiple exception paths, like <code>br_table</code></li>\n<li>no more calling convention stuff, just side tables</li>\n<li>and more</li>\n</ul>\n<p>Please take another look!</p>\n</blockquote>",
        "id": 503377314,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741127323
    },
    {
        "content": "<p>programmerjake submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2659381558\">PR review</a>.</p>",
        "id": 503382646,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741129700
    },
    {
        "content": "<p>programmerjake created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1980397630\">PR review comment</a>:</p>\n<blockquote>\n<p>\"this just not\" -- typo?</p>\n</blockquote>",
        "id": 503382647,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741129700
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2659509483\">PR review</a>:</p>\n<blockquote>\n<p>Thanks for taking this on @fitzgen, it's looking very good to me <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n</blockquote>",
        "id": 503392051,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741134229
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1980465482\">PR review comment</a>:</p>\n<blockquote>\n<p>For the option (3) vs (4) category I'd vote for (4) and would say that we can alleviate this problem by we pretty much have a <a href=\"https://github.com/bytecodealliance/wasmtime/blob/132a490d72e6381c593a409aeca50a765b54ca28/crates/wasmtime/src/runtime/vm/traphandlers.rs#L215\">single location that converts <code>Result&lt;T&gt;</code> into <code>T</code></a> since as the host we also have to do things like <code>catch_unwind</code> which we're doing there as well. Given that I'd vote for (4) as it's less churn in general.</p>\n</blockquote>",
        "id": 503392053,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741134229
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1980467390\">PR review comment</a>:</p>\n<blockquote>\n<p>To confirm, the thinking here is that \"longjmp\" is a standin for \"restore the stack and jump to a pc\", probably via an assembly stub, right? Basically (a) not <code>longjmp</code> itself, (b) not a cranelift-synthesized stub, and (c) simple enough that we can maintain handwritten assembly</p>\n</blockquote>",
        "id": 503392054,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741134229
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2659522306\">PR review</a>:</p>\n<blockquote>\n<p>Thanks for putting this together; the details all basically look good to me! Just one uncertainty/question below.</p>\n</blockquote>",
        "id": 503393358,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741134860
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1980474037\">PR review comment</a>:</p>\n<blockquote>\n<p>(I'm assuming the two-phase exceptions here refer to <a href=\"https://github.com/WebAssembly/exception-handling/issues/123\">this</a> family of ideas)</p>\n<p>Is the transfer itself happening, or only the stack-walker's visit of the metadata at this site? In other words, does the catch itself happen multiple times? This is surprising to me (maybe I need to read more if so!).</p>\n<p>If the actual execution path is taken more than once, this is workable with our all-regs-clobbered approach, but it's worth noting that it will complicate regalloc otherwise: parallel moves on edges (implementing blockparams) are free to assume that they will execute only once, and swap/rotate as needed. Or in other words, a true \"multiple execution\" here is actually implying another (back)-edge that we're not encoding, which is problematic. Hopefully I'm reading too much into this, is all!</p>\n</blockquote>",
        "id": 503393360,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741134860
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2659991174\">PR review</a>:</p>\n<blockquote>\n<p>A few more thoughts on another read-through. Two things to clarify / add more detail on; no issues with the approach at all.</p>\n</blockquote>",
        "id": 503428575,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741153469
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1980735613\">PR review comment</a>:</p>\n<blockquote>\n<p>One thing I've just realized is not discussed explicitly here, and would be good to write down, is how the decision to attach the <code>try</code> primitive to <em>calls</em> interacts with the fact that <code>try</code>-blocks are arbitrary subregions in the Wasm structured control flow.</p>\n<p>This is a well-supported design to be clear, not least because it has the existence proof of LLVM's approach; I only think we should write down a little bit here. Something like:</p>\n<ul>\n<li>Because throws are not a CLIF instruction, they are necessarily a call out to some host primitive;</li>\n<li>Thus, all exception-raises happen when active CLIF functions on the stack are at callsites (either directly to that primitive, or indirectly to some other function that eventually reaches that primitive);</li>\n<li>Thus, it is sufficient to attach handler information only to callsites.</li>\n</ul>\n<p>The compilation strategy for a Wasm function body is then to track the active handlers for the try block(s) containing any given callsite as we translate to CLIF, and attach that list of handlers to each callsite as we translate it (with inner blocks for the same tag shadowing outer blocks as appropriate). We use an <code>invoke</code> whenever we're inside at least one <code>try</code> block, and a <code>call</code> otherwise (then the unwinder passes over us).</p>\n<p>On that last point: we should also note explicitly that the unwinder will pass over frames at callsites with ordinary <code>call</code> (or <code>call_indirect</code> or <code>return_call[_indirect]</code>) instructions; there is no need to always use <code>invoke</code> when an exception may be thrown somewhere down the stack. (This may follow straightforwardly from ordinary exception semantics for those in-the-know but isn't obvious at first, IMHO!) This is what permits a function-local compilation strategy to continue to work without e.g. exceptions in signatures; and it is possible to implement in Cranelift with our clobber-save scheme because we don't care about saving regs of a frame we won't restore to (when any frame above it that catches will have all of <em>its</em> regs saved).</p>\n</blockquote>",
        "id": 503428576,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741153469
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1980737201\">PR review comment</a>:</p>\n<blockquote>\n<p>It's probably worth noting here that we explicitly do not have <code>try_</code> variants of the tailcall instructions (<code>return_call[_indirect]</code>) because they remove the current frame from the stack, so it certainly can't expect to catch anything (!). Pretty clearly follows from that but not obvious at first if one is only looking at the different kinds of calls.</p>\n</blockquote>",
        "id": 503428577,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741153469
    },
    {
        "content": "<p>programmerjake submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2660154325\">PR review</a>.</p>",
        "id": 503437812,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741158476
    },
    {
        "content": "<p>programmerjake created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1980819822\">PR review comment</a>:</p>\n<blockquote>\n<p>so, for translation from wasm exceptions, do all exceptions translate to the same tag? if not, how do you handle the <code>catch_all</code> or <code>catch_all_ref</code> instructions?</p>\n</blockquote>",
        "id": 503437813,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741158476
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1980735613\">PR review comment</a>.</p>",
        "id": 503444565,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741161366
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2661836724\">PR review</a>.</p>",
        "id": 503581106,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741194967
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1981845377\">PR review comment</a>:</p>\n<blockquote>\n<p>To comment on this specifically, we talked about this in the Cranelift meeting today and I filed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10336\">https://github.com/bytecodealliance/wasmtime/issues/10336</a> which is certainly extra work but I think is \"The Answer\" for how to recover something that's <code>dwarfdump</code>-like with our own custom format</p>\n</blockquote>",
        "id": 503581108,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741194967
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2665193216\">PR review</a>.</p>",
        "id": 503852113,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741282666
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1983796148\">PR review comment</a>:</p>\n<blockquote>\n<p>C++ exceptions (and I assume Rust panics as well?) are two-phase. That link is a bit tree- rather than forest-focused, but I think this gives a decent, concise overview of C++'s two-phase implementation: <a href=\"https://nicolasbrailo.github.io/blog/2013/0326_Cexceptionsunderthehood8twophasehandling.html\">https://nicolasbrailo.github.io/blog/2013/0326_Cexceptionsunderthehood8twophasehandling.html</a></p>\n<p>If the first phase (search) always happened purely in the runtime based on the metadata in the side tables and only the second phase (cleanup) actually jumped to the landing pads, then we would only execute them once and I think we would be fine. That may be incompatible with reusing the existing system unwinder in <code>cg_clif</code>, but that might be the situation anyways, I'm not sure. cc @bjorn3 </p>\n<p>But yeah, I suspect this is probably why LLVM denotes landing pads as their own kind of block, rather than making them uniform with regular blocks: landing pads are essentially weird secondary function entry points whose transitive closure can't overwrite any (live) stack slots from the main function because they might be used upon resumption (catch) or read in the next invocation of the landing pad and all that stuff you mentioned above, and therefore it makes sense to flag them as different because they require special handling.</p>\n<p><em>shrug</em></p>\n<p>Kind of feel like maybe we should just ignore all this for now...</p>\n</blockquote>",
        "id": 503852115,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741282666
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2665201612\">PR review</a>.</p>",
        "id": 503852837,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741282856
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1983801270\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>we pretty much have a <a href=\"https://github.com/bytecodealliance/wasmtime/blob/132a490d72e6381c593a409aeca50a765b54ca28/crates/wasmtime/src/runtime/vm/traphandlers.rs#L215\">single location that converts <code>Result&lt;T&gt;</code> into <code>T</code></a></p>\n</blockquote>\n<p>I meant guest code, not VM code. All this discussion is in the context of, e.g., what kind of result should we return from <code>Func::call</code>. While our VM code is fixed and we can make claims like \"there is one place that cares about X\", guest code is an open world where we don't know how often people want to check for, handle, or automatically propagate exception results from <code>Func::call</code>. If we knew that answer, then choosing between (3) and (4) would be straightforward. But we don't yet, and it is also somewhat future-looking, so I am not sure how to proceed.</p>\n</blockquote>",
        "id": 503852838,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741282856
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2665208764\">PR review</a>.</p>",
        "id": 503853568,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741283053
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1983805371\">PR review comment</a>:</p>\n<blockquote>\n<p>No, sorry if this isn't clear: this sentence is referring to the existing <code>longjmp</code>s we have for panics and traps that skip over Wasm code. That <code>longjmp</code> path is mentioned just as a path we would _skip_ if there is an exception (instead of a panic/trap that we need to propagate over Wasm frames).</p>\n<p>Eventually we want to have inline Cranelift stubs to replace that, but that is orthogonal to this RFC, as mentioned in the footnote.</p>\n</blockquote>",
        "id": 503853570,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741283054
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2665221265\">PR review</a>.</p>",
        "id": 503854541,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741283336
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1983811716\">PR review comment</a>:</p>\n<blockquote>\n<p>We should be able to reserve a sentinel value for \"all\".</p>\n</blockquote>",
        "id": 503854542,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741283336
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1983811716\">PR review comment</a>.</p>",
        "id": 503854684,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741283386
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2665269792\">PR review</a>.</p>",
        "id": 503859164,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741284714
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1983841211\">PR review comment</a>:</p>\n<blockquote>\n<p>Hmm, yeah, OK, I had been assuming that the search phase would happen purely during the unwinder's stack-walk and table lookups, and that there would not be any invocation of Cranelift-compiled code until we find the handling frame and unwind to that point / jump to the handler. I was worried that the Wasm-specific discussion might imply a mechanism that explicitly exposes the phases in the future; but the current proposal doesn't have anything like that, it seems.</p>\n<p>I've looked at <a href=\"https://llvm.org/docs/ExceptionHandling.html\">the LLVM EH reference</a> where it says \"LLVM landing pads are conceptually alternative function entry points where an exception structure reference and a type info index are passed in as arguments.\" I kind of wish they had gone into more depth <em>why</em> they need to handle things this way, rather than have an ordinary control-flow edge out of the <code>invoke</code>...</p>\n<p>Anyway, I agree: let's design to Wasm exceptions, and we don't need multiple-shot resume here, so let's assume that the search phase can be done fully in the unwinder/runtime based on tables. If we need multiple-shot resume that's weird enough that we would need really a fully audit of the compiler/regalloc and a lot more careful thought than is in scope here IMHO!</p>\n</blockquote>",
        "id": 503859166,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741284714
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1983841211\">PR review comment</a>.</p>",
        "id": 503859338,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741284756
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2665301094\">PR review</a>.</p>",
        "id": 503862284,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741285607
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1983860329\">PR review comment</a>:</p>\n<blockquote>\n<p>Some more background on the LLVM side of things might be SEH on Windows. Circa 2015 IIRC LLVM only supported <code>invoke</code> and dwarf-based unwinding and then things changed quite a lot once SEH got implemented, so much so that brand new constructs were added to LLVM IR for SEH. Personally I know very little of SEH, as I suspect most others do too, but I know it's different enough from dwarf unwinding that there's probably not a one-size-fits-all low-level abstraction.</p>\n<p>Anyway that's just possible background to LLVM, I don't mean to detract from the conclusion here of focusing on wasm exceptions, which I personally very much agree with <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n</blockquote>",
        "id": 503862288,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741285608
    },
    {
        "content": "<p>programmerjake submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2665675147\">PR review</a>.</p>",
        "id": 503893653,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741296409
    },
    {
        "content": "<p>programmerjake created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1984075746\">PR review comment</a>:</p>\n<blockquote>\n<p>ok, so then cranelift most likely will need to support a wildcard exception tag, this should probably be added to the rfc</p>\n</blockquote>",
        "id": 503893655,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741296410
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2665778541\">PR review</a>.</p>",
        "id": 503903689,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741300238
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1984138954\">PR review comment</a>:</p>\n<blockquote>\n<p>This shouldn't require anything from Cranelift, the semantics of individual <code>ir::ExceptionTag</code>s and which one is the wildcard sentinel can all happen at the Wasmtime level. The fact that a particular <code>ir::ExceptionTag</code> is treated as a wildcard by Wasmtime should not have any affect on what Cranelift does.</p>\n</blockquote>",
        "id": 503903690,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741300238
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2665784190\">PR review</a>.</p>",
        "id": 503904351,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741300478
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1984142433\">PR review comment</a>:</p>\n<blockquote>\n<p>For C++ two-phase exceptions, the search phase does not run landingpads. Only once the frame that catches the exception has been determined does the stack get unwound and landingpads executed. During the search phase the personality function does run, but the personality function is called by the unwinding runtime like any other regular function. And the personality function normally doesn't need need to touch any registers or the stack during the search phase (unless you the compiler which the personality function is associated with requires this, but neither GCC nor LLVM require this and Cranelift should probably mirror this.)</p>\n</blockquote>",
        "id": 503904355,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741300479
    },
    {
        "content": "<p>bjorn3 edited <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1984142433\">PR review comment</a>.</p>",
        "id": 503904377,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741300496
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2665785512\">PR review</a>.</p>",
        "id": 503904450,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741300538
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1984143244\">PR review comment</a>:</p>\n<blockquote>\n<p>Thanks, fixed.</p>\n</blockquote>",
        "id": 503904451,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741300538
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>.</p>",
        "id": 503904557,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741300570
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2665788869\">PR review</a>.</p>",
        "id": 503904835,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741300688
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1984145312\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>But yeah, I suspect this is probably why LLVM denotes landing pads as their own kind of block, rather than making them uniform with regular blocks: landing pads are essentially weird secondary function entry points whose transitive closure can't overwrite any (live) stack slots from the main function because they might be used upon resumption (catch) or read in the next invocation of the landing pad and all that stuff you mentioned above, and therefore it makes sense to flag them as different because they require special handling.</p>\n</blockquote>\n<p>I think it is just because a landingpad often itself has arguments to indicate what exception was thrown. The landingpad arguments generally have different types from the regular return value. An invoke can't call a landingpad twice.</p>\n</blockquote>",
        "id": 503904837,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741300688
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>.</p>",
        "id": 503906629,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741301440
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1984138954\">PR review comment</a>.</p>",
        "id": 503906689,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741301474
    },
    {
        "content": "<p>programmerjake submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2665877264\">PR review</a>.</p>",
        "id": 503915489,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741305238
    },
    {
        "content": "<p>programmerjake created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1984202576\">PR review comment</a>:</p>\n<blockquote>\n<p>ah, ok. I thought the unwinder would be a cranelift thing.</p>\n</blockquote>",
        "id": 503915490,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741305238
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2667525719\">PR review</a>.</p>",
        "id": 504115022,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741359562
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1985219072\">PR review comment</a>:</p>\n<blockquote>\n<p>Guest profiling doesn't need stack unwinding, only stack walking, right? The difference between the two is that stack unwinding will run compiled code for each stack frame (and generally destroy the stack frame in the process) while stack walking just iterates over all stack frames and gets the instruction pointer. Stack walking can be done with either frame pointers or unwind tables, while stack unwinding needs more compiler cooperation. Cranelift already supports stack walking.</p>\n</blockquote>",
        "id": 504115023,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741359562
    },
    {
        "content": "<p>bjorn3 edited <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1985219072\">PR review comment</a>.</p>",
        "id": 504115118,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741359591
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2667537810\">PR review</a>.</p>",
        "id": 504116221,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741359845
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1985226114\">PR review comment</a>:</p>\n<blockquote>\n<p>SEH and <code>.eh_frame</code> use fundamentally different approaches that I don't think are easy to unify at the IR level. <code>.eh_frame</code> uses landingpads where execution continues in the context of the stack frame that you unwind into. This way you can for example return from the exception handler like normal. SEH however uses funclets which are functions that get the stack pointer of the stack frame as argument. Funclets can't return from the stack frame on which they get invoked. Catching exceptions requires cooperation with the filter function.</p>\n</blockquote>",
        "id": 504116223,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741359845
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2667543757\">PR review</a>.</p>",
        "id": 504116830,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741359984
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1985229556\">PR review comment</a>:</p>\n<blockquote>\n<p>Two phase exceptions doesn't run langing pads multiple times. Only the personality function.</p>\n</blockquote>",
        "id": 504116832,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741359984
    },
    {
        "content": "<p>bjorn3 edited <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1985229556\">PR review comment</a>.</p>",
        "id": 504117445,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741360130
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2667553863\">PR review</a>.</p>",
        "id": 504117554,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741360157
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1985234204\">PR review comment</a>:</p>\n<blockquote>\n<p>s/three/two?</p>\n</blockquote>",
        "id": 504117555,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741360157
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2667564355\">PR review</a>.</p>",
        "id": 504118206,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741360327
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1985239058\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>and where their respective handlers are located.</p>\n</blockquote>\n<p>The format for this is not specified by DWARF. Each language runtime is expected to define their own format. The personality function exists to interpret this format. Cranelift should probably emit the information necessary for consumers to emit the side table in whatever format they need.</p>\n</blockquote>",
        "id": 504118207,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741360327
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2667573869\">PR review</a>.</p>",
        "id": 504118808,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741360481
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1985243495\">PR review comment</a>:</p>\n<blockquote>\n<p>*associated</p>\n</blockquote>",
        "id": 504118810,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741360481
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2667577038\">PR review</a>.</p>",
        "id": 504119009,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741360537
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1985245067\">PR review comment</a>:</p>\n<blockquote>\n<p>I feel like wasm-opt or such should get a mode which turns all exception throws into traps. That way other wasm engines without exception support would also be able to handle these modules.</p>\n</blockquote>",
        "id": 504119011,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741360538
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2676024613\">PR review</a>.</p>",
        "id": 504945401,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741724216
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1990069341\">PR review comment</a>:</p>\n<blockquote>\n<p>Good clarification <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n</blockquote>",
        "id": 504945411,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741724216
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2676065676\">PR review</a>.</p>",
        "id": 504950191,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741725424
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1990094078\">PR review comment</a>:</p>\n<blockquote>\n<p>Right, I was referring to the personality function here as DWARF's (really <code>.eh_frame</code>'s) mechanism for determining where the respective handlers are located, since each FDE _can_ have its own personality function, and calling the function is the mechanism for figuring out if this frame is handling the exception or not. Of course, the personality functions are free to be implemented however they want, such as using a single personality routine for every FDE that interprets a custom format (as you mention) or using a bespoke personality function for every single landing pad with that landing pad's logic (that would otherwise have been in that custom format table) inlined into each FDE's personality function. But yeah, I think this is all a bit in the weeds and these details are not really relevant to the RFC itself.</p>\n</blockquote>",
        "id": 504950193,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741725424
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2676072001\">PR review</a>.</p>",
        "id": 504950813,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741725619
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r1990097891\">PR review comment</a>:</p>\n<blockquote>\n<p>I agree that would be nice, but of course I don't maintain <code>wasm-opt</code> :)</p>\n<p>We can always remove this knob if people don't use it or don't find it useful. But it will be nice as an incremental milestone either way. And it would always be useful if <code>wasm-opt</code> didn't support some proposed Wasm feature that Wasmtime did, and therefore you couldn't use <code>wasm-opt</code> to do this as a wasm-to-wasm transform because it would balk at the unimplemented feature usage.</p>\n</blockquote>",
        "id": 504950815,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741725619
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>.</p>",
        "id": 504951182,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741725735
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2715664736\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<p>As we seem to have reached pretty broad consensus, and feedback has moved more into the realm of typo fixes and minor clarifications, I'd like to propose that we merge this RFC!</p>\n<h1>Motion to Finalize</h1>\n<p><strong>Disposition: Merge</strong></p>\n<hr>\n<p>As always, details on the RFC process can be found here: <a href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/rfc-process.md#making-a-decision-merge-or-close\">https://github.com/bytecodealliance/rfcs/blob/main/accepted/rfc-process.md#making-a-decision-merge-or-close</a></p>\n</blockquote>",
        "id": 504951726,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741725909
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2715673767\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<p>I'd second the motion to merge <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n</blockquote>",
        "id": 504952632,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741726190
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2676116231\">PR review</a>:</p>\n<blockquote>\n<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n<p>At the risk of going to pun-jail, I have to note that I find this RFC... exceptional. Seconding!</p>\n</blockquote>",
        "id": 504955397,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741726996
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2715733657\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<p>As there has been signoff from representatives of two different BA stakeholder organizations, this RFC is now entering its 10-day</p>\n<h1>Final Comment Period</h1>\n<p>and the last day to raise concerns before this RFC merges is 2025-03-21.</p>\n<p>Thanks everyone!</p>\n</blockquote>",
        "id": 504958660,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1741728038
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2735268674\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<p>At the risk of slightly re-opening Pandora's box, I have a... <em>final comment</em>... during the Final Comment Period.</p>\n<p>I'm ~1.5 days into implementing the Cranelift side of exception handling right now, and I have been realizing in a fairly deep way how the block-parameter strategy we have in this RFC may be suboptimal. In brief, the problem is that breaking the invariant that the block-call arguments in the target match up with the parameters on that block is leading to a <em>lot</em> of refactoring and gross hacks throughout the compiler. I don't doubt that I could continue to bulldoze through, but I'm worried that this is a strong signal about design coherence that will lead to future pain and bugs as we work with the IR, so I took a step back to think a bit (and talk with @fitzgen offline earlier today).</p>\n<p>We originally decided above that we would write <code>try_call fn0(args...), block1(args1), [ tag1: block2(args2), tag2: block3(args3), ... ]</code> to mean that after return, control reaches one of <code>block1</code> (no exception thrown), <code>block2</code> or <code>block3</code> (or unwinds further up the stack) with the following block parameters: (i) returns of <code>fn0</code> concatenated with <code>args1</code> for <code>block1</code>; (ii) a single pointer-width exception payload argument and <code>args2</code> for <code>block2</code>, and (iii) likewise for <code>block3</code>. In other words, the <code>BlockCall</code>s have <code>N</code>, <code>M</code> and <code>P</code> args, but the blocks themselves have <code>N + len(fn0.rets)</code>, <code>M + 1</code>, and <code>P + 1</code> params. This doesn't happen anywhere else in the IR, and leads to a lot of awkwardness in the parser, the verifier, the phi-removal pass, lowering, and regalloc's view of blockparams (so far). We anticipated that this aspect might be a little weird but it seemed tenable at a high level.</p>\n<p>We took this approach because we wanted to achieve a few goals: successor blocks should not be a special category or specially restricted; the IR should encode the invariant that function returns are only valid on normal return, and an exception payload is only valid on catching an exception; and we shouldn't do anything weird with SSA, like define return values and immediately use them in the <code>try_call</code>.</p>\n<p>I believe I have a better solution now though that still preserves these properties, and avoids the higher-than-anticipated impedance mismatches. Namely:</p>\n<ul>\n<li>We don't actually need an exception payload parameter in the IR, we think. In Wasmtime, we always have <code>vmctx</code>, and we can convey exceptional state through a field there (or perhaps in the <code>Store</code> since unwinding can cross instances).</li>\n<li>Return values can be defined by the <code>try_call</code> itself. They must already be defined at this point from a regalloc point of view, as a sort of \"early def\", because the register state will be filled in before control returns to the caller and transfers across the edge to the normal-return target.</li>\n</ul>\n<p>The latter point means that the normal-return values are defined even on exceptional returns. This may seem like a semantic lie. I have what I think is a reasonable answer that technically avoids adding UB to the IR: we could provide in the unwind metadata information about where return values go (registers/stack locations), and specify that it is up to the embedder to either fill those values in, or guarantee that it does not use the values on exceptional paths. (In effect, the values are always \"returned\", it's just that the unwinder decides the return values on unwinding; and Wasmtime is free to decide that the current value in <code>rax</code> at time of throw is the return value, because it generated IR that doesn't care, or it could zero them as a defense-in-depth thing.)</p>\n<p>Anyway, I'd be curious what others think, and I'm happy to fill in more about the pain-points discovered.</p>\n<p>(Slightly tangential but worth saying, IMHO: I personally think we should always at least begin implementation or prototype before fully merging an RFC, and this is why -- there are some things we just can't know fully until we work through all the details!)</p>\n</blockquote>",
        "id": 506629670,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1742357176
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2735391003\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<blockquote>\n<p>We don't actually need an exception payload parameter in the IR, we think</p>\n</blockquote>\n<p>cg_clif absolutely needs it.</p>\n</blockquote>",
        "id": 506638362,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1742362576
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2735480700\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<p>Hmm, that is good to know. And there isn't a way to tunnel the state through, e.g., a TLS slot? I suppose the issue here is that you don't control the stdlib so we basically need the same capability as LLVM for the native-code case...</p>\n<hr>\n<p>I think one way to express what I'm finding in implementation is that there has to be <em>something</em> weird and different about exceptional edges, because they do introduce this payload. That payload has to come out of thin air somehow. The ways we have are:</p>\n<ul>\n<li>No it doesn't -- no payload here! (the new suggestion)</li>\n<li>Extra magical block args that are not in the block call, making the block calls special and different and requiring contortions when viewing those edges</li>\n<li>Extra magical operators at the start of the target blocks (i.e., landingpad instructions), making the blocks special and different and requiring contortions when editing them (and making sharing them harder)</li>\n</ul>\n<p>I suppose the last option -- one I don't like, but just to name it -- is to say that both the normal returns and exceptional returns arise as normal defs, so the instruction results for a <code>try_call</code> are the concatenation of calls and exception payload. (If you squint, this is Go's <code>result, err := f(...)</code>...) But this means that we have extra magical logic when squaring function signatures with instruction results (which will come up in, e.g., ABI code).</p>\n<p>So we either punt on the problem, or we have awkward logic on edges, or awkward logic on blocks, or awkward logic on calls. The native-code case apparently means we can't punt on the problem.</p>\n<p>I'm not sure what to make of this -- we can discuss more in the Cranelift meeting tomorrow I suppose.</p>\n</blockquote>",
        "id": 506644803,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1742366024
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2735589398\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<blockquote>\n<p>And there isn't a way to tunnel the state through, e.g., a TLS slot? I suppose the issue here is that you don't control the stdlib so we basically need the same capability as LLVM for the native-code case...</p>\n</blockquote>\n<p>Yeah, rust_eh_personality only passes it as landingpad argument.</p>\n<p>Did you see how I did the landingpad arguments in my branch by the way. While it adds some complexity, it didn't seem like it added all that much complexity.</p>\n</blockquote>",
        "id": 506652494,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1742369312
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2737618398\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<p>We discussed this in the Cranelift meeting <a href=\"https://github.com/bytecodealliance/meetings/blob/main/cranelift/2025/cranelift-03-19.md\">this morning</a> and came to a relatively reasonable design point, which I'm actually fairly happy about: we decided to reify the \"arising in the middle of an edge\" values, the return values and exception payloads, as a new kind of \"placeholder argument\" in the block calls. There are some sketches of this above but basically it looks like: <code>try_call fn0(...), block1(ret0, ret1, v1, v2), [ tag1: block2(exn0, v3), ... ]</code>. In other words, we allow <code>retN</code> and <code>exnN</code> values in block calls on a <code>try_call[_indirect]</code> instruction.</p>\n<p>Importantly, the args themselves are a sum-type of \"normal value\" or \"placeholder\" (try-call return, try-call exception payload, other in the future?). We don't define a new kind of value; these args are not values.</p>\n<p>This is nice for a few reasons:</p>\n<ul>\n<li>It avoids the problem of mismatching block-call argument list and block parameter list, which started this whole discussion and would be a recurring footgun/wart in the design otherwise.</li>\n<li>It requires only local validation; we can know if the block calls are correct (referring to valid return values and exception payloads) by looking only at the function signature of the called function.</li>\n<li>It feels closest to the reality of where the values are defined: not by the <code>try_call</code> for all dominated instructions in both paths; not in successors (with landingpads or equivalent); but actually <em>on the edge</em>. Code that processes block-call arguments will need to handle this case, but it is front-and-center (and exposable as a new type) rather than an implicit thing.</li>\n<li>It uses syntactic restrictions rather than cross-instruction or cross-block invariants to ensure well-formedness of the construct.</li>\n</ul>\n<p>I'll continue building this and will say more if there are other unanticipated issues, but I don't expect there to be at the moment!</p>\n</blockquote>",
        "id": 506799009,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1742408378
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>.</p>",
        "id": 514178491,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1745514142
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2828303020\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<p>I've updated the RFC based on the final comments and the CLIF design tweaks Chris made during his prototyping.</p>\n<p>Given that the prototyping has merged into Cranelift <code>main</code> and that cg-clif is passing all of Rust's unwinding tests in a branch based on that prototyping, it seems like we are in a great place here and I'm going to go ahead and start a new final comment period on this RFC.</p>\n<hr>\n<h1>Final Comment Period</h1>\n<p><strong>Disposition: merge.</strong></p>\n<p><strong>The last day to raise concerns before this RFC merges is 2025-05-03.</strong></p>\n<p>Thanks again, everyone!</p>\n</blockquote>",
        "id": 514179423,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1745514440
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2791944011\">PR review</a>.</p>",
        "id": 514180452,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1745514791
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2792169867\">PR review</a>.</p>",
        "id": 514203857,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1745519911
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r2059032183\">PR review comment</a>:</p>\n<blockquote>\n<p>This is only done for the tail calling convention. For the system_v calling convention try_call uses the exact same set of clobbered registers as regular call.</p>\n</blockquote>",
        "id": 514203860,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1745519912
    },
    {
        "content": "<p>bjorn3 edited <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#discussion_r2059032183\">PR review comment</a>.</p>",
        "id": 514203948,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1745519933
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2792173345\">PR review</a>.</p>",
        "id": 514204345,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1745520014
    },
    {
        "content": "<p>tschneidereit submitted <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#pullrequestreview-2793456218\">PR review</a>.</p>",
        "id": 514327628,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1745571605
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>.</p>",
        "id": 514426589,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1745601226
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/rfcs/pull/36#issuecomment-2881543556\">commented</a> on <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>:</p>\n<blockquote>\n<p>Whoops, forgot to merge this on the third, so it got some extra FCP time.</p>\n<p>Thanks @dhil for writing the first draft of this RFC and to everyone who provided feedback, brainstormed, and helped improve it!</p>\n</blockquote>",
        "id": 518156631,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1747255804
    },
    {
        "content": "<p>fitzgen merged <a href=\"https://github.com/bytecodealliance/rfcs/pull/36\">PR #36</a>.</p>",
        "id": 518156652,
        "sender_full_name": "RFC notifications bot",
        "timestamp": 1747255809
    }
]