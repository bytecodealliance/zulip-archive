[
    {
        "content": "<p>hi! i'm currently writing a GameCube emulator and using cranelift to JIT the PowerPC Gekko CPU. currently, i've been able to boot my first few games (Luigi's Mansion, Zelda Wind Waker, etc) and while that's awesome, i've found out my JIT performance is insufficient - games run around 20-30% speed in the more intensive parts.</p>\n<p>now, i'm implementing optimizations on my JIT and one of the most common ones is <em>block linking</em>: most block exit points jump to fixed guest addresses, so instead of returning to the dispatcher and searching the block mappings for the block of the target, the executed block could be patched to instead just jump (or tail call) to the block of the target directly.</p>\n<p>i'm looking for ways to implement this within cranelift, since i'd preferably want to <em>not</em> do patching manually (i.e. inspecting the generated machine code and writing out bytes, that sort of thing). i have thought of two possibilities:</p>\n<ol>\n<li>keep the block's <code>Function</code> in memory, modify it and recompile the whole block when i need to patch one of the exits. this seems like the easiest option, but also the worst performing - compiling blocks multiple times for a few changes to call targets isn't ideal... </li>\n<li>create a \"trampoline\" function for each exit point which could then be easily patched, as it's outside the block itself. i'm worried the indirection would hurt performance.</li>\n</ol>\n<p>i'm looking for some insights on other ways to approach the problem, or maybe improve the ones i've listed.</p>",
        "id": 558317969,
        "sender_full_name": "vx",
        "timestamp": 1763592130
    },
    {
        "content": "<p>You may be interested in my <a href=\"https://www.youtube.com/watch?v=Avp55U2JFcQ\">talk</a> at Rust Nation UK where I show how to build a binary translator JIT based on Cranelift. You can find the code <a href=\"https://github.com/Amanieu/a-tale-of-binary-translation\">here</a>.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"Avp55U2JFcQ\" href=\"https://www.youtube.com/watch?v=Avp55U2JFcQ\"><img src=\"https://uploads.zulipusercontent.net/b386a2595629a869fb30608c3fa6bfb7d45d2fef/68747470733a2f2f692e7974696d672e636f6d2f76692f417670353555324a4663512f6d7164656661756c742e6a7067\"></a></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/Amanieu/a-tale-of-binary-translation\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/b1b53370eb6d6025eb9e8c5f8e7459e0bc3743ce/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f303164326234313533323965353565366537633539383036663934653663666665396335623561313633393935393864336336343231333230313838336137302f416d616e6965752f612d74616c652d6f662d62696e6172792d7472616e736c6174696f6e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/Amanieu/a-tale-of-binary-translation\" title=\"GitHub - Amanieu/a-tale-of-binary-translation: Simple RISC-V emulator presented at Rust Nation 2023\">GitHub - Amanieu/a-tale-of-binary-translation: Simple RISC-V emulator presented at Rust Nation 2023</a></div><div class=\"message_embed_description\">Simple RISC-V emulator presented at Rust Nation 2023 - Amanieu/a-tale-of-binary-translation</div></div></div>",
        "id": 558318812,
        "sender_full_name": "Amanieu",
        "timestamp": 1763592557
    },
    {
        "content": "<p>Essentially you want to have a function pointer in global memory for each exit out of a function that initially points to a resolver function. The resolver function will then JIT the block if needed and store the resulting function pointer in the global.</p>",
        "id": 558318978,
        "sender_full_name": "Amanieu",
        "timestamp": 1763592649
    },
    {
        "content": "<p>That's as much as you can do without modifying Cranelift itself.</p>",
        "id": 558319025,
        "sender_full_name": "Amanieu",
        "timestamp": 1763592677
    },
    {
        "content": "<p>that's pretty similar to the second idea i listed, except better! indeed, there's no need for a trampoline function - calling a function pointer and then modifying it is a great idea.</p>",
        "id": 558319434,
        "sender_full_name": "vx",
        "timestamp": 1763592893
    },
    {
        "content": "<p>i also think this is would be pretty good performance-wise. i'll take a look at your talk, too. thanks for the insight :)</p>",
        "id": 558319541,
        "sender_full_name": "vx",
        "timestamp": 1763592952
    }
]