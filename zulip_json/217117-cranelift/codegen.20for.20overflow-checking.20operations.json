[
    {
        "content": "<p>Currently if you codegen an operation such as <code>u64::checked_sub(v)</code> to wasm you are going to get a sequence of operations that first check for bounds (<code>i64.lt_u</code> in this case) and then the actual subtraction inside an if.</p>\n<p>This seems to be compiled pretty much verbatim by clift on x86:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">mov</span><span class=\"w\">    </span><span class=\"mh\">0x30</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">rdi</span><span class=\"p\">),</span><span class=\"o\">%</span><span class=\"n\">rax</span>\n<span class=\"w\">  </span><span class=\"n\">cmp</span><span class=\"w\">    </span><span class=\"cp\">$</span><span class=\"mh\">0x4d2</span><span class=\"p\">,</span><span class=\"o\">%</span><span class=\"n\">rax</span>\n<span class=\"w\">  </span><span class=\"n\">jb</span><span class=\"w\">     </span><span class=\"n\">fail</span>\n<span class=\"w\">  </span><span class=\"n\">sub</span><span class=\"w\">    </span><span class=\"cp\">$</span><span class=\"mh\">0x4d2</span><span class=\"p\">,</span><span class=\"o\">%</span><span class=\"n\">rax</span>\n<span class=\"w\">  </span><span class=\"n\">mov</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"p\">,</span><span class=\"mh\">0x30</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">rdi</span><span class=\"p\">)</span>\n<span class=\"n\">fail</span><span class=\"p\">:</span>\n<span class=\"w\">  </span><span class=\"nc\">ud2</span>\n</code></pre></div>\n<p>However this can compute sub and get overflow information from flags directly. A-la:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">mov</span><span class=\"w\">    </span><span class=\"mh\">0x30</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">rdi</span><span class=\"p\">),</span><span class=\"o\">%</span><span class=\"n\">rax</span>\n<span class=\"w\">  </span><span class=\"n\">sub</span><span class=\"w\">    </span><span class=\"cp\">$</span><span class=\"mh\">0x4d2</span><span class=\"p\">,</span><span class=\"o\">%</span><span class=\"n\">rax</span>\n<span class=\"w\">  </span><span class=\"n\">jo</span><span class=\"w\">     </span><span class=\"n\">fail</span>\n<span class=\"w\">  </span><span class=\"n\">mov</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"p\">,</span><span class=\"mh\">0x30</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">rdi</span><span class=\"p\">)</span>\n<span class=\"n\">fail</span><span class=\"p\">:</span>\n<span class=\"w\">  </span><span class=\"nc\">ud2</span>\n</code></pre></div>\n<p>Would such optimization be desirable? Is there an issue for this?</p>",
        "id": 543955558,
        "sender_full_name": "Simonas (nagisa)",
        "timestamp": 1760015275
    },
    {
        "content": "<p>Similarly silly thing happens when using i64.sub128 to test for overflow as well:</p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"w\">  </span><span class=\"nf\">mov</span><span class=\"w\">    </span><span class=\"mi\">0x30</span><span class=\"p\">(</span><span class=\"nv\">%rdi</span><span class=\"p\">),</span><span class=\"nv\">%rax</span>\n<span class=\"w\">  </span><span class=\"nf\">xor</span><span class=\"w\">    </span><span class=\"nv\">%rdx</span><span class=\"p\">,</span><span class=\"nv\">%rdx</span><span class=\"w\">                 </span><span class=\"c1\">;; rdx = 0</span>\n<span class=\"w\">  </span><span class=\"nf\">sub</span><span class=\"w\">    </span><span class=\"no\">$0x4d2</span><span class=\"p\">,</span><span class=\"nv\">%rax</span>\n<span class=\"w\">  </span><span class=\"nf\">sbb</span><span class=\"w\">    </span><span class=\"no\">$0x0</span><span class=\"p\">,</span><span class=\"nv\">%rdx</span><span class=\"w\">                 </span><span class=\"c1\">;; rdx = 0 - 0 - overflow_flag</span>\n<span class=\"w\">  </span><span class=\"nf\">test</span><span class=\"w\">   </span><span class=\"nv\">%rdx</span><span class=\"p\">,</span><span class=\"nv\">%rdx</span><span class=\"w\">                 </span><span class=\"c1\">;; rdx == 0?</span>\n<span class=\"w\">  </span><span class=\"nf\">jne</span><span class=\"w\">    </span><span class=\"no\">fail</span>\n<span class=\"w\">  </span><span class=\"nf\">mov</span><span class=\"w\">    </span><span class=\"nv\">%rax</span><span class=\"p\">,</span><span class=\"mi\">0x30</span><span class=\"p\">(</span><span class=\"nv\">%rdi</span><span class=\"p\">)</span>\n<span class=\"nl\">fail:</span>\n<span class=\"w\">  </span><span class=\"nf\">ud2</span>\n</code></pre></div>\n<p>which could equally test for overflow flag.</p>\n<p>Sample wat:</p>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">module</span>\n  <span class=\"p\">(</span><span class=\"k\">global</span> <span class=\"nv\">$glob</span> <span class=\"p\">(</span><span class=\"k\">mut</span> <span class=\"kt\">i64</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">i64.const</span> <span class=\"mf\">12345</span><span class=\"p\">))</span>\n\n  <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"one\"</span><span class=\"p\">)</span>\n    <span class=\"nb\">global.get</span> <span class=\"nv\">$glob</span>\n    <span class=\"nb\">i64.const</span> <span class=\"mf\">1234</span>\n    <span class=\"nb\">i64.lt_u</span>\n    <span class=\"k\">if</span>\n      <span class=\"nb\">unreachable</span>\n    <span class=\"k\">else</span>\n      <span class=\"p\">(</span><span class=\"nb\">i64.sub</span> <span class=\"p\">(</span><span class=\"nb\">global.get</span> <span class=\"nv\">$glob</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">i64.const</span> <span class=\"mf\">1234</span><span class=\"p\">))</span>\n      <span class=\"nb\">global.set</span> <span class=\"nv\">$glob</span>\n    <span class=\"k\">end</span>\n  <span class=\"p\">)</span>\n\n  <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"two\"</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"k\">local</span> <span class=\"kt\">i64</span><span class=\"p\">)</span>\n    <span class=\"nb\">global.get</span> <span class=\"nv\">$glob</span>\n    <span class=\"nb\">local.tee</span> <span class=\"mi\">0</span>\n    <span class=\"nb\">i64.const</span> <span class=\"mf\">1234</span>\n    <span class=\"nb\">i64.lt_u</span>\n    <span class=\"k\">if</span>\n      <span class=\"nb\">unreachable</span>\n    <span class=\"k\">else</span>\n      <span class=\"p\">(</span><span class=\"nb\">i64.sub</span> <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"nb\">i64.const</span> <span class=\"mf\">1234</span><span class=\"p\">))</span>\n      <span class=\"nb\">global.set</span> <span class=\"nv\">$glob</span>\n    <span class=\"k\">end</span>\n  <span class=\"p\">)</span>\n\n  <span class=\"p\">(</span><span class=\"k\">func</span> <span class=\"p\">(</span><span class=\"k\">export</span> <span class=\"s2\">\"three\"</span><span class=\"p\">)</span>\n    <span class=\"p\">(</span><span class=\"k\">local</span> <span class=\"kt\">i64</span><span class=\"p\">)</span>\n    <span class=\"nb\">global.get</span> <span class=\"nv\">$glob</span>\n    <span class=\"nb\">i64.const</span> <span class=\"mi\">0</span>\n    <span class=\"nb\">i64.const</span> <span class=\"mf\">1234</span>\n    <span class=\"nb\">i64.const</span> <span class=\"mi\">0</span>\n    <span class=\"nb\">i64.sub</span><span class=\"mf\">128</span>\n    <span class=\"nb\">i64.eqz</span>\n    <span class=\"k\">if</span>\n    <span class=\"k\">else</span>\n      <span class=\"nb\">unreachable</span>\n    <span class=\"k\">end</span>\n    <span class=\"nb\">global.set</span> <span class=\"nv\">$glob</span>\n  <span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</code></pre></div>",
        "id": 543957515,
        "sender_full_name": "Simonas (nagisa)",
        "timestamp": 1760015747
    },
    {
        "content": "<p>Optimizations are definitely desirable! This is a space that has historically been quite tricky to optimize, but if possible we'd definitely be interested</p>",
        "id": 543977922,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1760020521
    },
    {
        "content": "<p>it's tricky to match on in Cranelift's mid-end optimization framework because the operation is split across control-flow blocks</p>",
        "id": 543991258,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1760023829
    },
    {
        "content": "<p>I think the i64.sub128 case might be possible to improve without going across a control flow block. The clif looks this currently:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">                                </span><span class=\"n\">block0</span><span class=\"p\">(</span><span class=\"n\">v0</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v1</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i64</span><span class=\"p\">):</span>\n<span class=\"o\">@</span><span class=\"mi\">006</span><span class=\"n\">c</span><span class=\"w\">                               </span><span class=\"n\">v4</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">load</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">table</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"o\">+</span><span class=\"mi\">48</span>\n<span class=\"w\">                                    </span><span class=\"n\">v17</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">uextend</span><span class=\"p\">.</span><span class=\"kt\">i128</span><span class=\"w\"> </span><span class=\"n\">v4</span>\n<span class=\"o\">@</span><span class=\"mi\">0070</span><span class=\"w\">                               </span><span class=\"n\">v6</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"mi\">1234</span>\n<span class=\"w\">                                    </span><span class=\"n\">v19</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">uextend</span><span class=\"p\">.</span><span class=\"kt\">i128</span><span class=\"w\"> </span><span class=\"n\">v6</span><span class=\"w\">  </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">v6</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1234</span>\n<span class=\"o\">@</span><span class=\"mi\">0075</span><span class=\"w\">                               </span><span class=\"n\">v10</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">isub</span><span class=\"w\"> </span><span class=\"n\">v17</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v19</span>\n<span class=\"o\">@</span><span class=\"mi\">0075</span><span class=\"w\">                               </span><span class=\"n\">v11</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v12</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">isplit</span><span class=\"w\"> </span><span class=\"n\">v10</span>\n<span class=\"o\">@</span><span class=\"mi\">006</span><span class=\"n\">a</span><span class=\"w\">                               </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iconst</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"o\">@</span><span class=\"mi\">0077</span><span class=\"w\">                               </span><span class=\"n\">v13</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">icmp</span><span class=\"w\"> </span><span class=\"n\">eq</span><span class=\"w\"> </span><span class=\"n\">v12</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\">  </span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">v2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"o\">@</span><span class=\"mi\">0077</span><span class=\"w\">                               </span><span class=\"n\">v14</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">uextend</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"n\">v13</span>\n<span class=\"o\">@</span><span class=\"mi\">007</span><span class=\"n\">b</span><span class=\"w\">                               </span><span class=\"n\">trapz</span><span class=\"w\"> </span><span class=\"n\">v14</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">user11</span>\n<span class=\"o\">@</span><span class=\"mi\">0078</span><span class=\"w\">                               </span><span class=\"n\">jump</span><span class=\"w\"> </span><span class=\"n\">block2</span>\n\n<span class=\"w\">                                </span><span class=\"n\">block2</span><span class=\"p\">:</span>\n<span class=\"o\">@</span><span class=\"mi\">007</span><span class=\"n\">a</span><span class=\"w\">                               </span><span class=\"n\">jump</span><span class=\"w\"> </span><span class=\"n\">block3</span>\n\n<span class=\"w\">                                </span><span class=\"n\">block3</span><span class=\"p\">:</span>\n<span class=\"o\">@</span><span class=\"mi\">007</span><span class=\"n\">d</span><span class=\"w\">                               </span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"kt\">i64</span><span class=\"w\"> </span><span class=\"n\">notrap</span><span class=\"w\"> </span><span class=\"n\">aligned</span><span class=\"w\"> </span><span class=\"n\">table</span><span class=\"w\"> </span><span class=\"n\">v11</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"o\">+</span><span class=\"mi\">48</span>\n<span class=\"o\">@</span><span class=\"mi\">007</span><span class=\"n\">f</span><span class=\"w\">                               </span><span class=\"n\">jump</span><span class=\"w\"> </span><span class=\"n\">block1</span>\n\n<span class=\"w\">                                </span><span class=\"n\">block1</span><span class=\"p\">:</span>\n<span class=\"o\">@</span><span class=\"mi\">007</span><span class=\"n\">f</span><span class=\"w\">                               </span><span class=\"k\">return</span>\n</code></pre></div>\n<p>The part with icmp at @0077 in particular could probably be simplified to just (if trapz supports non-i32 sized registers?)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">@</span><span class=\"mi\">007</span><span class=\"n\">b</span><span class=\"w\">                               </span><span class=\"n\">trapz</span><span class=\"w\"> </span><span class=\"n\">v12</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">user11</span>\n</code></pre></div>\n<p>cause it just compares value with 0 and then passes it along into trapz.</p>",
        "id": 543993201,
        "sender_full_name": "Simonas (nagisa)",
        "timestamp": 1760024325
    },
    {
        "content": "<p>(assuming I'm looking at post-optimization clif as output by wasmtime --emit-clif?)</p>",
        "id": 543993699,
        "sender_full_name": "Simonas (nagisa)",
        "timestamp": 1760024467
    },
    {
        "content": "<p>if nobody takes this on, I may take a look at least at the last thing here over the weekend.</p>",
        "id": 543995035,
        "sender_full_name": "Simonas (nagisa)",
        "timestamp": 1760024815
    },
    {
        "content": "<p>(to trapnz, not trapz…)</p>",
        "id": 543996600,
        "sender_full_name": "Simonas (nagisa)",
        "timestamp": 1760025206
    },
    {
        "content": "<blockquote>\n<p>However this can compute sub and get overflow information from flags directly</p>\n</blockquote>\n<p>This is going to be very tricky and needs careful design work, as a warning -- there are a number of tough-to-crack reasons that we don't share flags generation with multiple consumers of those flags:</p>\n<ul>\n<li>We don't track flags with regalloc, and doing so would be tricky because a \"spill\" is very expensive (either a special instruction like pushf on x86-64 or msr on aarch64, or just rematerializing all the flags) and there's only one set of flags. The consequence of this is that we always codegen flags producers and consumers together</li>\n<li>In essence this is an \"opportunistic rematerialization\" optimization, where we notice some other instruction has computed a result and we can use it too. We don't have any infrastructure for that in isel and in general it's an NP-complete (set-cover) problem so we'd want to decide on a good approximation strategy</li>\n<li>All of our opts are on a single value, not \"seeing two similar values side-by-side\". We do have some ideas that we came up with when discussing how to merge div/rem into one instruction if the ISA gives us that; the basic idea would be to have a mid-end rewrite that turns both sub <em>and</em> the icmp into a \"subtract result and icmp result\" combo op, then let GVN do its thing, and rely on the cost minimization to pick the combined op. But that needs the cost minimization to be aware of multiple uses amortizing cost, which it doesn't do today</li>\n</ul>\n<p>All this to say, it's not a simple \"add an opt rule\" thing -- we need deep thought on our core algorithms to give us the tools to do this</p>",
        "id": 544015377,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1760030894
    },
    {
        "content": "<p>I started prodding the i64.sub128 case with what I think should be relatively straightforward:</p>\n<div class=\"codehilite\" data-code-language=\"isle\"><pre><span></span><code>(rule (simplify_skeleton (trapz (uextend _ a) code)) (trapz a code))\n</code></pre></div>\n<p>and </p>\n<div class=\"codehilite\" data-code-language=\"clif\"><pre><span></span><code>function %test1(i32) -&gt; i32 {\nblock0(v0: i32):\n    v1 = uextend.i64 v0\n    trapz.i64 v1, user1\n    return v0\n}\n</code></pre></div>\n<p>as my test case. However, even though logs suggest that the rule matches and applies (<code>simplify_skeleton: replace inst with inst3: trapz.i32 v0, user1</code>) it ends up weird shortly after:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[2025-10-10T16:39:19Z TRACE cranelift_codegen::egraph] Processing inst inst1: trapz.i64 v1, user1\n[2025-10-10T16:39:19Z TRACE cranelift_codegen::opts] new iter from root v1\n[2025-10-10T16:39:19Z TRACE cranelift_codegen::opts] iter: value v1\n[2025-10-10T16:39:19Z TRACE cranelift_codegen::opts]  -&gt; value of type i64\n[2025-10-10T16:39:19Z TRACE cranelift_codegen::egraph]  -&gt; simplify_skeleton: yielded 1 simplification(s)\n[2025-10-10T16:39:19Z TRACE cranelift_codegen::egraph]  -&gt; simplify_skeleton: replace inst with inst3: trapz.i32 v0, user1\n[2025-10-10T16:39:19Z TRACE cranelift_codegen::egraph]  -&gt; mergeable side-effecting op inst1\n[2025-10-10T16:39:19Z TRACE cranelift_codegen::egraph]  -&gt; inserts as new (no GVN)\n[2025-10-10T16:39:19Z TRACE cranelift_codegen::egraph] Processing inst inst2: return v0\n[2025-10-10T16:39:19Z TRACE cranelift_codegen::egraph] rewriting arg v0 of inst inst2 to v0\n[2025-10-10T16:39:19Z TRACE cranelift_codegen::egraph]  -&gt; simplify_skeleton: yielded 0 simplification(s)\n[2025-10-10T16:39:19Z TRACE cranelift_codegen::alias_analysis] alias analysis: scanning at inst2 with state LastStores { heap: None, table: None, vmctx: No\nne, other: None } (MultiAry { opcode: Return, args: EntityList { index: 9, unused: PhantomData&lt;cranelift_codegen::ir::entities::Value&gt; } })\n[2025-10-10T16:39:19Z TRACE cranelift_codegen::egraph] egraph built:\n    function %test1(i32) -&gt; i32 fast {\n    block0(v0: i32):\n        trapz.i64 v1, user1 ;; /!\\ why v1? the insn should've been replaced with `trapz.i32 v0`.\n        return v0\n    }\n</code></pre></div>\n<p>which eventually returns back to the original shape with the uextend. Before I dive into this (and having read the cautioning message above as well as the comment on <code>simplify_skeleton_inst</code>): should it be possible to make <em>this</em> transformation? am I right in thinking that the outcome here is weird?</p>",
        "id": 544215567,
        "sender_full_name": "Simonas (nagisa)",
        "timestamp": 1760116191
    },
    {
        "content": "<p>Adding a little more logging around the <code>if cost &lt; best_cost</code> logic (line 689 in cranelift/codegen/src/egraphs.rs), I see</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">[</span><span class=\"mi\">2025</span><span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"n\">T17</span><span class=\"p\">:</span><span class=\"mi\">22</span><span class=\"p\">:</span><span class=\"mi\">12</span><span class=\"n\">Z</span><span class=\"w\"> </span><span class=\"n\">TRACE</span><span class=\"w\"> </span><span class=\"n\">cranelift_codegen</span><span class=\"p\">::</span><span class=\"n\">egraph</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">cost</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Cost</span><span class=\"p\">::</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">op_cost</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">depth</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"> </span><span class=\"n\">best_cost</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Cost</span><span class=\"p\">::</span><span class=\"n\">Finite</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">op_cost</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">depth</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>so I think this is a consequence of <code>Cost::of_skeleton_op</code> not considering the cost of operands; it appears that the two trapz's are equally costly so we prefer not to replace.</p>\n<p>I'd be happy to review a PR if you wanted to add operand cost into <code>Cost::of_skeleton_op</code>, then add that simplification rule!</p>",
        "id": 544217753,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1760117091
    },
    {
        "content": "<p>Hm, this is somewhat problematic to do as elaborator computes costs for values after the skeleton passes run. We also wouldn't want to recurse in the <code>Cost::of_skeleton_op</code> as that would lead straight into the pit of non-linearity. </p>\n<p>For initial prototyping I'll compute costs of operands recursing 1-deep only, but in the final version computation of cost for skeleton ops may want to become a little more like that of <code>of_pure_op</code> wherein the caller maintains a list of operand costs…</p>",
        "id": 544259411,
        "sender_full_name": "Simonas (nagisa)",
        "timestamp": 1760136392
    },
    {
        "content": "<p>Ah, yeah, you're right</p>",
        "id": 544259704,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1760136595
    },
    {
        "content": "<p>An alternative approach is to say that <code>simplify_skeleton</code> always unconditionally takes one rewrite and performs it. That would mean that the constructor is no longer \"multi\", which would cause the ISLE compiler's overlap checking to statically check that only one rewrite is possible (either because of LHS non-overlap or because of explicit priorities); then we always take that rewrite. Since these ops don't get turned into multi-representation egraph nodes anyway, I don't see that as <em>hugely</em> problematic, though it does mean that one has to be a little more manual about choosing the correct rewrites</p>",
        "id": 544259928,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1760136739
    },
    {
        "content": "<p>(cc <span class=\"user-mention\" data-user-id=\"253990\">@fitzgen (he/him)</span> on that one for thoughts; he's out today and will be back next week)</p>",
        "id": 544259947,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1760136752
    },
    {
        "content": "<p>I wasn't able to spend too much time on this, although I did find myself hitting new and exciting bugs in the implementation of <code>simplify_skeleton</code> <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 544415805,
        "sender_full_name": "Simonas (nagisa)",
        "timestamp": 1760289033
    },
    {
        "content": "<p>if we wanted to keep the multi aspect, and fix the cost computation, then we could create a separate type of eclass for the side-effectful skeleton that stores insts instead of values</p>\n<p>or we could just switch to non-multi and add priorities. although I vaguely remember attempting that at one point and running into islec bugs I didn't want to fix, iirc</p>",
        "id": 544595428,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1760375381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"515815\">Simonas (nagisa)</span> <a href=\"#narrow/channel/217117-cranelift/topic/codegen.20for.20overflow-checking.20operations/near/544415805\">said</a>:</p>\n<blockquote>\n<p>I wasn't able to spend too much time on this, although I did find myself hitting new and exciting bugs in the implementation of <code>simplify_skeleton</code> <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>\n</blockquote>\n<p>bug reports and fixes are always welcome!</p>",
        "id": 544595533,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1760375447
    }
]