[
    {
        "content": "<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/68a6afd4f925724fd359c13a27fac5a6163d12f4/cranelift/codegen/src/opts/bitops.isle#L44-L50\">https://github.com/bytecodealliance/wasmtime/blob/68a6afd4f925724fd359c13a27fac5a6163d12f4/cranelift/codegen/src/opts/bitops.isle#L44-L50</a></p>\n<p>Hi, reading mid-end optimizations in ISLE, I noticed that these rules increase cost which defined in <a href=\"https://github.com/bytecodealliance/wasmtime/blob/68a6afd4f925724fd359c13a27fac5a6163d12f4/cranelift/codegen/src/egraph/cost.rs#L111-L132\">https://github.com/bytecodealliance/wasmtime/blob/68a6afd4f925724fd359c13a27fac5a6163d12f4/cranelift/codegen/src/egraph/cost.rs#L111-L132</a>.<br>\nIs there a rationale why such rules exist? I think this is opposed to the first rule writing mid-end opts in ISLE stated at <a href=\"https://github.com/bytecodealliance/wasmtime/blob/68a6afd4f925724fd359c13a27fac5a6163d12f4/cranelift/codegen/src/opts/README.md\">https://github.com/bytecodealliance/wasmtime/blob/68a6afd4f925724fd359c13a27fac5a6163d12f4/cranelift/codegen/src/opts/README.md</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/68a6afd4f925724fd359c13a27fac5a6163d12f4/cranelift/codegen/src/opts/bitops.isle#L44-L50\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/4176f6de7ac20f6e6830f90d3f2ad197998dafea/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f376336643565376435343430623533363230343364353462346437313432623931616633393463623338336464316333373838636439303661346136643466322f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/68a6afd4f925724fd359c13a27fac5a6163d12f4/cranelift/codegen/src/opts/bitops.isle#L44-L50\" title=\"wasmtime/cranelift/codegen/src/opts/bitops.isle at 68a6afd4f925724fd359c13a27fac5a6163d12f4 · bytecodealliance/wasmtime\">wasmtime/cranelift/codegen/src/opts/bitops.isle at 68a6afd4f925724fd359c13a27fac5a6163d12f4 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/68a6afd4f925724fd359c13a27fac5a6163d12f4/cranelift/codegen/src/egraph/cost.rs#L111-L132\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/4176f6de7ac20f6e6830f90d3f2ad197998dafea/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f376336643565376435343430623533363230343364353462346437313432623931616633393463623338336464316333373838636439303661346136643466322f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/68a6afd4f925724fd359c13a27fac5a6163d12f4/cranelift/codegen/src/egraph/cost.rs#L111-L132\" title=\"wasmtime/cranelift/codegen/src/egraph/cost.rs at 68a6afd4f925724fd359c13a27fac5a6163d12f4 · bytecodealliance/wasmtime\">wasmtime/cranelift/codegen/src/egraph/cost.rs at 68a6afd4f925724fd359c13a27fac5a6163d12f4 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/68a6afd4f925724fd359c13a27fac5a6163d12f4/cranelift/codegen/src/opts/README.md\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/4176f6de7ac20f6e6830f90d3f2ad197998dafea/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f376336643565376435343430623533363230343364353462346437313432623931616633393463623338336464316333373838636439303661346136643466322f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/68a6afd4f925724fd359c13a27fac5a6163d12f4/cranelift/codegen/src/opts/README.md\" title=\"wasmtime/cranelift/codegen/src/opts/README.md at 68a6afd4f925724fd359c13a27fac5a6163d12f4 · bytecodealliance/wasmtime\">wasmtime/cranelift/codegen/src/opts/README.md at 68a6afd4f925724fd359c13a27fac5a6163d12f4 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>",
        "id": 558884660,
        "sender_full_name": "Bongjun Jang",
        "timestamp": 1763893982
    },
    {
        "content": "<p>The first rule there is a guideline, but not a hard rule (the system doesn't depend on always-reducing cost as an invariant). In the specific case you linked, it is a kind of <em>normalization</em>: the idea is that we want to simplify possibly deeply nested bit-op expressions and the way we do that is by \"pushing NOTs down the tree\" to the leaves</p>",
        "id": 558917700,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763926938
    },
    {
        "content": "<p>thanks for the reply. normalization (constant operand to right, etc) can help improve the execution performance in general, but how does \"pushing NOTs down the tree\"  improve performance? Is there any possibility or evidence that it can lead to better codegen/optimization opportunity for this case?</p>",
        "id": 558959872,
        "sender_full_name": "Bongjun Jang",
        "timestamp": 1763965816
    },
    {
        "content": "<p>afaik the general idea of e-graphs (what ISLE is mostly used for) is that it generates a bunch of different equivalent expressions for your code and then picks the least expensive one, so some of the expression transformations may make it more expensive only for later optimizations to make it even less expensive.<br>\ne.g. if you're optimizing <code>((a == b) &amp; !c) &amp; !d</code>, just doing the de-morgan rule once would give you <code>!(!((a == b) &amp; !c) | !!d)</code> which is a bit more expensive, but that can be further optimized to <code>!((a != b) | c) | d</code> which has one less instruction than the original expression.</p>",
        "id": 558985718,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1763975500
    },
    {
        "content": "<p>Yes, and in general, pushing boolean expressions toward a normal form allows expressions to GVN together more. I don't have ready examples or data for that, but it's a general compilers-transformation principle. I would consider these rules part of the same family as the push-constants-to-the-right-and-reassociate rules that let cprop work better.</p>",
        "id": 560043625,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1764028607
    },
    {
        "content": "<p>(Note to researchers: getting data on how individual rules, and combinations of rules together, bring optimization benefit -- i.e., somehow finding a way to attribute \"credit\" to rules -- would be really neat and a way to talk about all this more objectively)</p>",
        "id": 560043751,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1764028656
    },
    {
        "content": "<p>Hi, I uploaded performance evaluation data of removing the rules in wasmtime Github: <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12086\">https://github.com/bytecodealliance/wasmtime/issues/12086</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/issues/12086\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/a7f99053fdf3618b1b5d8aafa3dde374dd31a99b/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f623361393534336433623032386365393637633961393839366139613033313533376237346631363662613264333239356461636563653634653839306131372f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f3132303836&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/issues/12086\" title=\"Cranelift: deoptimizing rules in ISLE · Issue #12086 · bytecodealliance/wasmtime\">Cranelift: deoptimizing rules in ISLE · Issue #12086 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">Hi, this is a follow up from #cranelift &gt; Deoptimizing ISLE rules?. As mentioned in the Zulip topic above, I suspect these ISLE rules can degrade performance, since it can increase the number of in...</div></div></div>",
        "id": 560086655,
        "sender_full_name": "Bongjun Jang",
        "timestamp": 1764057015
    }
]