[
    {
        "content": "<p>I'm planning to write an experimental new backend for the Z80—an 8-bit CPU that was widely used from the 1970s to the 1990s.</p>\n<p>As background, I previously created a Rust-to-Z80 asm compiler that uses a multi-step process: Rust → LLVM IR → C → ASM.<br>\n(<a href=\"https://github.com/zlfn/rust-gb\">https://github.com/zlfn/rust-gb</a>)<br>\nHowever, this pipeline is very complicated and unstable. I now want to write a more stable and direct backend for this old CPU.</p>\n<p>Cranelift seems like a good candidate, but unfortunately, there isn't a clear guide for implementing a new backend, and it has been difficult for me to debug. Currently, I'm trying to write a simple proof-of-concept for Cranelift Z80 codegen. It will be support only basic instructions and contains many TODO placeholders—but I’m not sure what should I do first.</p>\n<p>Ultimately, I want to be able to take arbitrary Rust code or a CLIF file and verify that it correctly compiles into Z80 object code.<br>\n(It seems that generating object code for a specific architecture would require modifying cranelift-object or cranelift-module, but I'm not entirely sure how.)</p>\n<p>Since the Z80 doesn't have a standardized executable format or high level system calls, I want to generate object code in a format that's compatible with C linkers—because I want my code to work together with existing C code and libraries.</p>\n<p>I don't have a z80 Cranelift backend yet, but today I tried testing how I <em>would</em> debug things if I made one.<br>\nI assumed the compilation flow would be:<br>\n<strong>Rust → CLIF → Object → Binary.</strong></p>\n<p>I know I can emit <code>.clif</code> files from Rust code using the <code>emit=llvm-ir</code> flag.<br>\nBut how can I turn these CLIF files into object files?<br>\nAlso, it looks like there is one CLIF file per function, and I don’t see any constant data in them.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/zlfn/rust-gb\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/ac8b3b83a9a28cfc4e415bee9dae38eb6517f029/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f656261633634333763343231353261386637633937306636366463613530303661336237383766386332353531393732623166313862393063396265386333302f7a6c666e2f727573742d6762&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/zlfn/rust-gb\" title=\"GitHub - zlfn/rust-gb: Compile Rust code to GBZ80 (Gameboy Z80)\">GitHub - zlfn/rust-gb: Compile Rust code to GBZ80 (Gameboy Z80)</a></div><div class=\"message_embed_description\">Compile Rust code to GBZ80 (Gameboy Z80). Contribute to zlfn/rust-gb development by creating an account on GitHub.</div></div></div>",
        "id": 533331037,
        "sender_full_name": "zlfn",
        "timestamp": 1754585903
    },
    {
        "content": "<p>There is currently no way to serialize cranelift ir to a text format in a way that you can easily feed it into cranelift-module. The cranelift ir text format only stores information for individual functions, not the names of functions or which symbols are imported by functions. And it indeed doesn't store constant data. cranelift-module is designed for streaming compilation. Basically you feed it one function or data object and then it would immediately compile it and add it to the object file that is being built (in the case of cranelift-object) or write it to memory that will be mapped executable (in the case of cranelift-jit).</p>",
        "id": 533433784,
        "sender_full_name": "bjorn3",
        "timestamp": 1754646971
    }
]