[
    {
        "content": "<p>So I have this (maybe rather strange) use case of JITing only \"parts\" of some riscv(32) bytecode.</p>\n<p>For a bit of context, I run these instructions in a interpreter normally because I am generating proofs of correct execution which requires me to collect auxiliary information per cycle, however I also have an \"unconstrained\" mode, which runs the instructions without collecting this data, this is the part I want to JIT.</p>\n<p>For my use case, Im only given this bytecode, and I only want to JIT some parts of it that are \"sandwhiched\" say, between two placeholder opcodes.</p>\n<p>I think most of what i'm trying to do is clear to me, but one thing im having trouble fleshing out is the JALR instruction.</p>\n<p>My naive approach to solve this is to actually JIT the whole program, interpreting each instruction as a basic block, and basically implementing like a dynamic jump table at runtime.</p>\n<p>Im curious to gather feedback and see if anyone can help me think of a better approach to handling these dynamic jumps.</p>\n<p>Thank you in advance!</p>",
        "id": 494461699,
        "sender_full_name": "Nate",
        "timestamp": 1737159571
    },
    {
        "content": "<p>The classical way of handling indirect jumps in a dynamic binary translation (DBT) system like Valgrind, Pin or Dynamo (to give some keywords to search on!) is to have a big dispatch hashtable from entry-point PC to \"trace\" or \"block\" of jit'd code starting at that address. You then compile indirect jumps (or calls) into a sequence that looks up in that hashtable, does a jump to the equivalent native code if present, otherwise invokes the JIT compiler to generate new code (or escape to an interpreter or whatever)</p>",
        "id": 494467761,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737164087
    },
    {
        "content": "<p>It sounds like what you're wanting to do is a slightly more precomputed version of that where you handle every individual instruction as a potential entry point ahead of time; probably you'll have much better results if you do it on demand (if your environment permits true JIT), since relatively few instructions will be targets of indirect jumps/calls</p>",
        "id": 494467818,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737164139
    },
    {
        "content": "<p>Thanks for the response, lots of interesting info here.</p>\n<p>I think that last part is exactly what im looking to do. I think my next question is, once I do know my entrypoint, say at some pc=X,</p>\n<p>How much of the program do I start jitting from pc=X? Until I hit another indirect jump? </p>\n<p>Maybe im misunderstanding, but my understanding of what youre saying is that I should basically maintain a mapping, just in time, of pc -&gt; jitted function, but how do i share state between this?</p>",
        "id": 494468540,
        "sender_full_name": "Nate",
        "timestamp": 1737164730
    },
    {
        "content": "<p>And maybe for more clarity I will always be starting off in the interpreter, and then enter the JIT at some arbitrary PC</p>",
        "id": 494468640,
        "sender_full_name": "Nate",
        "timestamp": 1737164786
    },
    {
        "content": "<blockquote>\n<p>Maybe im misunderstanding, but my understanding of what youre saying is that I should basically maintain a mapping, just in time, of pc -&gt; jitted function, but how do i share state between this?</p>\n</blockquote>\n<p>Is it like I might pass in some pointer to my \"virtual registers\", ie some *mut [Value; 32] and pass this between jitted functions</p>",
        "id": 494468696,
        "sender_full_name": "Nate",
        "timestamp": 1737164846
    },
    {
        "content": "<p>Yes, exactly, typically you have a \"struct CPUState\" and within a jit'd block you can load and store to this, perhaps keeping values in registers (SSA values) until the end; and your interpreter operates on the same state.</p>",
        "id": 494469006,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737165106
    },
    {
        "content": "<p>How long to JIT, and whether you follow one path or both sides of a conditional, etc., is an interesting heuristic question that different systems answer differently</p>",
        "id": 494469062,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737165125
    },
    {
        "content": "<p>Basically your questions boil down to \"how do I design a dynamic binary translation system\" and I'd recommend reading at least the Dynamo paper (<a href=\"https://dl.acm.org/doi/pdf/10.1145/349299.349303\">https://dl.acm.org/doi/pdf/10.1145/349299.349303</a>) -- \"fragment cache\", \"trace selection\" and all the rest</p>",
        "id": 494469133,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737165186
    },
    {
        "content": "<p>Valgrind is a good open-source contemporary example of a system like this, and you may find it instructive to read their internal docs and source too</p>",
        "id": 494469154,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737165216
    },
    {
        "content": "<p>Awesome thank you very much!</p>",
        "id": 494469226,
        "sender_full_name": "Nate",
        "timestamp": 1737165264
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254389\">@Chris Fallin</span> Last question for now would be which do you think is better for my registers, the stack operations vs the <code>*mut [Value; u32]</code> approach?</p>\n<p>Couldnt find much info on how cranelift treats/reasons about the stack assignments, are they persistent between functions from the same context?</p>",
        "id": 494544525,
        "sender_full_name": "Nate",
        "timestamp": 1737226402
    },
    {
        "content": "<p>Cranelift has stackslots but they are local to the current function; so if you need to store state that persists across different compiled instruction traces and your interpreter (I think you do, for CPU registers?) then you'll want to emit normal loads and stores to an array of values in memory</p>",
        "id": 494544927,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737226702
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"254389\">@Chris Fallin</span> ive made alot of progress already and its been such a pleasure to use Cranelift so far!</p>\n<p>No pressure at all, but im curious if you would have some insight on how to implement this function correctly, as it fails during (Cranelift) compilation with </p>\n<p><code>failed to compile: Compilation(Verifier(VerifierErrors([VerifierError { location: inst3, context: Some(\"jump block1(v8)\"), message: \"uses value arg from non-dominating block1\" }])))</code></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"cp\">#[tracing::instrument(skip_all, fields(opcode = instruction.opcode.mnemonic(), pc = pc))]</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">translate_branch</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">instruction</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Instruction</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">pc</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">BuilderResult</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">tracing</span><span class=\"p\">::</span><span class=\"n\">trace</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"Translating branch\"</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">rs1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">imm</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instruction</span><span class=\"p\">.</span><span class=\"n\">b_type</span><span class=\"p\">();</span>\n\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">rs1_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">load</span><span class=\"p\">(</span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">int_32_type</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"n\">MemFlags</span><span class=\"p\">::</span><span class=\"n\">trusted</span><span class=\"p\">(),</span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">registers_ptr</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"n\">rs1</span><span class=\"p\">.</span><span class=\"n\">register_offset</span><span class=\"p\">(),</span>\n<span class=\"w\">        </span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">rs2_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">load</span><span class=\"p\">(</span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">int_32_type</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"n\">MemFlags</span><span class=\"p\">::</span><span class=\"n\">trusted</span><span class=\"p\">(),</span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">registers_ptr</span><span class=\"p\">,</span>\n<span class=\"w\">            </span><span class=\"n\">rs2</span><span class=\"p\">.</span><span class=\"n\">register_offset</span><span class=\"p\">(),</span>\n<span class=\"w\">        </span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">instruction</span><span class=\"p\">.</span><span class=\"n\">opcode</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">Opcode</span><span class=\"p\">::</span><span class=\"n\">BEQ</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">icmp</span><span class=\"p\">(</span><span class=\"n\">IntCC</span><span class=\"p\">::</span><span class=\"n\">Equal</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs1_val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs2_val</span><span class=\"p\">),</span>\n<span class=\"w\">            </span><span class=\"n\">Opcode</span><span class=\"p\">::</span><span class=\"n\">BNE</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">icmp</span><span class=\"p\">(</span><span class=\"n\">IntCC</span><span class=\"p\">::</span><span class=\"n\">NotEqual</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs1_val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs2_val</span><span class=\"p\">),</span>\n<span class=\"w\">            </span><span class=\"n\">Opcode</span><span class=\"p\">::</span><span class=\"n\">BLT</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">icmp</span><span class=\"p\">(</span><span class=\"n\">IntCC</span><span class=\"p\">::</span><span class=\"n\">SignedLessThan</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs1_val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs2_val</span><span class=\"p\">),</span>\n<span class=\"w\">            </span><span class=\"n\">Opcode</span><span class=\"p\">::</span><span class=\"n\">BGE</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">icmp</span><span class=\"p\">(</span><span class=\"n\">IntCC</span><span class=\"p\">::</span><span class=\"n\">SignedGreaterThanOrEqual</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs1_val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs2_val</span><span class=\"p\">)</span>\n<span class=\"w\">            </span><span class=\"p\">}</span>\n<span class=\"w\">            </span><span class=\"n\">Opcode</span><span class=\"p\">::</span><span class=\"n\">BLTU</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">icmp</span><span class=\"p\">(</span><span class=\"n\">IntCC</span><span class=\"p\">::</span><span class=\"n\">UnsignedLessThan</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs1_val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs2_val</span><span class=\"p\">),</span>\n<span class=\"w\">            </span><span class=\"n\">Opcode</span><span class=\"p\">::</span><span class=\"n\">BGEU</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">icmp</span><span class=\"p\">(</span><span class=\"n\">IntCC</span><span class=\"p\">::</span><span class=\"n\">UnsignedGreaterThanOrEqual</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs1_val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rs2_val</span><span class=\"p\">)</span>\n<span class=\"w\">            </span><span class=\"p\">}</span>\n<span class=\"w\">            </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">unreachable!</span><span class=\"p\">(),</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// If weve already visited this branch point, jump to it.</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">branch_block</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">branch_points</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">pc</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">tracing</span><span class=\"p\">::</span><span class=\"n\">trace</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"Found a branch we already know about: {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">pc</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">jump</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">branch_block</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"n\">cond</span><span class=\"p\">]);</span>\n<span class=\"w\">            </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">BuilderResult</span><span class=\"p\">::</span><span class=\"n\">Branch</span><span class=\"p\">;</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">branch_block</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">create_block</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">branch_points</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">pc</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">branch_block</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">cond_param</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">append_block_param</span><span class=\"p\">(</span><span class=\"n\">branch_block</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">int_32_type</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">jump</span><span class=\"p\">(</span><span class=\"n\">branch_block</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"n\">cond_param</span><span class=\"p\">]);</span>\n\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">switch_to_block</span><span class=\"p\">(</span><span class=\"n\">branch_block</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">branched</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">create_block</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">not_branched</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">create_block</span><span class=\"p\">();</span>\n\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">brif</span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">branched</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[],</span><span class=\"w\"> </span><span class=\"n\">not_branched</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[]);</span>\n\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">switch_to_block</span><span class=\"p\">(</span><span class=\"n\">branched</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">seal_block</span><span class=\"p\">(</span><span class=\"n\">branched</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"n\">BuilderResult</span><span class=\"p\">::</span><span class=\"n\">NewBranch</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">pc</span><span class=\"p\">.</span><span class=\"n\">wrapping_add</span><span class=\"p\">(</span><span class=\"n\">imm</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">not_branched</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>I beleive the problem is here:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"c1\">// If weve already visited this branch point, jump to it.</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">branch_block</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">branch_points</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">pc</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">tracing</span><span class=\"p\">::</span><span class=\"n\">trace</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"Found a branch we already know about: {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">pc</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">builder</span><span class=\"p\">.</span><span class=\"n\">ins</span><span class=\"p\">().</span><span class=\"n\">jump</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">branch_block</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"n\">cond</span><span class=\"p\">]);</span>\n<span class=\"w\">            </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">BuilderResult</span><span class=\"p\">::</span><span class=\"n\">Branch</span><span class=\"p\">;</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>Basically I think we can encounter a situation when translating like a for loop that says something like</p>\n<ul>\n<li>do loop</li>\n<li>if condition branch to the beginning</li>\n<li>else continue</li>\n</ul>\n<p>so my strategy is to store these branch points, and immediately eval the case where we branched, (since its an immediate offset) sure this means we might have some overlapping instructions in diff blocks but thats ok for now.</p>\n<p>If i hit this branch at this pc again, then I can signal to \"translator\" to follow the non branch case, but this is where the error comes from</p>\n<p>Thanks for all the help so far!</p>",
        "id": 495180287,
        "sender_full_name": "Nate",
        "timestamp": 1737510804
    },
    {
        "content": "<p>The error message I think makes sense, cond comes from a block that is like a successor of the branch block, but im curious f theres like an obvious way to make this work im not seeing</p>",
        "id": 495181811,
        "sender_full_name": "Nate",
        "timestamp": 1737511691
    },
    {
        "content": "<p>the error message is indicating that an SSA invariant is not valid -- basically you're using a value that isn't always set on all paths into a use-point (that's the \"non-dominating block\" bit)</p>",
        "id": 495193728,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737518625
    },
    {
        "content": "<p>the high-level idea is that you need to add block params whenever you have a \"merge point\" -- control flow coming in and a use that comes from one of several defs in the joining paths</p>",
        "id": 495193809,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737518670
    },
    {
        "content": "<p>if you're tracking SSA values for registers in the translated riscv32 code, I suspect the simplest way about this will be to have a block param for each machine register on every basic block</p>",
        "id": 495193840,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737518704
    },
    {
        "content": "<p>(there are more optimal ways, but you'll need to get more into SSA construction algorithms to get there -- the above should be sufficient to get a correct compilation)</p>",
        "id": 495193887,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737518740
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"206238\" href=\"/#narrow/channel/206238-general/topic/.28open.20discussion.29.20JIT.20only.20parts.20of.20an.20unstructured.20programs\">#general &gt; (open discussion) JIT only parts of an unstructured programs</a> by <span class=\"user-mention silent\" data-user-id=\"234973\">Till Schneidereit</span>.</p>",
        "id": 495348460,
        "sender_full_name": "Notification Bot",
        "timestamp": 1737570246
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"868311\">@Nate</span> You may be interested in <a href=\"https://github.com/Amanieu/a-tale-of-binary-translation\">https://github.com/Amanieu/a-tale-of-binary-translation</a> which seems to be exactly what your are trying to do. It's a simple binary translator that I developed as a teaching example which targets RV32I.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/Amanieu/a-tale-of-binary-translation\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/63b543597ba0bc50240f845eec403dbe422f49e7/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f653334386530613431386236323234646231343163396162643661653131383837626462343731353839396632643637333434393530643732623363643039372f416d616e6965752f612d74616c652d6f662d62696e6172792d7472616e736c6174696f6e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/Amanieu/a-tale-of-binary-translation\" title=\"GitHub - Amanieu/a-tale-of-binary-translation: Simple RISC-V emulator presented at Rust Nation 2023\">GitHub - Amanieu/a-tale-of-binary-translation: Simple RISC-V emulator presented at Rust Nation 2023</a></div><div class=\"message_embed_description\">Simple RISC-V emulator presented at Rust Nation 2023 - Amanieu/a-tale-of-binary-translation</div></div></div>",
        "id": 495378286,
        "sender_full_name": "Amanieu",
        "timestamp": 1737581881
    },
    {
        "content": "<p>This is the cranelift backend: <a href=\"https://github.com/Amanieu/a-tale-of-binary-translation/blob/master/src/backend/jit/cranelift.rs\">https://github.com/Amanieu/a-tale-of-binary-translation/blob/master/src/backend/jit/cranelift.rs</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/Amanieu/a-tale-of-binary-translation/blob/master/src/backend/jit/cranelift.rs\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/63b543597ba0bc50240f845eec403dbe422f49e7/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f653334386530613431386236323234646231343163396162643661653131383837626462343731353839396632643637333434393530643732623363643039372f416d616e6965752f612d74616c652d6f662d62696e6172792d7472616e736c6174696f6e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/Amanieu/a-tale-of-binary-translation/blob/master/src/backend/jit/cranelift.rs\" title=\"a-tale-of-binary-translation/src/backend/jit/cranelift.rs at master · Amanieu/a-tale-of-binary-translation\">a-tale-of-binary-translation/src/backend/jit/cranelift.rs at master · Amanieu/a-tale-of-binary-translation</a></div><div class=\"message_embed_description\">Simple RISC-V emulator presented at Rust Nation 2023 - Amanieu/a-tale-of-binary-translation</div></div></div>",
        "id": 495383110,
        "sender_full_name": "Amanieu",
        "timestamp": 1737583946
    },
    {
        "content": "<p>I was actually able to get this to work end to end! Appreciate the additional resources! Were getting something like 15x speed up over the interpreter, and its only a bit slower than native (due to it being 32 bit taget were translating)</p>",
        "id": 495818899,
        "sender_full_name": "Nate",
        "timestamp": 1737767623
    },
    {
        "content": "<p>(The solution was that we should compute the branch condition in the branch block, rather than passing it from the current block)</p>",
        "id": 495818976,
        "sender_full_name": "Nate",
        "timestamp": 1737767652
    },
    {
        "content": "<p>Once its public ill share here as well!</p>",
        "id": 495819413,
        "sender_full_name": "Nate",
        "timestamp": 1737767957
    }
]