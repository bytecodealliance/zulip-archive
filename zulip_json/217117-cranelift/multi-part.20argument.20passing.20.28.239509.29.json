[
    {
        "content": "<p>hi, i'm writing a C compiler at the moment and want to implement passing structs by value. i saw from discussion on reddit and on github (<a href=\"https://github.com/bytecodealliance/wasmtime/issues/9509\">#9509</a>) that there is an issue with the way this is handled by cranelift currently</p>\n<p>to summarize: sometimes, the ABI (SysV) allows passing small structs in registers. however, other times, if the struct is larger than some size, it must be passed via the stack. </p>\n<p>currently, cranelift delegates this choice to frontend author - for big structs, they should use StructArgument purpose on a ptrsize-value param, and cranelift will generate a memcpy from the pointer given to Call IR instruction to the stack. </p>\n<p>however, there's an edge case when a small struct which would ordinarily be passed through registers instead has to be passed through stack due to lack of registers for <em>some</em> of its fields (or some other reason). in this case, SysV mandates that the entire struct go onto the stack, but if the frontend lowers a struct into multiple values, there's no way for Cranelift to reason about those values making up the struct as a group. </p>\n<p>it seems like you can get it to work by essentially doing all of the ABI calculations yourself, but this seems like a bit of a hack, and not really ideal. </p>\n<p>i'd like for my compiler to implement this properly, so i was hoping to get some input from maintainers about possible patch for cranelift</p>\n<p>from github: add some kind of AbiParamGroup abstraction to ir::Signature to say that multiple Values should be treated as a unit for the purposes of allocating argument-passing registers when passing small structs, keep StructArgument for larger structs. need to emit code to spill registers onto stack when doing Call, and to load from stack on the other side. </p>\n<p>i guess my thought is that this feels a bit confusing to have both StructArgument and this \"AbiParamGroup\" mechanism for frontend authors, but since they are expected to handle some ABI details anyways, maybe its ok?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/issues/9509\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/4e24a657f585afc7e889c8dae6cd872661d7b2a4/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f636337633961336164346535656162376539363664396165633930343836613839343933393436613063393331383062643739353562623166366635333438642f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f39353039&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/issues/9509\" title=\"Cranelift: Correctly handle abi calculation for multi-part arguments 路 Issue #9509 路 bytecodealliance/wasmtime\">Cranelift: Correctly handle abi calculation for multi-part arguments 路 Issue #9509 路 bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">Feature When lowering a C or Rust type in a clif ir function signature, sometimes it is necessary to split it into multiple clif ir level parameters. For example #[repr(C)] struct F32Array { field0...</div></div></div>",
        "id": 544660641,
        "sender_full_name": "joshua you",
        "timestamp": 1760418543
    },
    {
        "content": "<p>I don't fully remember all the discussion here, but I also don't see anything in the issue you linked about</p>\n<blockquote>\n<p>keep StructArgument for larger structs</p>\n</blockquote>\n<p>and I suspect we actually wouldn't want to do that; rather we'd expect the caller to use a stackslot to put the struct somewhere on stack, then pass the pointer in. In other words, we want to give building blocks to allow you to build an implementation of the ABI without platform-specific knowledge (that's the param grouping and ISA-specific allocation algorithm over it) but not to bundle in too much extra.</p>",
        "id": 544798038,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1760460618
    },
    {
        "content": "<p>wouldn't it still be necessary to have the StructArgument purpose though? even if you make the memcpy into callee's argument passing area explicit, you'd still have to tell cranelift what order that struct goes into the callee's argument passing area relative to implicit spills in function call from register pressure</p>",
        "id": 544819313,
        "sender_full_name": "joshua you",
        "timestamp": 1760468848
    },
    {
        "content": "<p>Ah, I may be misremembering the details of the ABI -- it's been a few years, sorry :-) If it has to be in a particular place, then yep, you're right. I seem to remember a pointer to the arg being passed in a reg and if that's the case and there are no restrictions where it actually lives, then we may not need it</p>",
        "id": 544821184,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1760469575
    },
    {
        "content": "<blockquote>\n<p>I seem to remember a pointer to the arg being passed in a reg and if that's the case and there are no restrictions where it actually lives, then we may not need it</p>\n</blockquote>\n<p>That is on s390x and maybe on aarch64, where cg_clif would indeed not use StructArgument. On x86_64 you definitively need StructArgument however.</p>",
        "id": 544918030,
        "sender_full_name": "bjorn3",
        "timestamp": 1760520307
    }
]