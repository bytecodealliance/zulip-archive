[
    {
        "content": "<p>Hello,<br>\nI am working on a garbage collected language like Java and I am running into some issues when trying to run my GC on generated code. For the most part, the stack maps generated work really well until recently. For some reason, one of the function calls in my language doesn't seem to have a stack map for it and I am not sure why.<br>\nI am trying to figure out if my issue is just user error on my part. </p>\n<p>The way that function calls work in my language is that they are fetched based on a few values that tell the runtime where to find the required function. If the function hasn't been seen before, then it gets JIT-ed where we store the IP locations as keys to lists of SP offsets. This process allows me to run a check for GC before calling functions.</p>\n<p>Here is the code in my language that I am trying to run that is giving me trouble:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>class Main {\n\n    fn main(args: [String]) {\n        let printer: Printer = new Printer();\n        let n: u64 = 5\n        let result: u64 = Main::fib(n); // stack spills correctly here\n        printer.println-int(result);\n        Main::thrash() // Create a bunch of garbage to collect\n        let arr: [u64] = [1, 2, 3, 4];\n        while True {\n            Main::from-array(arr); // For some reason we have stack spilling around this call but not at this call\n        }\n    }\n\n    fn fib(n: u64) -&gt; u64 {\n        if n &lt; 2 {\n            return n;\n        }\n        return Main::fib(n - 1) + Main::fib(n - 2);\n    }\n\n    fn from-array(arr: [u64]) {\n        let x: u64 = 0;\n    }\n\n    fn thrash() {\n        let i: u64 = 0;\n        while i &lt; 10 {\n            let x: [u64] = new [u64; 1];\n            i = i + 1;\n        }\n    }\n}\n</code></pre></div>\n<p>I know that some of the stack maps are working because I ran the part of my code that collects references and it found a few of them but not all of them.</p>\n<p>Any help is appreciated. If you need any other information like a disassembly, please let me know how to do such a thing, and I will try to provide it as fast as I can.</p>",
        "id": 526314729,
        "sender_full_name": "Alec Davis",
        "timestamp": 1751255031
    },
    {
        "content": "<p>What is the generated clif ir?</p>",
        "id": 526366228,
        "sender_full_name": "bjorn3",
        "timestamp": 1751278468
    },
    {
        "content": "<p>How can I dump the generated clif ir?</p>",
        "id": 526421390,
        "sender_full_name": "Alec Davis",
        "timestamp": 1751295157
    },
    {
        "content": "<p>You can do <code>println!(\"{func}\");</code> right after you finalize the <code>FunctionBuilder</code> if your <code>Function</code> is stored in a variable called <code>func</code>.</p>",
        "id": 526426405,
        "sender_full_name": "bjorn3",
        "timestamp": 1751296571
    },
    {
        "content": "<p>what would be even better would be the complete trace logging output, so we could see the CLIF before and after safepoint spilling. that would be something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">RUST_LOG</span><span class=\"o\">=</span><span class=\"n\">trace</span><span class=\"w\"> </span><span class=\"n\">cargo</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span>\n</code></pre></div>\n<p>if you are using <code>env_logger</code></p>",
        "id": 526435297,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1751299287
    },
    {
        "content": "<p>Sorry for taking so long. But here is the resulting clif ir. The logs are quite long and too big for pastebin. Should I just put the logs in a separate reply or is there a particular section you want to see?</p>\n<p>clif ir:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>    function u0:0(i64, i64) system_v {\n        ss0 = explicit_slot 8, align = 8\n        ss1 = explicit_slot 8, align = 8\n        sig0 = (i64) -&gt; i64 system_v\n        sig1 = (i64, i64, i64) -&gt; i64 system_v\n        sig2 = (i64) -&gt; i8 system_v\n        sig3 = (i64, i64) -&gt; i64 system_v\n        sig4 = (i64) -&gt; i8 system_v\n        sig5 = (i64, i64, i64, i64, i64) -&gt; i64 system_v\n        sig6 = (i64) -&gt; i8 system_v\n        sig7 = (i64, i64, i64) system_v\n        sig8 = (i64) -&gt; i8 system_v\n        sig9 = (i64, i64, i64) -&gt; i64 system_v\n        sig10 = (i64) -&gt; i8 system_v\n        sig11 = (i64) system_v\n        sig12 = (i64) -&gt; i8 system_v\n        sig13 = (i64) -&gt; i64 system_v\n        sig14 = (i64, i64, i64) system_v\n        sig15 = (i64, i64, i64, i64) system_v\n        sig16 = (i64) -&gt; i8 system_v\n        sig17 = (i64, i64, i64, i64) system_v\n        sig18 = (i64) -&gt; i8 system_v\n        sig19 = (i64, i64, i64, i64) system_v\n        sig20 = (i64) -&gt; i8 system_v\n        sig21 = (i64, i64, i64, i64) system_v\n        sig22 = (i64) -&gt; i8 system_v\n        sig23 = (i64, i64, i64) -&gt; i64 system_v\n        sig24 = (i64) -&gt; i8 system_v\n        sig25 = (i64, i64) system_v\n        sig26 = (i64) -&gt; i8 system_v\n        sig27 = (i64, i64, i64, i64, i64) -&gt; i64 system_v\n        sig28 = (i64) -&gt; i8 system_v\n        sig29 = (i64, i64, i64) system_v\n        sig30 = (i64) -&gt; i8 system_v\n        sig31 = (i64, i64, i64, i64, i64) -&gt; i64 system_v\n        sig32 = (i64) -&gt; i8 system_v\n        sig33 = (i64, i64, i64) system_v\n        sig34 = (i64) -&gt; i8 system_v\n        sig35 = (i64) system_v\n        fn0 = u0:8 sig0\n        fn1 = u0:9 sig1\n        fn2 = u0:6 sig2\n        fn3 = u0:6 sig4\n        fn4 = u0:10 sig5\n        fn5 = u0:6 sig6\n        fn6 = u0:6 sig8\n        fn7 = u0:9 sig9\n        fn8 = u0:6 sig10\n        fn9 = u0:6 sig12\n        fn10 = u0:8 sig13\n        fn11 = u0:11 sig14\n        fn12 = u0:12 sig15\n        fn13 = u0:6 sig16\n        fn14 = u0:12 sig17\n        fn15 = u0:6 sig18\n        fn16 = u0:12 sig19\n        fn17 = u0:6 sig20\n        fn18 = u0:12 sig21\n        fn19 = u0:6 sig22\n        fn20 = u0:9 sig23\n        fn21 = u0:6 sig24\n        fn22 = u0:6 sig26\n        fn23 = u0:10 sig27\n        fn24 = u0:6 sig28\n        fn25 = u0:6 sig30\n        fn26 = u0:10 sig31\n        fn27 = u0:6 sig32\n        fn28 = u0:6 sig34\n        fn29 = u0:7 sig35\n\n    block0(v0: i64, v1: i64):\n        jump block1\n\n    block1:\n        v2 = iconst.i64 35\n        v3 = call fn0(v2)  ; v2 = 35\n        v99 = stack_addr.i64 ss1\n        store notrap v3, v99\n        v4 = iconst.i64 5\n        v5 = iconst.i64 66\n        v6 = iconst.i64 68\n        v8 = call fn1(v0, v5, v6), stack_map=[i64 @ ss1+0]  ; v5 = 66, v6 = 68\n        v9 = call fn2(v0), stack_map=[i64 @ ss1+0]\n        brif v9, block2, block3\n\n    block2:\n        return\n\n    block3:\n        v11 = call_indirect.i64 sig3, v8(v0, v4), stack_map=[i64 @ ss1+0]  ; v4 = 5\n        v13 = call fn3(v0), stack_map=[i64 @ ss1+0]\n        brif v13, block4, block5\n\n    block4:\n        return\n\n    block5:\n        v16 = iconst.i64 35\n        v17 = iconst.i64 -1\n        v18 = iconst.i64 36\n        v20 = call fn4(v0, v3, v16, v17, v18), stack_map=[i64 @ ss1+0]  ; v16 = 35, v17 = -1, v18 = 36\n        v21 = call fn5(v0), stack_map=[i64 @ ss1+0]\n        brif v21, block6, block7\n\n    block6:\n        return\n\n    block7:\n        call_indirect.i64 sig7, v20(v0, v3, v11), stack_map=[i64 @ ss1+0]\n        v24 = call fn6(v0), stack_map=[i64 @ ss1+0]\n        brif v24, block8, block9\n\n    block8:\n        return\n\n    block9:\n        v25 = iconst.i64 66\n        v26 = iconst.i64 70\n        v28 = call fn7(v0, v25, v26), stack_map=[i64 @ ss1+0]  ; v25 = 66, v26 = 70\n        v29 = call fn8(v0), stack_map=[i64 @ ss1+0]\n        brif v29, block10, block11\n\n    block10:\n        return\n\n    block11:\n        call_indirect.i64 sig11, v28(v0), stack_map=[i64 @ ss1+0]\n        v32 = call fn9(v0), stack_map=[i64 @ ss1+0]\n        brif v32, block12, block13\n\n    block12:\n        return\n\n    block13:\n        v33 = iconst.i64 4\n        v34 = iconst.i64 19\n        v35 = call fn10(v34), stack_map=[i64 @ ss1+0]  ; v34 = 19\n        v100 = stack_addr.i64 ss0\n        store notrap v35, v100\n        v101 = stack_addr.i64 ss0\n        v98 = load.i64 notrap v101\n        call fn11(v0, v98, v33), stack_map=[i64 @ ss1+0, i64 @ ss0+0]  ; v33 = 4\n        v37 = iconst.i64 0\n        v38 = iconst.i64 1\n        v102 = stack_addr.i64 ss0\n        v97 = load.i64 notrap v102\n        call fn12(v0, v97, v37, v38), stack_map=[i64 @ ss1+0, i64 @ ss0+0]  ; v37 = 0, v38 = 1\n        v39 = call fn13(v0), stack_map=[i64 @ ss1+0, i64 @ ss0+0]\n        brif v39, block14, block15\n\n    block14:\n        return\n\n    block15:\n        v40 = iconst.i64 1\n        v41 = iconst.i64 2\n        v103 = stack_addr.i64 ss0\n        v96 = load.i64 notrap v103\n        call fn14(v0, v96, v40, v41), stack_map=[i64 @ ss1+0, i64 @ ss0+0]  ; v40 = 1, v41 = 2\n        v43 = call fn15(v0), stack_map=[i64 @ ss1+0, i64 @ ss0+0]\n        brif v43, block16, block17\n\n    block16:\n        return\n\n    block17:\n        v44 = iconst.i64 2\n        v45 = iconst.i64 3\n        v104 = stack_addr.i64 ss0\n        v95 = load.i64 notrap v104\n        call fn16(v0, v95, v44, v45), stack_map=[i64 @ ss1+0, i64 @ ss0+0]  ; v44 = 2, v45 = 3\n        v47 = call fn17(v0), stack_map=[i64 @ ss1+0, i64 @ ss0+0]\n        brif v47, block18, block19\n\n    block18:\n        return\n\n    block19:\n        v48 = iconst.i64 3\n        v49 = iconst.i64 4\n        v105 = stack_addr.i64 ss0\n        v94 = load.i64 notrap v105\n        call fn18(v0, v94, v48, v49), stack_map=[i64 @ ss1+0, i64 @ ss0+0]  ; v48 = 3, v49 = 4\n        v51 = call fn19(v0), stack_map=[i64 @ ss1+0, i64 @ ss0+0]\n        brif v51, block20, block21\n\n    block20:\n        return\n\n    block21:\n        v106 = stack_addr.i64 ss0\n        v93 = load.i64 notrap v106\n        jump block22\n\n    block22:\n        v52 = iconst.i8 1\n        brif v52, block23, block24  ; v52 = 1\n\n    block23:\n        v54 = iconst.i64 66\n        v55 = iconst.i64 69\n        v57 = call fn20(v0, v54, v55)  ; v54 = 66, v55 = 69\n        v58 = call fn21(v0)\n        brif v58, block26, block27\n\n    block26:\n        return\n\n    block27:\n        call_indirect.i64 sig25, v57(v0, v93)\n        v61 = call fn22(v0)\n        brif v61, block28, block29\n\n    block28:\n        return\n\n    block29:\n        v64 = iconst.i64 35\n        v65 = iconst.i64 -1\n        v66 = iconst.i64 36\n        v68 = call fn23(v0, v3, v64, v65, v66)  ; v64 = 35, v65 = -1, v66 = 36\n        v69 = call fn24(v0)\n        brif v69, block30, block31\n\n    block30:\n        return\n\n    block31:\n        call_indirect.i64 sig29, v68(v0, v3, v11)\n        v72 = call fn25(v0)\n        brif v72, block32, block33\n\n    block32:\n        return\n\n    block33:\n        jump block22\n\n    block24:\n        v75 = iconst.i64 35\n        v76 = iconst.i64 -1\n        v77 = iconst.i64 36\n        v79 = call fn26(v0, v3, v75, v76, v77)  ; v75 = 35, v76 = -1, v77 = 36\n        v80 = call fn27(v0)\n        brif v80, block34, block35\n\n    block34:\n        return\n\n    block35:\n        call_indirect.i64 sig33, v79(v0, v3, v11)\n        v83 = call fn28(v0)\n        brif v83, block36, block37\n\n    block36:\n        return\n\n    block37:\n        call fn29(v0)\n        return\n    }\n</code></pre></div>",
        "id": 526513756,
        "sender_full_name": "Alec Davis",
        "timestamp": 1751336642
    },
    {
        "content": "<p>It seems like the clif ir you generate contains a couple more calls than the source you are compiling. Can you get some debug information about which <code>fn*</code> corresponds with a call to what function? You could do a <code>println!()</code> at the point you are emitting the could I would guess.</p>",
        "id": 526614748,
        "sender_full_name": "bjorn3",
        "timestamp": 1751378184
    },
    {
        "content": "<p>Several of the calls don't have stack maps at least.</p>",
        "id": 526614854,
        "sender_full_name": "bjorn3",
        "timestamp": 1751378214
    },
    {
        "content": "<p>Also is the source available somewhere?</p>",
        "id": 526614864,
        "sender_full_name": "bjorn3",
        "timestamp": 1751378216
    },
    {
        "content": "<p>Yeah, I should specify a few details. I'll put the log in a separate reply due to its length.</p>\n<p>Basically when you call, you fetch the function and then call it. After calling a function, we test if the context parameter holds an exception (another function call). There are also a few operations that are done through function calls like creating an object, creating an array (one for each size + object + floats)</p>\n<p>You can find the <a href=\"https://github.com/Ki11erRabbit/rowan/blob/main/rowan/src/runtime/jit.rs#L584\">source code here</a>, it is not the greatest thing in the world but it could help you. Right now many design ideas have changed and I haven't documented them yet. </p>\n<p>But to compile the test file I have you do <code>cargo run --bin rowanc -- -s rowan-test-files rowan-test-files</code> then to run the runtime, you will need to do it on a machine that supports libunwind (this will likely change) and do <code>cargo run --bin rowan -- output/Main.class</code></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/Ki11erRabbit/rowan/blob/main/rowan/src/runtime/jit.rs#L584\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/61181ac96dd7496f67fd3754ba01e91251a8c449/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f313463396233656464643431376462633032656362633262396634326364623232393537343939623731363437363934383037376161306661633733363133342f4b69313165725261626269742f726f77616e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/Ki11erRabbit/rowan/blob/main/rowan/src/runtime/jit.rs#L584\" title=\"rowan/rowan/src/runtime/jit.rs at main · Ki11erRabbit/rowan\">rowan/rowan/src/runtime/jit.rs at main · Ki11erRabbit/rowan</a></div><div class=\"message_embed_description\">A high level object oriented programming language for the 20s - Ki11erRabbit/rowan</div></div></div>",
        "id": 526627468,
        "sender_full_name": "Alec Davis",
        "timestamp": 1751381716
    },
    {
        "content": "<p>And here is the log output from before and after stack spilling.<br>\n<a href=\"https://pastebin.com/V01TyyDf\">https://pastebin.com/V01TyyDf</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://pastebin.com/V01TyyDf\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/0dd7fd84c0d50799f92983226fb62fb426402b54/68747470733a2f2f706173746562696e2e636f6d2f692f66616365626f6f6b2e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://pastebin.com/V01TyyDf\" title=\"Cranelift Logs - Pastebin.com\">Cranelift Logs - Pastebin.com</a></div><div class=\"message_embed_description\">Pastebin.com is the number one paste tool since 2002. Pastebin is a website where you can store text online for a set period of time.</div></div></div>",
        "id": 526628167,
        "sender_full_name": "Alec Davis",
        "timestamp": 1751381889
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"896771\">@Alec Davis</span> I feel like I'm not understanding exactly what your issue is, and what you expect to be happening but is not happening or whatever, so I think what would be really helpful would be:</p>\n<ul>\n<li>The smallest test case you can create that exhibits the questionable behavior<ul>\n<li>ideally this is just a small Rust program using just <code>cranelift_frontend::FunctionBuilder</code> APIs rather than your whole compiler, but it is understandable if that is too difficult</li>\n</ul>\n</li>\n<li>precise steps to reproduce the questionable behavior<ul>\n<li>i.e. how to run the test case: <code>cargo test</code>? <code>cargo run</code>? something else?</li>\n</ul>\n</li>\n<li>A description of exactly what you expect to be happening<ul>\n<li>Something like: \"I would expect that <code>v12</code>, since it is marked as needing inclusion in stack maps, is spilled to the stack before the <code>call</code> instruction in <code>block4</code> and then reloaded from the stack after the <code>call</code>.\"</li>\n</ul>\n</li>\n<li>A description of exactly what is actually happening instead of what you expect<ul>\n<li>Something like: \"However, <code>v12</code> is not spilled to the stack and reloaded after the <code>call</code> and is instead reused across the <code>call</code>, which could lead to stale GC values.\"</li>\n</ul>\n</li>\n<li>The trace logs for this test case, specifically for the <code>cranelift-frontend</code> crate<ul>\n<li>e.g. with <code>env_logger</code> that would be <code>RUST_LOG=cranelift_frontend=trace ...</code></li>\n<li>filtering the trace logs for just the frontend crate should make it small enough to fit in a github gist</li>\n</ul>\n</li>\n</ul>\n<p>I think providing this level of detail will help clarify things and help us help you -- thanks!</p>",
        "id": 526645035,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1751387261
    },
    {
        "content": "<p>I'll be sure to do that, thanks for the feedback. I am busy at work for most of the day, so it is hard to respond quickly while people are awake/available. I'll be sure to put the logs in a gist.</p>",
        "id": 526703999,
        "sender_full_name": "Alec Davis",
        "timestamp": 1751418751
    },
    {
        "content": "<p>I believe that this is the smallest example in my language (I compile to my own class file definition so it is a little hard to share). I'll annotate what I think is supposed to happen.</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>class Main {\n\n    static thing: u64 = 66666666666;\n\n    fn main(args: [String]) {\n        let printer: Printer = new Printer();\n        let n: u64 = 40;\n        Main::thrash() // We create some garbage to collect\n        while True {\n            // Here to call println-int, we first fetch the method, but before trying that we first\n            // try to acquire a lock, if we are able to acquire it, then that means the runtime isn't\n            // collecting garbage. If we can't, then we run the routine to to collect all live rooted\n            // memory on the stack which should only include the printer object.\n            // However, for some reason, the call to fetch this particular method doesn't get a\n            // stack spill but the calls around it do. If we did a print before this loop, it would also find it there\n            printer.println-int(n);\n        }\n    }\n\n    fn thrash() {\n        let i: u64 = 0;\n        while i &lt; 10 {\n            let x: [u64] = new [u64; 1];\n            i = i + 1;\n        }\n    }\n}\n</code></pre></div>\n<p>I haven't set up a decent test system yet so to test this example you can overwrite <code>rowan-test-files/main.rowan</code> with the contents above. </p>\n<p>Then to run the compiler to generate the associated class file you provide 2 arguments, the path to the stdlib directory and a path to the directory with your project. In this case, we want them to be the same because we don't need the standard library.<br>\nSo the command to be run will be this:</p>\n<p><code>cargo run --bin rowanc -- -s rowan-test-files rowan-test-files</code></p>\n<p>This will put the newly generated class file in a directory called <code>output</code>.</p>\n<p>To then run the runtime with the class file (It should be noted that the runtime only supports x86_64 SystemV systems. I am working on changing this) you run this command:</p>\n<p><code>cargo run --bin rowan -- output/Main.class</code></p>\n<p>What will happen, is that the runtime will link the class with itself and call the main method in the Main class.</p>\n<p>In the main method above, what should happen is that:</p>\n<ul>\n<li>we create a printer object. </li>\n<li>Then create some garbage with the <code>thrash</code> method,</li>\n<li>We loop forever to allow the garbage collector to run</li>\n<li>Then call a method on the printer object to provide a way for the runtime to check if the garbage collector is running. </li>\n</ul>\n<p>Garbage collection should run every 5 seconds. This is to test that it actually works.</p>\n<ul>\n<li>\n<p>When we call the print method, 4 things happen in this order.</p>\n<ol>\n<li>We spill to the stack with a stack map so that we can find the printer object.</li>\n<li>We run the fetch function. This checks for GC and will scan the stack if GC is happening</li>\n<li>We call the fetched method.</li>\n<li>We check if the runtime context parameter has an exception attached to it, we bail from the current method if there was an exception thrown.</li>\n</ol>\n</li>\n</ul>\n<p>However, what ends up happening is that in the loop, the call to fetch the print method doesn't get the stack spilled, and a stack map generated. This then causes the printer to get collected when it should still be in scope. This then causes a Rust panic because the object's pointer is null.</p>\n<p>Then for completeness, here is the clif ir with where I think a stack map should exist but doesn't exist</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>function u0:0(i64, i64) system_v {\n        sig0 = (i64) -&gt; i64 system_v\n        sig1 = (i64, i64, i64) -&gt; i64 system_v\n        sig2 = (i64) -&gt; i8 system_v\n        sig3 = (i64) system_v\n        sig4 = (i64) -&gt; i8 system_v\n        sig5 = (i64, i64, i64, i64, i64) -&gt; i64 system_v\n        sig6 = (i64) -&gt; i8 system_v\n        sig7 = (i64, i64, i64) system_v\n        sig8 = (i64) -&gt; i8 system_v\n        sig9 = (i64) system_v\n        fn0 = u0:7 sig0\n        fn1 = u0:8 sig1\n        fn2 = u0:5 sig2\n        fn3 = u0:5 sig4\n        fn4 = u0:9 sig5\n        fn5 = u0:5 sig6\n        fn6 = u0:5 sig8\n        fn7 = u0:6 sig9\n\n    block0(v0: i64, v1: i64):\n        v7 -&gt; v0\n        v11 -&gt; v0\n        jump block1\n\n    block1:\n        v2 = iconst.i64 35\n        v3 = call fn0(v2)  ; v2 = 35\n        v4 = iconst.i64 40\n        v5 = iconst.i64 66\n        v6 = iconst.i64 69\n        v8 = call fn1(v7, v5, v6)  ; v5 = 66, v6 = 69\n        v9 = call fn2(v7)\n        brif v9, block2, block3(v8)\n\n    block2:\n        return\n\n    block3(v10: i64):\n        call_indirect.i64 sig3, v8(v7)\n        v12 = call fn3(v11)\n        brif v12, block4, block5\n\n    block4:\n        return\n\n    block5:\n        jump block6(v4, v3, v11)  ; v4 = 40\n\n    block6(v26: i64, v28: i64, v30: i64):\n        v14 -&gt; v26\n        v27 -&gt; v26\n        v15 -&gt; v28\n        v29 -&gt; v28\n        v19 -&gt; v30\n        v23 -&gt; v30\n        v25 -&gt; v30\n        v31 -&gt; v30\n        v13 = iconst.i8 1\n        brif v13, block7, block8  ; v13 = 1\n\n    block7:\n        v16 = iconst.i64 35\n        v17 = iconst.i64 -1\n        v18 = iconst.i64 36\n        v20 = call fn4(v19, v15, v16, v17, v18)  ; v16 = 35, v17 = -1, v18 = 36 // Right here we should have a stack map since we are fetching a method.\n        v21 = call fn5(v19)\n        brif v21, block10, block11(v20)\n\n    block10:\n        return\n\n    block11(v22: i64):\n        call_indirect.i64 sig7, v20(v19, v15, v14)\n        v24 = call fn6(v23)\n        brif v24, block12, block13\n\n    block12:\n        return\n\n    block13:\n        jump block6(v27, v29, v31)\n\n    block8:\n        call fn7(v25)\n        return\n    }\n</code></pre></div>\n<p>However, when looking at the clif ir block7, we don't have a stack map. In fact, the last stack map was in block where we call <code>thrash</code>.</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>    block7:\n        v16 = iconst.i64 35\n        v17 = iconst.i64 -1\n        v18 = iconst.i64 36\n        v20 = call fn4(v19, v15, v16, v17, v18)  ; v16 = 35, v17 = -1, v18 = 36 // There should be a stack map here but there isn't one.\n        v21 = call fn5(v19)\n        brif v21, block10, block11(v20)\n</code></pre></div>\n<p>You can see the more detailed logs in <a href=\"https://gist.github.com/Ki11erRabbit/9b7a31e56b75fd8cad3fa0e84e681b0b\">this gist</a></p>\n<p>Hopefully, this was both enough and not too much information. I look forward to hearing your response.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://gist.github.com/Ki11erRabbit/9b7a31e56b75fd8cad3fa0e84e681b0b\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/91f9baed8f4fc08c462d1a4de5a8c23942d45e97/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f6173736574732f676973742d6f672d696d6167652d3534666437646330373133652e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://gist.github.com/Ki11erRabbit/9b7a31e56b75fd8cad3fa0e84e681b0b\" title=\"rowan cranelift JIT logs\">rowan cranelift JIT logs</a></div><div class=\"message_embed_description\">rowan cranelift JIT logs. GitHub Gist: instantly share code, notes, and snippets.</div></div></div>",
        "id": 526708436,
        "sender_full_name": "Alec Davis",
        "timestamp": 1751422297
    },
    {
        "content": "<p>I wonder if using when using vars, I need to mark them again as requiring a stackmap. I tried marking the vars at one point as needing a stack map and that didn't change anything.</p>",
        "id": 527018370,
        "sender_full_name": "Alec Davis",
        "timestamp": 1751554701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"896771\">Alec Davis</span> <a href=\"#narrow/channel/217117-cranelift/topic/Help.20with.20Stack.20Spilling.20for.20Garbage.20Collection/near/527018370\">said</a>:</p>\n<blockquote>\n<p>I wonder if using when using vars, I need to mark them again as requiring a stackmap. I tried marking the vars at one point as needing a stack map and that didn't change anything.</p>\n</blockquote>\n<p>if you expect the values that are associated with those variables to be in stack maps, then yes, you need to mark the variables as needing stack maps</p>",
        "id": 527023298,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1751556106
    },
    {
        "content": "<p>The thing is, I tried that, and it didn't change anything, the same problem occurred. Would I also have to mark the value I get from using the variable as needing a stack map? That is something I haven't tried yet.</p>",
        "id": 527088196,
        "sender_full_name": "Alec Davis",
        "timestamp": 1751587075
    },
    {
        "content": "<p>So far, I have given every function call that should get a stack map a stack map but I am still missing some live memory.<br>\nI have set variables, and values as needing stack maps and I am still having issues with constructing a stack map. I wonder if when I convert the stack map into a data structure that my runtime can use I am doing something wrong.</p>\n<p>I construct my own map that I can look up during the gc phase.</p>\n<p>This is how I construct a hashmap where the key is the the instruction pointer and the value is a list of offsets from the stack pointer.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">compiled_code</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">context</span><span class=\"p\">.</span><span class=\"n\">compiled_code</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">stack_maps</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">compiled_code</span><span class=\"p\">.</span><span class=\"n\">buffer</span><span class=\"p\">.</span><span class=\"n\">user_stack_maps</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">object_locations</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">location</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">stack_maps</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">objects</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"p\">.</span><span class=\"n\">entries</span><span class=\"p\">()</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"p\">)</span>\n<span class=\"w\">                </span><span class=\"p\">.</span><span class=\"n\">collect</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">();</span>\n<span class=\"w\">            </span><span class=\"n\">object_locations</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">((</span><span class=\"o\">*</span><span class=\"n\">location</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">objects</span><span class=\"p\">));</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">locations</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">object_locations</span><span class=\"p\">;</span>\n\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"p\">.</span><span class=\"n\">get_finalized_function</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">object_locations</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">HashMap</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">locations</span><span class=\"p\">.</span><span class=\"n\">into_iter</span><span class=\"p\">()</span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">for_each</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">offset</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">objects</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                </span><span class=\"n\">object_locations</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">objects</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"p\">});</span>\n</code></pre></div>",
        "id": 527223462,
        "sender_full_name": "Alec Davis",
        "timestamp": 1751655172
    },
    {
        "content": "<p>I think it was just user error on my part. Thank you, everyone for help.</p>",
        "id": 527309789,
        "sender_full_name": "Alec Davis",
        "timestamp": 1751757276
    }
]