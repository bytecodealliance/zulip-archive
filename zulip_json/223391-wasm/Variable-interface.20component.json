[
    {
        "content": "<p>Is there any existing way that one might build a component that can export a function having an indeterminate signature?  We could obviously build a new component for each signature of interest and then link that in where it's needed, but for something like e.g. wrpc, it seems like it would be nice if it were possible to build a component that could be connected to any import, and that would get at runtime some representation of the types that it's been called with.</p>",
        "id": 534471886,
        "sender_full_name": "Lachlan Gunn",
        "timestamp": 1755174256
    },
    {
        "content": "<p>There is not, and I'm not sure that the component model itself would ever support exactly what you are describing. You could certainly define an interface that provides this functionality, which would likely end up looking a lot like existing RPC systems with reflection interfaces.</p>",
        "id": 534473349,
        "sender_full_name": "Lann Martin",
        "timestamp": 1755174753
    },
    {
        "content": "<p>I mean, speaking as an old Microsoft-ee, you're free to reimplement IQueryInterface if you want, but ymmv: <a href=\"https://news.ycombinator.com/item?id=43021361\">https://news.ycombinator.com/item?id=43021361</a></p>",
        "id": 534474417,
        "sender_full_name": "Ralph",
        "timestamp": 1755175106
    },
    {
        "content": "<p>We shall not be reimplementing DCOM, speaking for my MegaCorp. :-)</p>",
        "id": 534474480,
        "sender_full_name": "Ralph",
        "timestamp": 1755175129
    },
    {
        "content": "<p>but others can.....</p>",
        "id": 534474506,
        "sender_full_name": "Ralph",
        "timestamp": 1755175137
    },
    {
        "content": "<p>Yeah, I was about five years too young to get into DCOM so don't know better.  My thinking was that you could, in principle, create some adaptor module that could pull out the data directly and then transform it to a standard form before using the component model's lifting and lowering.</p>",
        "id": 534489072,
        "sender_full_name": "Lachlan Gunn",
        "timestamp": 1755179931
    },
    {
        "content": "<p>The thinking was that then you wouldn't need to somehow generate a monomorphised core module when linking in an RPC adaptor.</p>",
        "id": 534489396,
        "sender_full_name": "Lachlan Gunn",
        "timestamp": 1755180013
    },
    {
        "content": "<blockquote>\n<p>My thinking was that you could, in principle, create some adaptor module that could pull out the data directly and then transform it to a standard form before using the component model's lifting and lowering.</p>\n</blockquote>\n<p>this is one of the nice properties of the component model: exactly what you're describing here is possible today, without any special support by the component model itself. Obviously you either have to write the adapters by hand or have a tool generate them for you. But in either case, you can fully do it in your toolchain, without the runtime or the spec needing to support it in any way</p>",
        "id": 535132945,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1755611150
    },
    {
        "content": "<p>...and in case this isn't clear, you can do all this <em>without source code</em>; component binaries encode their own interface types.</p>",
        "id": 535135083,
        "sender_full_name": "Lann Martin",
        "timestamp": 1755611721
    }
]