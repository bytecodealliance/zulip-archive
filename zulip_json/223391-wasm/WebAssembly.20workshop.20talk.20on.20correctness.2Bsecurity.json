[
    {
        "content": "<p>I just gave a talk today at the WebAssembly Workshop (WAW 2025) at POPL on correctness efforts in Wasmtime+Cranelift (and a tiny bit about how weval can also be seen as a correctness effort). The recording is <a href=\"https://www.youtube.com/watch?v=tiksgrSC3Ig&amp;t=2453s\">here</a> if anyone is interested in watching; I'll post slides later as well.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"tiksgrSC3Ig\" href=\"https://www.youtube.com/watch?v=tiksgrSC3Ig&amp;t=2453s\"><img src=\"https://uploads.zulipusercontent.net/b9e301680529180442a46e51e18bb191c9a7f69b/68747470733a2f2f692e7974696d672e636f6d2f76692f74696b73677253433349672f64656661756c742e6a7067\"></a></div><p>(That's a timestamped link at 40m53s into the whole day workshop recording, which has a bunch of other interesting talks I'd recommend watching too -- full program <a href=\"https://popl25.sigplan.org/home/waw-2025#program\">here</a>)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://popl25.sigplan.org/home/waw-2025#program\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/310ea425a65507b242bc07ce2eacfbcfae4e7e58/68747470733a2f2f706f706c32352e736967706c616e2e6f72672f676574496d6167652f6361726f7573656c2f44656e7665725f536b796c696e655f696e5f57696e7465722e6a7065673f31373139323933383630303030&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://popl25.sigplan.org/home/waw-2025#program\" title=\"WAW 2025 -  - WebAssembly Workshop - POPL 2025\">WAW 2025 -  - WebAssembly Workshop - POPL 2025</a></div><div class=\"message_embed_description\">WebAssembly is a general-purpose low-level virtual machine. It was the first programming language to be introduced to the Web since JavaScript, and has since been adopted in many other environments, such as edge and cloud computing, mobile computing, blockchains, and embedded systems. Unusually for an industrial language, WebAssembly’s normative specification is stated fully in terms of a pen-and-paper formal semantics. In addition, multiple mechanisations of this semantics have been created and used to prove the soundness of the WebAssembly type system. \nThe rigor of WebAssembly’s semanti ...</div></div></div>",
        "id": 494979138,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737442152
    },
    {
        "content": "<p>Great talk and very interesting topic!<br>\nOne thing that confused me a bit was here: <a href=\"https://www.youtube.com/watch?v=tiksgrSC3Ig&amp;t=4019s\">YouTube -  - YouTube</a><br>\nYou spoke about how important is linear time verifiability because one would not want a Wasm module to load in quadratic time or worse. However, from what I know (and I might very well be wrong) is that Wasm validation (part of loading) already is quadratic since <code>multi-value</code> Wasm was enabled.<br>\nE.g. checking the type of stack manipulating control flow and calls is non-linear with <code>multi-value</code> Wasm. At least in all implementations I know it is quadratic in the worst-case.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"tiksgrSC3Ig\" href=\"https://www.youtube.com/watch?v=tiksgrSC3Ig&amp;t=4019s\"><img src=\"https://uploads.zulipusercontent.net/b9e301680529180442a46e51e18bb191c9a7f69b/68747470733a2f2f692e7974696d672e636f6d2f76692f74696b73677253433349672f64656661756c742e6a7067\"></a></div>",
        "id": 495049707,
        "sender_full_name": "Robin Freyler",
        "timestamp": 1737466467
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"374806\">@Robin Freyler</span> good question! I actually was not aware of quadratic complexity of multi-value validation, though I can see how that could be the case with a particular implementation (linear-time equality on signature rather than constant interned signature ID). I believe <code>wasmparser</code> should be able to do the check in constant time (so linear-time validation overall) because it has an interned ID for the block type (<a href=\"https://docs.rs/wasmparser/latest/wasmparser/enum.Operator.html#variant.Block\">here</a>) rather than an explicit list of params/results. <span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> could confirm for sure that the implementation is as I suspect...</p>\n<p>I'll note in the talk though that I was coming from the Wasm standards angle, where the spec <em>has</em> definitely been careful to ensure linear-time validation is possible, and that's a topic that comes up from time to time in discussion of extensions. Cranelift overall is definitely not a linear-time compiler but with a validator it's a desirable property not to add new superlinear blowups, which was my main point :-)</p>",
        "id": 495095769,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737476690
    },
    {
        "content": "<p>Oh I wasn't aware of any quadratic behavior in wasmparser's validator myself, but I could also very well have missed something</p>",
        "id": 495097249,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1737477109
    },
    {
        "content": "<p>A slightly more nuanced additional thought as well here after reading some code: a block with a signature, when branched to, will involve pushing/popping types on the type stack (e.g. <a href=\"https://github.com/bytecodealliance/wasm-tools/blob/6e9164c5db03892c9dc603ba1f783e84d0eacdd7/crates/wasmparser/src/validator/operators.rs#L1829\">here</a> for <code>block</code>); but when branching, a valid module will also have needed to produce those values somehow, and the block consume them; those instructions overall are linear, so the module size also must scale up. In other words, the validation cost is still linear overall in code size</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-tools/blob/6e9164c5db03892c9dc603ba1f783e84d0eacdd7/crates/wasmparser/src/validator/operators.rs#L1829\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/4b7738d51232898a6e3a47168ba9e6cf115af1ad/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f356536663765656366353439313134623563383064353033396364383030323633356566663437636561363364613736663138383061343763313634383237652f62797465636f6465616c6c69616e63652f7761736d2d746f6f6c73&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-tools/blob/6e9164c5db03892c9dc603ba1f783e84d0eacdd7/crates/wasmparser/src/validator/operators.rs#L1829\" title=\"wasm-tools/crates/wasmparser/src/validator/operators.rs at 6e9164c5db03892c9dc603ba1f783e84d0eacdd7 · bytecodealliance/wasm-tools\">wasm-tools/crates/wasmparser/src/validator/operators.rs at 6e9164c5db03892c9dc603ba1f783e84d0eacdd7 · bytecodealliance/wasm-tools</a></div><div class=\"message_embed_description\"> CLI and Rust libraries for low-level manipulation of WebAssembly modules  - bytecodealliance/wasm-tools</div></div></div>",
        "id": 495097534,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737477187
    },
    {
        "content": "<p>(seen another way: consider any per-parameter work when handling block signature validation to be amortized/accounted against the producer and consumer of that particular value instead)</p>",
        "id": 495097634,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737477217
    },
    {
        "content": "<p>so I think we're good, and I'd be very surprised if the Wasm spec itself missed a superlinear validation issue like this (<span class=\"user-mention\" data-user-id=\"374806\">@Robin Freyler</span> please do let us know if we're missing something!)</p>",
        "id": 495097858,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737477258
    },
    {
        "content": "<p>I will try to come up with a Wasm file that I think could be problematic:</p>\n<div class=\"codehilite\" data-code-language=\"WebAssembly\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">module</span>\n    <span class=\"p\">(</span><span class=\"k\">func</span>\n        <span class=\"p\">(</span><span class=\"k\">param</span>\n            <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span>\n            <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span>\n        <span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"k\">result</span>\n            <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span>\n            <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span>\n        <span class=\"p\">)</span>\n\n        <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">6</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">7</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">8</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">9</span><span class=\"p\">)</span>\n        <span class=\"p\">(</span><span class=\"k\">block</span> <span class=\"c1\">;; block is not even necessary but makes it simpler to follow maybe</span>\n            <span class=\"p\">(</span><span class=\"k\">param</span>\n                <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span>\n                <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span>\n            <span class=\"p\">)</span>\n            <span class=\"p\">(</span><span class=\"k\">result</span>\n                <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span>\n                <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span> <span class=\"kt\">i32</span>\n            <span class=\"p\">)</span>\n            <span class=\"c1\">;; Some conditional returns with multiple inputs/outputs</span>\n            <span class=\"c1\">;; A Wasm validation implementation might be quadratic here,</span>\n            <span class=\"c1\">;; because encoding a new conditional branch will have constant</span>\n            <span class=\"c1\">;; size but validation overhead in terms of the number of inputs</span>\n            <span class=\"c1\">;; and outputs defined once above. The validation stack has to be</span>\n            <span class=\"c1\">;; manipulated for each conditional branch in the general case for</span>\n            <span class=\"c1\">;; each input and output to check if all inputs and outputs match</span>\n            <span class=\"c1\">;; their expected types.</span>\n            <span class=\"c1\">;;</span>\n            <span class=\"c1\">;; This is a super simplified example that could easily be mutated</span>\n            <span class=\"c1\">;; in order to make it hard to use heuristics to avoid such quadratic</span>\n            <span class=\"c1\">;; cases.</span>\n            <span class=\"p\">(</span><span class=\"nb\">br_if</span> <span class=\"mi\">0</span> <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">br_if</span> <span class=\"mi\">0</span> <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">br_if</span> <span class=\"mi\">0</span> <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n            <span class=\"c1\">;; etc..</span>\n            <span class=\"p\">(</span><span class=\"nb\">br_if</span> <span class=\"mi\">0</span> <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n            <span class=\"p\">(</span><span class=\"nb\">br_if</span> <span class=\"mi\">0</span> <span class=\"p\">(</span><span class=\"nb\">local.get</span> <span class=\"mi\">0</span><span class=\"p\">))</span>\n        <span class=\"p\">)</span>\n    <span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n<p>(Not checked if this is syntactically valid Wasm tbh.)</p>",
        "id": 495113636,
        "sender_full_name": "Robin Freyler",
        "timestamp": 1737481981
    },
    {
        "content": "<p>Fascinating, yeah, I had forgotten that <code>br_if</code> effectively duplicates its args (leaves them on the stack for the not-taken path). I might recommend detaching this thread / putting it under a separate topic since it is a general Wasm validation performance question/issue rather than specific to my talk.</p>\n<p>It'd be interesting to see how much blowup this can actually cause (aside from the bad theoretical asymptotic bound)  -- I tried expanding your example to 50 params and 1M lines of <code>br_if</code>, and <code>wasm-tools validate</code> still validates the wat in 0.41s on my (M1 Air) laptop</p>",
        "id": 495122493,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737485118
    },
    {
        "content": "<p>Wanted to say as well great talk Chris! Just listened to it and it's a great explanation of the space!</p>",
        "id": 495163533,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1737501848
    },
    {
        "content": "<p>thanks! now I just need to acquire free time somehow to tie up all the loose ends and actually ship PCC...</p>",
        "id": 495194135,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1737518892
    },
    {
        "content": "<p>great talk!</p>",
        "id": 495369951,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1737578533
    }
]