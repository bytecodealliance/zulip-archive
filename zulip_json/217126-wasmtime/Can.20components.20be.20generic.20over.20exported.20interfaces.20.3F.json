[
    {
        "content": "<p>It's possible to generic of the imported interfaces of a components (in fact this is how <code>add_to_linker</code> works). Is it possible to also do this with exported interfaces ?<br>\nSo for example this is possible</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wastime</span><span class=\"p\">::</span><span class=\"n\">component</span><span class=\"p\">::</span><span class=\"n\">bindgen</span><span class=\"p\">({</span>\n<span class=\"w\">    </span><span class=\"n\">inline</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">r</span><span class=\"p\">#</span><span class=\"s\">\"</span>\n<span class=\"s\">        package example:interface-imports;</span>\n\n<span class=\"s\">        interface logging {</span>\n<span class=\"s\">            enum level {</span>\n<span class=\"s\">                debug,</span>\n<span class=\"s\">                info,</span>\n<span class=\"s\">                warn,</span>\n<span class=\"s\">                error,</span>\n<span class=\"s\">            }</span>\n\n<span class=\"s\">            log: func(level: level, msg: string);</span>\n<span class=\"s\">        }</span>\n\n<span class=\"s\">        world with-imports {</span>\n<span class=\"s\">            import logging;</span>\n<span class=\"s\">        }</span>\n<span class=\"s\">    \"</span><span class=\"p\">#</span>\n<span class=\"p\">});</span>\n\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">example</span><span class=\"p\">::</span><span class=\"n\">interface_imports</span><span class=\"p\">::</span><span class=\"n\">logging</span><span class=\"p\">::</span><span class=\"n\">Host</span>\n\n<span class=\"k\">fn</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Host</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">host</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">T</span><span class=\"p\">){</span>\n<span class=\"w\">  </span><span class=\"c1\">// Do stuff like</span>\n<span class=\"w\">  </span><span class=\"c1\">// Create a store owning a T</span>\n<span class=\"w\">  </span><span class=\"c1\">// and use it to instantiate a component</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Is there a way to something like this </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wastime</span><span class=\"p\">::</span><span class=\"n\">component</span><span class=\"p\">::</span><span class=\"n\">bindgen</span><span class=\"p\">({</span>\n<span class=\"w\">    </span><span class=\"n\">inline</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">r</span><span class=\"p\">#</span><span class=\"s\">\"</span>\n<span class=\"s\">        package example:interface-imports;</span>\n\n<span class=\"s\">        interface logging {</span>\n<span class=\"s\">            enum level {</span>\n<span class=\"s\">                debug,</span>\n<span class=\"s\">                info,</span>\n<span class=\"s\">                warn,</span>\n<span class=\"s\">                error,</span>\n<span class=\"s\">            }</span>\n\n<span class=\"s\">            log: func(level: level, msg: string);</span>\n<span class=\"s\">        }</span>\n\n<span class=\"s\">        world with-imports {</span>\n<span class=\"s\">            export logging;</span>\n<span class=\"s\">        }</span>\n<span class=\"s\">    \"</span><span class=\"p\">#</span>\n<span class=\"p\">});</span>\n\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">example</span><span class=\"p\">::</span><span class=\"n\">interface_imports</span><span class=\"p\">::</span><span class=\"n\">logging</span><span class=\"p\">::</span><span class=\"n\">Guest</span>\n\n<span class=\"k\">fn</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Guest</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">guest</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">T</span><span class=\"p\">){</span>\n<span class=\"w\">  </span><span class=\"c1\">// Do things like calling guest.call_log():</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>The use case is that I'd like to have a library that ingests any component that implements (i.e. export) interfaces. As far as I know it's not possible to do without me creating that guest trait and users implementing it for the specific struct created when they call <code>bindgen!</code></p>",
        "id": 546176998,
        "sender_full_name": "Antoine Lavandier",
        "timestamp": 1761036728
    },
    {
        "content": "<p>Yeah I would agree the guest side would be pretty difficult here due to the fact that it needs to get hooked up to <code>no_mangle</code> functions. It's sort of \"almost there\" but not quite given the current generated bindings</p>",
        "id": 546254172,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761057348
    },
    {
        "content": "<p>I took more time to look at the generated code and I think that I have potential solution that would essentially mirror what happens for imported interfaces. If I'm not mistaken declaring <code>with: { \"interface\": path::to::mod}</code> removes the <code>mod interface { ... }</code> part of the generated code and instead adds <code>use path::to::mod::{Host, add_to_linker,  ...}</code>. <br>\nApplied to exported interfaces this could look like this <br>\nSo by default everything is generated at the <code>bindgen</code> call site and otherwise, it's replace by  <code>use</code> statements when the <code>bindgen</code> caller provides a path to a module that already generates the approriate code.<br>\nThen the trait could be defined only once and implemented directly on the struct <code>exports::interface::Guest</code> and/or the <code>MyWorld</code> struct.</p>",
        "id": 546262562,
        "sender_full_name": "Antoine Lavandier",
        "timestamp": 1761059315
    }
]