[
    {
        "content": "<p>Hi, I wanted to leave a small usage report of <code>run_concurrent</code> and the <code>Accessor</code> API with the asynchronous component model. I am using wasmtime to embed a wasm component, and I want that component to run its tasks while I also invoke more tasks. In this specific case, I want to invoke more HTTP handlers while other handlers are already running. That is difficult because (it seems to me) that <code>run_concurrent</code> is the only way to get access to the <code>Accessor</code> I need to do new invocations, and <code>run_concurrent</code> takes a &amp;mut self. (And I want more control than the standard wasi-http wrapper gives, so that's why I am not using that.)</p>\n<p>In my mental right now, run_concurrent plays double duty -- it lets me start tasks with an accessor when I call it, and it lets the component make progress while it is running. I wish those were detangled. In an ideal world, I would use tokio::spawn a task that invokes something like run_concurrent on a component instance to let the component do work. Then, whenever I want to muck around with the state, I wish I could get an accessor temporarily by invoking some <code>get_accessor</code> that would temporarily pause the <code>run_concurrent</code> and let me invoke tasks or modify state.</p>\n<p>My janky workaround (<a href=\"https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/wasmtimewrapper.rs#L74\">code</a>) right now is to have a worker task that invokes run_concurrent, and that takes tasks from a queue to be invoked inside of that run_concurrent. I can then post tasks (<a href=\"https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/main.rs#L55\">code</a>) to that queue without worrying about starting and stopping the run_concurrent. But it feels yucky.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/wasmtimewrapper.rs#L74\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/edd64ad54267c0a881b2e76df857807e2df5f5e3/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353537636165643337613838623165346436663065623234616434333930326365666134656631356135333739616537363331386661323133373139336562632f6a656c6c6576616e64656e686f6f66662f706f7332&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/wasmtimewrapper.rs#L74\" title=\"pos2/wasi3experiment/src/wasmtimewrapper.rs at a83e626fea10f6a90791e68a446adc5d51b5b784 · jellevandenhooff/pos2\">pos2/wasi3experiment/src/wasmtimewrapper.rs at a83e626fea10f6a90791e68a446adc5d51b5b784 · jellevandenhooff/pos2</a></div><div class=\"message_embed_description\">Contribute to jellevandenhooff/pos2 development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/main.rs#L55\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/edd64ad54267c0a881b2e76df857807e2df5f5e3/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353537636165643337613838623165346436663065623234616434333930326365666134656631356135333739616537363331386661323133373139336562632f6a656c6c6576616e64656e686f6f66662f706f7332&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/main.rs#L55\" title=\"pos2/wasi3experiment/src/main.rs at a83e626fea10f6a90791e68a446adc5d51b5b784 · jellevandenhooff/pos2\">pos2/wasi3experiment/src/main.rs at a83e626fea10f6a90791e68a446adc5d51b5b784 · jellevandenhooff/pos2</a></div><div class=\"message_embed_description\">Contribute to jellevandenhooff/pos2 development by creating an account on GitHub.</div></div></div>",
        "id": 547841192,
        "sender_full_name": "Jelle van den Hooff",
        "timestamp": 1761789742
    },
    {
        "content": "<p>It's also entirely possible I am doing something silly and there is an easier way to do this -- I am all ears :)</p>",
        "id": 547841263,
        "sender_full_name": "Jelle van den Hooff",
        "timestamp": 1761789805
    },
    {
        "content": "<p>(And I tried to find issues describing this on the wasmtime repo but did not find anything that quite matched this.)</p>",
        "id": 547841394,
        "sender_full_name": "Jelle van den Hooff",
        "timestamp": 1761789900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"981641\">Jelle van den Hooff</span> <a href=\"#narrow/channel/217126-wasmtime/topic/run_concurrent.20and.20accessor.20async.20ergonomics/near/547841192\">said</a>:</p>\n<blockquote>\n<p>My janky workaround (<a href=\"https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/wasmtimewrapper.rs#L74\">code</a>) right now is to have a worker task that invokes run_concurrent, and that takes tasks from a queue to be invoked inside of that run_concurrent. I can then post tasks (<a href=\"https://github.com/jellevandenhooff/pos2/blob/a83e626fea10f6a90791e68a446adc5d51b5b784/wasi3experiment/src/main.rs#L55\">code</a>) to that queue without worrying about starting and stopping the run_concurrent.</p>\n</blockquote>\n<p>FWIW, I think this is a fine approach, and matches what we do in <code>wasmtime-wasi-http</code> to support <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi-http/src/handler.rs\">handling multiple concurrent incoming requests in a single instance</a>.  Perhaps we could generalize the pattern and make it a built-in part of the Wasmtime API.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi-http/src/handler.rs\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/53ccd21a716c5551e22adba4f377e4e48177dd40/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f313631306661383431303832353162663530383464666137326464386234363937633830363262343661643130316438393739393838626630396661633831622f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi-http/src/handler.rs\" title=\"wasmtime/crates/wasi-http/src/handler.rs at main · bytecodealliance/wasmtime\">wasmtime/crates/wasi-http/src/handler.rs at main · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>",
        "id": 547937285,
        "sender_full_name": "Joel Dice",
        "timestamp": 1761831421
    },
    {
        "content": "<p>I am also planning on using channels to solve this once I switch to WASI 0.3.</p>\n<blockquote>\n<p>Perhaps we could generalize the pattern and make it a built-in part of the Wasmtime API.</p>\n</blockquote>\n<p>I do think that simplifying the API by making this happen under the hood would be a nice improvement.</p>",
        "id": 548197689,
        "sender_full_name": "Celarye",
        "timestamp": 1761927241
    }
]