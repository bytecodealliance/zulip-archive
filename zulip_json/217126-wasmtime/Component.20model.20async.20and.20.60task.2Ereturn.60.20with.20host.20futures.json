[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"509936\">@Joel Dice</span> let's say I invoke an async guest function from the host. The guest calls <code>task.return</code> and then sleeps for 10s. Does the host-side future resolve immediately on <code>task.return</code> or does it wait for the task to exit?</p>",
        "id": 537339154,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756836044
    },
    {
        "content": "<p>It <em>should</em> be immediate, right?</p>",
        "id": 537341286,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756836870
    },
    {
        "content": "<p>I suppose this is was a leading question, but I'm under the impression it's not immediate currently. I was about to open an issue for making it immediate but wanted to confirm first.</p>\n<p>If it is immediate, however, then we also need more API bindings since right now the host otherwise has no way of knowing when the task has exited after returning</p>",
        "id": 537341491,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756836944
    },
    {
        "content": "<p>so, yes, I agree it should probably be immediate, but in doing so we need to expose the \"task exited\" event too</p>",
        "id": 537341552,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756836968
    },
    {
        "content": "<p>Is the task that returned special from the caller's perspective compared to any other task that might have been created?</p>",
        "id": 537341798,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756837072
    },
    {
        "content": "<p>To me it is insofar as it represents the guests request to keep running after returning, so if the host wants to respect that it needs to know when the guest is done</p>",
        "id": 537341955,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756837137
    },
    {
        "content": "<p>Oh right this is meaningful because of the pseudo-structured-concurrency thing</p>",
        "id": 537342138,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756837222
    },
    {
        "content": "<p>well the host wouldn't have a guarantee that when the guest task exits that there's no transitive tasks, so it's not structured in that sense</p>",
        "id": 537342290,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756837279
    },
    {
        "content": "<p>but basically if everyone wants to participate in the structured concurrency paradigm it should be possible IMO</p>",
        "id": 537342325,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756837299
    },
    {
        "content": "<p>Do borrows have to be dropped before <code>task.return</code> or before task exit?</p>",
        "id": 537342586,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756837420
    },
    {
        "content": "<p>before <code>task.return</code>, <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Async.md#returning:~:text=decremented%20when%20the%20caller%20is%20notified%20that%20the%20subtask%20has%20returned.\">I see</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Async.md#returning:~:text=decremented%20when%20the%20caller%20is%20notified%20that%20the%20subtask%20has%20returned.\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/aa89c102473fd5d2b37ebdffc3166e2adc9db6a6/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f643132363664373639333264336362383530386430326466636262626565346662653865336566393234363339656237343964313132636665326165356130622f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Async.md#returning:~:text=decremented%20when%20the%20caller%20is%20notified%20that%20the%20subtask%20has%20returned.\" title=\"component-model/design/mvp/Async.md at main 路 WebAssembly/component-model\">component-model/design/mvp/Async.md at main 路 WebAssembly/component-model</a></div><div class=\"message_embed_description\">Repository for design and specification of the Component Model - WebAssembly/component-model</div></div></div>",
        "id": 537343084,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756837651
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253994\">Alex Crichton</span> <a href=\"#narrow/channel/217126-wasmtime/topic/Component.20model.20async.20and.20.60task.2Ereturn.60.20with.20host.20futures/near/537342290\">said</a>:</p>\n<blockquote>\n<p>well the host wouldn't have a guarantee that when the guest task exits that there's no transitive tasks, so it's not structured in that sense</p>\n</blockquote>\n<p>I <em>think</em> it should, if <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Async.md#structured-concurrency:~:text=the%20supertask%20semantically%20%22tail%20calls%22%20any%20still%2Dlive%20subtasks\">this</a> is implemented (and applies to the host)</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Async.md#structured-concurrency:~:text=the%20supertask%20semantically%20%22tail%20calls%22%20any%20still%2Dlive%20subtasks\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/aa89c102473fd5d2b37ebdffc3166e2adc9db6a6/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f643132363664373639333264336362383530386430326466636262626565346662653865336566393234363339656237343964313132636665326165356130622f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Async.md#structured-concurrency:~:text=the%20supertask%20semantically%20%22tail%20calls%22%20any%20still%2Dlive%20subtasks\" title=\"component-model/design/mvp/Async.md at main 路 WebAssembly/component-model\">component-model/design/mvp/Async.md at main 路 WebAssembly/component-model</a></div><div class=\"message_embed_description\">Repository for design and specification of the Component Model - WebAssembly/component-model</div></div></div>",
        "id": 537343326,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756837773
    },
    {
        "content": "<p>aha good point, and now I also don't know whether that's implemented</p>",
        "id": 537343763,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756837951
    },
    {
        "content": "<p>Currently, there's no convenient way to wait for a task to exit in the Wasmtime API.  I was thinking we could make <code>call_concurrent</code> return a tuple of the result and a future that resolves when the task exits; that should be easy enough to do, but isn't implemented yet.</p>\n<p>Technically, you can also pass a forever-pending future to <code>Instance::run_concurrent</code> and wait for it to return a \"deadlock\" trap, which means \"the runtime has nothing left to do\".  We use that hack in a few tests to wait for all outstanding tasks to exit, but it's obviously not a great long-term solution, plus it won't help if you only care about a specific task exiting.</p>",
        "id": 537350361,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756840757
    },
    {
        "content": "<p>Ah ok, so <code>task.return</code> is indeed immediate today?</p>",
        "id": 537350417,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756840795
    },
    {
        "content": "<p>Yes.</p>",
        "id": 537352090,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756841618
    }
]