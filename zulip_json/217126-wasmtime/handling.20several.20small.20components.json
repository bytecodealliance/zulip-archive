[
    {
        "content": "<p>hi, i was thinking of using wasm and wasmtime to allow users to implement their own custom extensions for my game, my concern tho is that by having potentially a lot of small mods this is going to mean that i get a ton of memory usage even if each one is doing relatively little, i was wondering what would be considered best practice in such a scenario to make so the mods are well isolated but minimize resource usage</p>",
        "id": 566986716,
        "sender_full_name": "giovanni cristellon",
        "timestamp": 1767890492
    },
    {
        "content": "<p>note that (by default, on 64-bit systems) Wasmtime will reserve large chunks of virtual memory in the process for each wasm linear memory, most of that is for guard pages, which never get backed by physical memory. additionally, only the memory pages that are actually touched by the wasm program will ever get backed by physical memory, and while that is potentially every page in the wasm linear memory in theory, many pages within the wasm linear memory never tend to get touched in practice.</p>\n<p>but if you are concerned about virtual memory reservations, you can always do things like disable guard pages (at the cost of slowing down wasm execution because explicit bounds checks will be added to each load/store, instead of relying on the guard pages to catch out-of-bounds accesses)</p>\n<p>you can also validate/enforce memory limits on plugins, either by</p>\n<ul>\n<li>statically enforcing a limit via parsing the wasm and checking the number of memories it has and the maximum limit on each memory</li>\n<li>dynamically enforcing a limit via a <a href=\"https://docs.rs/wasmtime/latest/wasmtime/trait.ResourceLimiter.html\"><code>wasmtime::ResourceLimiter</code></a> (or <code>ResourceLimiterAsync</code>)</li>\n</ul>",
        "id": 567008922,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1767897646
    },
    {
        "content": "<p>To expand on what was already covered above -- you'll likely benefit from perusing the <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html\"><code>wasmtime::Config</code> struct</a></p>\n<p>For example the <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Config.html#method.memory_guard_size\"><code>memory_guard_size</code> option</a> which relates directly to the explanation above (it's not the only related option but is well documented like the others).</p>\n<p>Also, there's a question of what the WebAssembly binaries are written in -- when building WebAssembly components from scripting languages (e.g. Javascript, Python) there is often a large overhead as each binary contains a copy of the runtime. There are a few ways to overcome that size limit, with varying levels of difficulty. One of the easier ways is to change the plugin binaries that users pass around to actually contain just some chunk of code (assuming your dynamic language Wasm toolchain supports <code>eval</code>), and then keep a pool of one or more components that contains the engine. </p>\n<p>There are other ways but that's probably the easiest one to grok (well, other than requiring a language that produces smaller WASM binaries).</p>\n<p>Do you by any chance have some numbers around the resource usage and what stage at which it becomes problematic (during executions? steady state?)</p>",
        "id": 567091063,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1767947238
    },
    {
        "content": "<p>for now i am purely at an exploratory stage and trying to make sure i don't start with an architecture that is not suited for i want to do so i don't have benchmarks yet</p>",
        "id": 567135504,
        "sender_full_name": "giovanni cristellon",
        "timestamp": 1767963283
    }
]