[
    {
        "content": "<p>In the interest of helping push the story around wasip3 forward, I'm interested in pushing a bit on the guest-language side of things. Currently wizer can be an important component of Rust/Go/JS initialization and component-init is the equivalent for componentize-py. It's expected that JS will move to requiring component-init in migrating to wit-dylib which componentize-py will also move to as well (componentize-py still going to use component-init).</p>\n<p>Currently component-init lives in a <a href=\"https://github.com/dicej/component-init/\">repo</a> under <span class=\"user-mention\" data-user-id=\"509936\">@Joel Dice</span>'s github account and <span class=\"user-mention\" data-user-id=\"253992\">@Pat Hickey</span> has a <a href=\"https://github.com/bytecodealliance/wizer/pull/138\">PR to merge it into Wizer</a>. I'd like to propose that we go a step further and merge both projects into the Wasmtime repository itself. My initial proposal would be a <code>wasmtime-wizer</code> crate and a <code>wasmtime wizer</code> subcommand. The goals of this merge would be:</p>\n<ol>\n<li>Easier maintenance by having one repo instead of 3, no need to keep them all in-sync.</li>\n<li>Easier maintenance in that everything is kept in-sync with Wasmtime. Wasm-tools deps up-to-date, wasmtime up-to-date, etc.</li>\n<li>Easier maintenance in that we're alerted earlier in the development process if something hits a problem with wizer pre-init since it should come up as part of repo tests.</li>\n<li>Better support for more WASI/WASIp{2,3} options in the CLI. I'm imagining that <code>wasmtime wizer</code> would share all the same CLI arguments as <code>wasmtime run</code> effectively and it's easy to share implementations from within Wasmtime itself.</li>\n<li>Less tools for users to think about, running wasm means you grab Wasmtime and no need to manage Wasmtime/wizer/component-init versions separately.</li>\n</ol>\n<p>After reviewing wizer and component-init I'm envisioning that a few changes would be made along the way. Nothing ground-shatteringly different but still worth noting:</p>\n<ul>\n<li>In component-init the actual execution/fetching values of wasm is behind a trait. That makes it amenable to (theoretically) using any runtime for initialization instead of just Wasmtime. I think this would be easy to preserve and would be a nice abstraction to have internally (aka a tight boundary between Wasmtime itself and the wasmtime-wizer crate)</li>\n<li>Currently component-init preserves subcomponents as-is, but I don't think this is valid and I think we'll need to disallow subcomponents. Specifically the function executed might mutate state in a subcomponent but that's not being snapshotted.</li>\n<li>Currently component-init rejects fewer instructions than Wizer, so it'll be updated to reject the same instructions as Wizer.</li>\n<li>Wizer I believe needs to be updated to disallow <code>memory.init</code> because data segments change after initialization. While <code>memory.init</code> is valid during initialization it's meaning data-segment-wise would change after. LLVM-based toolchains don't emit <code>memory.init</code> though.</li>\n<li>Wizer disallows all reference-type instructions, including things it doesn't need to like <code>ref.null</code>, <code>table.size</code>, <code>table.get</code>, etc. I believe this is an artifact of \"let's enable reference-types but just the call-overlong-leb bit\" but I think it's worth being more precise about which instructions are allowed or not.</li>\n<li>We'll want to reject globals of any reference type. These can't be snapshotted basically. Tables of non-funcref reference types also need to be disallowed, and tables of reference-types are allowed but only because element segment initialization is always replayed and known to not be mutated in the body of the module.</li>\n</ul>\n<p>Those are the things I can remember off the top of my head at least after reviewing these codebases. I suspect further changes/tweaks might be necessary.</p>\n<hr>\n<p>Ok that's a lot of words and exposition, but I wanted to double-check that others are ok with this as well. There's been no activity on the <a href=\"https://github.com/bytecodealliance/wizer/issues/133\">issue I opened in April</a> and my impression is that folks would prefer to have Wizer taken care of by someone else, so I wanted to provide an opportunity for any objections to be raised before committing to too much</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/dicej/component-init/\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/4f0fc3314d151e7d4ac3c85d1b576d76a2004d0d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f343130396330353665386335306164616161333136326461373630616666366235303834306665376363656331353930633336376535373639356533393634312f646963656a2f636f6d706f6e656e742d696e6974&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/dicej/component-init/\" title=\"GitHub - dicej/component-init: WebAssembly Component Pre-initializer\">GitHub - dicej/component-init: WebAssembly Component Pre-initializer</a></div><div class=\"message_embed_description\">WebAssembly Component Pre-initializer. Contribute to dicej/component-init development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wizer/pull/138\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/808a7db0fa54cdd22155e89bf8871259c34caf1c/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f653639376666333238303438376335353761393132333636626662393330346466313535326637383536653932303131323161663739636232653132363639302f62797465636f6465616c6c69616e63652f77697a65722f70756c6c2f313338&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wizer/pull/138\" title=\"Add `component-init` project to this repo by pchickey · Pull Request #138 · bytecodealliance/wizer\">Add `component-init` project to this repo by pchickey · Pull Request #138 · bytecodealliance/wizer</a></div><div class=\"message_embed_description\">@dicej and I would like to add the component-init project to this repo. It has been developed at https://github.com/dicej/component-init. I moved the entire contents of that repo into the component...</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wizer/issues/133\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/62da8b6a9b1dcd860653935b517307c7bc6a4ba7/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f623639343035626163663062396532333737323837656362326664663839373063323138346635643961303036656435363739376331363066373536343133322f62797465636f6465616c6c69616e63652f77697a65722f6973737565732f313333&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wizer/issues/133\" title=\"Merge into upstream wasmtime/wasm-tools? · Issue #133 · bytecodealliance/wizer\">Merge into upstream wasmtime/wasm-tools? · Issue #133 · bytecodealliance/wizer</a></div><div class=\"message_embed_description\">This has come up a few times in discussion with other folks so I wanted to pose the question here: what would folks here think about merging this crate into wasmtime/wasm-tools? The rough idea/rati...</div></div></div>",
        "id": 542835596,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1759441735
    },
    {
        "content": "<p>Thanks Alex that sounds like a good plan to me. Its probably worthwhile to merge component-init and wizer as part of the changes that happen along the way, much of the implementation can be shared between the two</p>",
        "id": 542844631,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1759446670
    },
    {
        "content": "<blockquote>\n<p>We'll want to reject globals of any reference type. These can't be snapshotted basically. Tables of non-funcref reference types also need to be disallowed, and tables of reference-types are allowed but only because element segment initialization is always replayed and known to not be mutated in the body of the module.</p>\n</blockquote>\n<p>When you say \"reject\" you mean report an error if any of these are around at the time of snapshotting, right? I.e., it'd be perfectly fine to use reference types, as long as they're all dropped when the snapshot is taken? And same for Component Model resource handles?</p>\n<p>Also, I guess this means there's no story for GC, right? Is it even possible to snapshot those, even theoretically, or is that not viable within wasm semantics?</p>",
        "id": 543090367,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1759586808
    },
    {
        "content": "<p>just a small note, at least I currently rely on the @bytecodealliance/wizer npm package, would be nice if those were still released, but otherwise the change sounds great</p>",
        "id": 543092071,
        "sender_full_name": "Ramon Klass",
        "timestamp": 1759588270
    },
    {
        "content": "<blockquote>\n<p>Is it even possible to snapshot those, even theoretically, or is that not viable within wasm semantics?</p>\n</blockquote>\n<p>There's no way to write constant initializer expressions that construct an arbitrary object graph with cycles, if I understand correctly (p. 73 of <a href=\"https://webassembly.github.io/spec/versions/core/WebAssembly-3.0-draft.pdf\">https://webassembly.github.io/spec/versions/core/WebAssembly-3.0-draft.pdf</a> does show <code>struct.new*</code>, <code>array.new*</code>, etc as valid constant initializers, assuming their field values/operands are constant, but it's noted there that initializers for a global can only refer to previously defined globals, so there's no way to build a cycle).</p>\n<p>A way around this would be to write out a sequence of initialization code that rebuilds the object graph, of course; either all objects for simplicity, or only \"tying the knot\" on the residual cycles/forward refs if we analyze for that. Then prepend this code to the start function (or add one).</p>\n<p>I don't think any of this would require adding mutability to globals or fields, since the original program to construct the cycle would already require that mutability to construct the original graph we're snapshotting.</p>\n<p>That's my quick analysis anyway, not to say any of this is <em>easy</em> only that it seems <em>possible</em> with enough work :-)</p>",
        "id": 543112345,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1759607037
    },
    {
        "content": "<p>thanks, that's very helpful. My hunch would be that only the \"tying the knot\" version of this would lead to viable performance, but I might be wrong about that</p>",
        "id": 543174930,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1759682976
    },
    {
        "content": "<p>My thinking was that tables-of-references and globals-of-references would be outright rejected at validation time. No escape hatch for \"ok well you didn't modify it so that's ok\". The main reason for me is that with the component model it's not actually possible to look at the value of any reference-typed global or table. </p>\n<p>The reason function tables sort-of-work is that we don't modify any element segments and all table mutations are forbidden (e.g. <code>table.set</code> will be disallowed and you can't mutate items you fetch via <code>table.get</code> since they're <code>funcref</code>). Tables or globals of <code>anyref</code> could, for example, have mutated contents after you get them and there'd be no way to observe that across a component boundary.</p>\n<p>We could consider relaxing these restrictions for the core wasm version of initialization where we can actually witness the shape of object graphs and such, though. My thinking was that this probably wasn't necessary so we'd disallow it anyway. Otherwise Chris's idea is the best I'd have. All <code>start</code> functions are already removed so we'd basically just be replacing the <code>start</code> function, if any, and that'd replay all mutations made that we couldn't stick in constant initializers</p>",
        "id": 543332651,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1759761216
    },
    {
        "content": "<blockquote>\n<p>just a small note, at least I currently rely on the <br>\n@bytecodealliance/wizer npm package, would be nice if those were still <br>\nreleased, but otherwise the change sounds great</p>\n</blockquote>\n<p>Thanks for highlighting that! I've got no experience setting up npm pubilshing from CI, much less from the Wasmtime repo, so this'll be interesting...</p>",
        "id": 543332822,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1759761249
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253994\">Alex Crichton</span> <a href=\"#narrow/channel/217126-wasmtime/topic/Moving.20wizer.2Fcomponent-init.20into.20Wasmtime/near/542835596\">said</a>:</p>\n<blockquote>\n<p>There's been no activity on the <a href=\"https://github.com/bytecodealliance/wizer/issues/133\">issue I opened in April</a></p>\n</blockquote>\n<p>Huh, I never saw that issue, sorry!</p>\n<p>In general I'm in favor.</p>\n<p>Have you thought at all about how to expose Wizer's programmatic API from Wasmtime's API?</p>\n<hr>\n<p>regarding snapshotting references and mutating tables, we have an issue open with some brainstormed ideas from a while ago: <a href=\"https://github.com/bytecodealliance/wizer/issues/29\">https://github.com/bytecodealliance/wizer/issues/29</a></p>\n<p>straightline code on an injected <code>__init_gc_heap</code> function or whatever to create the initial heap graphs is also what I have been imagining for GC snapshots.</p>\n<p>but given that this tool is effectively becoming wasmtime-specific anyways, we could potentially have a custom section that encodes the heap graph, and then compilation to a <code>.cwasm</code> could create a GC heap CoW image from that custom section or something. Or we could do use the custom section only as a hint to analyze the entry points and check that the init-gc-heap function is the first thing called on all paths, and if so then do compile-time evaluation of the init-gc-heap function and make a CoW image from that, and then remove the calls to the init-gc-heap function from the <code>.cwasm</code></p>\n<p>but this stuff can all be discussed after the initial merge into wasmtime</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wizer/issues/29\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/e981c2ad3d4fb41d6aac43b419ddbbdc78c13206/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f643661303837383363643463303261393332336237316632666665653363356163313737626531373530633433656630393062323038393739336566316166312f62797465636f6465616c6c69616e63652f77697a65722f6973737565732f3239&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wizer/issues/29\" title=\"Add support for snapshotting tables · Issue #29 · bytecodealliance/wizer\">Add support for snapshotting tables · Issue #29 · bytecodealliance/wizer</a></div><div class=\"message_embed_description\">Right now there are two potential kinds of tables: funcref tables externref tables The latter are easy to support, since Wasm can't construct an externref, only receive it from the outside world. A...</div></div></div>",
        "id": 543404799,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1759783336
    },
    {
        "content": "<p>FWIW, \"GC object initializers including cycles\" seems like a reasonable topic to bring up at the CG -- for parity with linear memories, the ability to set up the Wasm module state to any state reachable at runtime seems like a clearly missing capability...</p>",
        "id": 543405197,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1759783525
    },
    {
        "content": "<p>(I realize \"let's standardize it!\" is not at all the shortest path here but just adding my voice in favor of that route)</p>",
        "id": 543405239,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1759783548
    },
    {
        "content": "<p>(also, in my infinite free cycles, I'd be interested in helping to explore what that would look like; maybe something like rec-groups for types? each \"GC data segment\" is a letrec?)</p>",
        "id": 543405362,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1759783618
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/channel/217126-wasmtime/topic/Moving.20wizer.2Fcomponent-init.20into.20Wasmtime/near/543112345\">said</a>:</p>\n<blockquote>\n<p>A way around this would be to write out a sequence of initialization code that rebuilds the object graph, of course; either all objects for simplicity, or only \"tying the knot\" on the residual cycles/forward refs if we analyze for that. Then prepend this code to the start function (or add one).</p>\n</blockquote>\n<p>This seems like the most pragmatic, runtime-agnostic option to me (at least until there's a standard, declarative way to do it).  <code>component-init</code> already removes any and all start functions as part of its job; adding a new one just for building (or adding cycles to) an object graph seems reasonable.</p>",
        "id": 543405705,
        "sender_full_name": "Joel Dice",
        "timestamp": 1759783803
    },
    {
        "content": "<p>Standards-wise we're also likely going to want to figure out a way to plumb reference types through the component model WIT boundary, or perhaps make all this wasmtime-internal, but somehow dealing with reference types and components</p>",
        "id": 543410120,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1759785671
    },
    {
        "content": "<p>I agree that having good standards support for this is very important, yes. In the meantime, in addition to the options laid out above, an option could be to make snapshotting emit cwasm files, not wasm, and do whatever works best inside Wasmtime—i.e., snapshot the GC heap as effectively a linear memory</p>",
        "id": 543502230,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1759835265
    },
    {
        "content": "<p>we can't literally snapshot the GC heap's linear memory because it contains <code>VMSharedTypeIndex</code>s, which will change in different <code>Engine</code>s at runtime (depending on the order that modules are loaded/unloaded and all that)</p>\n<p>we <em>could</em> try to factor those out to a side table somehow, and use module type indices instead, but then casts and subtyping and everything would get slower, especially when linking modules that use the same GC types together</p>",
        "id": 543589852,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1759858945
    },
    {
        "content": "<p>ah, that makes sense. And building a patch table wouldn't work?</p>",
        "id": 543593768,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1759860278
    },
    {
        "content": "<p>(and also instance IDs in exception objects' headers, because of the generativity)</p>",
        "id": 543594942,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1759860699
    },
    {
        "content": "<p>That said, it does seem desirable to make the GC heap image a pure function of the Wasm execution only, just for the CoW startup advantages, especially in a future where many more languages use GC...</p>",
        "id": 543595337,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1759860831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"234973\">Till Schneidereit</span> <a href=\"#narrow/channel/217126-wasmtime/topic/Moving.20wizer.2Fcomponent-init.20into.20Wasmtime/near/543593768\">said</a>:</p>\n<blockquote>\n<p>ah, that makes sense. And building a patch table wouldn't work?</p>\n</blockquote>\n<p>we could always do that, but every single object's header would need patching, so I doubt we would actually gain much in practice (it would be rare that a page wouldn't get patched, forcing a copy)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/channel/217126-wasmtime/topic/Moving.20wizer.2Fcomponent-init.20into.20Wasmtime/near/543594942\">said</a>:</p>\n<blockquote>\n<p>(and also instance IDs in exception objects' headers, because of the generativity)</p>\n</blockquote>\n<p>ah yes, good point. not used to thinking about exceptions yet!</p>\n<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/channel/217126-wasmtime/topic/Moving.20wizer.2Fcomponent-init.20into.20Wasmtime/near/543595337\">said</a>:</p>\n<blockquote>\n<p>That said, it does seem desirable to make the GC heap image a pure function of the Wasm execution only, just for the CoW startup advantages, especially in a future where many more languages use GC...</p>\n</blockquote>\n<p>yeah if we can figure out how to keep <code>ref.{test,cast}</code> and <code>br_on_cast[_fail]</code> fast, that would be fantastic.</p>\n<p>I guess the common case is same-module stuff, so maybe we could replace the <code>VMSharedTypeIndex</code> in the object header with <code>(ModuleId, ModuleInternedTypeIndex)</code> packed as a <code>u64</code> and the fast path goes from a pair of <code>u32</code> loads and a comparison to a pair of <code>u64</code> loads and a comparison and it doesn't handle cross-module compares anymore. then we have a series of side tables that jit code can access to go from <code>(ModuleId, ModuleInternedTypeIndex)</code> to <code>VMSharedTypeIndex</code> at runime or something. So with this scheme, every GC object gets a little bigger, our fast path is a tiny bit slower in theory (maybe not actually in practice?) and handles slightly fewer cases. but we gain snapshot-ability. seems not too bad</p>",
        "id": 543607753,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1759865644
    },
    {
        "content": "<p>first step is here: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11805\">https://github.com/bytecodealliance/wasmtime/pull/11805</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/11805\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/73909d739f0e801fea81f70f5973946083c48e9e/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f343762633634303534646463623764313533383335393762363962363964656563663037663661613463666237383838623063623231383862366231363563312f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3131383035&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/11805\" title=\"Merge the wizer repository into this repository by alexcrichton · Pull Request #11805 · bytecodealliance/wasmtime\">Merge the wizer repository into this repository by alexcrichton · Pull Request #11805 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">This PR is the first step in what will be a few to merge the wizer and component-init repositories into this main repository. The goal is to consolidate these features here in Wasmtime and provide ...</div></div></div>",
        "id": 543630471,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1759875520
    },
    {
        "content": "<blockquote>\n<p><code>(ModuleId, ModuleInternedTypeIndex)</code> packed as a <code>u64</code></p>\n</blockquote>\n<p>Do we need that much index space for both of these? As in, could we get by with using 16 bit for each, or something a bit more annoying like 14 or 12 for module IDs and the rest for type indices?</p>\n<p>Details aside, this makes sense to me</p>",
        "id": 543719794,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1759922023
    },
    {
        "content": "<p>probably we could? but also the existing system assumes 32 bits and it might be annoying to track down all the places we make those assumptions. but maybe not, worth trying</p>",
        "id": 543783896,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1759939060
    },
    {
        "content": "<p>Ok Wizer is now merged by merging two unrelated histories, and a subsequent PR has landed showing repo CI is still green.</p>\n<p>If any issues crop up feel free to ping my. Fingers crossed my assertion that bisection/blame all works well will bear true in the limit of time...</p>",
        "id": 544051885,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1760046341
    },
    {
        "content": "<p>Thanks Alex!</p>",
        "id": 544057173,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760049623
    },
    {
        "content": "<p><a href=\"https://github.com/bytecodealliance/wasmtime/pull/11878\">https://github.com/bytecodealliance/wasmtime/pull/11878</a> is the next major step for component-init</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/11878\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/5f2bc8875cbd0d33c67a291bdda2b4bec23f8dde/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633063653635323866653564653534393731366639343763666536373339346666373163316534373733316664333837626439333363616134313266323662382f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3131383738&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/11878\" title=\"Merge component-init into wasmtime-wizer by alexcrichton · Pull Request #11878 · bytecodealliance/wasmtime\">Merge component-init into wasmtime-wizer by alexcrichton · Pull Request #11878 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">This commit is the next phase of merging the wizer and component-init repositories into Wasmtime. This does not take the same approach as merging wizer where the git histories were merged, but inst...</div></div></div>",
        "id": 545459076,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1760657666
    },
    {
        "content": "<p>Ok this is now more-or-less done. Wizer's README is <a href=\"https://github.com/bytecodealliance/wizer\">updated</a> to point to wasmtime and the source code of wizer itself now uses wasmtime (git dep for now). I've got a PR for <a href=\"https://github.com/dicej/component-init/pull/17\">component-init too</a>.</p>\n<p>I think that wasmtime-wizer is at feature parity with both component-init and wizer, so anything remaining is a bug I'm not aware of</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wizer\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/96a051f595199b7fa0feefbd5874bec0713552d1/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f373764633933313938363935363462373833386166353434306538323661376162323637323831656366663564326466383565346231633936353538366461662f62797465636f6465616c6c69616e63652f77697a6572&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wizer\" title=\"GitHub - bytecodealliance/wizer: The WebAssembly Pre-Initializer\">GitHub - bytecodealliance/wizer: The WebAssembly Pre-Initializer</a></div><div class=\"message_embed_description\">The WebAssembly Pre-Initializer. Contribute to bytecodealliance/wizer development by creating an account on GitHub.</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/dicej/component-init/pull/17\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/bd6cad1695ed0f5dd611f489368e1ca6a6d372f6/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633264376135336339613232663964393763393033353830646337663230393066623464636461363762373234323232393064656635613763656239616165372f646963656a2f636f6d706f6e656e742d696e69742f70756c6c2f3137&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/dicej/component-init/pull/17\" title=\"Add a disclaimer about `wasmtime wizer` by alexcrichton · Pull Request #17 · dicej/component-init\">Add a disclaimer about `wasmtime wizer` by alexcrichton · Pull Request #17 · dicej/component-init</a></div><div class=\"message_embed_description\">Now that the work has merged upstream I figured it'd be good to try to start redirecting users to Wasmtime now.</div></div></div>",
        "id": 546338290,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761086440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253994\">Alex Crichton</span> <a href=\"#narrow/channel/217126-wasmtime/topic/Moving.20wizer.2Fcomponent-init.20into.20Wasmtime/near/546338290\">said</a>:</p>\n<blockquote>\n<p>I think that wasmtime-wizer is at feature parity with both component-init and wizer</p>\n</blockquote>\n<p>Does that include the module index mapping hack we talked about which <code>componentize-py</code> uses, or are we hoping to make that obsolete by way of improved component support in <code>wasmtime-py</code>?</p>",
        "id": 546338502,
        "sender_full_name": "Joel Dice",
        "timestamp": 1761086586
    },
    {
        "content": "<p>I'm hoping that no one ever learns about that but you and me so I can continue to lie and say there's feature parity</p>",
        "id": 546338742,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761086768
    },
    {
        "content": "<p>well, I was hoping that, not any more lol</p>",
        "id": 546338750,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761086774
    },
    {
        "content": "<p>but yeah I'm hoping to obsolete it</p>",
        "id": 546338762,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761086787
    },
    {
        "content": "<p>what about the guest crate for component-init?</p>",
        "id": 546339825,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761087592
    },
    {
        "content": "<p>it should be renamed from component-init to wizer probably?</p>",
        "id": 546339881,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761087617
    },
    {
        "content": "<p>that's true, the guest side of tooling isn't fleshed out yet</p>",
        "id": 546340101,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761087735
    },
    {
        "content": "<p>the init function was also renamed to <code>wizer-initialize</code> to avoid ambiguity</p>",
        "id": 546340120,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761087747
    },
    {
        "content": "<p>yeah, thats a good name</p>",
        "id": 546340139,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761087761
    },
    {
        "content": "<p>also to be the same as core wasm which is also now <code>wizer-initialize</code> (to be the same as components)</p>",
        "id": 546340142,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761087763
    },
    {
        "content": "<p>related: if we want to have library code which can take advantage of wizer, can we allow it to be <code>wizer-initialize-*</code>?</p>",
        "id": 546340195,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761087807
    },
    {
        "content": "<p>naively I'd expect that to be a C++-like ctor/initializer ideally</p>",
        "id": 546340239,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761087840
    },
    {
        "content": "<p><code>wizer-init</code>? <code>initialize</code> sure is a lot of syllables... <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 546340260,
        "sender_full_name": "Lann Martin",
        "timestamp": 1761087854
    },
    {
        "content": "<p>what do you mean c++-like ctor/initializer</p>",
        "id": 546340307,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761087877
    },
    {
        "content": "<p>e.g. <code>_initialize</code> basically</p>",
        "id": 546340369,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761087902
    },
    {
        "content": "<p>the old wasip1 convention which wasm-tools component new recognizes</p>",
        "id": 546340389,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761087912
    },
    {
        "content": "<p>i dont think i follow</p>",
        "id": 546340439,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761087947
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"480579\">Lann Martin</span> <a href=\"#narrow/channel/217126-wasmtime/topic/Moving.20wizer.2Fcomponent-init.20into.20Wasmtime/near/546340260\">said</a>:</p>\n<blockquote>\n<p><code>wizer-init</code>? <code>initialize</code> sure is a lot of syllables... <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>\n</blockquote>\n<p>You can change the default when invoking <code>wasmtime wizer</code>, fwiw</p>",
        "id": 546340504,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1761087988
    },
    {
        "content": "<p>sry heading out to dinner now, I'll respond more later though</p>",
        "id": 546340663,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761088058
    },
    {
        "content": "<p>Ok to expand on <code>_initialize</code> more -- for C++ for example when compiled with <code>-mexec-model=reactor</code> all C++ intializers (e.g. constructors for statics) are executed from <code>_initialize</code> and the linker is responsible for synthesizing <code>__wasm_call_ctors</code> which lists all functions from all libraries. That is then executed during <code>wizer-initialize</code> since it's an export as <code>wasm-tools component new</code> recognizes <code>_initialize</code> and runs it. Effectively <code>__wasm_call_ctors</code> should be run during initialization and, IMO, is a better vector for library-based initialization.</p>",
        "id": 546476925,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761144202
    },
    {
        "content": "<p>fwiw I always just call __wasm_call_ctors() from wizer.initialize before doing anything else since it doesn't hurt to call it if there are no ctors</p>",
        "id": 546487980,
        "sender_full_name": "Ramon Klass",
        "timestamp": 1761146757
    },
    {
        "content": "<p>I didn’t know this worked. That’s super helpful</p>",
        "id": 546500011,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761149741
    },
    {
        "content": "<p>Is there enough exposed so that wasmtime wizer can run _initialize and nothing else if there’s no wizer-initialize export?</p>",
        "id": 546500444,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761149886
    },
    {
        "content": "<p>For core wasm there's support for specifying the initialization function as <code>_initialize</code>, but for components there's no support just yet for \"just instantiate this component, don't actually invoke anything\"</p>",
        "id": 546504743,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761151184
    },
    {
        "content": "<p>right but is there anything that stops us from doing that besides adding the right logic to <code>wasmtime wizer</code> itself?</p>",
        "id": 546506226,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761151707
    },
    {
        "content": "<p>basically what im looking for is that, if im producing components and intend to wizer them, i can stop using the <code>#[component-init]</code> proc macro and just use <code>#[ctor]</code> instead, and not lose anything by doing so</p>",
        "id": 546506284,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761151726
    },
    {
        "content": "<p>yeah it would be pretty easy to configure wizer to just instantiate and do nothing else</p>",
        "id": 546506834,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761151921
    },
    {
        "content": "<p>now I'll also caution that iunno if <code>#[ctor]</code> supports wasm just yet</p>",
        "id": 546506874,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761151934
    },
    {
        "content": "<p>I forget if rustc exposes enough things to plumb through to LLVM to support that</p>",
        "id": 546506911,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761151945
    },
    {
        "content": "<p>it claims to</p>",
        "id": 546507140,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761152034
    },
    {
        "content": "<p>oh nice</p>",
        "id": 546509949,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761152984
    }
]