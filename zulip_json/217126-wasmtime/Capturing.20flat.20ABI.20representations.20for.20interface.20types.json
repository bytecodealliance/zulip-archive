[
    {
        "content": "<p>I think this might be something that's more appropriate to calculate on-the-fly rather than to retain in memory -- I suspect it'd be relatively heavyweight to keep in memory while returning an <code>impl Iterator</code> or similar may not be too hard</p>",
        "id": 543331046,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1759760868
    },
    {
        "content": "<p>That's true, It could be heavyweight for large records, but there's a tradeoff there for RR to minimize performance overheads. Fully reconstructing the flat ABI for types may be expensive, and they are already being parsed once at the very beginning. </p>\n<p>Maybe the right approach then is to compute and cache the splits on-the-fly. The overarching issue though is that the flat ABI isn't really formalized anywhere besides the actual lowering implementation. There needs to be a way to keep this computation consistent with any changes made to the lowering implementations. Would we just make a comment there?</p>",
        "id": 543452984,
        "sender_full_name": "Arjun Ramesh",
        "timestamp": 1759818789
    },
    {
        "content": "<p>Oh I wouldn't worry much about the cost here, the flat representation is &lt;= 16 types and walking a type tree to produce 16 things should always be quite fast. I would imagine that there's some sort of helper method internally which can be called between the various locations so we'd only implement that once and share it amongst the various callers</p>",
        "id": 543545931,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1759847059
    }
]