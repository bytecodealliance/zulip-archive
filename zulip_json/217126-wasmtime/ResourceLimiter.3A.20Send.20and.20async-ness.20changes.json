[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"634398\">Graydon Hoare</span> has marked this topic as unresolved.</p>",
        "id": 541370144,
        "sender_full_name": "Notification Bot",
        "timestamp": 1758776766
    },
    {
        "content": "<p>no wait, that .. is no good. my access to my ResourceLimiter is through a RefCell and I can't _return_ an &amp;mut T out of the accessor function registered on the store, because the RefCell::RefMut needs to release the borrow when we're done with it but we never get control back.</p>",
        "id": 541370231,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1758776815
    },
    {
        "content": "<p>it would be ok if the interface for working with ResourceLimiter wasn't a function on store but instead a callback from store to a closure that took a temporarily-borrowed ResourceLimiter and then returned to store so it could release a dynamic borrow..</p>",
        "id": 541370510,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1758776999
    },
    {
        "content": "<p>I guess my other option is, ugh, put the whole thing in a mutex? we hit this budget object quite often, it's already kinda terrible that it's a refcell.</p>",
        "id": 541371021,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1758777355
    },
    {
        "content": "<p>and .. that's also not possible, because the interface wants me to return &amp;mut dyn ResourceLimiter and again, the budget object itself even if we can make _it_ an Arc&lt;Mutex&lt;...&gt;&gt; is contained as a field inside a Host that is itself an Rc&lt;&gt; and we _definitely_ can't make that either Send or singly owned as we'd need if we wanted to project-out one of its fields to get a singly owned &amp;mut dyn ResourceLimiter out of it.</p>",
        "id": 541373034,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1758778919
    },
    {
        "content": "<p>I actually .. cannot think of anything we can do to make resource limiting work here, inefficiently or otherwise, with this interface as it is. it's got to either lose the Send bound, or turn into a callback interface that regains control so it can release a dynamic borrow (which I suspect will actually break the Send-ness in other ways? I'm not sure)</p>",
        "id": 541373250,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1758779067
    },
    {
        "content": "<p>basically the issue is that our T in Store&lt;T&gt; is not uniquely owned, nor is the budget object inside of it. and it'd involve tearing the thing apart to change that.</p>",
        "id": 541374325,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1758779793
    },
    {
        "content": "<p>Ah yeah unfortunately non-<code>Send</code> embeddings basically just aren't well supported in Wasmtime today. We haven't figure out a great way to support it (but you're not the only one that would like us to support it!)</p>\n<p>You're right though that it's entirely related to async, and it's related to being able to migrate a computation (future) between threads (e.g. this is a requirement to spawn a tokio future). </p>\n<p>The only 2 solutions we know of are (1) we duplicate much of the API with Send/non-Send APIs and (2) embedders unsafely impl <code>Send</code> as you've outlined here. Unfortunately neither is really great and as such that's where I feel like we haven't ever figured out a great solution for this</p>",
        "id": 541471200,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1758810046
    },
    {
        "content": "<p>would you be at all amenable to the idea of changing the interface store uses (the function passed to <code>Store::limiter</code>) used to extract a <code>&amp;mut dyn ResourceLimiter</code>? if it was possible for that to extract the &amp;mut at the site of use via callback -- by passing a closure to the extractor-helper and having it call the callback with the &amp;mut, then resume control -- then it could be combined with a dynamic borrow.</p>",
        "id": 541506742,
        "sender_full_name": "Graydon Hoare",
        "timestamp": 1758819800
    },
    {
        "content": "<p>I'm not quite sure I follow necessarily but for me if it works it works so would be happy to change. Id caution though that the traits and interfaces here are in a fine balance right now to keep async functions producing send futures, so I suspect that changing this may be nontrivial (but am happy to be proven wrong)</p>",
        "id": 541534699,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1758829971
    }
]