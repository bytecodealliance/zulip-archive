[
    {
        "content": "<p>Hey everyone, in short, I'm working on inline Wasm module instrumentation, which is relying on a single global \"fuel\" counter.</p>\n<p>The module is parsed ahead-of-time and the global is injected along with an export of it under a well-known name.<br>\nThis approach works great for almost all use cases, except one: a trap in module's <code>start</code> function.</p>\n<p>Using the existing Wasmtime API, the runtime can set up a call hook to observe the global value, however to do that the <code>Global</code> has to be either closed over or passed through the <code>Store</code> state.</p>\n<p>The challenge is that the <code>Global</code> can only be accessed either <em>after instantiation</em>, by looking it up from the <code>Instance</code> or, if the module invokes a host function, the host could access the global via the <code>Caller::get_module_export</code>, even during instantiation.</p>\n<p>The challenge is the case when the module traps in <code>start</code> function - it appears that existing API is insufficient to observe the value of the global in that case.</p>\n<p>It seems that one fairly non-intrusive way of making this work could be exposing the <code>Caller</code> (or just <code>Instance</code>/similar construct) in a new <em>module instantiation</em> hook API. E.g. <code>Linker::instantiate_with_hook(store, module, |caller| {})</code>. The hook would be called <em>before</em> invoking <code>start</code>.</p>\n<p>What do you all think?<br>\nAre there any other ways to solve this issue I have not thought about?</p>\n<p>I'd be happy to work on this feature</p>",
        "id": 539799397,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1758036328
    },
    {
        "content": "<p>Another possible implementation would be to move the <code>start</code> function to a well-known name which is invoked manually by the embedder as well, which if you're already mutating the module may not be too too difficult to do. Would that be reasonable to integrate?</p>",
        "id": 539881774,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1758051787
    },
    {
        "content": "<p>The current API design is intended to somewhat closely follow the web which also doesn't provide access to anything if the <code>start</code> function traps, but it's not like we can't add an API like the one you've described I mostly just think it'd be nice to avoid if we could</p>",
        "id": 539881930,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1758051837
    },
    {
        "content": "<p>Interesting, I haven't thought of that - I guess the runtime should just be careful about always running the custom <code>start</code> before accessing any exports this way.</p>\n<p>The current workaround I went with is injecting an <code>init</code> import call in the <code>start</code>, where the <code>init</code> in thr host looks up the global via <code>Caller</code> and keeps it in the <code>Store</code> for the call hook to keep in-sync. Just wanted to call out this gap to see if there's interest in adding something like this.</p>\n<p>A custom start would probably be both faster and simpler though. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Thanks for the feedback, I will double-check with the spec on the potential side-effects of doing this, but it sounds like a great idea!</p>",
        "id": 539885516,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1758053297
    },
    {
        "content": "<p>start section should have never been in wasm and if there was a way to turn it off without \"breaking the web\" i think a supermajority of the cg would</p>",
        "id": 539893018,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1758056477
    },
    {
        "content": "<p>so doing anything possible to avoid using it is the way to go imo</p>",
        "id": 539893061,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1758056492
    }
]