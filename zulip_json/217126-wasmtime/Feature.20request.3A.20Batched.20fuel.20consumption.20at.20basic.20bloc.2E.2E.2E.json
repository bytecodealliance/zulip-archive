[
    {
        "content": "<p>unsure! I'd recommend reading <code>func_environ.rs</code> in wasmtime to get a better idea for how fuel is translated</p>",
        "id": 560956632,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1764462870
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> Thank you so much! You were right!</p>",
        "id": 560957384,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764463721
    },
    {
        "content": "<p>I had another feature suggestion though. Why not track the fuel inside of the wasm binary itself as a global variable? It would be faster than doing host calls every then and now which will be usually slower (right?).</p>\n<p>I saw I think wasmer doing this optimization.</p>",
        "id": 560957595,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764463957
    },
    {
        "content": "<p>Sent you an email as well. <span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span></p>",
        "id": 560958566,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764465164
    },
    {
        "content": "<p>if it's tracked inside the guest, then that means the guest can freely modify it, making it unreliable, no?</p>",
        "id": 561156319,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1764595072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"234973\">Till Schneidereit</span> <a href=\"#narrow/channel/217126-wasmtime/topic/Feature.20request.3A.20Batched.20fuel.20consumption.20at.20basic.20bloc.2E.2E.2E/near/561156319\">said</a>:</p>\n<blockquote>\n<p>if it's tracked inside the guest, then that means the guest can freely modify it, making it unreliable, no?</p>\n</blockquote>\n<p>I think finding a non-colliding memory region that the program does not touch would work. Maybe a local variable somewhere.</p>\n<p>Is there a way a program can walk through all of its local variables without knowing the name of the variable or not? If not then this should be fine.</p>",
        "id": 561205489,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764605419
    },
    {
        "content": "<p>what do you mean by \"a local variable\"? Apart from the stack, everything inside the guest can be fully inspected by the guest. The wasm specification establishes a sandbox where everything inside of it is meant to be accessible by the guest, and absolutely shouldn't be treated as trustworthy</p>",
        "id": 561215913,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1764607450
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"1001975\">@Aarav Dayal</span> what do you mean by</p>\n<blockquote>\n<p>It would be faster than doing host calls every then and now which will be usually slower (right?).</p>\n</blockquote>\n<p>I am not sure if you are imagining that Wasmtime's fuel metering does hostcalls to increment fuel, but it actually doesn't: fuel is a field in a VM-internal data structure that is directly accessed by the compiled code. We do a hostcall only when fuel runs out.</p>",
        "id": 561224910,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1764609207
    },
    {
        "content": "<p><strong>(I realised after reading Chris's message that my suggestion is not needed, please feel free to ignore this message)</strong></p>\n<p>Okay so from what I asked ChatGPT and understood from it atleast is that a wasm program will not compile if it tries to access a global variable that does not exist.</p>\n<p>For example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"n\">module</span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">global</span><span class=\"w\"> </span><span class=\"cp\">$counter</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">.</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">))</span>\n\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"cp\">$getCounter</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">global</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"cp\">$counter</span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"p\">)</span>\n\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">export</span><span class=\"w\"> </span><span class=\"s\">\"getCounter\"</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"cp\">$getCounter</span><span class=\"p\">))</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n<p>Now if I run a static analyzer and find a non colliding name / index for the global variable and use that as the fuel counter variable for a smart contract VM then it should be safe right?</p>\n<p>This is with the assumption that the WAT / WASM does not import anything that the compiling host is not aware of. This is kind of the idea of a smart contract blockchain VM (it knows what is strictly available to the tenant).</p>",
        "id": 561226883,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764609637
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/channel/217126-wasmtime/topic/Feature.20request.3A.20Batched.20fuel.20consumption.20at.20basic.20bloc.2E.2E.2E/near/561224910\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"1001975\">Aarav Dayal</span> what do you mean by</p>\n<blockquote>\n<p>It would be faster than doing host calls every then and now which will be usually slower (right?).</p>\n</blockquote>\n<p>I am not sure if you are imagining that Wasmtime's fuel metering does hostcalls to increment fuel, but it actually doesn't: fuel is a field in a VM-internal data structure that is directly accessed by the compiled code. We do a hostcall only when fuel runs out.</p>\n</blockquote>\n<p>Oh yeah I literally looked at this yesterday! You are right sorry.</p>\n<p>But can we make it faster by reserving a register for fuel metering instead? Would it actually worsen the performance of certain workloads as that workload could've benefitted more from an additional register or is the tradeoff just right enough?</p>\n<p>Credits to -&gt; <a href=\"https://github.com/bytecodealliance/wasmtime/issues/4109\">https://github.com/bytecodealliance/wasmtime/issues/4109</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/issues/4109\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/cafe31524600a11a028d749901ad4ebd5d04248c/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f343032636232303766356238383363643363613330363431313533373637663637353436363132653239303433373330626439323565613966333664663933342f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f34313039&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/issues/4109\" title=\"Slacked fuel metering 路 Issue #4109 路 bytecodealliance/wasmtime\">Slacked fuel metering 路 Issue #4109 路 bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">wasmtime right now has the fuel mechanism. It allows precise control of how many instructions are executed before suspending execution, at least at a basic block granularity. The price is a rather ...</div></div></div>",
        "id": 561227157,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764609696
    },
    {
        "content": "<blockquote>\n<p>But can we make it faster by reserving a register for fuel metering instead?</p>\n</blockquote>\n<p>The fuel variable is already register-allocated along with every other local value in the IR that we compile.</p>\n<p>You're getting to the point of detailed suggestions that it would be a good idea for you to actually study the implementation in detail, look at the compiled machine code, and come to us with concrete suggestions based on what you see. I'd recommend not resorting to ChatGPT to fill you in on details here: our experience is that folks using LLMs to understand Wasmtime either come to us with bafflingly wrong (or \"not even wrong\") understandings or just get very basic suggestions that have already been considered and rejected.</p>",
        "id": 561232924,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1764610903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/channel/217126-wasmtime/topic/Feature.20request.3A.20Batched.20fuel.20consumption.20at.20basic.20bloc.2E.2E.2E/near/561232924\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>But can we make it faster by reserving a register for fuel metering instead?</p>\n</blockquote>\n<p>The fuel variable is already register-allocated along with every other local value in the IR that we compile.</p>\n<p>You're getting to the point of detailed suggestions that it would be a good idea for you to actually study the implementation in detail, look at the compiled machine code, and come to us with concrete suggestions based on what you see. I'd recommend not resorting to ChatGPT to fill you in on details here: our experience is that folks using LLMs to understand Wasmtime either come to us with bafflingly wrong (or \"not even wrong\") understandings or just get very basic suggestions that have already been considered and rejected.</p>\n</blockquote>\n<p>I am sorry for not providing helpful suggestions. I had to resort this time to ChatGPT as I am not a Rust developer.</p>\n<p>I will personally go ahead and watch videos and content to actually understand the underlying architecture.</p>\n<p>As of now I am committing to wasmtime as my underlying VM runtime as it seems to be the best choice for my tradeoff range.</p>\n<p>Will come back to you asap if I have any good suggestions.</p>\n<p>Sorry for wasting time of the contributors.</p>",
        "id": 561234371,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764611176
    },
    {
        "content": "<p>No need to apologize! Trying to guide you toward productive paths if you want to contribute but there's nothing wrong with starting at a basic level. Best of luck</p>",
        "id": 561236648,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1764611618
    },
    {
        "content": "<p>Thank you so much Chris.</p>",
        "id": 561237719,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764611815
    }
]