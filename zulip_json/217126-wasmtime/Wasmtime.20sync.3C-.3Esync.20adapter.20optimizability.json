[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254389\">@Chris Fallin</span> <span class=\"user-mention\" data-user-id=\"253990\">@fitzgen (he/him)</span> question for y'all. Components historically have had a <code>may_{enter,leave}</code> flag associated with them which is a spec-level definition about reentrance protection and things like that. In the course of the component-model-async work this has changed, notably <code>may_enter</code>, which is no longer a flag but rather morally a stack that's passed around. In the course of component-model-async development work <span class=\"user-mention\" data-user-id=\"509936\">@Joel Dice</span> has run across a situation where the old <code>may_enter</code> handling is now broken and needs to be updated.</p>\n<p>The easiest way to update things is to invoke a function that, on the host, that Joel already has for component-model-async work. This is basically already host host&lt;-&gt;guest calls work (or so I'm led to believe, Joel correct me if I'm wrong). The stickler here is guest&lt;-&gt;guest calls. Currently that manipulation/inspection of <code>may_{enter,leave}</code> is baked directly in the adapter between components. The flags are wasm globals defined in the <code>VMComponentInstance</code>.</p>\n<p>This all brings me to the question for y'all: the easiest way to return to spec compliance is to update adapters to call a host function. I expect that this is unacceptable perf-wise for use caes y'all have envisioned for compile-time builtins. Are y'all in a position where you can't take a regression in compile-time-builtin runtime performance w.r.t. inlining and such? Or is there runway to land a host call for now and optimize later as necessary?</p>",
        "id": 563170820,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1765454952
    },
    {
        "content": "<p>The change in question that this is coming up on is <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12153\">https://github.com/bytecodealliance/wasmtime/pull/12153</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/12153\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/786f9b6b41af595081c0f15804e2cd9fae352b6d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f356532643263356332653032663232613331383630616335666531623533646233363031316537376436313732646437663732666237346138633932323539322f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3132313533&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12153\" title=\"allow instance to be reentered while yielding by dicej · Pull Request #12153 · bytecodealliance/wasmtime\">allow instance to be reentered while yielding by dicej · Pull Request #12153 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">The spec says we should allow this, so now we do.\nThansk to Alex for the test case!\nFixes #12128</div></div></div>",
        "id": 563171208,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1765455110
    },
    {
        "content": "<p>Hmm, thanks for the heads-up. Question: will this affect async-ABI components or \"p2 style\" (sync ABI) components as well?</p>\n<p>It would be pretty unfortunate for our inlined \"get a byte\" accessor in a linked-in component to make a hostcall on every loop iteration in which it's called, to the extent that it would destroy our zero-copy story, so it would be nice if there were a path to not doing this. (FWIW I suspect once we have this zero-copy story working it'll be of interest to a lot of other embedded and network-stack folks as well.) Is there such a path or is it expected that this is the forever-solution?</p>",
        "id": 563247689,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1765474495
    },
    {
        "content": "<p>Is there a reason that continuing to use globals is difficult? As Chris said, this would be pretty damning to the compile-time builtins story. Even the global is a lot more overhead than we want</p>",
        "id": 563248723,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1765474793
    },
    {
        "content": "<p>This would affect all component&lt;-&gt;component interactions, including sync&lt;-&gt;sync functions, which is what wasip2 today exclusively uses.</p>\n<p>To clarify, optimizations are possible here. It requires more compliation infrastructure, more analyses, more runtime data structures, etc. It is inevitable to me that this'll get implemented.</p>\n<p>What I'm mostly curious on is whether these optimizations are a hard requirement today for anything to land</p>",
        "id": 563251295,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1765475592
    },
    {
        "content": "<p>(Note that Alex is out on PTO for a week, so probably won't respond soon.  I'll try to answer as best I can.) EDIT: nevermind :)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"254389\">Chris Fallin</span> <a href=\"#narrow/channel/217126-wasmtime/topic/Wasmtime.20sync.3C-.3Esync.20adapter.20optimizability/near/563247689\">said</a>:</p>\n<blockquote>\n<p>Question: will this affect async-ABI components or \"p2 style\" (sync ABI) components as well?</p>\n</blockquote>\n<p>It depends on how much up-front optimization we do.  If no optimization, then yes, sync ABI components will be affected.  One perhaps not-too-difficult optimization would be to detect that the component has only sync imports and exports at load time, carry that info through to the FACT module generator, and fall back to the existing check-and-set-a-flag behavior.  There are also other optimizations available.</p>",
        "id": 563251360,
        "sender_full_name": "Joel Dice",
        "timestamp": 1765475612
    },
    {
        "content": "<p>If you search for <code>trap_if_on_the_stack</code> in <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md\">https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md</a> and scroll down to the prose about optimization, you can see some of the options.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f79c03bf441e3af0c298d37e150837c3c9ab7519/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f623231383935333730656138646465393337643333333335323732616461613839396261303961396238626532643139366333663939623634626133346433662f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md\" title=\"component-model/design/mvp/CanonicalABI.md at main · WebAssembly/component-model\">component-model/design/mvp/CanonicalABI.md at main · WebAssembly/component-model</a></div><div class=\"message_embed_description\">Repository for design and specification of the Component Model - WebAssembly/component-model</div></div></div>",
        "id": 563251782,
        "sender_full_name": "Joel Dice",
        "timestamp": 1765475739
    },
    {
        "content": "<p>I think if that single optimization were implemented (avoid all this if everything is sync) at least I would be happy for now (it would maintain our status-quo). We'd need to figure out how to avoid the hostcall when we eventually move to native async ABI but our embedding doesn't do that today.</p>\n<p>It still seems like a pretty big perf regression in general for \"tightly bound components\" (little accessor calls) and I'm sure y'all have done a lot of thinking on this already but I'm happy to brainstorm or help on optimizations to make this logic inlined if needed!</p>",
        "id": 563251799,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1765475744
    },
    {
        "content": "<p>Alex felt the all-sync-component optimization would be onerous when we chatted last night.  Alex, do you still feel that way?  It doesn't feel like a huge lift to me.</p>",
        "id": 563252038,
        "sender_full_name": "Joel Dice",
        "timestamp": 1765475813
    },
    {
        "content": "<p>FWIW, we now have at least one component-level analysis in-tree already with the <code>analyze_function_imports</code> stuff: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/99ef35d1477ce35754ac338f28bee542d1d42661/crates/environ/src/component/translate.rs#L550\">https://github.com/bytecodealliance/wasmtime/blob/99ef35d1477ce35754ac338f28bee542d1d42661/crates/environ/src/component/translate.rs#L550</a></p>",
        "id": 563252839,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1765476056
    },
    {
        "content": "<p>I am not aware personally of anyone currently today relying on the absolute fastest possible performance between two components. I realize there are plans that could manifest in such a dependency, but I am under the impression that those plans are for the future. I am hoping to decouple the optimization work and get it off the critical path.</p>\n<p>I would primarily want to make sure that the optimization work doesn't have accidental holes in it, so I'd want to be able to spend a nontrivial chunk of time thinking/reviewing/planning/etc, and that is something that I would prefer to not have on the critical path</p>",
        "id": 563252890,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1765476071
    },
    {
        "content": "<p>I'm not sure this is the kind of \"relying\" you mean, but we absolutely intend to have the fastest possible component&lt;--&gt;component performance, yes.</p>",
        "id": 563265597,
        "sender_full_name": "Ralph",
        "timestamp": 1765480582
    },
    {
        "content": "<p>HOWEVER, our time-to-market is likely so slow that this \"requirement\" doesn't have much impact. It might take 9-12 months before we could even offer something that takes advantage here -- I'm imagining that is sufficiently long that it isn't as directly relevant to you as it might have been.</p>",
        "id": 563265791,
        "sender_full_name": "Ralph",
        "timestamp": 1765480654
    },
    {
        "content": "<p>???</p>",
        "id": 563265794,
        "sender_full_name": "Ralph",
        "timestamp": 1765480657
    },
    {
        "content": "<p>Yes, we don't literally have a dependence on this today either, but it's the sort of thing that needs to be resolved sooner than later from our PoV; the zero-copy approach we've sketched (and that Nick has built the foundations of) is pretty essential to us getting buy-in in the places where we plan to use Wasmtime. I guess I just want to make sure that we're not taking such a regression lightly.</p>\n<p>I'm also curious -- we're not seeing the other side of the tradeoff here (or I haven't digested all the other threads that would give me that background, sorry) -- presumably this change is happening because of unforeseen corner cases? Or is it a spec change that has its own discussion and set of tradeoffs (such that we'd want to feed back this pain into that tradeoff decision)?</p>",
        "id": 563273315,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1765483238
    },
    {
        "content": "<p>Yes, this is the result of a spec change related to async tasks.  Given that there can be more than one concurrent task for an instance at a given time, guarding against recursive reentrance requires not just asking \"has this instance been entered\" but \"has this instance been entered for <em>this</em> task\".  So rather than just a single flag that's global to the instance, we at minimum need a per-task bitset with capacity for the number of instances in a composition.  Please see the <code>CanonticalAbi.md</code> discussion of <code>trap_if_on_the_stack</code> for a list of optimization opportunities.</p>\n<p>In short, we have some great options for optimizing this; it's just a question of how urgent those optimizations are vs. other priorities.</p>",
        "id": 563279882,
        "sender_full_name": "Joel Dice",
        "timestamp": 1765485918
    },
    {
        "content": "<p>My read on this Joel is that we should plan out and concretely know what optimizations we want to implement short-term, and while we can defer a literal PR we shouldn't defer planning such a PR</p>",
        "id": 563943257,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1765841370
    },
    {
        "content": "<p>so e.g. we can split PRs up but they need to be ~weeks at most apart</p>",
        "id": 563943314,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1765841399
    },
    {
        "content": "<p>Even just the unoptimized version has proven a bit more complicated than I had initially expected, given that we need to check for recursive reentrance during initialization, when dropping resources, and during calls to <code>[Typed]Func::call</code> -- all places we previously relied on a per-instance flag and did not maintain a task stack.  The good news is that once we have the unoptimized version passing all tests, optimization should be straightforward, especially with a fresh mental model of everything.</p>",
        "id": 563943812,
        "sender_full_name": "Joel Dice",
        "timestamp": 1765841750
    },
    {
        "content": "<p>Wrote up the current state of affairs <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12153#issuecomment-3683744163\">here</a>, tl;dr; current plan is to change the adapter but not in a way such that the current performance profile will change</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/12153#issuecomment-3683744163\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/ec6cd93e30a7c2d18cd35f7cbc17a6a467970eea/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f363335313761363139313165616538363037393062356665336531663138373465366539343766643965323532633838393330383436613762653565663932382f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3132313533&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12153#issuecomment-3683744163\" title=\"allow instance to be reentered while yielding by dicej · Pull Request #12153 · bytecodealliance/wasmtime\">allow instance to be reentered while yielding by dicej · Pull Request #12153 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">The spec says we should allow this, so now we do.\nThansk to Alex for the test case!\nFixes #12128</div></div></div>",
        "id": 565057175,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1766430475
    },
    {
        "content": "<p>Thanks, Alex.  I'm implementing all that now.</p>",
        "id": 565057397,
        "sender_full_name": "Joel Dice",
        "timestamp": 1766430611
    },
    {
        "content": "<p>A few of us have been discussing this on GitHub and elsewhere.  I'll try to summarize the latest thinking here, but note that there are still a lot of details to work out:</p>\n<ul>\n<li>The ultimate goal is to make sync-to-sync compositions as fast as practical, regardless of whether the callee uses async intrinsics or not.  We also want async-to-async, async-to-sync, and sync-to-async compositions to be as fast as practical, but the overheads for those cases tend to be shadowed by other performance constraints, so we have a bit more flexibility there.</li>\n<li>Component model concurrency adds a few new pieces of state which need to be updated when crossing a component boundary:<br>\n    - Which task-local storage to use<br>\n    - The current thread ID<br>\n    - The set of instances on the task's stack<br>\n    - Whether or not the task may block</li>\n<li>As much as practical, we'd like to avoid using host calls and minimize the amount of Cranelift code to run before and after invoking the callee.  We have a few ways we can do that:<br>\n    - Statically analyze the component, which could be as simple as noticing whether it uses any concurrency features at all, or else involve more in-depth data flow analysis.  The idea here is that a component should only pay for what it uses.<br>\n    - Avoid allocating a full <code>GuestTask</code> instance every time we enter a component instance and instead e.g. load and store state from/to stack slots allocated in Cranelift-generated adapter code.<br>\n    - Possibly tweak the CM spec to e.g. allocate thread IDs from a separate index space from other handles, which would make them cheaper to create and destroy.  Luke also has ideas about how to restrict which lift/lower compositions are allowed by the spec, which could make data flow analysis and fine-grained, per-task instance stacks unnecessary.</li>\n</ul>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12153\">My first effort</a> to apply a few of the above optimizations had mixed success, and the PR grew too big anyway.  I've since split out part of that into <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12282\">a more focused PR</a>.  I plan to follow that up with more PRs once we've determined the next steps.</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"928951\">@Sy Brand</span></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/12153\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/4c91549a529d7bf24f22038c7dc0daefe1f9ecfb/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f323331653931346332653466656637353266366235313631646538613237343062373931373235356366373031636335303237333862396433613533303266372f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3132313533&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12153\" title=\"allow instance to be reentered while yielding by dicej · Pull Request #12153 · bytecodealliance/wasmtime\">allow instance to be reentered while yielding by dicej · Pull Request #12153 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">The spec says we should allow this, so now we do.\nThansk to Alex for the test case!\nFixes #12128</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/12282\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/70c930ea5d743b0f4c2ac36e929c230301def76d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353361343964623965333765353032666130623063356539633065646135353635646334616138353462363030363431353532383933626665646265323162642f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3132323832&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12282\" title=\"add missing may-block checks for sync-to-sync guest-to-guest calls by dicej · Pull Request #12282 · bytecodealliance/wasmtime\">add missing may-block checks for sync-to-sync guest-to-guest calls by dicej · Pull Request #12282 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">Previously, we weren&#39;t updating or checking the may-block status of a task across sync-to-sync, guest-to-guest calls, meaning we were allowing blocking in cases we shouldn&#39;t have.\nThis fixe...</div></div></div>",
        "id": 567165352,
        "sender_full_name": "Joel Dice",
        "timestamp": 1767972032
    },
    {
        "content": "<p>More thinking on this -- <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12311\">https://github.com/bytecodealliance/wasmtime/issues/12311</a></p>\n<p>For reentrance Luke had an idea that means we can entirely eliminate all reentrance checks at runtime as it's a static property of a component as to whether reentrance is allowed. Given that the current state is:</p>\n<ul>\n<li>We'll remove <code>may_enter</code> due to the reentrancy idea.</li>\n<li>(lazy lowering) will remove <code>may_leave</code>, a current part of sync&lt;-&gt;sync adapters</li>\n<li>(wasip3) we'll eventually shift around where <code>may_block</code> will live (it'll be in <code>VMAsyncTask</code>)</li>\n<li>(wasip3) we'll eventually shift to using <code>VMAsyncTask</code> so the manipulation will be a push/pop of a linked ilst </li>\n<li>Eventually, with this push/pop, plus a few Cranelift optimizations I don't think will be too undue, we'll compile down to zero instructions on a sync&lt;-&gt;sync adapter</li>\n</ul>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/issues/12311\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/d4c566c8f3de79c59360ab4bce1ec6357192d55b/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f393230343735393236643462636662356339336236383434613038626138363964383931313464326138343161633563613334366632306337626636633663652f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f3132333131&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/issues/12311\" title=\"Optimize guest-to-guest sync-to-sync management of async task related infrastructure · Issue #12311 · bytecodealliance/wasmtime\">Optimize guest-to-guest sync-to-sync management of async task related infrastructure · Issue #12311 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">This is a meta/tracking issue about remaining work necessary to optimize the guest-to-guest sync-to-sync adapter generated by Wasmtime when component-model-async is enabled. Some more historical di...</div></div></div>",
        "id": 567268374,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1767995745
    },
    {
        "content": "<p>Another aspect of this to think about is allocating stacks and allocating/initializing TLS blocks</p>",
        "id": 567602549,
        "sender_full_name": "Sy Brand",
        "timestamp": 1768239792
    },
    {
        "content": "<p>(not in wasmtime, but a related issue)</p>",
        "id": 567602679,
        "sender_full_name": "Sy Brand",
        "timestamp": 1768239829
    },
    {
        "content": "<p>I'm currently looking into generating wrappers around exports that do so and trying to think through when those can be elided</p>",
        "id": 567602844,
        "sender_full_name": "Sy Brand",
        "timestamp": 1768239865
    },
    {
        "content": "<p>To the extent that's purely a toolchain thing I think that's ok, as that's up to the toolchain/options/language/etc to optimize that away</p>",
        "id": 567603368,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1768239996
    },
    {
        "content": "<p>E.g. I wouldn't be worried about that cost for rust source code, the main thing to optimize so far is handwritten <code>*.wat</code> which wouldn't have wasm to initialize tls blocks</p>",
        "id": 567603463,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1768240024
    }
]