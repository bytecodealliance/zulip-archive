[
    {
        "content": "<p>Is there a happy-path set of features that will allow wasmtime to target wasm32-unknown-unknown? I'm looking for a way to use the component model inside environments that do not support components. One thought was to compile wasmtime itself to wasm and run embedded until proper support arrives. Unfortunately many of wasmtime's dependencies do not support wasm32.</p>",
        "id": 504704521,
        "sender_full_name": "Scott Andrews",
        "timestamp": 1741647874
    },
    {
        "content": "<p>If you can run javascript you can use <a href=\"https://github.com/bytecodealliance/jco\">https://github.com/bytecodealliance/jco</a> which turns a component into core wasm modules + glue js code. If you want to compile wasmtime for wasm32-unknown-unknown you will have to use the Pulley interpreter for wasm execution (which is much slower than the regular jitting wasmtime does) and compile wasmtime with the <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/examples/min-platform\">min-platform configuration</a>.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/jco\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/896fff7444d9c522a2510e341712eb5c1704a82f/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f656430373164323035303466363066343234313438353234333664613036313233393562363664383535623761616364376136633037323331336531326233642f62797465636f6465616c6c69616e63652f6a636f&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/jco\" title=\"GitHub - bytecodealliance/jco: JavaScript toolchain for working with WebAssembly Components\">GitHub - bytecodealliance/jco: JavaScript toolchain for working with WebAssembly Components</a></div><div class=\"message_embed_description\">JavaScript toolchain for working with WebAssembly Components - bytecodealliance/jco</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/tree/main/examples/min-platform\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/aed9657fb6e16af75559e3d5e6abb28a5ec77c17/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f323466333965303064623664313630366133376166323833663738323863633265653938346132383536626532333962616536303866343361383562663438632f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/examples/min-platform\" title=\"wasmtime/examples/min-platform at main · bytecodealliance/wasmtime\">wasmtime/examples/min-platform at main · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>",
        "id": 504804888,
        "sender_full_name": "bjorn3",
        "timestamp": 1741690539
    },
    {
        "content": "<p>Thanks bjorn3. I think the path of least resistance will be to host the component over wrpc and use the go bindings natively.</p>",
        "id": 505120828,
        "sender_full_name": "Scott Andrews",
        "timestamp": 1741783259
    }
]