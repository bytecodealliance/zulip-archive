[
    {
        "content": "<p>Hi, I'm currently working on a benchmarking project for which I would like to compare the runtimes between AOT, JIT, and interpreted, using wasmtime (as well as wamr). Unfortunately I was not able to find the documentation on how to run my benchmarks AOT/JIT/interpreted specifically. </p>\n<p>How can I specify the code execution model?</p>",
        "id": 573250699,
        "sender_full_name": "pino",
        "timestamp": 1770806047
    },
    {
        "content": "<p>For AOT compilation: <a href=\"https://docs.wasmtime.dev/cli-options.html#compile\">https://docs.wasmtime.dev/cli-options.html#compile</a> ; tl;dr: you'll do a <code>wasmtime compile</code> then use <code>wasmtime run --allow-precompiled file.cwasm</code>.</p>\n<p>For interpreted mode (Pulley), <code>wasmtime compile --target pulley64</code> (if you're on a 64-bit host) then run. You may need to build with an extra feature to include Pulley if you're on a platform that has a full compiler backend.</p>\n<p>Note however that you aren't going to find much interesting comparing the default (\"JIT\") and AOT, because they run literally exactly the same compilation. \"JIT\" just compiles to an in-memory ELF image first. So you'll see startup time ~equal to the time that <code>wasmtime compile</code> takes, then runtime performance will be identical. We don't do e.g. per-function compilation, tiering, or JIT-based specialization at all.</p>",
        "id": 573320744,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1770824490
    }
]