[
    {
        "content": "<p>Hi, I am trying to build a system where components run in their own thread. Since <code>Store</code> is not thread safe, I can’t call into the component from outside the thread. I was reading the posts about <code>run_concurrent</code> and <code>call_concurrent</code> and they seem very promising for my use case. </p>\n<p>The design would be something like calling my component’s entry point with <code>call_concurrent</code> and then using a <code>select!</code> loop to receive messages from the host/other threads for my component to process. Reading the documentation for <code>StoreContextMut::run_concurrent</code> (<a href=\"https://docs.wasmtime.dev/api/wasmtime/struct.StoreContextMut.html#method.run_concurrent\">https://docs.wasmtime.dev/api/wasmtime/struct.StoreContextMut.html#method.run_concurrent</a>), though, it seems like this is actually not working in the current implementation of <code>wasmtime</code>. Is that correct?</p>\n<p>I was also wondering about cancellation safety of the future returned by <code>call_concurrent</code>. <code>tokio::select!</code> cancels remaining futures when one is ready. But that would drop the <code>Store</code> right? For example something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"p\">.</span><span class=\"n\">get_typed_func</span><span class=\"p\">(</span><span class=\"err\">…</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">entry_fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"p\">.</span><span class=\"n\">call_concurrent</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.);</span>\n<span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">tokio</span><span class=\"p\">::</span><span class=\"n\">select</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">entry_fut</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"c1\">// async block to avoid .await/cancel directly on entry_fut, does this work?</span>\n<span class=\"w\">    </span><span class=\"n\">cmd</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">command_queue</span><span class=\"p\">.</span><span class=\"n\">recv</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">…</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">msg</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">message_queue</span><span class=\"p\">.</span><span class=\"n\">recv</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">…</span><span class=\"p\">,</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Would the above result in the store getting dropped due to <code>entry_fut</code> being cancelled when one of the queues is ready?</p>\n<p>Is there a better way to go about this?</p>",
        "id": 563954567,
        "sender_full_name": "Jonathan H",
        "timestamp": 1765851212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"930440\">Jonathan H</span> <a href=\"#narrow/channel/217126-wasmtime/topic/.60StoreContextMut.3A.3Arun_concurrent.60.20and.20.60tokio.3A.3Aselect!.60/near/563954567\">said</a>:</p>\n<blockquote>\n<p>Reading the documentation for <code>StoreContextMut::run_concurrent</code> (<a href=\"https://docs.wasmtime.dev/api/wasmtime/struct.StoreContextMut.html#method.run_concurrent\">https://docs.wasmtime.dev/api/wasmtime/struct.StoreContextMut.html#method.run_concurrent</a>), though, it seems like this is actually not working in the current implementation of <code>wasmtime</code>. Is that correct?</p>\n</blockquote>\n<p>That documentation is referring to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11869\">https://github.com/bytecodealliance/wasmtime/issues/11869</a> and <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11870\">https://github.com/bytecodealliance/wasmtime/issues/11870</a>.  Traditionally, an \"async host function\" in Wasmtime meant a function which returned a <code>Future</code> which closed over the <code>StoreContextMut</code> and thus had exclusive access to it until that <code>Future</code> was dropped.  That was fine for <code>Futures</code>s which wanted to yield to the host embedder (e.g. to do other work not involving that specific store).  However, it meant that the store could not be used for any other purpose until the <code>Future</code> was dropped, i.e. no Wasm code could be run in instances owned by that store, etc.</p>\n<p>Clearly that model wouldn't work for the new component model async ABI, where the whole point was to allow multiple concurrent tasks to execute and be interleaved, and where host functions should only (at most) block the caller, but not other tasks.  So we added a new <code>Linker::func_wrap_concurrent</code> function for registering host functions.  Unlike the existing <code>func_wrap_async</code> function, <code>func_wrap_concurrent</code> takes a closure which returns a <code>Future</code> which only has exclusive access to the store <em>between</em> await points but not across await points.  That means it effectively yields control of the store whenever it awaits, allowing that store to be used for other work, e.g. running other tasks owned by the store.</p>\n<p>As you would expect, <code>wasmtime-wasi[-http]</code>'s WASIp3 implementation uses <code>func_wrap_concurrent</code> rather than <code>func_wrap_async</code>.  However, its WASIp2 implementation remains unchanged -- it's still using <code>func_wrap_async</code>.  That means any component using WASIp2 APIs (or custom host functions implemented using <code>func_wrap_async</code>) can potentially monopolize the entire store, starving the event loop that drives <code>run_concurrent</code>.  In addition, the epoch interruption mechanism is still using something akin to <code>func_wrap_async</code> and also monopolizes the store.</p>\n<p>Both of those issues are entirely fixable, but will take some time to do.  Meanwhile, you can absolutely use <code>tokio::select!</code> inside <code>run_concurrent</code>; just keep in mind that <em>nothing</em> in the closure you pass to <code>run_concurrent</code> (inside or outside a <code>tokio::select!</code>) can run as long as a call to a host function added using <code>func_wrap_async</code> is pending.  Alternatively, if your component only uses WASIp3 imports and/or custom host functions added using <code>func_wrap_concurrent</code>, and doesn't use epoch interruption callbacks which <code>await</code>, then there's no chance <code>run_concurrent</code> will be starved.  And once we've addressed those issues, you won't have to worry about any of this.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/issues/11869\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/80b651632d07de2a1f53970829fd9e664e7373e2/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f336563343234643136306164633030326665303534633661646636383031653761613262353831343632376438636337303961373436396663656164633635622f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f3131383639&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/issues/11869\" title=\"Async libcalls &quot;block&quot; the store from making progress on concurrent tasks · Issue #11869 · bytecodealliance/wasmtime\">Async libcalls \"block\" the store from making progress on concurrent tasks · Issue #11869 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">At this time the implementation of async libcalls in Wasmtime all use the block_on helper internally in the implementation. This has the property, though, that the store is \"locked\" while the libca...</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/issues/11870\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/e3eece56471c25ace9d0d28c058c125f9d190a82/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f656335313063326564623839353635356335306335653232303336366266643266346130613834633836356639643632313765333238653565386632636262302f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f3131383730&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/issues/11870\" title=\"Functions defined with `wrap_async` and various variants &quot;block&quot; the store from making progress on concurrent tasks · Issue #11870 · bytecodealliance/wasmtime\">Functions defined with `wrap_async` and various variants \"block\" the store from making progress on concurrent tasks · Issue #11870 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">This issue is similar to #11869 but I've separated it out to specifically deal with usage of block_on with respect to wrap_async and its variants. The wrap_async function has been a pillar of Wasmt...</div></div></div>",
        "id": 564053840,
        "sender_full_name": "Joel Dice",
        "timestamp": 1765895010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"930440\">Jonathan H</span> <a href=\"#narrow/channel/217126-wasmtime/topic/.60StoreContextMut.3A.3Arun_concurrent.60.20and.20.60tokio.3A.3Aselect!.60/near/563954567\">said</a>:</p>\n<blockquote>\n<p>I was also wondering about cancellation safety of the future returned by <code>call_concurrent</code>. <code>tokio::select!</code> cancels remaining futures when one is ready. But that would drop the <code>Store</code> right?</p>\n</blockquote>\n<p>No, it won't drop the store.  The <code>Future</code> returned by <code>call_concurrent</code> does not own the store, and it will only have exclusive access to the store between <code>await</code> points.  That's what allows it to run concurrently with other in-progress tasks created using <code>call_concurrent</code>.  Furthermore, dropping that <code>Future</code> will <em>not</em> drop the task it represents.  There's currently no public API for cancelling tasks (that's a TODO item), so that task will continue to run until either it finishes or the closure you passed to <code>run_concurrent</code> returns.  The only effect dropping that <code>Future</code> will have is that you'll have no way to retrieve the result returned by the task, if any.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"930440\">Jonathan H</span> <a href=\"#narrow/channel/217126-wasmtime/topic/.60StoreContextMut.3A.3Arun_concurrent.60.20and.20.60tokio.3A.3Aselect!.60/near/563954567\">said</a>:</p>\n<blockquote>\n<p>Is there a better way to go about this?</p>\n</blockquote>\n<p>What you've sketched looks reasonable to me.</p>",
        "id": 564056005,
        "sender_full_name": "Joel Dice",
        "timestamp": 1765895584
    },
    {
        "content": "<p>Thank you so much for the incredibly detailed response. I’m going to move forward with what I have and also see if I can migrate to WASIp3.</p>\n<p>Thanks so much for the incredible work on wasmtime and the willingness and time you put into helping users like me.</p>",
        "id": 564158523,
        "sender_full_name": "Jonathan H",
        "timestamp": 1765934359
    }
]