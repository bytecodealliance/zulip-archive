[
    {
        "content": "<p>Is there a way to reclaim the linear memory used by an Instance (Component or Module) without destroying the <code>Store</code> ?<br>\nThe use case is a service where people can publish, update and run wasm code running on micro controllers. Right now all of the instances belong to the same store so if I update the same capsule over and over (destroying the instance and rebuilding it) at some point since the store is never destroyed wasmtime panics (in my testing at `src/runtime/vm/mmap_vec.rs:72:18). <br>\nIs there a way to:</p>\n<ul>\n<li>Reclaim the memory without destroying the store</li>\n<li>If not, at least gracefully fail instead of panicking<br>\nAlso, the functions <code>MmapVec::new_externally_owned</code>/<code>Mmap::from_raw</code> seem like they could be part of the solution. Is there an example of usage somewhere that I could take inspiration from ? </li>\n</ul>\n<p>Wasmtime version is <code>42.0</code> at rev <code>3dc6b5ec5572ab8b304c668d5b929bbc7f49cbcf</code></p>",
        "id": 574546971,
        "sender_full_name": "Antoine Lavandier",
        "timestamp": 1771430992
    },
    {
        "content": "<p>No, the <code>Store</code> is meant to be cheap to create and freshly created for each unit of work you have -- \"request\", or an update lifecycle, or whatever. Unfortunately there's no way to remove an instance from a store once created (doing so would greatly complicate our index-based handles; we'd need some kind of invalidation and/or GC)</p>",
        "id": 574551642,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1771432117
    },
    {
        "content": "<p>in your host code, is there a reason you can't create a new store each time you \"destroy the instance and rebuild it\"?</p>",
        "id": 574551756,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1771432147
    },
    {
        "content": "<p>Right now I could do as you say (and will if it's the only option) but I have concerns: currently I have one store that \"owns\" all of my instances, to do what you propose, I would need to either have a) one store per instance or b) kill all of the instances, destroy the store, update the relevant bytecode, rebuild everything everytime I want to update the capsules. <br>\na) has the following issues :</p>\n<ul>\n<li>What if my store data is non trivial and thus cloning isn't great. This is a lesser concern because I don't expect the store data to be big relative to the linear memory of the capsules. </li>\n<li>If at some point I want to support composing the modules/components then I run into an issue because I would need several instances on a single store. </li>\n</ul>\n<p>b) seems generally like a hassle and inefficient</p>",
        "id": 574554411,
        "sender_full_name": "Antoine Lavandier",
        "timestamp": 1771432807
    },
    {
        "content": "<p><code>Store</code> is designed to be cheap to create and throw away, that is its main use case</p>",
        "id": 574561468,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1771434565
    },
    {
        "content": "<p>e.g. function-as-a-service platforms create one <code>Store</code> (and <code>Instance</code> within that store) per incoming HTTP request, and then throw it away when the HTTP request is completed; create a new <code>Store</code> for the next incoming HTTP request, etc...</p>",
        "id": 574561737,
        "sender_full_name": "fitzgen (he/him)",
        "timestamp": 1771434643
    },
    {
        "content": "<blockquote>\n<p>What if my store data is non trivial and thus cloning isn't great</p>\n</blockquote>\n<p>If there's shared data you need to reference from hostcalls on all stores, you could put it behind an <code>Arc</code> and share a reference to it? That's cheap to clone</p>\n<blockquote>\n<p>If at some point I want to support composing the modules/components then I run into an issue because I would need several instances on a single store.</p>\n</blockquote>\n<p>This one is interesting; having instances with different lifetimes in different stores talk to each other somehow is a plausible use-case. You can make this work with some host-side glue (an instance/function handle API basically)</p>",
        "id": 574561902,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1771434689
    },
    {
        "content": "<p>FWIW instances with different lifetimes are currently somewhat fundamentally not supported for composed components: there's no way to sever the link between one component's exports and another's imports, for one. The Component Model change intended to make this viable is described <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/FutureFeatures.md#blast-zones\">here</a>. Implementing this will certainly involve either a pretty substantial change in Wasmtime's architecture or (much more likely) using separate stores per \"blast zone\"</p>",
        "id": 574621312,
        "sender_full_name": "Till Schneidereit",
        "timestamp": 1771456346
    },
    {
        "content": "<p>Thanks for the replies. I think that for now I'll just have multiple stores and deal with code composition when it becomes relevant. <br>\nAlso, is there a way or a plan to make the panic go away ? I would prefer my service to reply with a non enough memory error than straight up crash ...</p>",
        "id": 574694659,
        "sender_full_name": "Antoine Lavandier",
        "timestamp": 1771497237
    },
    {
        "content": "<p>I've sent <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12625\">https://github.com/bytecodealliance/wasmtime/pull/12625</a> to handle the panic by returning an error instead</p>",
        "id": 574760554,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1771515787
    }
]