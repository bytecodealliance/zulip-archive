[
    {
        "content": "<p>When using <code>func_wrap</code>, the <code>Caller</code> arg can be used to access guest functions through <code>caller.get_export</code>. So it's possible to have something like this</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">func_wrap</span><span class=\"p\">(</span><span class=\"s\">\"test\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"call_with\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">caller</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Caller</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"c1\">// I'm assuming the other arguments can be used to get a function name</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"n\">func_name</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">Extern</span><span class=\"p\">::</span><span class=\"n\">Func</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"n\">caller</span><span class=\"p\">.</span><span class=\"n\">as_context_mut</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.).</span><span class=\"n\">unwrap</span><span class=\"p\">(),</span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n<span class=\"p\">})</span>\n</code></pre></div>\n<p>One use case for this is when you want to have the container drive some logic, for example networking while also leaving the routing to the host. It could look something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">func_wrap</span><span class=\"p\">(</span><span class=\"s\">\"test\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"register_callbacks\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">caller</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Caller</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">,</span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">..</span><span class=\"p\">.});</span>\n<span class=\"c1\">// This function is called by the guest to register routing rules first</span>\n\n<span class=\"c1\">// Then this is called to \"deploy\" the logic</span>\n<span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">func_wrap</span><span class=\"p\">(</span><span class=\"s\">\"test\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"receive\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">caller</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Caller</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">msg</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">recv</span><span class=\"p\">();</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func_name</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">results</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">.</span><span class=\"n\">routing_rules</span><span class=\"p\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">  </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"n\">func_name</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">Extern</span><span class=\"p\">::</span><span class=\"n\">Func</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"n\">caller</span><span class=\"p\">.</span><span class=\"n\">as_context_mut</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">results</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">(),</span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n<span class=\"p\">})</span>\n</code></pre></div>\n<p>Is this thing possible with the component model through the <code>Guest</code>, <code>Host</code> and <code>XXImports</code> traits ? A more structured way could be allowing a <code>wit</code> <code>interface</code> to import/require other interfaces or single functions and thus be allowed to call this from within the <code>Host</code> trait.</p>",
        "id": 544710058,
        "sender_full_name": "Antoine Lavandier",
        "timestamp": 1760437174
    },
    {
        "content": "<p>What I'm envisioning would look like this </p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>package ....;\n\ninterface api {\n  require foo: func();\n  bar: func();\n}\n\nworld baz {\n  import api;\n}\n</code></pre></div>\n<p>Host side:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wasmtime</span><span class=\"p\">::</span><span class=\"n\">component</span><span class=\"p\">::</span><span class=\"n\">bindgen</span><span class=\"o\">!</span><span class=\"p\">({</span>\n<span class=\"p\">});</span>\n\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.::</span><span class=\"n\">api</span><span class=\"p\">::{</span><span class=\"n\">Host</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">add_to_linker</span><span class=\"p\">};</span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">api</span><span class=\"p\">::</span><span class=\"n\">required</span><span class=\"p\">::</span><span class=\"n\">foo</span><span class=\"p\">;</span>\n\n<span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">MyHost</span><span class=\"p\">;</span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Host</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyHost</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">();</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Guest Side: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wit_bindgen</span><span class=\"p\">::</span><span class=\"n\">generate</span><span class=\"o\">!</span><span class=\"p\">();</span>\n\n<span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">MyGuest</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">api</span><span class=\"p\">::</span><span class=\"n\">Required</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"fm\">todo!</span><span class=\"p\">();</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 544719261,
        "sender_full_name": "Antoine Lavandier",
        "timestamp": 1760440260
    },
    {
        "content": "<p>The component model doesn't currently allow this kind of callback implementation; you can't call into a component instance that is already on the stack.</p>",
        "id": 544736386,
        "sender_full_name": "Lann Martin",
        "timestamp": 1760445188
    },
    {
        "content": "<p>Some other ideas:</p>\n<ul>\n<li>The \"callback\" return value carries any \"actions\" the callback wants to perform (e.g. <code>variant callback-actions { increment-counter, set-value(string), ... }</code>).</li>\n<li>The callback and its caller share some <code>resource</code> import from a common outer instance. The caller passes an instance of this resource to the callback which calls \"update\" methods on this resource and the caller observes the results after return.</li>\n<li>The new component model async features give a lot more options, such as using <code>stream</code>s as a sort of rpc channel.</li>\n</ul>",
        "id": 544738885,
        "sender_full_name": "Lann Martin",
        "timestamp": 1760445929
    }
]