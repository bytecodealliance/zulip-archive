[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10923\">issue #10923</a>:</p>\n<blockquote>\n<p>Spinning out the discussion from <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10919#discussion_r2126137327\">here</a> and today's Cranelift meeting. The question is should Wasmtime be using <code>C-unwind</code> in more locations?</p>\n<p>Current state of the world that this could apply to:</p>\n<ul>\n<li>When Wasmtime <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/traphandlers.rs#L399-L413\">calls <code>setjmp</code></a> the shim uses <code>extern \"C\"</code>.</li>\n<li>After calling <code>setjmp</code> Wasmtime makes its way to <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/vmcontext.rs#L904-L924\">here</a> (through exclusively Wasmtime-defined code) with <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasmtime/src/runtime/vm/vmcontext.rs#L44\">this definition of <code>VMArrayCallNative</code></a> which uses <code>extern \"C\"</code></li>\n<li>Signal handlers <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/sys/unix/signals.rs#L129\">are defined as <code>extern \"C\"</code></a> but will <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/sys/unix/signals.rs#L219\">call <code>longjmp</code></a></li>\n<li>Windows vectored exception handlers are <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/sys/windows/vectored_exceptions.rs#L52\">defined as <code>extern \"system\"</code></a> and <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/sys/windows/vectored_exceptions.rs#L118\">call <code>longjmp</code></a></li>\n<li>The <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/libcalls.rs#L1464\"><code>raise</code> libcall</a> transitively invokes <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/traphandlers.rs#L659\"><code>longjmp</code> here</a> but the entrypoint for <code>raise</code> is <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/libcalls.rs#L118\">defined here with <code>extern \"C\"</code></a></li>\n<li>The <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10919\">upcoming unwinder</a> uses <code>extern \"C\"</code> for <code>__cranelift_throw</code>, and this is presumably the same pattern we'll use in Wasmtime.</li>\n</ul>\n<p>Rust defines foreign unwinding <a href=\"https://doc.rust-lang.org/stable/reference/panic.html#unwinding-across-ffi-boundaries\">here</a>, specifically:</p>\n<blockquote>\n<p>Unwinding with the wrong ABI is undefined behavior:</p>\n<ul>\n<li>Causing an unwind into Rust code from a foreign function that was called via a function declaration or pointer declared with a non-unwinding ABI, such as \"C\", \"system\", etc. (For example, this case occurs when such a function written in C++ throws an exception that is uncaught and propagates to Rust.)</li>\n</ul>\n</blockquote>\n<p>If \"causing an unwind\" includes longjmp and custom Cranelift-defined unwinds then every single location listed above is UB. @bjorn3 mentioned this shouldn't work at all on Windows right now, but something must work on Windows insofar that tests are passing, and we didn't bottom it out in the Cranelift meeting what was going on.</p>\n<hr>\n<p>In short, <code>extern \"C\"</code> guarantees that there's a aborting landing pad to catch unwinds, and we're guaranteed to skip it in all of the above cases as <code>longjmp</code> doesn't run this landing pad (nor does Cranelift-based unwinding). With <code>extern \"C-unwind\"</code>, however, it's still the case that <code>longjmp</code> and Cranelift don't run Rust landing pads which is still UB if they exist (in theory).</p>\n<p>In essence I'm not sure how best to proceed here. At the end of the day at a functional level we want a guarantee that when we <code>longjmp</code> in Wasmtime there's no Rust destructors on the stack, but even if that is the case (as we think it is today) it's still not clear whether this is all UB and needs to change one way or another. Will changing to <code>C-unwind</code> fix things? Do we need to use inline assembly stubs or similar more aggressively?</p>\n</blockquote>",
        "id": 522415248,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749058424
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10923#issuecomment-2940857238\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10923\">issue #10923</a>:</p>\n<blockquote>\n<p>One possibility to solve all of this is to move the responsibility of longjmp/setjmp into Cranelift. For example one could imagine:</p>\n<ul>\n<li>Entry trampolines bake in a <code>setjmp</code> call defined by Cranelift</li>\n<li>Invocations of the <code>raise</code> libcall are replaced by a <code>longjmp</code> defined by Cranelift</li>\n<li>Signal handlers, when catching a signal, update the execution context to resume at a Cranelift-defined stub to execute a Cranelift-defined longjmp</li>\n<li>The \"throw\" logic for exceptions would turn into a Cranelift intrinsic/instruction and wouldn't need inline assembly on the Wasmtime side of things</li>\n</ul>\n<p>In such a world I don't believe there's any unwinding at all defined in Wasmtime and everything happens exclusively through Cranelift. That's a pretty good deal of refactoring, however, and I'm not sure how easy it would be to model such intrinsics/etc in Cranelift.</p>\n</blockquote>",
        "id": 522416088,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749058695
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10923\">issue #10923</a>:</p>\n<blockquote>\n<p>Spinning out the discussion from <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10919#discussion_r2126137327\">here</a> and today's Cranelift meeting. The question is should Wasmtime be using <code>C-unwind</code> in more locations?</p>\n<p>Current state of the world that this could apply to:</p>\n<ul>\n<li>When Wasmtime <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/traphandlers.rs#L399-L413\">calls <code>setjmp</code></a> the shim uses <code>extern \"C\"</code>.</li>\n<li>After calling <code>setjmp</code> Wasmtime makes its way to <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/vmcontext.rs#L904-L924\">here</a> (through exclusively Wasmtime-defined code) with <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasmtime/src/runtime/vm/vmcontext.rs#L44\">this definition of <code>VMArrayCallNative</code></a> which uses <code>extern \"C\"</code></li>\n<li>Signal handlers <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/sys/unix/signals.rs#L129\">are defined as <code>extern \"C\"</code></a> but will <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/sys/unix/signals.rs#L219\">call <code>longjmp</code></a></li>\n<li>Windows vectored exception handlers are <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/sys/windows/vectored_exceptions.rs#L52\">defined as <code>extern \"system\"</code></a> and <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/sys/windows/vectored_exceptions.rs#L118\">call <code>longjmp</code></a></li>\n<li>The <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/libcalls.rs#L1464\"><code>raise</code> libcall</a> transitively invokes <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/traphandlers.rs#L659\"><code>longjmp</code> here</a> but the entrypoint for <code>raise</code> is <a href=\"https://github.com/bytecodealliance/wasmtime/blob/5603ee7b099c837aa7194f1052e7c73cf4c36750/crates/wasmtime/src/runtime/vm/libcalls.rs#L118\">defined here with <code>extern \"C\"</code></a></li>\n<li>The <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10919\">upcoming unwinder</a> uses <code>extern \"C\"</code> for <code>__cranelift_throw</code>, and this is presumably the same pattern we'll use in Wasmtime.</li>\n</ul>\n<p>Rust defines foreign unwinding <a href=\"https://doc.rust-lang.org/stable/reference/panic.html#unwinding-across-ffi-boundaries\">here</a>, specifically:</p>\n<blockquote>\n<p>Unwinding with the wrong ABI is undefined behavior:</p>\n<ul>\n<li>Causing an unwind into Rust code from a foreign function that was called via a function declaration or pointer declared with a non-unwinding ABI, such as \"C\", \"system\", etc. (For example, this case occurs when such a function written in C++ throws an exception that is uncaught and propagates to Rust.)</li>\n</ul>\n</blockquote>\n<p>If \"causing an unwind\" includes longjmp and custom Cranelift-defined unwinds then every single location listed above is UB. @bjorn3 mentioned this shouldn't work at all on Windows right now, but something must work on Windows insofar that tests are passing, and we didn't bottom it out in the Cranelift meeting what was going on.</p>\n<hr>\n<p>In short, <code>extern \"C\"</code> guarantees that there's a aborting landing pad to catch unwinds, and we're guaranteed to skip it in all of the above cases as <code>longjmp</code> doesn't run this landing pad (nor does Cranelift-based unwinding). With <code>extern \"C-unwind\"</code>, however, it's still the case that <code>longjmp</code> and Cranelift don't run Rust landing pads which is still UB if they exist (in theory).</p>\n<p>In essence I'm not sure how best to proceed here. At the end of the day at a functional level we want a guarantee that when we <code>longjmp</code> in Wasmtime there's no Rust destructors on the stack, but even if that is the case (as we think it is today) it's still not clear whether this is all UB and needs to change one way or another. Will changing to <code>C-unwind</code> fix things? Do we need to use inline assembly stubs or similar more aggressively?</p>\n</blockquote>",
        "id": 542139612,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1759179870
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10923#issuecomment-3349052151\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10923\">issue #10923</a>:</p>\n<blockquote>\n<p>I'm going to close this after recent refactorings with exceptions/trampolines/etc. Without setjmp/longjmp any more there's only a tiny handful of functions we skip over, the <code>raise</code> entrypoint plus macOS mach ports handling, and I think those are in a reasonable state.</p>\n</blockquote>",
        "id": 542139615,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1759179871
    }
]