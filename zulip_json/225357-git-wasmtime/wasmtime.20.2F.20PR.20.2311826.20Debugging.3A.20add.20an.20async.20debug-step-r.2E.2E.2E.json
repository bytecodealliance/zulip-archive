[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a> from <code>cfallin:wasmtime-debug-traps</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>(Stacked on top of #11769.)</p>\n<p>As part of the new guest-debugging API, we want to allow the host to<br>\nexecute the debugged guest code asynchronously, receiving its \"debug<br>\nstep\" results each time a debugging-relevant event occurs. In the<br>\nfullness of time, this will include: traps, thrown exceptions,<br>\nbreakpoints and watchpoints hit, single-steps, etc.</p>\n<p>As a first step, this PR adds:</p>\n<ul>\n<li>\n<p>A notion of running an asynchronous function call in a \"debug<br>\n  session\";</p>\n</li>\n<li>\n<p>An API on that debug session object (which owns the store while the<br>\n  function is running) that provides an async method to get the next<br>\n<code>DebugStepResult</code>;</p>\n</li>\n<li>\n<p>An implementation that transmutes traps into a debug-step result,<br>\n  allowing introspection of the guest state before the trap tears down<br>\n  its stack;</p>\n</li>\n<li>\n<p>Access to the stack introspection API provided by <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11769\">https://github.com/bytecodealliance/wasmtime/pull/11769</a>.</p>\n</li>\n</ul>\n<p>The implementation works by performing <em>call injection</em> from the signal<br>\nhandler. The basic idea is that rather than perform an exception resume<br>\nfrom the signal handler, directly rewriting register state to unwind all<br>\nWasm frames and return the error code to the host, we rewrite register<br>\nstate to redirect to a handwritten assembly stub. This stub cannot<br>\nassume anything about register state (because we don't enforce any<br>\nconstraints on register state at all the points that trapping signals<br>\ncould occur); thus, it has to save every register. To allow this<br>\ntrampoline to do anything at all, we inject a few parameters to it; the<br>\noriginal values of the parameter registers, as well as the original PC<br>\n(location of the trap), are saved to the store so they can be restored<br>\ninto the register-save frame before the injected stub returns (if it<br>\ndoes).</p>\n<p>The injected stub can then call into the runtime to perform a<br>\nfiber-suspend, setting a \"debug yield\" value that indicates that a trap<br>\noccurred.</p>\n<p>A few notes on design constraints that forced my hand in several ways:</p>\n<ul>\n<li>\n<p>We need to inject a call by rewriting only register state, not pushing<br>\n  a new frame from within the stack handler, because it appears that<br>\n  Windows vectored exception handlers run on the same stack as the guest<br>\n  and so there is no room to push an additional frame.</p>\n</li>\n<li>\n<p>We need access to the store from the signal context now; we can get<br>\n  this from TLS if we add a raw backpointer from VMStoreContext to<br>\n  StoreOpaque. I <em>believe</em> we aren't committing any serious pointer<br>\n  provenance or aliasing-rules crimes here, because dynamically we are<br>\n  taking ownership of the store back when we're running within the<br>\n  signal context (it's as if it was passed as an argument, via a very<br>\n  circuitous route), but I could very well be wrong. I hope we can find<br>\n  another working approach if so!</p>\n</li>\n<li>\n<p>The trap suspend protocol looks a little like a resumable trap but<br>\n  only because we need to properly tear down the future (otherwise we<br>\n  get a panic on drop). Basically we resume back, and if the trap was a<br>\n  non-resumable trap, the assembly stub returns not to the original PC<br>\n  but the PC of <em>another</em> stub that does the original<br>\n  resume-to-entry-handler action.</p>\n</li>\n</ul>\n<p>Everything is set up here for resumable traps (e.g. for breakpoints) to<br>\nalso work, but I haven't implemented that yet; that's the next PR (and<br>\nrequires some other machinery, most notably a private copy of code<br>\nmemory and the ability to edit and re-publish it; and metadata to<br>\nindicate where to patch in breaks; and a <code>pc += BREAK_SIZE</code> somewhere to<br>\nskip over on resume).</p>\n<p>This is a draft that works on Linux on x86-64; I still need to implement</p>\n<ul>\n<li>[ ] aarch64, riscv64, s390x assembly stubs</li>\n<li>[ ] Windows and macOS updates to trap handlers</li>\n<li>[ ] equivalent behavior on the <code>raise</code> libcall too, not just<br>\n      signal-based traps</li>\n</ul>\n<p>but I wanted to post it now to communicate the current direction and get<br>\nany early feedback.</p>\n</blockquote>",
        "id": 543888686,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1759995158
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>.</p>",
        "id": 543889158,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1759995317
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>.</p>",
        "id": 543889608,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1759995481
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826#issuecomment-3385044185\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>:</p>\n<blockquote>\n<h4>Label Messager: wasmtime:config</h4>\n<p>It looks like you are changing Wasmtime's configuration options. Make sure to<br>\ncomplete this check list:</p>\n<ul>\n<li>\n<p>[ ] If you added a new <code>Config</code> method, you wrote extensive documentation for<br>\n      it.</p>\n<p>&lt;details&gt;</p>\n<p>Our documentation should be of the following form:</p>\n<p>```text<br>\nShort, simple summary sentence.</p>\n<p>More details. These details can be multiple paragraphs. There should be<br>\ninformation about not just the method, but its parameters and results as<br>\nwell.</p>\n<p>Is this method fallible? If so, when can it return an error?</p>\n<p>Can this method panic? If so, when does it panic?</p>\n<h1>Example</h1>\n<p>Optional example here.<br>\n```</p>\n<p>&lt;/details&gt;</p>\n</li>\n<li>\n<p>[ ] If you added a new <code>Config</code> method, or modified an existing one, you<br>\n  ensured that this configuration is exercised by the fuzz targets.</p>\n<p>&lt;details&gt;</p>\n<p>For example, if you expose a new strategy for allocating the next instance<br>\nslot inside the pooling allocator, you should ensure that at least one of our<br>\nfuzz targets exercises that new strategy.</p>\n<p>Often, all that is required of you is to ensure that there is a knob for this<br>\nconfiguration option in [<code>wasmtime_fuzzing::Config</code>][fuzzing-config] (or one<br>\nof its nested <code>struct</code>s).</p>\n<p>Rarely, this may require authoring a new fuzz target to specifically test this<br>\nconfiguration. See [our docs on fuzzing][fuzzing-docs] for more details.</p>\n<p>&lt;/details&gt;</p>\n</li>\n<li>\n<p>[ ] If you are enabling a configuration option by default, make sure that it<br>\n  has been fuzzed for at least two weeks before turning it on by default.</p>\n</li>\n</ul>\n<p>[fuzzing-config]: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194\">https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194</a><br>\n[fuzzing-docs]: <a href=\"https://docs.wasmtime.dev/contributing-fuzzing.html\">https://docs.wasmtime.dev/contributing-fuzzing.html</a></p>\n<hr>\n<p>&lt;details&gt;</p>\n<p>To modify this label's message, edit the &lt;code&gt;.github/label-messager/wasmtime-config.md&lt;/code&gt; file.</p>\n<p>To add new label messages or remove existing label messages, edit the<br>\n&lt;code&gt;.github/label-messager.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/label-messager-action\">Learn more.</a></p>\n<p>&lt;/details&gt;</p>\n</blockquote>",
        "id": 543915258,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760003141
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>.</p>",
        "id": 544255202,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760134105
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>.</p>",
        "id": 544262141,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760138083
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>.</p>",
        "id": 544264093,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760139436
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>.</p>",
        "id": 544267367,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760141590
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>.</p>",
        "id": 544363209,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760234060
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>.</p>",
        "id": 544375581,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760250157
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>:</p>\n<blockquote>\n<p>(Stacked on top of #11769.)</p>\n<p>As part of the new guest-debugging API, we want to allow the host to<br>\nexecute the debugged guest code asynchronously, receiving its \"debug<br>\nstep\" results each time a debugging-relevant event occurs. In the<br>\nfullness of time, this will include: traps, thrown exceptions,<br>\nbreakpoints and watchpoints hit, single-steps, etc.</p>\n<p>As a first step, this PR adds:</p>\n<ul>\n<li>\n<p>A notion of running an asynchronous function call in a \"debug<br>\n  session\";</p>\n</li>\n<li>\n<p>An API on that debug session object (which owns the store while the<br>\n  function is running) that provides an async method to get the next<br>\n<code>DebugStepResult</code>;</p>\n</li>\n<li>\n<p>An implementation that transmutes traps into a debug-step result,<br>\n  allowing introspection of the guest state before the trap tears down<br>\n  its stack;</p>\n</li>\n<li>\n<p>Access to the stack introspection API provided by <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11769\">https://github.com/bytecodealliance/wasmtime/pull/11769</a>.</p>\n</li>\n</ul>\n<p>The implementation works by performing <em>call injection</em> from the signal<br>\nhandler. The basic idea is that rather than perform an exception resume<br>\nfrom the signal handler, directly rewriting register state to unwind all<br>\nWasm frames and return the error code to the host, we rewrite register<br>\nstate to redirect to a handwritten assembly stub. This stub cannot<br>\nassume anything about register state (because we don't enforce any<br>\nconstraints on register state at all the points that trapping signals<br>\ncould occur); thus, it has to save every register. To allow this<br>\ntrampoline to do anything at all, we inject a few parameters to it; the<br>\noriginal values of the parameter registers, as well as the original PC<br>\n(location of the trap), are saved to the store so they can be restored<br>\ninto the register-save frame before the injected stub returns (if it<br>\ndoes).</p>\n<p>The injected stub can then call into the runtime to perform a<br>\nfiber-suspend, setting a \"debug yield\" value that indicates that a trap<br>\noccurred.</p>\n<p>A few notes on design constraints that forced my hand in several ways:</p>\n<ul>\n<li>\n<p>We need to inject a call by rewriting only register state, not pushing<br>\n  a new frame from within the stack handler, because it appears that<br>\n  Windows vectored exception handlers run on the same stack as the guest<br>\n  and so there is no room to push an additional frame.</p>\n</li>\n<li>\n<p>We need access to the store from the signal context now; we can get<br>\n  this from TLS if we add a raw backpointer from VMStoreContext to<br>\n  StoreOpaque. I <em>believe</em> we aren't committing any serious pointer<br>\n  provenance or aliasing-rules crimes here, because dynamically we are<br>\n  taking ownership of the store back when we're running within the<br>\n  signal context (it's as if it was passed as an argument, via a very<br>\n  circuitous route), but I could very well be wrong. I hope we can find<br>\n  another working approach if so!</p>\n</li>\n<li>\n<p>The trap suspend protocol looks a little like a resumable trap but<br>\n  only because we need to properly tear down the future (otherwise we<br>\n  get a panic on drop). Basically we resume back, and if the trap was a<br>\n  non-resumable trap, the assembly stub returns not to the original PC<br>\n  but the PC of <em>another</em> stub that does the original<br>\n  resume-to-entry-handler action.</p>\n</li>\n</ul>\n<p>Everything is set up here for resumable traps (e.g. for breakpoints) to<br>\nalso work, but I haven't implemented that yet; that's the next PR (and<br>\nrequires some other machinery, most notably a private copy of code<br>\nmemory and the ability to edit and re-publish it; and metadata to<br>\nindicate where to patch in breaks; and a <code>pc += BREAK_SIZE</code> somewhere to<br>\nskip over on resume).</p>\n<p>This is a draft that works on Linux on x86-64; I still need to implement</p>\n<ul>\n<li>[x] aarch64, riscv64, s390x assembly stubs</li>\n<li>[ ] Windows and macOS updates to trap handlers</li>\n<li>[ ] equivalent behavior on the <code>raise</code> libcall too, not just<br>\n      signal-based traps</li>\n</ul>\n<p>but I wanted to post it now to communicate the current direction and get<br>\nany early feedback.</p>\n</blockquote>",
        "id": 544432376,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760307200
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>:</p>\n<blockquote>\n<p>(Stacked on top of #11769.)</p>\n<p>As part of the new guest-debugging API, we want to allow the host to<br>\nexecute the debugged guest code asynchronously, receiving its \"debug<br>\nstep\" results each time a debugging-relevant event occurs. In the<br>\nfullness of time, this will include: traps, thrown exceptions,<br>\nbreakpoints and watchpoints hit, single-steps, etc.</p>\n<p>As a first step, this PR adds:</p>\n<ul>\n<li>\n<p>A notion of running an asynchronous function call in a \"debug<br>\n  session\";</p>\n</li>\n<li>\n<p>An API on that debug session object (which owns the store while the<br>\n  function is running) that provides an async method to get the next<br>\n<code>DebugStepResult</code>;</p>\n</li>\n<li>\n<p>An implementation that transmutes traps into a debug-step result,<br>\n  allowing introspection of the guest state before the trap tears down<br>\n  its stack;</p>\n</li>\n<li>\n<p>Access to the stack introspection API provided by <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11769\">https://github.com/bytecodealliance/wasmtime/pull/11769</a>.</p>\n</li>\n</ul>\n<p>The implementation works by performing <em>call injection</em> from the signal<br>\nhandler. The basic idea is that rather than perform an exception resume<br>\nfrom the signal handler, directly rewriting register state to unwind all<br>\nWasm frames and return the error code to the host, we rewrite register<br>\nstate to redirect to a handwritten assembly stub. This stub cannot<br>\nassume anything about register state (because we don't enforce any<br>\nconstraints on register state at all the points that trapping signals<br>\ncould occur); thus, it has to save every register. To allow this<br>\ntrampoline to do anything at all, we inject a few parameters to it; the<br>\noriginal values of the parameter registers, as well as the original PC<br>\n(location of the trap), are saved to the store so they can be restored<br>\ninto the register-save frame before the injected stub returns (if it<br>\ndoes).</p>\n<p>The injected stub can then call into the runtime to perform a<br>\nfiber-suspend, setting a \"debug yield\" value that indicates that a trap<br>\noccurred.</p>\n<p>A few notes on design constraints that forced my hand in several ways:</p>\n<ul>\n<li>\n<p>We need to inject a call by rewriting only register state, not pushing<br>\n  a new frame from within the stack handler, because it appears that<br>\n  Windows vectored exception handlers run on the same stack as the guest<br>\n  and so there is no room to push an additional frame.</p>\n</li>\n<li>\n<p>We need access to the store from the signal context now; we can get<br>\n  this from TLS if we add a raw backpointer from VMStoreContext to<br>\n  StoreOpaque. I <em>believe</em> we aren't committing any serious pointer<br>\n  provenance or aliasing-rules crimes here, because dynamically we are<br>\n  taking ownership of the store back when we're running within the<br>\n  signal context (it's as if it was passed as an argument, via a very<br>\n  circuitous route), but I could very well be wrong. I hope we can find<br>\n  another working approach if so!</p>\n</li>\n<li>\n<p>The trap suspend protocol looks a little like a resumable trap but<br>\n  only because we need to properly tear down the future (otherwise we<br>\n  get a panic on drop). Basically we resume back, and if the trap was a<br>\n  non-resumable trap, the assembly stub returns not to the original PC<br>\n  but the PC of <em>another</em> stub that does the original<br>\n  resume-to-entry-handler action.</p>\n</li>\n</ul>\n<p>Everything is set up here for resumable traps (e.g. for breakpoints) to<br>\nalso work, but I haven't implemented that yet; that's the next PR (and<br>\nrequires some other machinery, most notably a private copy of code<br>\nmemory and the ability to edit and re-publish it; and metadata to<br>\nindicate where to patch in breaks; and a <code>pc += BREAK_SIZE</code> somewhere to<br>\nskip over on resume).</p>\n<p>This is a draft that works on Linux on x86-64; I still need to implement</p>\n<ul>\n<li>[x] aarch64, riscv64, s390x assembly stubs</li>\n<li>[ ] Windows and macOS updates to trap handlers</li>\n<li>[x] equivalent behavior on the <code>raise</code> libcall too, not just<br>\n      signal-based traps</li>\n</ul>\n<p>but I wanted to post it now to communicate the current direction and get<br>\nany early feedback.</p>\n</blockquote>",
        "id": 544432377,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760307203
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826#issuecomment-3395423839\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>:</p>\n<blockquote>\n<p>This now has support for all our native architectures, but not macOS or Windows; integrating with the separate exception-handling thread on macOS is proving to be a little unexpectedly interesting and I think the form it may take is that the call-injection machinery I've built here will subsume the existing (non-state-preserving, for-unwinding-traps-only) call injection on macOS. I haven't looked in detail at Windows yet as I'll have to dust off my Windows VM (for the first time since implementing fastcall in 2021!) but I <em>hope</em> the only tricky bit there will be adding a fastcall variant of the x86-64 stub.</p>\n<p>One interesting bit that might be good to discuss (cc @alexcrichton / @fitzgen) is the actual API for the \"debug step\" protocol. I'm relatively happy with the <code>DebugSession</code> in the current PR, with the <code>async fn next(..) -&gt; Option&lt;DebugStepResult&gt;</code> that runs until a trap or exception or breakpoint or ... event. The dynamic store ownership protocol basically works with the safe Rust restrictions there too: one can get at the store only when the Wasm code yields, which is morally like a hostcall that passes a reborrowed <code>&amp;mut Store</code> back. One can then read all store-owned state until one resumes. (To allow the debugger to take control back when running, the plan is that this will compose fine with epochs; we can make an epoch change a debug step event too.) There's the separate issue I wrote up in #11835 about whether \"access to store during yields\" means <code>StoreOpaque</code> or the whole <code>Store</code> but that's not the issue here.</p>\n<p>The thing that I am finding interesting is how to <em>enter</em> a debug session. Right now I have a <code>Func::call_debug</code> that is like <code>call_async</code> but returns a <code>DebugSession</code>, not a future directly. That's fine but feels pretty ad-hoc, and importantly, will not compose with any wit-bindgen-generated host-side glue. For example, attaching a debugger to a WASI CLI-world or HTTP-world component won't be directly possible because the raw calls are inside generated code. So instead I'm considering an alternative (which was actually my first draft before getting lost in Futures Hell and finding an exit to this current world):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">session</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">with_debugger</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">store</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"c1\">// ...</span>\n<span class=\"w\">  </span><span class=\"n\">wasi_bindings</span><span class=\"p\">.</span><span class=\"n\">main</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"c1\">// ...</span>\n<span class=\"w\">  </span><span class=\"nb\">Ok</span><span class=\"p\">(())</span>\n<span class=\"p\">});</span>\n\n<span class=\"k\">while</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">step</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">session</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">update_debug_ui</span><span class=\"p\">(</span><span class=\"n\">step</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"n\">update_memory_view</span><span class=\"p\">(</span><span class=\"n\">mem</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">session</span><span class=\"p\">));</span>\n<span class=\"w\">  </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>The idea here is that there is that the session wraps an inner arbitrary future that runs with the store. I was tripped up before about the store dynamic ownership-passing protocol but the idea above that debug-steps are morally like hostcalls, so a debug yield passes ownership back, seems to free us from that question. What do you think?</p>\n<p>(In the current implementation, nested debug sessions are forbidden dynamically, and the debug session sees only one Wasm activation deep i.e. from Wasm entry to Wasm exit and any hostcall is an atomic step; these simplifying restrictions are important to the coherency of the above too, IMHO.)</p>\n</blockquote>",
        "id": 544433077,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760308156
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826#issuecomment-3395423839\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>:</p>\n<blockquote>\n<p>This now has support for all our native architectures, but not macOS or Windows; integrating with the separate exception-handling thread on macOS is proving to be a little unexpectedly interesting and I think the form it may take is that the call-injection machinery I've built here will subsume the existing (non-state-preserving, for-unwinding-traps-only) call injection on macOS. I haven't looked in detail at Windows yet as I'll have to dust off my Windows VM (for the first time since implementing fastcall in 2021!) but I <em>hope</em> the only tricky bit there will be adding a fastcall variant of the x86-64 stub.</p>\n<p>One interesting bit that might be good to discuss (cc @alexcrichton / @fitzgen) is the actual API for the \"debug step\" protocol. I'm relatively happy with the <code>DebugSession</code> in the current PR, with the <code>async fn next(..) -&gt; Option&lt;DebugStepResult&gt;</code> that runs until a trap or exception or breakpoint or ... event. The dynamic store ownership protocol basically works with the safe Rust restrictions there too: one can get at the store only when the Wasm code yields, which is morally like a hostcall that passes a reborrowed <code>&amp;mut Store</code> back. One can then read all store-owned state until one resumes. (To allow the debugger to take control back when running, the plan is that this will compose fine with epochs; we can make an epoch change a debug step event too.) There's the separate issue I wrote up in #11835 about whether \"access to store during yields\" means <code>StoreOpaque</code> or the whole <code>Store</code> but that's not the issue here.</p>\n<p>The thing that I am finding interesting is how to <em>enter</em> a debug session. Right now I have a <code>Func::call_debug</code> that is like <code>call_async</code> but returns a <code>DebugSession</code>, not a future directly. That's fine but feels pretty ad-hoc, and importantly, will not compose with any wit-bindgen-generated host-side glue. For example, attaching a debugger to a WASI CLI-world or HTTP-world component won't be directly possible because the raw calls are inside generated code. So instead I'm considering an alternative (which was actually my first draft before getting lost in Futures Hell and finding an exit to this current world):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">session</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">with_debugger</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">store</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"c1\">// ...</span>\n<span class=\"w\">  </span><span class=\"n\">wasi_instance</span><span class=\"p\">.</span><span class=\"n\">main</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"c1\">// ...</span>\n<span class=\"w\">  </span><span class=\"nb\">Ok</span><span class=\"p\">(())</span>\n<span class=\"p\">});</span>\n\n<span class=\"k\">while</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">step</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">session</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">update_debug_ui</span><span class=\"p\">(</span><span class=\"n\">step</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"n\">update_memory_view</span><span class=\"p\">(</span><span class=\"n\">mem</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">session</span><span class=\"p\">));</span>\n<span class=\"w\">  </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>The idea here is that there is that the session wraps an inner arbitrary future that runs with the store. I was tripped up before about the store dynamic ownership-passing protocol but the idea above that debug-steps are morally like hostcalls, so a debug yield passes ownership back, seems to free us from that question. What do you think?</p>\n<p>(In the current implementation, nested debug sessions are forbidden dynamically, and the debug session sees only one Wasm activation deep i.e. from Wasm entry to Wasm exit and any hostcall is an atomic step; these simplifying restrictions are important to the coherency of the above too, IMHO.)</p>\n</blockquote>",
        "id": 544433132,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760308247
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>.</p>",
        "id": 544465597,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760336384
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826#issuecomment-3398662211\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>:</p>\n<blockquote>\n<blockquote>\n<p>integrating with the separate exception-handling thread on macOS is proving to be a little unexpectedly interesting</p>\n</blockquote>\n<p>One idea to work with this is that, for all platforms, when the signal handler updates state to the trampoline to call out to the host anything clobbered is pushed to the stack instead of saved in the store.  For example the stack pointer would be decremented by 32, the first 16 bytes being the saved return address/frame pointer (pretending it's a called frame) and the next 16 bytes would be 2 clobbered registers or something like that. That would work on macOS and all other platforms as well and means that the store isn't necessary in the signal handler routine at least.</p>\n<p>Also, somewhat orthogonal, but I don't think that the asm stubs need to save all registers, only the caller-saved ones according to the native ABI, right? </p>\n<blockquote>\n<p>The thing that I am finding interesting is how to enter a debug session</p>\n</blockquote>\n<p>I'm not sure of a way other than what you've described you've done in this PR already with a <code>call_debug</code>. The <code>call</code>/<code>call_async</code> interfaces effectively fundamentally don't do what you want which is that they take and \"lock\" the store for the entire duration of the call. There's no way to interrupt the call halfway through and get the store back at the caller side. This works for host imports because once within the future we can temporarily loan the store to the host during a host call, but that doesn't work for giving the store back to the original caller. I do agree though that <code>call_debug</code> is not great and doesn't compose well with generated bindings, so I agree it'd be worthwhile to try to fix this.</p>\n<p>What might work best is to go ahead and sketch out <code>call_debug</code> and test/implement with that for now and we can brainstorm later about a possible alternative. My suspicion is that it's going to look like <code>run_concurrent</code> from the component-model-async proposal.</p>\n</blockquote>",
        "id": 544606466,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760381069
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826#issuecomment-3398779195\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>:</p>\n<blockquote>\n<blockquote>\n<p>Also, somewhat orthogonal, but I don't think that the asm stubs need to save all registers, only the caller-saved ones according to the native ABI, right?</p>\n</blockquote>\n<p>Ah, in this case we <em>do</em> actually need to save everything: we're interrupting guest code and we don't have regalloc clobbers on the trap-causing instruction so we need to effectively do a full context switch. (Including vector registers, so this is somewhat heavyweight.)</p>\n<p>More is in <a href=\"https://github.com/cfallin/wasmtime/blob/18c8796d39cc6080f3556d49b65531d452d488bc/crates/wasmtime/src/runtime/vm/traphandlers/inject_call/x86_64.rs#L14-L32\">this comment</a> in this PR.</p>\n<blockquote>\n<p>I'm not sure of a way other than what you've described you've done in this PR already with a call_debug.</p>\n</blockquote>\n<p>What do you think about the <code>with_debugger</code> sketch above?</p>\n<blockquote>\n<p>There's no way to interrupt the call halfway through and get the store back at the caller side. </p>\n</blockquote>\n<p>I guess this is what I'm trying to get at with</p>\n<blockquote>\n<p>The dynamic store ownership protocol basically works with the safe Rust restrictions there too: one can get at the store only when the Wasm code yields, which is morally like a hostcall that passes a reborrowed &amp;mut Store back.</p>\n</blockquote>\n<p>and also restated over in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835#issuecomment-3398091021\">this</a> comment; a <em>hostcall</em> is effectively an interrupt to a call, and so if one sees any debug-step yield that occurs at a trapping instruction as a fancy way of that instruction \"calling\" back to the host, I think this should actually work. Very important is the way that the lifetimes are tied together on the <code>async fn next</code> on the session: it takes a <code>Pin&lt;&amp;mut Self&gt;</code> with the implicit lifetime there tied to the future, so it <em>does</em> own the store until the future is ready; but the future becomes ready (async fn returns) every time a \"debug step result\" / debug event occurs, which is effectively such a hostcall. Does that make sense? I think this capability is pretty important for the feasibility of the whole enterprise here so I'm happy to try to explain it another way if needed :-)</p>\n</blockquote>",
        "id": 544610759,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760383570
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826#issuecomment-3398923196\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>:</p>\n<blockquote>\n<blockquote>\n<p>The thing that I am finding interesting is how to _enter_ a debug session. Right now I have a <code>Func::call_debug</code> that is like <code>call_async</code> but returns a <code>DebugSession</code>, not a future directly. That's fine but feels pretty ad-hoc, and importantly, will not compose with any wit-bindgen-generated host-side glue. For example, attaching a debugger to a WASI CLI-world or HTTP-world component won't be directly possible because the raw calls are inside generated code. So instead I'm considering an alternative (which was actually my first draft before getting lost in Futures Hell and finding an exit to this current world):</p>\n</blockquote>\n<p>This API makes sense to me, modulo bike shedding the exact naming and such.</p>\n<p>We could alternatively, if we wanted to rearrange some deck chairs, make the API a callback on the <code>Store</code> that is given the debugging-equivalent of <code>Caller</code> and a step/break/etc event, instead of designing the API as a coroutine that returns many step/break/etc events until the computation completes. This is essentially what SpiderMonkey's <code>Debugger</code> API exposes: when you set a breakpoint, for example, you provide a callback that is invoked with the <code>Debugger.Frame</code> object when the breakpoint is hit (for us it would be that and the <code>Caller</code>) and you return a \"continuation value\" which is morally <code>enum { Return(Value), Throw(Value), Panic }</code>. This is potentially easier to integrate transparently with existing API usage (e.g. an existing call into host <code>bindgen!</code> code).</p>\n<p>But these two approaches are basically the same at the end of the day, and we should be able to make either work if we can make one of them work.</p>\n</blockquote>",
        "id": 544616004,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760386382
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826#issuecomment-3398927603\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>:</p>\n<blockquote>\n<blockquote>\n<p>(In the current implementation, nested debug sessions are forbidden dynamically, and the debug session sees only one Wasm activation deep i.e. from Wasm entry to Wasm exit and any hostcall is an atomic step; these simplifying restrictions are important to the coherency of the above too, IMHO.)</p>\n</blockquote>\n<p>Callbacks, rather than coroutines, should also Just Work for multiple activations, I think.</p>\n</blockquote>",
        "id": 544616266,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760386489
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826#issuecomment-3398955630\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>:</p>\n<blockquote>\n<p>That's fair, yeah; the thing I am trying to aim for is a nice API for the debugger main event loop, and a callback-based approach would have to timeslice debugger and debuggee at the top level and use a channel to push events from the callback, then pause if waiting for a \"continue\" token; this is also more awkward in a world that we have the debugger component using all this from behind a wit interface. Whereas the async coroutine approach unfolds this in a way that can work in a single thread without channels; the program-under-test is \"just\" a thing that one can poll for the next output. But, either could work.</p>\n</blockquote>",
        "id": 544617484,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760387172
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>.</p>",
        "id": 544875956,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760503898
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826#issuecomment-3404827087\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\", \"pulley\", \"wasmtime:api\", \"wasmtime:config\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: pulley</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 544888765,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760510993
    },
    {
        "content": "<p>cfallin closed without merge <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>.</p>",
        "id": 548328600,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762021215
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826#issuecomment-3476647192\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">PR #11826</a>:</p>\n<blockquote>\n<p>I'm closing this for now but I'll keep the branch around -- I'm going to write up an issue describing a simpler path, but we can keep the call-injection stubs around for future performance work one day, if we need them.</p>\n</blockquote>",
        "id": 548328601,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762021215
    }
]