[
    {
        "content": "<p>badeend opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089\">issue #10089</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/WebAssembly/wasi-tls\">wasi-tls</a> has <a href=\"https://github.com/WebAssembly/WASI/pull/639\">recently been accepted</a> as a phase 1 proposal.</p>\n<p>We'd like to start implementing this in wasmtime. There already exists some prior efforts:</p>\n<ul>\n<li>@dicej created a standalone WASI host with TLS support at: <a href=\"https://github.com/dicej/dotnet-wasi-tls\">https://github.com/dicej/dotnet-wasi-tls</a><br>\n    - This implements a minimal subset of the <a href=\"https://github.com/WebAssembly/wasi-sockets/pull/104\">draft spec</a>.<br>\n    - Uses the <code>native-tls</code> crate.</li>\n<li>@jsturtevant modified the .NET runtime to use Joel's implementation at: <a href=\"https://github.com/dotnet/runtime/compare/main...jsturtevant:runtime:wasi-tls-2\">https://github.com/dotnet/runtime/compare/main...jsturtevant:runtime:wasi-tls-2</a><br>\n    - This successfully runs their SqlClient.</li>\n<li>Based on Joel's work, I (@badeend) started integrating it into wasmtime itself: <a href=\"https://github.com/badeend/wasmtime/tree/wasi-tls\">https://github.com/badeend/wasmtime/tree/wasi-tls</a><br>\n    - This too is just a minimal subset of the <a href=\"https://github.com/WebAssembly/wasi-sockets/pull/104\">draft spec</a>. Although the WIT in this branch has evolved slightly.<br>\n    - Uses the <code>rustls</code> crate.<br>\n    - The changes are part of the wasi-sockets interface, which is not the right place.<br>\n    - And some boilerplate:<br>\n        - threading through a new <code>tls</code> CLI flag<br>\n        - Change <code>rustls</code> from a <code>wasi-http</code>-only dependency to a workspace dependency.</li>\n</ul>\n<hr>\n<p>My suggestion is to add a new standalone <code>wasi-tls</code> crate:</p>\n<ul>\n<li>under the <code>/crates</code> folder, similar to the other proposals.</li>\n<li>with its own <code>world.wit</code> and <code>types.wit</code>.</li>\n<li>that targets WASI v0.2 for the time being. Work on a v0.3 interface can happen in parallel in the future.</li>\n<li>that is completely experimental and therefore behind a <code>tls</code> flag.</li>\n<li>uses <code>rustls</code> for its implementation? (up for discussion, see next comment)</li>\n</ul>\n<p>Thoughts?</p>\n<hr>\n<p>CC @dicej @jsturtevant</p>\n</blockquote>",
        "id": 495483550,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737632857
    },
    {
        "content": "<p>badeend <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089#issuecomment-2609606884\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089\">issue #10089</a>:</p>\n<blockquote>\n<p>I did an inventory of the two most popular rust TLS crates to see how suitable they are to implement the <a href=\"https://github.com/WebAssembly/wasi-sockets/pull/104\">draft spec</a>:</p>\n<p><strong><code>rustls</code>:</strong></p>\n<ul>\n<li>doesn't support post-handshake authentication.</li>\n<li>supports programmatic client certificate selection, but the callback isn't async.</li>\n<li>supports programmatic peer certificate verification, but the callback isn't async.</li>\n</ul>\n<p><strong><code>native-tls</code>:</strong></p>\n<ul>\n<li>does not support TLS1.3 (yet)</li>\n<li>uses MacOS Secure Transport, which is deprecated and will likely never receive TLS1.3 support.</li>\n<li>does not support programmatic client certificate selection</li>\n<li>does not support programmatic peer certificate verification</li>\n<li>can't inspect the peer's certificate chain, only the leaf cert</li>\n<li>can't inspect ClientHello nor select server certificate &amp; other configurations based on SNI</li>\n<li>can't read SNI submitted server name</li>\n<li>can't read negotiated TLS version</li>\n<li>can't read negotiated cipher suite</li>\n<li>can't configure ALPN ids on the server side</li>\n<li>can't configure cipher suites</li>\n<li>can't request mid-handshake client certificate on the server side</li>\n<li>doesn't support post-handshake authentication</li>\n</ul>\n<p>From wasmtime's POV, <code>rustls</code> seems an obvious choice:</p>\n<ul>\n<li>it is already used by wasi-http,</li>\n<li>it is the most feature complete,</li>\n<li>allows us to quickly iterate on the WIT definitions. Most additions are simply hooking it up to the corresponding rustls methods.</li>\n</ul>\n<p>Despite its shortcomings, from a Standards POV, <code>native-tls</code> has one important leg up:<br>\nInstant validation of portability goals against three different industry-standard back-ends (OpenSSL, SChannel, SecureTransport).<br>\nAFAIK, most of these shortcomings are of the <code>native-tls</code> crate itself and not of the underlying providers. Case in point: .NET's SSLStream is also built on top of SChannel &amp; OpenSSL, yet _does_ support the desired features.</p>\n<hr>\n<p>In the current stage the interface is still simple enough that it doesn't really matter which one we choose. I just wanted to throw it out there before we start sinking too much time into the integration of either option.</p>\n</blockquote>",
        "id": 495483720,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737632900
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089#issuecomment-2610420435\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089\">issue #10089</a>:</p>\n<blockquote>\n<p>How unreasonable do you think it would be to support both rustls and native-tls? For example via compile-time Cargo features? It seems reasonable to have rustls as the default given its breadth of features but being able to showcase both in the same codebase would be a nice example for others looking to implement the proposal as well.</p>\n</blockquote>",
        "id": 495546163,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737651470
    },
    {
        "content": "<p>badeend <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089#issuecomment-2614056123\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089\">issue #10089</a>:</p>\n<blockquote>\n<p>Given the current simplicity of the WASI interface, it should be doable to have both backends. Looking into the future, I can't vouch for how tenable the situation will be. </p>\n<p>The current plan is that @jsturtevant will work on the initial implementation. I haven't checked in with him on this specific point yet, but I suspect that we'll start with  just a single backend. We could add the secondary backend in a follow-up PR.</p>\n<p>@jsturtevant Does this sound about right to you?</p>\n</blockquote>",
        "id": 495893742,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737829453
    },
    {
        "content": "<p>jsturtevant <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089#issuecomment-2616484134\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089\">issue #10089</a>:</p>\n<blockquote>\n<p>Sounds good to me.  My biggest concern would be the lack of features on the native-tls side but the initial interface is pretty minimal so shouldn't be an issue initially.  We can adjust as we go.</p>\n</blockquote>",
        "id": 496179152,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737999692
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089#issuecomment-2616535740\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089\">issue #10089</a>:</p>\n<blockquote>\n<p>Also to be clear if you the implementor @jsturtevant would prefer to pick one or the other I think that's totally ok too. I wouldn't consider it a requirement to support both at the beginning at all. Given how things are leaning I think it would make sense to start with rustls and once that's all working we could see if adding a native-tls backend would make sense?</p>\n</blockquote>",
        "id": 496183461,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738001110
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089#issuecomment-2616536684\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089\">issue #10089</a>:</p>\n<blockquote>\n<p>Ok sorry early morning strikes again, @badeend already said all that, disregard me.</p>\n</blockquote>",
        "id": 496183524,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738001133
    },
    {
        "content": "<p>jsturtevant <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089#issuecomment-2644415419\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089\">issue #10089</a>:</p>\n<blockquote>\n<p>Just an update, I've gotten pretty far on this, debugging one last issue before opening up a PR.  </p>\n</blockquote>",
        "id": 498455547,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738978743
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10089\">issue #10089</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/WebAssembly/wasi-tls\">wasi-tls</a> has <a href=\"https://github.com/WebAssembly/WASI/pull/639\">recently been accepted</a> as a phase 1 proposal.</p>\n<p>We'd like to start implementing this in wasmtime. There already exists some prior efforts:</p>\n<ul>\n<li>@dicej created a standalone WASI host with TLS support at: <a href=\"https://github.com/dicej/dotnet-wasi-tls\">https://github.com/dicej/dotnet-wasi-tls</a><br>\n    - This implements a minimal subset of the <a href=\"https://github.com/WebAssembly/wasi-sockets/pull/104\">draft spec</a>.<br>\n    - Uses the <code>native-tls</code> crate.</li>\n<li>@jsturtevant modified the .NET runtime to use Joel's implementation at: <a href=\"https://github.com/dotnet/runtime/compare/main...jsturtevant:runtime:wasi-tls-2\">https://github.com/dotnet/runtime/compare/main...jsturtevant:runtime:wasi-tls-2</a><br>\n    - This successfully runs their SqlClient.</li>\n<li>Based on Joel's work, I (@badeend) started integrating it into wasmtime itself: <a href=\"https://github.com/badeend/wasmtime/tree/wasi-tls\">https://github.com/badeend/wasmtime/tree/wasi-tls</a><br>\n    - This too is just a minimal subset of the <a href=\"https://github.com/WebAssembly/wasi-sockets/pull/104\">draft spec</a>. Although the WIT in this branch has evolved slightly.<br>\n    - Uses the <code>rustls</code> crate.<br>\n    - The changes are part of the wasi-sockets interface, which is not the right place.<br>\n    - And some boilerplate:<br>\n        - threading through a new <code>tls</code> CLI flag<br>\n        - Change <code>rustls</code> from a <code>wasi-http</code>-only dependency to a workspace dependency.</li>\n</ul>\n<hr>\n<p>My suggestion is to add a new standalone <code>wasi-tls</code> crate:</p>\n<ul>\n<li>under the <code>/crates</code> folder, similar to the other proposals.</li>\n<li>that uses the WIT file from <a href=\"https://github.com/WebAssembly/wasi-tls/pull/1\">this PR</a></li>\n<li>that targets WASI v0.2 for the time being. Work on a v0.3 interface can happen in parallel in the future.</li>\n<li>that is completely experimental and therefore behind a <code>tls</code> flag.</li>\n<li>uses <code>rustls</code> for its implementation? (up for discussion, see next comment)</li>\n</ul>\n<p>Thoughts?</p>\n<hr>\n<p>CC @dicej @jsturtevant</p>\n</blockquote>",
        "id": 504172765,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741377046
    }
]