[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11417\">issue #11417</a>:</p>\n<blockquote>\n<p>When a GC allocation fails in Wasmtime right now the current algorithm is to (a) grow the heap and (b) failing that perform a GC. This means that practically all applications will, by default, grow the entire GC heap to 4GB before any GC actually happens. This has an unfortunate side effect of meaning that we very rarely test GC behavior outside of explicit GC calls right now in tests and fuzzing (otherwise I would presume issues in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11416\">https://github.com/bytecodealliance/wasmtime/pull/11416</a> would have been caught sooner?). This additionally means that applications which have a small working set of memory but a large amount of churn will have a very large memory footprint as the heap grows.</p>\n<p>I think this is something we'll want to tune over time, but by default I think that a GC should happen with some amount of balance before reaching the limit of linear memory. I'm not sure what a good heuristic is, but I feel that our current heuristic isn't the right default.</p>\n</blockquote>",
        "id": 533900877,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754969830
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasm-proposal:gc label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11417\">Issue #11417</a>.</p>",
        "id": 533900878,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754969830
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11417#issuecomment-3180272994\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11417\">issue #11417</a>:</p>\n<blockquote>\n<p>Perhaps a decent heuristic could be: when we hit the GC heap limit, GC first, then if the heap occupancy after GC is over a threshold (50%? tunable knob?) then grow?</p>\n<p>I wonder if this could be a reason that we see large slowdowns in allocation-heavy benchmarks currently: even if growth is in-place (virtual memory-based GC store), growth-first guarantees cache misses on every new object, while a benchmark with a small working set that could fit in cache would otherwise be much happier with address reuse after a GC. (This trades off with the time to do the GC, of course!)</p>\n</blockquote>",
        "id": 534024277,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755018932
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11417#issuecomment-3180292851\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11417\">issue #11417</a>:</p>\n<blockquote>\n<p>That seems reasonable to me yeah. While I'm sure caches are indeed an issue historical profiling has also shown that <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11159\">https://github.com/bytecodealliance/wasmtime/issues/11159</a> is a major slodown -- basically the allocation algorithm right now is pretty non-optimal.</p>\n</blockquote>",
        "id": 534025203,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755019365
    }
]