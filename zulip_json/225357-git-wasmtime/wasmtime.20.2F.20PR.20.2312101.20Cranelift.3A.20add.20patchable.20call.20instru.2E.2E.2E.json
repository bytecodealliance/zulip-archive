[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a> from <code>cfallin:magical-disappearing-patchable-call-now-you-see-it-now-you-dont</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>The new <code>patchable_call</code> CLIF instruction pairs with the <code>patchable</code> ABI, and emits a callsite with one new key property: the MachBuffer carries metadata that describes exactly which byte range to \"NOP out\" (overwrite with NOP instructions) to disable that callsite. Doing so is semantically valid and explicitly supported.</p>\n<p>This enables patching of code at runtime to dynamically turn on and off features such as instrumentation or debugging hooks. We plan to use this to implement breakpoints in Wasmtime's guest debugging support.</p>\n<p>As part of this change, I added a notion of \"unit of NOP bytes\" to the MachBuffer so that the consumer (e.g., Wasmtime's Cranelift-based code compilation pipeline and metadata-producing logic) can handle patchable callsites without any other special knowledge of the ISA.</p>\n<p>For the \"real metal\" ISAs there are perfectly well-defined NOPs to use, but for Pulley, where all opcodes are assigned at compile time by macro magic, I explicitly defined NOP as opcode byte 0 by moving <code>Nop</code>'s definition to the top of the list and adding a unit test asserting its encoding.</p>\n<p>A design note: in principle it would be possible, as an alternative, to treat \"patchability\" as an orthogonal dimension of all callsites, and emit the metadata describing the instruction-offset range for any callsite with the flag set. The only truly necessary semantic restriction is that there are no return values (because if we turn the callsite off, nothing writes to them); we could support patchability for other ABIs and for the other kinds of call instructions. The <code>patchable</code> ABI would then be better described as something like the \"no clobbers ABI\". I opted not to generalize in this way because it creates some less-tested corners and the generalized form, at least at the MachInst level, is not really much simpler in the end.</p>\n<p>A testing note: I opted not to implement actual code patching in the <code>cranelift-tools</code> filetest runner and test patching callsites in/out via some actuation (e.g. a magic hostcall, like we do for throws) because (i) that's a lot of new plumbing and (ii) we are going to test this very shortly in Wasmtime anyway and (iii) the correctness (or not) of the location-and-length metadata is easy enough to verify in the disassemblies in the compile-tests.</p>\n<p>&lt;!--<br>\nPlease make sure you include the following information:</p>\n<ul>\n<li>\n<p>If this work has been discussed elsewhere, please include a link to that<br>\n  conversation. If it was discussed in an issue, just mention \"issue #...\".</p>\n</li>\n<li>\n<p>Explain why this change is needed. If the details are in an issue already,<br>\n  this can be brief.</p>\n</li>\n</ul>\n<p>Our development process is documented in the Wasmtime book:<br>\n<a href=\"https://docs.wasmtime.dev/contributing-development-process.html\">https://docs.wasmtime.dev/contributing-development-process.html</a></p>\n<p>Please ensure all communication follows the code of conduct:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md\">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>\n--&gt;</p>\n</blockquote>",
        "id": 561071168,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764569139
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers\">wasmtime-compiler-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>.</p>",
        "id": 561071169,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764569139
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-default-reviewers\">wasmtime-default-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>.</p>",
        "id": 561071170,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764569139
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/abrown\">abrown</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>.</p>",
        "id": 561071171,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764569139
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/fitzgen\">fitzgen</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>.</p>",
        "id": 561071200,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764569155
    },
    {
        "content": "<p>bjorn3 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#pullrequestreview-3524371119\">PR review</a>.</p>",
        "id": 561125651,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764586491
    },
    {
        "content": "<p>bjorn3 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#discussion_r2576595601\">PR review comment</a>:</p>\n<blockquote>\n<p>Would it be possible to do something like:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">smallvec</span><span class=\"p\">::</span><span class=\"n\">smallvec</span><span class=\"o\">!</span><span class=\"p\">[];</span>\n<span class=\"n\">pulley_interpreter</span><span class=\"p\">::</span><span class=\"n\">op</span><span class=\"p\">::</span><span class=\"n\">Nop</span><span class=\"w\"> </span><span class=\"p\">{}.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"p\">);</span>\n<span class=\"n\">bytes</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 561125654,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764586491
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#pullrequestreview-3526750296\">PR review</a>:</p>\n<blockquote>\n<p>For Pulley, I'd agree it'd be nice to not have to rely on opcode 0 since that'd enable us to move it around and add payloads as necessary too. I vaguely recall seeing somewhere that some ISA (maybe wasm?) has opcode 0 as a trap which means if you accidentally start executing a bunch of zeros it'll die quickly as opposed to sliding into whatever's next and start executing that.</p>\n<p>Otherwise though, I'm realizing that in the context of epochs-with-signal-handlers this is a pretty powerful instruction since, in theory, a patchable load (with the right ABI) could be replaced with a load-from-thing. More generally everything we could want to do with some sort of resumable exception seems like it would ideally want to go through this mechanism (ish) where IR-wise it's a call but runtime-wise we patch it to something that's a context-specific nop and signal handlers get to \"rewrite\" it to a call.</p>\n<p>Given this, would it be worth fleshing out the ABI a bit here? For example is there a downside to saying that the <code>patchable</code> ABI clobbers 1 or 2 registers? Or something along those lines in lieu of attempting to encode the ABI in the function itself or something like that. </p>\n<p>I've not thought about this too too deeply per se, but it sort of feels like this is on the cusp of being a framework at least for catch-a-thing-with-a-signal-and-go-back-to-wasm albeit not precisely suitable as-is (due to no clobbers). I realize though that this goal is orthogonal to debugging stuff, so if you'd prefer to not try to think about this now that's also fine too</p>\n</blockquote>",
        "id": 561263754,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764619504
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#issuecomment-3598773409\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>:</p>\n<blockquote>\n<p>I agree that code-patching could be the basis for a lot of other mechanisms that push cost away from the common case (leaving it to be \"just the cost of fetching some NOPs\") and toward an uncommon case. In particular I like the idea (that I think you're suggesting?) of having a trap context rewrite all epoch-yield callsites into actual calls, while they're NOPs by default.</p>\n<p>The one difficulty to keep in mind wrt anything involving signals is that patching the code will also require ownership of the <code>Store</code>, which is something that we don't yet have in a signal context; I guess that's where the modified ABI comes in, so \"vmctx is an implicit argument in a known fixed register\" is a way around that.</p>\n<p>... but now that I think about that, the existing instruction is already suitable: the ABI is \"no clobbers but there are still register args\", so a <code>patchable_call %epoch_yield(v0)</code> where <code>v0</code> is <code>vmctx</code> will already have <code>vmctx</code> in <code>rdi</code> or <code>x0</code> or whatever, even when the callsite is in its default NOP'd-out state. So from that we could get the <code>Store</code> (<code>Instance::enter_from_wasm</code> etc) and from that patch all sites.</p>\n<p>@erikrose there's a potential epoch-yield mechanism that requires no dead loads/stores at all -- happy to discuss further.</p>\n<p>I'm not sure what other generalizations we could consider here other than the ones mentioned in my commit message above (any callsite / any ABI vs <code>patchable</code> only) but for that dimension I think I want to stick with what we have for the time being. If there's some other instruction we should have here too I'm happy to discuss further of course (maybe as part of a follow-on).</p>\n</blockquote>",
        "id": 561271145,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764622243
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#issuecomment-3598777117\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>:</p>\n<blockquote>\n<p>Ah, actually, I'm thinking in terms of a signal taken at the site itself; a signal taken from an arbitrary point (say <code>SIGALRM</code> on a periodic basis) still has no way to get <code>Store</code> ownership in the general case, so scratch that...</p>\n</blockquote>",
        "id": 561271284,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764622305
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#issuecomment-3598788048\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>:</p>\n<blockquote>\n<p>So I guess the instruction one would actually want for the epochs case is <code>patchable_call_or_load %epoch_yield(v0), v1</code> with <code>v1 being the page that gets unmapped to cause a SIGSEGV, then in that context do the patch (and there we do have the </code>Store`. Happy to sketch how that should look if @erikrose is curious.</p>\n</blockquote>",
        "id": 561271664,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764622470
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#issuecomment-3598788048\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>:</p>\n<blockquote>\n<p>So I guess the instruction one would actually want for the epochs case is <code>patchable_call_or_load %epoch_yield(v0), v1</code> with <code>v1</code> being the page that gets unmapped to cause a SIGSEGV, then in that context do the patch (and there we do have the <code>Store</code>. Happy to sketch how that should look if @erikrose is curious.</p>\n</blockquote>",
        "id": 561271685,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764622478
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#issuecomment-3598808083\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>:</p>\n<blockquote>\n<p>I should clarify I'm also stretching the imagination by using the term \"patchable\" here for what I'm saying. What I'd roughly envision is that we could have instructions (like epoch yields) which are translated to CLIF as a <code>patchable_call</code> instruction which gets machine code for \"do the call\". During compilation finalization, however, we'd rewrite all those call instructions to \"do a load from rdi\" or whatever register has the address of the load. At runtime nothing would actually end up being patched (avoids code copies which make instantiation expensive) and the signal handler would sort of do the patch for the code itself. The only thing that doesn't work in this scheme is the return address on x64 which must be located on the stack and we can't modify the stack in Windows vectored exception handlers (I even double-checked and apparently the red zone is 0 bytes on x64).</p>\n<p>If we got this working though this would all naturally extend to breakpoints where we could change the size of the patchable call to the size of a breakpoint instruction for that purpose. </p>\n<p>In general my rough hope is that we wouldn't need a CLIF-instruction-per-use-case and could funnel them through one relatively narrow waist ideally. Until there's a solution for x64 Windows exceptions, however, I don't think it's worth pushing too much on this because anything non-portable is only of niche value to have lots of infrastructure supporting it</p>\n</blockquote>",
        "id": 561272561,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764622805
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#issuecomment-3598859362\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>:</p>\n<blockquote>\n<p>A few thoughts:</p>\n<ul>\n<li>a \"Call or something else\" doesn't need one to mutate the stack (fortunately) (I think!) because within the signal handler we just update the code we're about to resume at; then the actual call executes and does the return-address push; so this is strictly better than the difficulties we had with the various call-injection trampolines</li>\n<li>I am imagining that when used for breakpoints, we do the patching to NOP during code finalization, so the image on disk is all NOPs and we have the bytes to patch in for a breakpoint call stored in metadata; so there's no CoW cost for any of this in the default case</li>\n<li>That said, I'm not totally sure I get the full picture you have for what you'd have a breakpoint be -- currently my thought is NOP-by-default, patched-to-call. Where does the load come in?</li>\n<li>Making this a more general framework where we could have (say) any two instructions, or patch one to another, or whatever, seems difficult from a compiler architecture point of view. I think the direction I see as feasible would be a \"swiss army knife patchable instruction\" that knows how to (provides metadata to) become (i) a call, (ii) a load, (iii) a NOP, (iv) maybe something else. Then any use case that needs to patch between any subset of these possible side-effects is subsumed by it.</li>\n</ul>\n<p>All that said, I think this discussion is well ahead of what we need to get breakpoints-MVP, so I'd prefer to defer it if that's OK and get review on the PR as-is, unless you think it needs to change in the short term!</p>\n</blockquote>",
        "id": 561274540,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764623399
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#issuecomment-3598895320\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>:</p>\n<blockquote>\n<blockquote>\n<p>All that said, I think this discussion is well ahead of what we need to get breakpoints-MVP, so I'd prefer to defer it if that's OK and get review on the PR as-is, unless you think it needs to change in the short term!</p>\n</blockquote>\n<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> from me. I've <a href=\"https://github.com/bytecodealliance/meetings/pull/717\">added this to the Cranelift meeting</a> where we can continue discussion</p>\n</blockquote>",
        "id": 561275935,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764623802
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#pullrequestreview-3527240241\">PR review</a>:</p>\n<blockquote>\n<p>LGTM modulo the pulley nop thing.</p>\n<p>Fine with not exercising the actual patching in <code>cranelift-tools</code>, since we have filetests, and all the actual patching will come in time as Wasmtime starts using this stuff.</p>\n</blockquote>",
        "id": 561284909,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764626850
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#discussion_r2578878409\">PR review comment</a>:</p>\n<blockquote>\n<p>+1 to avoiding the hard-coded assumption that <code>nop == 0</code> in Pulley.</p>\n</blockquote>",
        "id": 561284910,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764626851
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#discussion_r2578888399\">PR review comment</a>:</p>\n<blockquote>\n<p>Shouldn't it be the opposite? The function address we patch in is not necessarily in the same compilation unit as the current function, so it seems like we should always use <code>!colocated</code> for the most flexibility?</p>\n</blockquote>",
        "id": 561284911,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764626851
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#pullrequestreview-3527451038\">PR review</a>.</p>",
        "id": 561292607,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764630384
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#discussion_r2579027393\">PR review comment</a>:</p>\n<blockquote>\n<p>Ah, interesting -- I built it this way because (i) colocated calls are smaller and thus the better choice (all else equal) when there are going to be a bunch of them -- 4 bytes on aarch64, 5 bytes on x86-64 -- and (ii) the expected use in Wasmtime is that there's a patchable-to-host trampoline for this hostcall compiled into the object, so it really is colocated. I think that if the <em>destination</em> were patched what you say would be true but here the target is statically known still and it's just the enabled/disabled status that's dynamically patched.</p>\n</blockquote>",
        "id": 561292608,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764630384
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#pullrequestreview-3527641887\">PR review</a>.</p>",
        "id": 561301321,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764635731
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101#discussion_r2579170075\">PR review comment</a>:</p>\n<blockquote>\n<p>Sure, yep. It does still need to be a single-byte opcode (not an extended opcode) so it can be used to NOP out a sequence of any length -- the pre-existing definition as an extended opcode (two bytes) meant that wouldn't work. So this PR now moves it and adjusts the unit test to assert a single-byte encoding (value doesn't matter).</p>\n</blockquote>",
        "id": 561301322,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764635731
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>.</p>",
        "id": 561301325,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764635733
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>.</p>",
        "id": 561301389,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764635781
    },
    {
        "content": "<p>cfallin has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>.</p>",
        "id": 561301472,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764635834
    },
    {
        "content": "<p>cfallin merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12101\">PR #12101</a>.</p>",
        "id": 561306355,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764638563
    }
]