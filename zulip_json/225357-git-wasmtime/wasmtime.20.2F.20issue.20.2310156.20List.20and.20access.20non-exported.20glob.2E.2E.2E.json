[
    {
        "content": "<p>laurmaedje opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156\">issue #10156</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>I'd like to access (list/get/set) the value of globals that were not explicitly exported by the module.</p>\n<h4>Benefit</h4>\n<p>I'm trying to take a snapshot of a store's state, so that I can spin up a second instance that is behaviourally equivalent to the first one. Crucially, I don't want to snapshot in the middle of a function call, just at rest when the call stack should be empty.</p>\n<p>I went through the WebAssembly instruction reference and as far as can tell, when I instantiate a new module, the only things I would need to restore would be the main memory size &amp; data and the globals.[^1] I'm already snapshotting the memory (which is required to be exported in my case), but I can't snapshot the globals as far as I can tell.</p>\n<p>As far as I'm aware, LLVM-based compilers will typically only have one internal global with a shadow stack pointer. Since I'm only snapshotting when the call stack is empty, I expect not snapshotting globals for now will not immediately break in practice, but it does not seem quite correct and of course not every WebAssembly module comes from LLVM. So it'd be nice if that use case was covered somehow.</p>\n<h4>Alternatives</h4>\n<p>An alternative that would be even better for my purposes is a direct snapshotting API as discussed in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">https://github.com/bytecodealliance/wasmtime/issues/3017</a>. But I expect such an API to be _much_ harder to implement and the requirement might be that it also works with a non-empty call stack. The feature proposed here would be a minimal addition to implement snapshotting of an instance with an empty call stack manually.</p>\n<p>Another option is that there already is a way to do this and I just wasn't able to find it.</p>\n<h4>Notes</h4>\n<p>Background info: My motivation for this is adding support for automic <a href=\"https://github.com/typst/typst/pull/5779\">behind-the-scenes multi-threading for Typst's plugin system</a>. Typst uses <code>wasmi</code> rather than <code>wasmtime</code>, but I'm proposing the feature here first, because as far as I can tell, wasmi's API mostly mirrors wasmtime's, so proposing it here first seemed more fruitful to me.</p>\n<p>[^1]: I'm not taking any of the WebAssembly extensions into account here, which I don't intend to support at this time. I'm not sure whether they would add complication, but e.g. multi-memories might.</p>\n</blockquote>",
        "id": 496746147,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738234462
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156#issuecomment-2624182077\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156\">issue #10156</a>:</p>\n<blockquote>\n<p>Wizer handles this by intrumenting (modifying) the wasm module to allow access to non-exported globals and memories: <a href=\"https://github.com/bytecodealliance/wizer/blob/main/src/instrument.rs\">https://github.com/bytecodealliance/wizer/blob/main/src/instrument.rs</a></p>\n</blockquote>",
        "id": 496748333,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738235124
    },
    {
        "content": "<p>laurmaedje <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156#issuecomment-2624200551\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156\">issue #10156</a>:</p>\n<blockquote>\n<p>Thanks for the info! I saw the <code>__wizer_global_{}</code> in <a href=\"http://snapshot.rs\">snapshot.rs</a>, but didn't make the connection to <a href=\"http://instrument.rs\">instrument.rs</a>, so was unsure how that worked.</p>\n<p>I expect doing it this way would add quite a bit of dependency burden on top of <code>wasmi</code> (and also some performance overhead for doing this at runtime). However, as a last resort, it would indeed work.</p>\n</blockquote>",
        "id": 496750050,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738235626
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156#issuecomment-2627731001\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156\">issue #10156</a>:</p>\n<blockquote>\n<p>Wasmtime doesn't support accessing unexported globals/functions/tables/etc, so purely using the <code>wasmtime</code> crate API you'll be unable to solve this goal. As @bjorn3 mentioned though what you're doing is very similar to what Wizer does and Wizer achieve this goal by modifying the wasm binary ahead-of-time.</p>\n<p>If you're interested in doing that it may not be too too hard to implement this by using a combination of <code>wasmparser</code> and <code>wasm-encoder</code>, likely using the <a href=\"https://docs.rs/wasm-encoder/latest/wasm_encoder/reencode/index.html\"><code>wasm_encoder::reencode</code></a> module.</p>\n</blockquote>",
        "id": 497042292,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738340433
    },
    {
        "content": "<p>laurmaedje <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156#issuecomment-2627758032\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156\">issue #10156</a>:</p>\n<blockquote>\n<p>Thanks for the link! Is it an explicit decision to not support this or is it just currently not supported? If it's the former, I of course respect that and would then probably embark on the wizer-like route. Though I'd still be curious if there's any particular reason why it would be a bad idea to have such an API.</p>\n</blockquote>",
        "id": 497044384,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738341103
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156#issuecomment-2627773755\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156\">issue #10156</a>:</p>\n<blockquote>\n<p>The former yeah, it's an intentional design decision to only give access to explicit exports. That enables opportunities for us to optimize more, for example.</p>\n</blockquote>",
        "id": 497045765,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738341572
    },
    {
        "content": "<p>laurmaedje closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156\">issue #10156</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>I'd like to access (list/get/set) the value of globals that were not explicitly exported by the module.</p>\n<h4>Benefit</h4>\n<p>I'm trying to take a snapshot of a store's state, so that I can spin up a second instance that is behaviourally equivalent to the first one. Crucially, I don't want to snapshot in the middle of a function call, just at rest when the call stack should be empty.</p>\n<p>I went through the WebAssembly instruction reference and as far as can tell, when I instantiate a new module, the only things I would need to restore would be the main memory size &amp; data and the globals.[^1] I'm already snapshotting the memory (which is required to be exported in my case), but I can't snapshot the globals as far as I can tell.</p>\n<p>As far as I'm aware, LLVM-based compilers will typically only have one internal global with a shadow stack pointer. Since I'm only snapshotting when the call stack is empty, I expect not snapshotting globals for now will not immediately break in practice, but it does not seem quite correct and of course not every WebAssembly module comes from LLVM. So it'd be nice if that use case was covered somehow.</p>\n<h4>Alternatives</h4>\n<p>An alternative that would be even better for my purposes is a direct snapshotting API as discussed in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">https://github.com/bytecodealliance/wasmtime/issues/3017</a>. But I expect such an API to be _much_ harder to implement and the requirement might be that it also works with a non-empty call stack. The feature proposed here would be a minimal addition to implement snapshotting of an instance with an empty call stack manually.</p>\n<p>Another option is that there already is a way to do this and I just wasn't able to find it.</p>\n<h4>Notes</h4>\n<p>Background info: My motivation for this is adding support for automic <a href=\"https://github.com/typst/typst/pull/5779\">behind-the-scenes multi-threading for Typst's plugin system</a>. Typst uses <code>wasmi</code> rather than <code>wasmtime</code>, but I'm proposing the feature here first, because as far as I can tell, wasmi's API mostly mirrors wasmtime's, so proposing it here first seemed more fruitful to me.</p>\n<p>[^1]: I'm not taking any of the WebAssembly extensions into account here, which I don't intend to support at this time. I'm not sure whether they would add complication, but e.g. multi-memories might.</p>\n</blockquote>",
        "id": 497051245,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738343388
    },
    {
        "content": "<p>laurmaedje <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156#issuecomment-2627831681\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10156\">issue #10156</a>:</p>\n<blockquote>\n<p>Okay thanks for all the info!</p>\n</blockquote>",
        "id": 497051246,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738343388
    }
]