[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10933\">issue #10933</a>:</p>\n<blockquote>\n<p>Currently in Wasmtime it's safe to acquire <code>&amp;mut wasmtime::runtime::vm::Instance</code> in various locations and this is used pervasively. Technically though this alone is not sound as it allows <code>mem::swap</code>-ing two instances. This would mean that the offsets, used to calculate the size of the allocation used for deallocation, could get mixed up (among other issues). Ideally we would have an abstraction which allows mutable access but disallows usage of <code>mem::swap</code>. In a sense this is similar to <code>StoreContextMut</code> which basically entirely exists to prevent <code>mem::swap</code>-ing two stores. This approach has a lot of ergonomic downsides though and it's not fun to write against.</p>\n<p>Another alternative is to assume that this basically doesn't happen (it's an internal type in Wasmtime, and it's pretty unlikely we reach for doing this naturally). That would mean we'd document on some <code>unsafe</code> block somewhere \"this requires auditing the entire codebase\" which practically wouldn't happen but would in-practice work alright.</p>\n<p>Another possible alternative would be something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">InstanceFields</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// what `struct Instance` is today</span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">Instance</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">fields</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">InstanceFields</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">_something_forcing_mut_ref_to_be_dst</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">],</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>We'd keep methods and such on <code>impl Instance { ... }</code> and <code>Instance</code> would itself be a dynamically sized type which would disallow overwriting the entire structure via the type system. Runtime-wise this would have a slight cost as passing it by reference passes two values and one value is always zero (the <code>_something_forcing_mut_ref_to_be_dst</code> would always be zero-length, we wouldn't want it to encompass the <code>VMContext</code> as that would inaccurately model how <code>&amp;Instance</code> actually has mutable provenance to <code>VMContext</code>, but if <code>[u8]</code> covered the whole field then it would also seemingly be only shared provenance). LLVM might be able to figure that out though with enough inlining?</p>\n<p>Perosnally I'm tempted to pursue this last solution of a dynamically-sized type. It would still require auditing the entire <code>vm/instance.rs</code> module (as you could still overwrite <code>InstanceFields</code> in there) but that's a much less daunting task than the entire codebase.</p>\n</blockquote>",
        "id": 522663413,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749154623
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10933#issuecomment-2946054058\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10933\">issue #10933</a>:</p>\n<blockquote>\n<p>I'll also note that after <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10934\">https://github.com/bytecodealliance/wasmtime/pull/10934</a> this issue is equally applicable to components as well.</p>\n</blockquote>",
        "id": 522663685,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749154758
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10933#issuecomment-2946177315\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10933\">issue #10933</a>:</p>\n<blockquote>\n<p>So basically Instance needs to be pinned?</p>\n</blockquote>",
        "id": 522667146,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749156468
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10933#issuecomment-2946196534\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10933\">issue #10933</a>:</p>\n<blockquote>\n<p>Hm yes good point that's a much better articulation! Handing out <code>&amp;mut Instance</code> would not be safe and we would instead have to use <code>Pin&lt;&amp;mut Instance&gt;</code> everywhere. Projection to each field would be unsafe but managable. That's probably a better idea than the DST trick I was thinking of.</p>\n</blockquote>",
        "id": 522667744,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749156756
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasm-proposal:component-model label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10933\">Issue #10933</a>.</p>",
        "id": 522856073,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749250679
    },
    {
        "content": "<p>fitzgen closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10933\">issue #10933</a>:</p>\n<blockquote>\n<p>Currently in Wasmtime it's safe to acquire <code>&amp;mut wasmtime::runtime::vm::Instance</code> in various locations and this is used pervasively. Technically though this alone is not sound as it allows <code>mem::swap</code>-ing two instances. This would mean that the offsets, used to calculate the size of the allocation used for deallocation, could get mixed up (among other issues). Ideally we would have an abstraction which allows mutable access but disallows usage of <code>mem::swap</code>. In a sense this is similar to <code>StoreContextMut</code> which basically entirely exists to prevent <code>mem::swap</code>-ing two stores. This approach has a lot of ergonomic downsides though and it's not fun to write against.</p>\n<p>Another alternative is to assume that this basically doesn't happen (it's an internal type in Wasmtime, and it's pretty unlikely we reach for doing this naturally). That would mean we'd document on some <code>unsafe</code> block somewhere \"this requires auditing the entire codebase\" which practically wouldn't happen but would in-practice work alright.</p>\n<p>Another possible alternative would be something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">InstanceFields</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// what `struct Instance` is today</span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">Instance</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">fields</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">InstanceFields</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">_something_forcing_mut_ref_to_be_dst</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">],</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>We'd keep methods and such on <code>impl Instance { ... }</code> and <code>Instance</code> would itself be a dynamically sized type which would disallow overwriting the entire structure via the type system. Runtime-wise this would have a slight cost as passing it by reference passes two values and one value is always zero (the <code>_something_forcing_mut_ref_to_be_dst</code> would always be zero-length, we wouldn't want it to encompass the <code>VMContext</code> as that would inaccurately model how <code>&amp;Instance</code> actually has mutable provenance to <code>VMContext</code>, but if <code>[u8]</code> covered the whole field then it would also seemingly be only shared provenance). LLVM might be able to figure that out though with enough inlining?</p>\n<p>Perosnally I'm tempted to pursue this last solution of a dynamically-sized type. It would still require auditing the entire <code>vm/instance.rs</code> module (as you could still overwrite <code>InstanceFields</code> in there) but that's a much less daunting task than the entire codebase.</p>\n</blockquote>",
        "id": 524033794,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749865951
    }
]