[
    {
        "content": "<p>rnxpyke opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10521\">issue #10521</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Currently it's not possible to have a mutable reference to custom store data <em>and</em> something like store memory at the same time.<br>\nE.g, the following doesn't compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">hostfunc</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Caller</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">CustomData</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"p\">):</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">buf</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">Extern</span><span class=\"p\">::</span><span class=\"n\">Memory</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">\"memory\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">panic!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span>\n<span class=\"w\">    </span><span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">caller</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>By changing the struct layout of <code>Caller&lt;'_, CustomData&gt;</code> into something like </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Caller</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"c1\">// caller without data</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>you can access the caller and data fields seperately.<br>\nThe compiler is smart enough to allow mutable references to disjoint struct fields.</p>\n<h4>Benefit</h4>\n<p>code like this would typecheck:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">hostfunc</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Context</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">CustomData</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"p\">):</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">buf</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">Extern</span><span class=\"p\">::</span><span class=\"n\">Memory</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">\"memory\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">panic!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span>\n<span class=\"w\">    </span><span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"n\">caller</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>when copying data to or especially from wasm memory, you can skip an additional allocation that would otherwise be necessary.</p>\n<h4>Implementation</h4>\n<p>Expose <code>data</code> and the wasm <code>Caller</code> / <code>Store</code> as seperate (public) struct fields.</p>\n<h4>Alternatives</h4>\n<p>Current workarounds to the concrete problem of copying memory would be</p>\n<ul>\n<li>allocating a dedicated buffer, copy from store -&gt; intermediate -&gt; data</li>\n<li>declare data.buf field as <code>Option&lt;Vec&lt;_&gt;&gt;</code>, and <code>buf.take().unwrap()</code> the buffer to get ownership of the value.</li>\n</ul>\n<p>both solutions have drawbacks.<br>\neither you introduce another allocation, or you give up on some type safety by unwrapping options.</p>\n</blockquote>",
        "id": 510013570,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743705943
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10521#issuecomment-2776671244\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10521\">issue #10521</a>:</p>\n<blockquote>\n<p>Can you use <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html#method.data_and_store_mut\"><code>Memory::data_and_store_mut</code></a> to solve your use case here?</p>\n</blockquote>",
        "id": 510015966,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743706725
    },
    {
        "content": "<p>rnxpyke <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10521#issuecomment-2780673688\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10521\">issue #10521</a>:</p>\n<blockquote>\n<p>hm, I didn't see that method when speed-reading the documentation.<br>\nI think this api would also solve my allocation issues. <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n<p>It's kinda confusing that in the context of a host function using the <code>Caller</code> struct, <code>data</code> refers to the generic type parameter T, but in the <code>Memory</code> struct it's swapped, data refers to raw bytes and store to the generic type.<br>\n</p>\n</blockquote>",
        "id": 510363588,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743852595
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10521#issuecomment-2783571538\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10521\">issue #10521</a>:</p>\n<blockquote>\n<p>It's true it's unfortunate, but we're only so good at naming...</p>\n<p>Given that it works for you though I'm going to close this, but if you have anything further feel free to post here as well</p>\n</blockquote>",
        "id": 510690976,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744036725
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10521\">issue #10521</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Currently it's not possible to have a mutable reference to custom store data <em>and</em> something like store memory at the same time.<br>\nE.g, the following doesn't compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">hostfunc</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Caller</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">CustomData</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"p\">):</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">buf</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">Extern</span><span class=\"p\">::</span><span class=\"n\">Memory</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">\"memory\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">panic!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span>\n<span class=\"w\">    </span><span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">caller</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>By changing the struct layout of <code>Caller&lt;'_, CustomData&gt;</code> into something like </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">Context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Caller</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"c1\">// caller without data</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>you can access the caller and data fields seperately.<br>\nThe compiler is smart enough to allow mutable references to disjoint struct fields.</p>\n<h4>Benefit</h4>\n<p>code like this would typecheck:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">hostfunc</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Context</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">CustomData</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"p\">):</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">buf</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">Extern</span><span class=\"p\">::</span><span class=\"n\">Memory</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">caller</span><span class=\"p\">.</span><span class=\"n\">get_export</span><span class=\"p\">(</span><span class=\"s\">\"memory\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">panic!</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span>\n<span class=\"w\">    </span><span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ctx</span><span class=\"p\">.</span><span class=\"n\">caller</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>when copying data to or especially from wasm memory, you can skip an additional allocation that would otherwise be necessary.</p>\n<h4>Implementation</h4>\n<p>Expose <code>data</code> and the wasm <code>Caller</code> / <code>Store</code> as seperate (public) struct fields.</p>\n<h4>Alternatives</h4>\n<p>Current workarounds to the concrete problem of copying memory would be</p>\n<ul>\n<li>allocating a dedicated buffer, copy from store -&gt; intermediate -&gt; data</li>\n<li>declare data.buf field as <code>Option&lt;Vec&lt;_&gt;&gt;</code>, and <code>buf.take().unwrap()</code> the buffer to get ownership of the value.</li>\n</ul>\n<p>both solutions have drawbacks.<br>\neither you introduce another allocation, or you give up on some type safety by unwrapping options.</p>\n</blockquote>",
        "id": 510690977,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744036725
    }
]