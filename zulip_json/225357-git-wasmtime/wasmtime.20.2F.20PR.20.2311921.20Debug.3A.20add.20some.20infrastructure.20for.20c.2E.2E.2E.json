[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921\">PR #11921</a> from <code>cfallin:wasmtime-debug-callbacks-pulley</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>This is a followup to #11895 where I had disabled a test that failed to emit a debug event for a hostcall-generated trap on a divide-by-zero in Pulley. This PR allows that test to pass, and brings Pulley back to parity with native Cranelift in debug support currently.</p>\n<p>This was a bit of a \"start to pull the thread and the entire finished mechanism materializes\" PR; happy to consider ways to split it up if needed. In short, disabling signal-based traps on a Pulley configuration still relies on Pulley opcodes (e.g., divide) actually trapping, in a way that looks more like a \"native ISA trap\"; so I had to start to build out the actual trap-handling mechanisms. In any case, this will all be needed for followup work soon that will handle traps on native platforms (redirecting from signals by injecting calls), so this is not a distraction.</p>\n<p>This PR includes, ranked in decreasing order of \"may scare other Wasmtime maintainers\" score:</p>\n<ul>\n<li>\n<p>A raw <code>NonNull&lt;dyn VMStore&gt;</code> in the <code>CallThreadState</code>, with a long comment about provenance and mut-borrow exclusivity. This is needed right now to allow the interpreter to invoke the debug event handler, but will soon be needed when injecting hostcalls on signals, because a signal context also has no state available from the Wasm code other than what is in TLS. Hence, we need a way to get the store back from the Wasm when we do something that is \"morally a hostcall\" at a trapping instruction.</p>\n<p>I do believe this is sound, or at least close to it if not (please scrutinize carefully!); the basic idea is that the Wasm acts as an opaque blob in the middle, and the pointer comes out of it one way or another (the normal way, as the first arg to a hostcall, or the weird way, via TLS and the CallThreadState during a trap). Exclusive ownership is still clear at any given point and only one <code>&amp;mut</code> ever exists in the current frame at a time. That said, I haven't tested with miri yet.</p>\n<p>This does require careful thought about the Wasm compilation, too; we need the moral equivalent of a <code>&amp;mut self</code> reborrow as-if we were making a hostcall on each trapping instruction. It turns out that we already treat them as memory-fence instructions, so nothing loaded from the store can be moved or cached across them, and I've added a comment now about how this is load-bearing.</p>\n</li>\n<li>\n<p>Updates to <code>CallThreadState</code>'s \"exit state\", normally set by the exit trampoline, that we now also set when we invoke a debug event handler during a trap context[^1] so that <code>Store::debug_frames</code> properly sees the current activation. This is a little more awkward than it could be because we store the <em>tramopline</em> FP, not last Wasm FP, and there is no trampoline frame in this case, so I've added a flag and some conditionals. I'm happy to refactor instead to go (back) to storing the last Wasm FP instead, with the extra load in the exit trampoline to compute that.</p>\n</li>\n<li>\n<p>A whole bunch of plumbing, creating a large but mechanical diff, in the code translator to actually add debug tags on all traps and calls to <code>raise</code>. It turns out that once I got all of the above working in Pulley, the test disagreed about current Wasm PC between native and Pulley, and Pulley was right; native was getting it wrong because the <code>ud2</code> was sunk to the bottom in a cold block and, without tags, we scanned backward to pick up the last Wasm PC in the function. This new plumbing and addition of tags in all the appropriate places fixes that.</p>\n</li>\n</ul>\n<p>[^1]: I keep saying \"during a trap context\" here, but to avoid any<br>\n      signal-safety scares, note that when this is done for native<br>\n      signals in a followup PR, we will inject a hostcall by modifying<br>\n      stack/register state and returning from the actual signal context,<br>\n      so it really is as-if we did a hostcall from a trapping<br>\n      instruction.</p>\n<p>&lt;!--<br>\nPlease make sure you include the following information:</p>\n<ul>\n<li>\n<p>If this work has been discussed elsewhere, please include a link to that<br>\n  conversation. If it was discussed in an issue, just mention \"issue #...\".</p>\n</li>\n<li>\n<p>Explain why this change is needed. If the details are in an issue already,<br>\n  this can be brief.</p>\n</li>\n</ul>\n<p>Our development process is documented in the Wasmtime book:<br>\n<a href=\"https://docs.wasmtime.dev/contributing-development-process.html\">https://docs.wasmtime.dev/contributing-development-process.html</a></p>\n<p>Please ensure all communication follows the code of conduct:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md\">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>\n--&gt;</p>\n</blockquote>",
        "id": 546575258,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761182580
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers\">wasmtime-compiler-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921\">PR #11921</a>.</p>",
        "id": 546575259,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761182581
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921\">PR #11921</a>.</p>",
        "id": 546575260,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761182581
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921\">PR #11921</a>.</p>",
        "id": 546575261,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761182581
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921\">PR #11921</a>.</p>",
        "id": 546575565,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761182840
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921\">PR #11921</a>.</p>",
        "id": 546575687,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761182976
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921\">PR #11921</a>:</p>\n<blockquote>\n<p>This is a followup to #11895 where I had disabled a test that failed to emit a debug event for a hostcall-generated trap on a divide-by-zero in Pulley. This PR allows that test to pass, and brings Pulley back to parity with native Cranelift in debug support currently.</p>\n<p>This was a bit of a \"start to pull the thread and the entire finished mechanism materializes\" PR; happy to consider ways to split it up if needed. In short, disabling signal-based traps on a Pulley configuration still relies on Pulley opcodes (e.g., divide) actually trapping, in a way that looks more like a \"native ISA trap\"; so I had to start to build out the actual trap-handling mechanisms. In any case, this will all be needed for followup work soon that will handle traps on native platforms (redirecting from signals by injecting calls), so this is not a distraction.</p>\n<p>This PR includes, ranked in decreasing order of \"may scare other Wasmtime maintainers\" score:</p>\n<ul>\n<li>\n<p>A raw <code>NonNull&lt;dyn VMStore&gt;</code> in the <code>CallThreadState</code>, with a long comment about provenance and mut-borrow exclusivity. This is needed right now to allow the interpreter to invoke the debug event handler, but will soon be needed when injecting hostcalls on signals, because a signal context also has no state available from the Wasm code other than what is in TLS. Hence, we need a way to get the store back from the Wasm when we do something that is \"morally a hostcall\" at a trapping instruction.</p>\n<p>I do believe this is sound, or at least close to it if not (please scrutinize carefully!); the basic idea is that the Wasm acts as an opaque blob in the middle, and the pointer comes out of it one way or another (the normal way, as the first arg to a hostcall, or the weird way, via TLS and the CallThreadState during a trap). Exclusive ownership is still clear at any given point and only one <code>&amp;mut</code> ever exists in the current frame at a time. That said, I haven't tested with miri yet.</p>\n<p>This does require careful thought about the Wasm compilation, too; we need the moral equivalent of a <code>&amp;mut self</code> reborrow as-if we were making a hostcall on each trapping instruction. It turns out that we already treat them as memory-fence instructions, so nothing loaded from the store can be moved or cached across them, and I've added a comment now about how this is load-bearing.</p>\n</li>\n<li>\n<p>Updates to <code>CallThreadState</code>'s \"exit state\", normally set by the exit trampoline, that we now also set when we invoke a debug event handler during a trap context[^1] so that <code>Store::debug_frames</code> properly sees the current activation. This is a little more awkward than it could be because we store the <em>trampoline</em> FP, not last Wasm FP, and there is no trampoline frame in this case, so I've added a flag and some conditionals. I'm happy to refactor instead to go (back) to storing the last Wasm FP instead, with the extra load in the exit trampoline to compute that.</p>\n</li>\n<li>\n<p>A whole bunch of plumbing, creating a large but mechanical diff, in the code translator to actually add debug tags on all traps and calls to <code>raise</code>. It turns out that once I got all of the above working in Pulley, the test disagreed about current Wasm PC between native and Pulley, and Pulley was right; native was getting it wrong because the <code>raise</code> libcall was sunk to the bottom in a cold block and, without tags, we scanned backward to pick up the last Wasm PC in the function. This new plumbing and addition of tags in all the appropriate places fixes that.</p>\n</li>\n</ul>\n<p>[^1]: I keep saying \"during a trap context\" here, but to avoid any<br>\n      signal-safety scares, note that when this is done for native<br>\n      signals in a followup PR, we will inject a hostcall by modifying<br>\n      stack/register state and returning from the actual signal context,<br>\n      so it really is as-if we did a hostcall from a trapping<br>\n      instruction.</p>\n<p>&lt;!--<br>\nPlease make sure you include the following information:</p>\n<ul>\n<li>\n<p>If this work has been discussed elsewhere, please include a link to that<br>\n  conversation. If it was discussed in an issue, just mention \"issue #...\".</p>\n</li>\n<li>\n<p>Explain why this change is needed. If the details are in an issue already,<br>\n  this can be brief.</p>\n</li>\n</ul>\n<p>Our development process is documented in the Wasmtime book:<br>\n<a href=\"https://docs.wasmtime.dev/contributing-development-process.html\">https://docs.wasmtime.dev/contributing-development-process.html</a></p>\n<p>Please ensure all communication follows the code of conduct:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md\">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>\n--&gt;</p>\n</blockquote>",
        "id": 546575704,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761182997
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921\">PR #11921</a>.</p>",
        "id": 546584061,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761190534
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#pullrequestreview-3371715274\">PR review</a>.</p>",
        "id": 546742451,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761243088
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2456551359\">PR review comment</a>:</p>\n<blockquote>\n<p>Personally I'm a bit wary about how this is an ever-expanding structure with a huge matrix of fields all customized for various purposes. Especially with a whole litany of <code>last_*</code> fields for all sorts of purposes it's kind of hard to keep it all straight.</p>\n<p>Especially when I think these fields aren't actually modified from compiled code at all, would it be possible to store this elsewhere and/or infer it from control flow and/or other state? For example instead of <code>last_wasm_exit_trap_fp</code> could this store directly in <code>last_wasm_exit_trampoline_fp</code>? And instead of storing <code>last_wasm_exit_was_trap</code> could that be carried around as a paramter in relevant locations instead?</p>\n</blockquote>",
        "id": 546742452,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761243089
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2456543360\">PR review comment</a>:</p>\n<blockquote>\n<p>It looks like the only use of this is the interpreter bits, and for that the <code>trap</code> functionality already has a <code>VMContext</code> in scope. Would it be possible to use that <code>VMContext</code> already there instead of storing this here?</p>\n</blockquote>",
        "id": 546742454,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761243089
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2456514280\">PR review comment</a>:</p>\n<blockquote>\n<p>To confirm, you see no way this field could be stored in <code>FuncEnvironment</code> somehow? This is a lot of plumbing...</p>\n</blockquote>",
        "id": 546742455,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761243089
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2456558040\">PR review comment</a>:</p>\n<blockquote>\n<p>One of my worries is that as this state grows and grows more for all sorts of one-off things it becomes more and more difficult to ensure that everything is always kept in sync with everything else. I find it's more robust to reuse existing state and/or minimize state where possible to ensure that everything is exercised more often, where possible at least</p>\n</blockquote>",
        "id": 546742456,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761243089
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#pullrequestreview-3371821679\">PR review</a>.</p>",
        "id": 546743821,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761243640
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2456607064\">PR review comment</a>:</p>\n<blockquote>\n<p>We could, potentially; I don't know why it was originally designed this way. I'm happy to put together a separate refactor PR to move <code>stacks</code> under <code>env</code> (at worst there is some borrowing-related reason I haven't seen and I'll run into a roadblock there).</p>\n</blockquote>",
        "id": 546743822,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761243640
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2456636441\">PR review comment</a>:</p>\n<blockquote>\n<p>We could get to it through that <code>VMContext</code> and then <code>VMStoreContext</code>, but then two things:</p>\n<ul>\n<li>We'd need to add an equivalent field (a backpointer) to the <code>VMStoreContext</code> to get to the <code>dyn VMStore</code>; so we wouldn't be removing this field, only moving it; and</li>\n<li>We need this in followup work (my next PR) outside of an interpreter context, when we inject calls into the runtime on signals and we don't have a vmctx (we know nothing about the register state we've walked in on during the signal).</li>\n</ul>\n<p>In the latter case we can still get the <code>VMStoreContext</code> from the <code>CallThreadState</code> from TLS; so the question is just, do we want to add a layer of indirection and put the <code>NonNull&lt;dyn VMStore&gt;</code> there instead (but on the flip side, not have to set it on every Wasm entry). Happy to go either way...</p>\n</blockquote>",
        "id": 546744656,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761243977
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#pullrequestreview-3371854234\">PR review</a>.</p>",
        "id": 546744657,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761243978
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2456658356\">PR review comment</a>:</p>\n<blockquote>\n<p>Unfortunately not, as far as I can tell:</p>\n<p>The basic problem is that we have a <code>Store</code> (or <code>StoreContextMut</code>) exposed to the debug callback. That Store fundamentally has to know about the last activation so it can provide a view into those frames (via <code>debug_frames</code>). The way that we view the stack depends on exactly how the host entry occurred, and a trap is a new kind of host entry -- previously we didn't actually enter all that far into host code, only far enough to do the <code>raise</code> and return back out on the other side. There's no direct call-parameter dataflow we can add this onto; we aren't calling into the debug handler with some special thing that already has interpreted the debug frames, we're giving it the full Store. In particular, a trapping context means that we interpret PC differently: it points to the trapping instruction, not the instruction-after as in calls. So this logically belongs with the \"end of the last activation\" state: it's required to interpret the exit PC/FP. Also, because there's no trampoline, reusing <code>last_wasm_exit_trampoline_fp</code> is the wrong choice I think.</p>\n<p>I also share your unease with the ugliness here, and I think the one possible cleanup I see is to refactor back to storing the last Wasm FP, not trampoline FP. What do you think?</p>\n<ul>\n<li></li>\n</ul>\n</blockquote>",
        "id": 546745638,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761244315
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#pullrequestreview-3371880108\">PR review</a>.</p>",
        "id": 546745639,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761244316
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2456658356\">PR review comment</a>.</p>",
        "id": 546745665,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761244325
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#pullrequestreview-3371899935\">PR review</a>.</p>",
        "id": 546746293,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761244546
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2456675067\">PR review comment</a>:</p>\n<blockquote>\n<p>Also, regarding storing elsewhere: because it's part of the \"last activation\" state, it needs to be saved/restored along with other parts of the <code>VMStoreContext</code> when, for example, <code>CallThreadState</code>s are pushed/popped on the activation chain when fibers suspend. That all works with immutable borrows today and directly accesses the unsafe cells in this location; that's why I kept it here and not somewhere else.</p>\n</blockquote>",
        "id": 546746294,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761244547
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2457010217\">PR review comment</a>:</p>\n<blockquote>\n<p>OK, I've gone down this road a bit, but I don't think it's any better: the diff is huge (+1446 -938 so far, and I'm only ~a third done), and moreover it doesn't actually improve the plumbing situation here: there are still plenty of places where neither <code>stacks</code> nor <code>env</code> was available where we fundamentally need one or the other to get the debug tags right.</p>\n</blockquote>",
        "id": 546757852,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761248831
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#pullrequestreview-3372288458\">PR review</a>.</p>",
        "id": 546757853,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761248831
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2457023945\">PR review comment</a>:</p>\n<blockquote>\n<p>(To give a more principled argument why: we now need some metadata everywhere we could have a trap. We currently have a bunch of places low in the abstraction stack where we <em>only</em> have the Cranelift-level function builder, and some raw SSA values, and we're generating logic that could trap. Previously this was fine because we just added a static trap code indicating the kind of trap, and SourceLocs already track where we are. Now we need more metadata, e.g. for the stack shape. So fundamentally we need to carry that somehow and we have <em>no</em> Wasmtime-specific place to hang it now.)</p>\n</blockquote>",
        "id": 546758453,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761249063
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#pullrequestreview-3372306373\">PR review</a>.</p>",
        "id": 546758457,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761249063
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921\">PR #11921</a>.</p>",
        "id": 546764077,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761251267
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#pullrequestreview-3372508985\">PR review</a>.</p>",
        "id": 546764215,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761251321
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2457193363\">PR review comment</a>:</p>\n<blockquote>\n<p>I did the refactor to remove \"trampoline FP\" (in normal case) and \"trap FP\" (in trap case) bifurcation in favor of one FP in 7fd1f60e7c. We still need the <code>was_trap</code> state (and to save/restore it); there's no way to avoid that bit as far as I can tell.</p>\n</blockquote>",
        "id": 546764216,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761251321
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921\">PR #11921</a>.</p>",
        "id": 546766996,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761252479
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#pullrequestreview-3378751223\">PR review</a>.</p>",
        "id": 547000728,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761340570
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2461966079\">PR review comment</a>:</p>\n<blockquote>\n<p>Thinking more about this, this isn't sound due to the active use of TLS when an async function is invoked (e.g. handling a debug event). That might involve a fiber/thread switch which means that resumption on another thread would break the <code>tls::with</code> block.</p>\n<p>Somehow, I'm not sure how best how, but the invocation of the debug handler needs to be outside of <code>tls::with</code>. This is also why I tried really hard recently to get all async invocations to \"the libcall calls it and nothing else\" and this is effectively a regression from that where we're back to the state of \"deep in the bowels of the runtime all of a sudden there's a fiber switch\".</p>\n<p>Basically I think this might be worth rethinking how the async interface is implemented in the runtime. For example something should have prevented this construction in the first place via some sort of \"need to be in <code>async</code> context but not safely in an <code>async</code> context\".</p>\n</blockquote>",
        "id": 547000729,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761340571
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2461974508\">PR review comment</a>:</p>\n<blockquote>\n<p>Also, thinking a bit more on this, I think we should explicitly document debugging support as not tier 1 (either 2 or 3, probably 3 while it's in-progress) and possibly consider disabling it by default instead of enabling it by default. Given the pretty large amount of new <code>unsafe</code> and new primitives being written for it I wouldn't be confident enough myself to guarantee it's \"likely CVE-free\" until we've had a good deal more time to think about the unsafe primitives, fuzz things, etc.</p>\n</blockquote>",
        "id": 547000730,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761340571
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2461947717\">PR review comment</a>:</p>\n<blockquote>\n<p>Well, if the goal is to put this field here, then that leads to other questions for me:</p>\n<ul>\n<li>Much of the rest of the state in <code>CallThreadState</code> exists because it doesn't have a pointer to <code>Store</code>, so if one was added then it seems like all the state here should be removed in favor of accessing it through the store.</li>\n<li>Have you run this through the Miri tests? I think that this may be miri-unsound at a first glance (but I've got about a 70% hit rate on predicting this so not great). The <code>dyn VMStore</code> is passed to <code>CallThreadState::new</code> which gets a raw pointer from that, but immediately later the store is accessed <code>store.0.executor()</code> which I believe effectively invalidates the previously acquired mutable pointer.</li>\n<li>In general I don't really understand the provenance comment here. My understanding is that the invariant we need to uphold is that (a) when we enter wasm we start with a safe <code>VMStore</code>reference and (b) when in wasm all usage of <code>VMStore</code> is derived from either that raw pointers or other raw pointers originally derived. I don't know why that would limit usage of the store to just the trap handler or why Cranelift's optimizations or such would come into play here. </li>\n</ul>\n<p>Put another way, if this field exists then I think other store-related fields should all be deleted to avoid having state to keep in sync. Taking this provenance comment as-is means that it's not actually possible to do that because the field can only be used during traps, but I don't think that's accurate which means that I don't think the comment here is accurate.</p>\n<p>For Miri-things I think ideally a <code>CallThreadState</code> would have a lifetime parameter which is a phantom borrow of the <code>&amp;'a mut dyn VMStore</code> which logically ensures that while the <code>CallThreadState</code> is active all usage of the store must be derived from the state itself rather than via external borrows.</p>\n</blockquote>",
        "id": 547000731,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761340571
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2461912848\">PR review comment</a>:</p>\n<blockquote>\n<p>Well the current state here is that we pass in three different \"context\" style arguments which are basically just plumbed everywhere. I don't really know how best to address it, but it feels not great to pass so many context-style arguments all over the place. I'm not disputing that <code>FuncTranslationStacks</code> is needed, I'm mostly wondering why it's not possible to reduce all the boilerplate.</p>\n<blockquote>\n<p>we have no Wasmtime-specific place to hang it now</p>\n</blockquote>\n<p>How come this isn't <code>FuncEnvironment</code>? Isn't that Wasmtime-specific?</p>\n<hr>\n<p>On one hand I don't want to necessarily add more work to this PR and it's ok to address some othe time. On the other hand though it also feels likely that the next time this happens we'll have 4 context arguments to pass everywhere because for one reason or another it won't fit into the other contexts. Personally I feel like it's worth investigating why so many context arguments are needed here and whether something can be changed to adjust this (as a separate PR, but not an indefinitely-delayed PR to happen in the future).</p>\n<p>For example one thing to try would indeed be a fourth context which has pointers/references to all 3 other contexts. That fourth context is then the only context passed everywhere and methods/etc are all updated to be on the fourth context. This to me would decrease the cognitive load where there's still just a single context to actually worry about and the only minor detail is that the constituent parts of said context come from different locations which necessesitates a few wrapper structures.</p>\n</blockquote>",
        "id": 547000732,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761340571
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2462028496\">PR review comment</a>:</p>\n<blockquote>\n<p>So the basic issue is that <code>FuncEnvironment</code> is not plumbed everywhere; that is why I mentioned that we need <em>some</em> new plumbing in any case. Many of the places that didn't have <code>stacks</code> also did not have the environment.</p>\n<p>I plumbed through the bit that we need (<code>stacks</code>) but if we put <code>stacks</code> in the environment, we now need (i) a huge diff to do that refactor, and (ii) to add the required plumbing anyway. That's all I'm trying to say: I don't think there's a nice clean small diff we can have in this PR, it has to have a lot of churn to get the information we need.</p>\n<p>I agree refactoring this all would be nice. Ideally not in this PR!</p>\n</blockquote>",
        "id": 547002098,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761341450
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#pullrequestreview-3378912058\">PR review</a>.</p>",
        "id": 547002099,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761341451
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#pullrequestreview-3379064797\">PR review</a>.</p>",
        "id": 547006100,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761344046
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2462133985\">PR review comment</a>:</p>\n<blockquote>\n<p>I haven't figured out how to run this in miri yet (the furthest I've gotten is the blanket prohibition on Cranelift-compiling code with the error that results in me putting <code>#[cfg_attr(miri, ignore)]</code> on all my tests, but I haven't put any time into looking at how you've built miri testing elsewhere). I should definitely do that.</p>\n<p>That said, a few thoughts:</p>\n<ul>\n<li>\n<p>I agree a broader refactor to have just a <code>dyn VMStore</code> pop out the other side of <code>CallThreadState</code> would actually be ideal, then make this well-tested, well-vetted, and standardize on it. In general it seems like we've plumbed through <em>just enough</em> state for the things that we do need when we get control without a vmctx; doing this right once would be best.</p>\n</li>\n<li>\n<p>I tried to limit this to \"during traps\" to make the distinction about whether we have a <code>vmctx</code> passed in via a normal hostcall route or not. Basically, there is always one way that the root of ownership of the store passes back into the host: either via TLS -&gt; CallThreadState -&gt; VMStoreContext -&gt; raw VMStore pointer (trap route) or via vmctx -&gt; <code>Instance</code> -&gt; store pointer (<code>Instance::enter_store_from_wasm</code> route for libcalls).</p>\n<p>Technically I don't see a reason why we couldn't <em>always</em> use the TLS route, except for the obvious one, performance (and then the fiber-suspend one which you raise below, about which more thoughts below...).</p>\n<p>All of this hinges on my understanding of provenance which is that (true mut borrow) -&gt; (multiple raw pointers) -&gt; (true mut borrow derived from one of those raw pointers) is safe, i.e., you can pick one of multiple dataflow paths to get your raw pointer, and the others are just invalidated and must not be used. That should be what's going on here.</p>\n</li>\n<li>\n<p>On Cranelift optimizations: we're accustomed to thinking about Wasm as opaque, and considering only the provenance story on the Rust side, but it's important to think about what provenance means in a general compiler sense and ensuring we're not committing the same sins on the other side. In particular, if we have an implicit hostcall on trap, that's as-if we create a new <code>&amp;mut Store</code>, so just as provenance exists as a concern on the Rust side because language semantics around aliasing are load-bearing for optimizations, we have alias analysis and optimizations on the Cranelift side too. My point there is that we must ensure we have no cached state loaded from the store across any trapping instruction if we do this implicit hostcall thing; that would be exactly equivalent to an exclusive-mut-borrow violation on the Rust side. The reason this is discussed at all in this context is that we are taking the <code>&amp;mut dyn VMStore</code> now and using it, so we're creating this limitation on the Cranelift side. One depends on the other.</p>\n</li>\n</ul>\n</blockquote>",
        "id": 547006101,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761344046
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#pullrequestreview-3379073981\">PR review</a>.</p>",
        "id": 547006233,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761344191
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#discussion_r2462139067\">PR review comment</a>:</p>\n<blockquote>\n<p>Hmm. I agree we can address this by pulling the state out of the <code>tls::with</code> somehow -- i.e., the raw store pointer. We're not doing any store ownership yielding if we fiber-suspend so there's nothing unsafe with keeping that around across suspends, I think (correct me if I'm wrong?), so I just need to restructure my closure-based helpers?</p>\n</blockquote>",
        "id": 547006234,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761344191
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921#issuecomment-3445109601\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11921\">PR #11921</a>:</p>\n<blockquote>\n<p>Thanks for all your comments so far, @alexcrichton! A few overall thoughts:</p>\n<ul>\n<li>\n<p>In parallel to this, over in #11930, I have started to realize that injecting implicit hostcalls during traps may not be worth the complexity given variations in signal-handling quirks between platforms (got it working on Linux but each of macOS and Windows need different design bits). If that goes away and we require hostcall-based traps everywhere, then the only remaining \"debugger gets control outside of a libcall\" situation is Pulley's use of trapping instructions (e.v. my div-by-zero test which this PR enables), and there I'd prefer to refactor to make Pulley use true hostcall-based traps in those cases too.</p>\n<p>So if we go that way, we avoid the need to re-enter the runtime without a <code>vmctx</code> passed to us the normal way; and all of these ownership/provenance questions go away.</p>\n</li>\n<li>\n<p>That said: I realize I'm fighting a somewhat uphill battle on store provenance, but I do suspect it might be a need elsewhere in the future, for example if we do want to enable signal-based traps in debugging for performance later. At a high level the ownership handoff is dynamically valid; and the overall scheme should be compatible with stacked borrows (one mut borrow -&gt; multiple raw pointers -&gt; one mut borrow derived from one of them). I'm happy to keep talking about this and try for a refactor where we shift to one raw store pointer in the <code>CallThreadState</code> and derive other things (unsafe-intrinsics' <code>T</code> pointer, the <code>VMStoreContext</code>, ...) from that. That would give us a framework with fewer limitations for future work. The trick is finding the right abstraction for a safe API, I think...</p>\n</li>\n<li>\n<p>That also said, it occurs to me that the <code>Accessor</code> mechanism, with its TLS mechanism already vetted, could be an alternate foundation for all of this. (We already know it's the eventual alternate foundation for all of this, but I mean even in a callback world.) Basically, transfer ownership of the debug handler if any to the CallThreadState on entry and take back on exit; then that's <em>all</em> we need to invoke the handler, and it can keep its locally captured <code>Access</code>.</p>\n<p>I don't necessarily want to create a dependency on all of the refactoring you are planning to do around that, though...</p>\n</li>\n</ul>\n</blockquote>",
        "id": 547007130,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761344978
    }
]