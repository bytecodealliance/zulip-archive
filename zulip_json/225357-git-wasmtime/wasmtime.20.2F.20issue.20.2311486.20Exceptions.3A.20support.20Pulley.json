[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11486\">issue #11486</a>:</p>\n<blockquote>\n<p>The exception-handling support as implemented in #11326 does not yet support Pulley. It is almost there, but not quite:</p>\n<ul>\n<li>Pulley's use of Cranelift for code generation means that we <em>do</em> get exception metadata alongside Pulley bytecode, and a module that uses exceptions can be <em>compiled</em>;</li>\n<li>The support for stack-walking of Pulley stacks means that the exception unwinder <em>can</em> find handlers in Pulley code;</li>\n<li>However, the <code>raise</code> libcall implementation that Pulley uses does not account for <code>UnwindState::UnwindToWasm</code>. This means that we'll reach host-to-Wasm entry instead, with an unexpected unwind state, and panic.</li>\n</ul>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11326#issuecomment-3201732110\">this comment</a> I outline an alternative approach: we should</p>\n<ul>\n<li>invoke the real <code>raise</code> libcall, just as we do other libcalls, from Pulley;</li>\n<li>when we enter <code>unwind</code>, and either <code>wasmtime_longjmp()</code> or <code>wasmtime_unwinder::resume_to_exception_handler()</code>, we instead check the store's executor and<ul>\n<li>on native code, do as we do today</li>\n<li>on Pulley, update the Pulley interpreter state appropriately</li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 535416775,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755742642
    },
    {
        "content": "<p><a href=\"https://github.com/cfallin\">cfallin</a> added the pulley label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11486\">Issue #11486</a>.</p>",
        "id": 535416776,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755742643
    },
    {
        "content": "<p><a href=\"https://github.com/cfallin\">cfallin</a> added the wasm-proposal:exceptions label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11486\">Issue #11486</a>.</p>",
        "id": 535416777,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755742643
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11486#issuecomment-3208753504\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11486\">issue #11486</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"pulley\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: pulley</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 535416814,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755742674
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11486\">issue #11486</a>:</p>\n<blockquote>\n<p>The exception-handling support as implemented in #11326 does not yet support Pulley. It is almost there, but not quite:</p>\n<ul>\n<li>Pulley's use of Cranelift for code generation means that we <em>do</em> get exception metadata alongside Pulley bytecode, and a module that uses exceptions can be <em>compiled</em>;</li>\n<li>The support for stack-walking of Pulley stacks means that the exception unwinder <em>can</em> find handlers in Pulley code;</li>\n<li>However, the <code>raise</code> libcall implementation that Pulley uses does not account for <code>UnwindState::UnwindToWasm</code>. This means that we'll reach host-to-Wasm entry instead, with an unexpected unwind state, and panic.</li>\n</ul>\n<p>In <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11326#issuecomment-3201732110\">this comment</a> I outline an alternative approach: we should</p>\n<ul>\n<li>invoke the real <code>raise</code> libcall, just as we do other libcalls, from Pulley;</li>\n<li>when we enter <code>unwind</code>, and either <code>wasmtime_longjmp()</code> or <code>wasmtime_unwinder::resume_to_exception_handler()</code>, we instead check the store's executor and<ul>\n<li>on native code, do as we do today</li>\n<li>on Pulley, update the Pulley interpreter state appropriately</li>\n</ul>\n</li>\n</ul>\n</blockquote>",
        "id": 535588972,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755816170
    }
]