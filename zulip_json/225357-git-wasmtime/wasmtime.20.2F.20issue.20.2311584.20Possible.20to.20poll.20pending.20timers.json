[
    {
        "content": "<p>ignatz opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<p>Hey folks,</p>\n<p>I've been bumbling around the code-base trying to keep \"pumping\"/polling an instance with pending timers.</p>\n<p>In essence, I'm using wasi_http to send handle an HTTP request with a guest. So far so good. If the handler installs a timer I would like to keep polling beyond</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">response</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">proxy</span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"n\">wasi_http_incoming_handler</span><span class=\"p\">()</span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"n\">call_handle</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">req</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"p\">)</span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span>\n<span class=\"w\"> </span><span class=\"err\">```</span>\n\n<span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">assume</span><span class=\"w\"> </span><span class=\"n\">timers</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">captures</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"o\">'</span><span class=\"na\">s</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">resource_table</span><span class=\"err\">`</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">However</span><span class=\"w\"> </span><span class=\"n\">IIUC</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">resource_table</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">deliberately</span><span class=\"w\"> </span><span class=\"n\">opaque</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">don</span><span class=\"o\">'</span><span class=\"na\">t</span><span class=\"w\"> </span><span class=\"n\">have</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">particular</span><span class=\"w\"> </span><span class=\"n\">resource</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">poll</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Is</span><span class=\"w\"> </span><span class=\"n\">there</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"n\">particular</span><span class=\"w\"> </span><span class=\"n\">way</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">me</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">timers</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"o\">/</span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">keep</span><span class=\"w\"> </span><span class=\"n\">polling</span><span class=\"o\">?</span>\n<span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 537282629,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756818407
    },
    {
        "content": "<p>ignatz edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<p>Hey folks,</p>\n<p>I've been bumbling around the code-base trying to keep \"pumping\"/polling an \"instance\" for pending timers.</p>\n<p>In essence, I'm using wasi_http to send handle an HTTP request with a guest. So far so good. If the handler installs a timer I would like to keep polling beyond</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">response</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">proxy</span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"n\">wasi_http_incoming_handler</span><span class=\"p\">()</span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"n\">call_handle</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">req</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"p\">)</span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span>\n<span class=\"w\"> </span><span class=\"err\">```</span>\n\n<span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">assume</span><span class=\"w\"> </span><span class=\"n\">timers</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">captures</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"o\">'</span><span class=\"na\">s</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">resource_table</span><span class=\"err\">`</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">However</span><span class=\"w\"> </span><span class=\"n\">IIUC</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">resource_table</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">deliberately</span><span class=\"w\"> </span><span class=\"n\">opaque</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">don</span><span class=\"o\">'</span><span class=\"na\">t</span><span class=\"w\"> </span><span class=\"n\">have</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">particular</span><span class=\"w\"> </span><span class=\"n\">resource</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">poll</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Is</span><span class=\"w\"> </span><span class=\"n\">there</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"n\">particular</span><span class=\"w\"> </span><span class=\"n\">way</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">me</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">timers</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"o\">/</span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">keep</span><span class=\"w\"> </span><span class=\"n\">polling</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">make</span><span class=\"w\"> </span><span class=\"n\">sure</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">timers</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">change</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">trigger</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"o\">?</span>\n<span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 537283066,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756818530
    },
    {
        "content": "<p>ignatz edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<p>Hey folks,</p>\n<p>I've been bumbling around the code-base trying to keep \"pumping\"/polling an \"instance\" for pending timers.</p>\n<p>In essence, I'm using wasi_http to send handle an HTTP request with a guest. So far so good. If the handler installs a timer I would like to keep polling beyond</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">response</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">proxy</span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"n\">wasi_http_incoming_handler</span><span class=\"p\">()</span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"n\">call_handle</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">req</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"p\">)</span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span>\n<span class=\"w\"> </span><span class=\"err\">```</span>\n\n<span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">assume</span><span class=\"w\"> </span><span class=\"n\">timers</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">captures</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"o\">'</span><span class=\"na\">s</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">resource_table</span><span class=\"err\">`</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">However</span><span class=\"w\"> </span><span class=\"n\">IIUC</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">resource_table</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">deliberately</span><span class=\"w\"> </span><span class=\"n\">opaque</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">don</span><span class=\"o\">'</span><span class=\"na\">t</span><span class=\"w\"> </span><span class=\"n\">have</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">particular</span><span class=\"w\"> </span><span class=\"n\">resource</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">poll</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Is</span><span class=\"w\"> </span><span class=\"n\">there</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"n\">particular</span><span class=\"w\"> </span><span class=\"n\">way</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">me</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">timers</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"o\">/</span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">keep</span><span class=\"w\"> </span><span class=\"n\">polling</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">make</span><span class=\"w\"> </span><span class=\"n\">sure</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">timers</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">chance</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">trigger</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"o\">?</span>\n<span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 537283110,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756818542
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584#issuecomment-3245525302\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<p>Could you provide example code or describe in more detail the problem that you're running into? For example is a future getting \"stuck\"? Is something not making progress? The entirety of the guest's computation, regardless of whether it's internally using timers or anything else, is captured in the <code>Future</code> implementation returned by <code>call_handle</code>. In that sense your questions are difficult to answer because the answer is \"you do nothing and it should work\". That's what leads me to ask for more detail or more description of the problem.</p>\n</blockquote>",
        "id": 537295549,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756822223
    },
    {
        "content": "<p>ignatz <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584#issuecomment-3245751912\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<p>Hey @alexcrichton , thanks for the super reply <span aria-label=\"folded hands\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"folded hands\">:folded_hands:</span> </p>\n<blockquote>\n<p>Could you provide example code or describe in more detail the problem that you're running into? For example is a future getting \"stuck\"? Is something not making progress? The entirety of the guest's computation, regardless of whether it's internally using timers or anything else, is captured in the Future implementation returned by call_handle. In that sense your questions are difficult to answer because the answer is \"you do nothing and it should work\".</p>\n</blockquote>\n<p>Absolutely. Nothing is stuck. It does just work... maybe too well :) - let me expand...</p>\n<p>A strawman guest may look something like:</p>\n<div class=\"codehilite\" data-code-language=\"TypeScript\"><pre><span></span><code><span class=\"k\">export</span><span class=\"w\"> </span><span class=\"kd\">const</span><span class=\"w\"> </span><span class=\"nx\">incomingHandler</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">   </span><span class=\"nx\">handle</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">function</span><span class=\"w\"> </span><span class=\"p\">(</span>\n<span class=\"w\">     </span><span class=\"nx\">req</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">IncomingRequest</span><span class=\"p\">,</span>\n<span class=\"w\">     </span><span class=\"nx\">respOutparam</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"kt\">ResponseOutparam</span><span class=\"p\">,</span>\n<span class=\"w\">   </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">     </span><span class=\"nx\">setInterval</span><span class=\"p\">(()</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">\"Timer expired\"</span><span class=\"p\">)</span>\n<span class=\"w\">     </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"mf\">1000</span><span class=\"p\">);</span>\n\n<span class=\"w\">     </span><span class=\"nx\">ResponseOutparam</span><span class=\"p\">.</span><span class=\"nx\">set</span><span class=\"p\">(</span><span class=\"nx\">responseOutparam</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nx\">tag</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"s2\">\"ok\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nx\">val</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">});</span>\n<span class=\"w\">   </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>i.e. from the host's side <code>call_handle</code>'s Future will be fulfilled right away. It works, no problem <span aria-label=\"partying face\" class=\"emoji emoji-1f973\" role=\"img\" title=\"partying face\">:partying_face:</span> . However, I'm interested in \"side-effects\". The example may be silly, but the call could for example trigger a periodic refresh, fetch something and write it to a DB.<br>\nThis notion of starting something which may have side-affects and then drive them to completion may feel like an antithesis to the pure functional nature of <code>call_handler()</code>. Besides the intrinsic issues of resource leakages, infinite loops, ... is this something that would be possible?</p>\n<p>(In this picture, I'm owning the host/emebedder running someone else's code using my abstractions so a solution that involves calling back into the host before returning from the http handler would work for me)</p>\n</blockquote>",
        "id": 537307541,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756825731
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584#issuecomment-3245801712\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<p>As far as I understand, if the component spawned a sub task for running the <code>setInterval</code>, then the <code>wasi_http_incoming_handler()</code> task would block until this sub task has finished before returning to the host. If on the other hand the component were to manually poll the timer future without spawning a sub task for the <code>setInterval</code>, then you did have to call whichever code is responsible for this polling (javascript event loop?) from the host. Wasmtime can't do this for you as it depends on the exact way the component is implemented.</p>\n</blockquote>",
        "id": 537310550,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756826538
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584#issuecomment-3246277266\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<p>I fear there's no short answer to your question here @ignatz so I'll try to dissect the various pieces here to explain what's going on. At first I'm assuming everything being done here is with WASIp2. With WASIp2 there's no concept of async in WIT/components itself which is important because all Wasmtime as a host knows is \"did the function return or not\". So the first thing we can possibly do is to rephrase your question in terms of what the guest is doing. </p>\n<p>If a JS guest wants to support <code>setInterval</code> then the JS guest is the one faced with the question of \"the entrypoint has returned and there's pending work in <code>setInterval</code>, what should happen?\" The exact answer here depends on the runtime, but let's assume for now that the component-level function returns. This means that Wasmtime now has the result of <code>call_handle</code>, for example. Wasmtime has no means of knowing, however, that the guest has <code>setInterval</code> timers. Thus in this world there's no knowledge of what to do and the timers will just never fire.</p>\n<p>Solving this could be done with one of a few possible approaches. First is that the guest could avoid returning until all timers are done. This means that Wasmtime wouldn't ever return from <code>call_handle</code> until all timers are cleared. For WASIp2 HTTP this may not be so bad since <code>set</code> is where the response is sent. Second is that the guest and host could have a higher-level protocol between themselves. This would be outside the WASI standardization space but the guest could tell the host \"hey call me back in a few seconds\" and then has another entrypoint. This would likely be difficult to thread everywhere though due to the non-standard nature. Third though brings me to...</p>\n<p>All of this looks a little different in WASIp3. In WASIp3 the component model and WIT have native knowledge of async operations. There is a distinct concept of returning from a function and then exiting a task. This would mean that your example could be modeled as returning from the function and then continuing to execute work within the task so long as there are timers. Wasmtime's implementation of WASIp3, however, means that <code>call_handle</code> won't actually return until the component level task exits. This means that without further changes to the host API Wasmtime wouldn't be able to model this super well. I'll open an issue about this after I finish writing this comment.</p>\n<p>That's a lot of words to say, however, \"this should work by default\". What you're describing seems quite reasonable to me to expect to work by default without needing much interactions. How exactly that's modeled on the host is going to be a bit tricky. With WASIp2 it in theory should work already, and we'll need some changes to make it work with WASIp3.</p>\n<hr>\n<p>@bjorn3 </p>\n<blockquote>\n<p>if the component spawned a sub task for running the setInterval</p>\n</blockquote>\n<p>To clarify, WASIp2 has no concept of tasks for anything here. Given that tasks are either purely a host abstraction (e.g. a Tokio task) or a guest abstraction (e.g. a turn of the JS event loop). With that in mind I find your response somewhat difficult to interpret. In the context of WASIp3, however, there are definitely component-model level tasks, so is that what you were referring to? </p>\n</blockquote>",
        "id": 537337725,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756835492
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584#issuecomment-3246369063\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<p>Yeah, I was referring to wasip3.</p>\n</blockquote>",
        "id": 537342872,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756837555
    },
    {
        "content": "<p>ignatz <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584#issuecomment-3246520481\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'll try to dissect the various pieces here to explain what's going on. </p>\n</blockquote>\n<p><span aria-label=\"folded hands\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"folded hands\">:folded_hands:</span> </p>\n<blockquote>\n<p>At first I'm assuming everything being done here is with WASIp2. </p>\n</blockquote>\n<p>Affirmative</p>\n<blockquote>\n<p>If a JS guest wants to support <code>setInterval</code> then the JS guest is the one faced with the question of \"the entrypoint has returned and there's pending work in <code>setInterval</code>, what should happen?\" The exact answer here depends on the runtime, but let's assume for now that the component-level function returns. This means that Wasmtime now has the result of <code>call_handle</code>, for example. Wasmtime has no means of knowing, however, that the guest has <code>setInterval</code> timers. Thus in this world there's no knowledge of what to do and the timers will just never fire.</p>\n</blockquote>\n<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> that's where I'm at.</p>\n<blockquote>\n<p>Solving this could be done with one of a few possible approaches. First is that the guest could avoid returning until all timers are done. This means that Wasmtime wouldn't ever return from <code>call_handle</code> until all timers are cleared. For WASIp2 HTTP this may not be so bad since <code>set</code> is where the response is sent.</p>\n</blockquote>\n<p>This is the one I'm aware of, i.e. just keep polling the original future and everything will fall into place. That said, I would like to decouple.<br>\nExample: you're implementing some sort of message queue, you're submitting work, want it to be acknowledged and then pick up the result later on. Maybe even by a different caller or with connection interrupts, so keeping a stream open isn't ideal.</p>\n<blockquote>\n<p>Second is that the guest and host could have a higher-level protocol between themselves. This would be outside the WASI standardization space but the guest could tell the host \"hey call me back in a few seconds\" and then has another entrypoint. This would likely be difficult to thread everywhere though due to the non-standard nature.</p>\n</blockquote>\n<p>let's say the guest's <code>mySetInterval</code> calls the host to tell it timers have been installed. The host then calls the guest, e.g. after <code>call_handle</code> completes... but how would I ensure that that follow-up call only resolves after the last timer has expired or cancelled and the continuations get to run? That's sort of the functionality I was digging for. V8 for example has methods to check if there are ready events on the event-loop and \"pump\" it. Arguably, WASM doesn't have this kind of event-loop, which is probably at the heart of the problem, i.e. there isn't a clear entry-point for the host to call for the ambient computation to continue.</p>\n<blockquote>\n<p>All of this looks a little different in WASIp3. In WASIp3 the component model and WIT have native knowledge of async operations. There is a distinct concept of returning from a function and then exiting a task. This would mean that your example could be modeled as returning from the function and then continuing to execute work within the task so long as there are timers. Wasmtime's implementation of WASIp3, however, means that <code>call_handle</code> won't actually return until the component level task exits. This means that without further changes to the host API Wasmtime wouldn't be able to model this super well. I'll open an issue about this after I finish writing this comment.</p>\n</blockquote>\n<p><span aria-label=\"folded hands\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"folded hands\">:folded_hands:</span></p>\n<p>Sounds like whether with WASIp2 or WASIp3 the approach would be to model this behavior as \"don't return so the host has something that it can continue to poll and therefore advance the guest\". In this case, the end of an HTTP stream would have to be modeled not implicitly by returning but as an explicit stream-end marker. Does that match your thinking?</p>\n<blockquote>\n<p>That's a lot of words to say, however, \"this should work by default\". What you're describing seems quite reasonable to me to expect to work by default without needing much interactions. </p>\n</blockquote>\n<p>That would be wonderful (but suggests that my understanding in the previous paragraph is likely flawed - would love to be wrong :) ).</p>\n<blockquote>\n<p>How exactly that's modeled on the host is going to be a bit tricky. With WASIp2 it in theory should work already, and we'll need some changes to make it work with WASIp3.</p>\n</blockquote>\n<p>How to model it is definitely where I'm struggling. If it's already possible in WASIp2, maybe you could expand a little on how. Would this be the \"second\" approach, you mentioned, where the host calls back the guest?</p>\n<p>Thank you so much for your time and the wealth of information <span aria-label=\"folded hands\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"folded hands\">:folded_hands:</span> </p>\n</blockquote>",
        "id": 537350670,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756840939
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584#issuecomment-3250421224\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<p>Ok thanks @bjorn3, makes sense! I think the confusion then is that I don't think @ignatz was originally talking about wasip3 but you were, or at least that resolves my own personal confusion.</p>\n<p>After talking with @dicej I can correct my understanding of things. @ignatz I've opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11600\">https://github.com/bytecodealliance/wasmtime/issues/11600</a> for the WASIp3 side of things, which further codifies the \"true answer\" here as \"the guest completes but does not return\". Put another way:</p>\n<ul>\n<li>WASIp2: today you'll call <code>set</code> when your headers are ready. You'll finish up the body via the WASI resources you made and that'll be doing I/O and such. Then later you'll eventually actually exit. Blocking is done via <code>wasi:io/poll</code> which informs the host \"here's a list of things the guest is waiting on\". Through this there's no guest/host communication or callbacks or such, or rather it's sort of implicit via <code>wasi:io/poll</code>. This is why WASIp2 should \"just work\" today with appropriately configured guests (e.g. returning is blocked until all pending work is finished)</li>\n<li>WASIp3: it'll all work the same way except things are a bit more formal in the component model. The guest will return as it does today, and then with #11600 the embedder will be able to further await the guest exiting its task entirely. Here again there's not really any host/guest protocol other than the component model itself where the guest will inform the host via intrinsics \"I'm waiting on this timer\" or something like that, and the host's await of the task's end will naturally wait for its conclusion in the guest.</li>\n</ul>\n<p>I realize WASIp3 isn't necessarily fully documented, but does the WASIp2 bits make more sense? I realize I'm refining my own understanding of this over time as well so I'm a bit rambly...</p>\n</blockquote>",
        "id": 537537546,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756926153
    },
    {
        "content": "<p>ignatz closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<p>Hey folks,</p>\n<p>I've been bumbling around the code-base trying to keep \"pumping\"/polling an \"instance\" for pending timers.</p>\n<p>In essence, I'm using wasi_http to send handle an HTTP request with a guest. So far so good. If the handler installs a timer I would like to keep polling beyond</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">response</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">proxy</span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"n\">wasi_http_incoming_handler</span><span class=\"p\">()</span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"n\">call_handle</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">req</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"p\">)</span>\n<span class=\"w\">   </span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span>\n<span class=\"w\"> </span><span class=\"err\">```</span>\n\n<span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">assume</span><span class=\"w\"> </span><span class=\"n\">timers</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">captures</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"o\">'</span><span class=\"na\">s</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">resource_table</span><span class=\"err\">`</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">However</span><span class=\"w\"> </span><span class=\"n\">IIUC</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">resource_table</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">deliberately</span><span class=\"w\"> </span><span class=\"n\">opaque</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"w\"> </span><span class=\"n\">don</span><span class=\"o\">'</span><span class=\"na\">t</span><span class=\"w\"> </span><span class=\"n\">have</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">particular</span><span class=\"w\"> </span><span class=\"n\">resource</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">poll</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Is</span><span class=\"w\"> </span><span class=\"n\">there</span><span class=\"w\"> </span><span class=\"n\">any</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"n\">particular</span><span class=\"w\"> </span><span class=\"n\">way</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">me</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">timers</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"o\">/</span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">keep</span><span class=\"w\"> </span><span class=\"n\">polling</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">make</span><span class=\"w\"> </span><span class=\"n\">sure</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">timers</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">chance</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">trigger</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"o\">?</span>\n<span class=\"o\">~~~</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 537544627,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756929231
    },
    {
        "content": "<p>ignatz <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584#issuecomment-3250568623\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<blockquote>\n<p>I realize WASIp3 isn't necessarily fully documented, but does the WASIp2 bits make more sense? I realize I'm refining my own understanding of this over time as well so I'm a bit rambly...</p>\n</blockquote>\n<p>Really appreciate the time, glad if it's useful to you too</p>\n<blockquote>\n<p>WASIp2: today you'll call set when your headers are ready. You'll finish up the body via the WASI resources you made and that'll be doing I/O and such. Then later you'll eventually actually exit. Blocking is done via wasi:io/poll which informs the host \"here's a list of things the guest is waiting on\". Through this there's no guest/host communication or callbacks or such, or rather it's sort of implicit via wasi:io/poll. This is why WASIp2 should \"just work\" today with appropriately configured guests (e.g. returning is blocked until all pending work is finished)</p>\n</blockquote>\n<p>After reading this a few more times than I like to admit, I know see my fallacy. I can confirm that <code>.set()</code> completes the HTTP response independent of the incoming-handler returning. So as long as one manages to keep track of pending tasks, we can continue to drive the tasks from the handler's body. I'm carefully optimistic that this solves my problem <span aria-label=\"folded hands\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"folded hands\">:folded_hands:</span> </p>\n<p>I'm not sufficiently up-to-speed on WASIp3 to appreciate the nuances but it sounds like there will be more of a first-class Task concept that the embedder can explicitly drive to completion. If all I/O would be handled this way, this may solve the issue where I don't manage to keep track of all pending tasks a user's code may issue. That would be delightful <span aria-label=\"folded hands\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"folded hands\">:folded_hands:</span> </p>\n<p>Thanks again! </p>\n</blockquote>",
        "id": 537544629,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756929231
    },
    {
        "content": "<p>ignatz edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584#issuecomment-3250568623\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11584\">issue #11584</a>:</p>\n<blockquote>\n<blockquote>\n<p>I realize WASIp3 isn't necessarily fully documented, but does the WASIp2 bits make more sense? I realize I'm refining my own understanding of this over time as well so I'm a bit rambly...</p>\n</blockquote>\n<p>Really appreciate the time, glad if it's useful to you too</p>\n<blockquote>\n<p>WASIp2: today you'll call set when your headers are ready. You'll finish up the body via the WASI resources you made and that'll be doing I/O and such. Then later you'll eventually actually exit. Blocking is done via wasi:io/poll which informs the host \"here's a list of things the guest is waiting on\". Through this there's no guest/host communication or callbacks or such, or rather it's sort of implicit via wasi:io/poll. This is why WASIp2 should \"just work\" today with appropriately configured guests (e.g. returning is blocked until all pending work is finished)</p>\n</blockquote>\n<p>After reading this a few more times than I like to admit, I now see my fallacy. I can confirm that <code>.set()</code> completes the HTTP response independent of the incoming-handler returning. So as long as one manages to keep track of pending tasks, we can continue to drive the tasks from the handler's body. I'm carefully optimistic that this solves my problem <span aria-label=\"folded hands\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"folded hands\">:folded_hands:</span> </p>\n<p>I'm not sufficiently up-to-speed on WASIp3 to appreciate the nuances but it sounds like there will be more of a first-class Task concept that the embedder can explicitly drive to completion. If all I/O would be handled this way, this may solve the issue where I don't manage to keep track of all pending tasks a user's code may issue. That would be delightful <span aria-label=\"folded hands\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"folded hands\">:folded_hands:</span> </p>\n<p>Thanks again! </p>\n</blockquote>",
        "id": 537610492,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756972356
    }
]