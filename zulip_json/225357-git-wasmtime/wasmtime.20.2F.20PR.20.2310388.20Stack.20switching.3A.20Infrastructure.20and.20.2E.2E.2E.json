[
    {
        "content": "<p>frank-emrich opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a> from <code>frank-emrich:stack-switching-infra</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>This PR is part of a series that adds support for the <a href=\"https://github.com/WebAssembly/stack-switching\">Wasm stack switching proposal</a>. The explainer document for the proposal is <a href=\"https://github.com/WebAssembly/stack-switching/blob/main/proposals/stack-switching/Explainer.md\">here</a>. There's a tracking issue describing the overall progress and limitations here: #10248<br>\nThe draft PR #10177 contains the whole (initial) implementation of the proposal. </p>\n<p>This PR contains all of the necessary infrastructure and runtime support. In other words, this contains the entire implementation, except for codegen. Tests are added at the end, after codegen has also been added in a follow-up PR.</p>\n<p>This was developed together with @dhil.</p>\n<h3>General implementation notes</h3>\n<p>In Wasm, continuations are represented by values of type <code>(ref $ct)</code>, where <code>$ct</code> is a new composite type/heap type for continuations.<br>\nIn the implementation, these are represented by values of type <code>VMContObj</code>. These are fat pointers, consisting of a sequence counter, and a pointer to a <code>VMContRef</code>. The latter type is used for the actual representation of continuations.<br>\nThe sequence counter part of <code>VMContObj</code>s is used to check that every continuation value can only be used once.</p>\n<p>The <code>VMStoreContext</code> is extended to contain a \"stack chain\": It indicates what stack we are currently executing on. Logically, this is a linked list of stacks, since each continuation has a parent field. The chain stored in the <code>VMStoreContext</code> always ends with a value representing the initial stack. This is the stack we were on when entering Wasm, which will usually be the main stack. </p>\n<h3>Memory Management</h3>\n<p>Currently, memory management is very basic: The <code>StoreOpaque</code> provides a new method for allocation a new <code>VMContRef</code>, and keeps track of all continuations created this way. Continuations are never deallocated at the moment, meaning that they live until the store itself is deallocated. </p>\n<p>The stack memory used by each allocation (represented by type <code>ContinuationStack</code>) is always <code>mmap</code>-ed, with a guard page at the end. There is currently no support for growing stacks, or segmented stacks.</p>\n<h3>Backtrace generation</h3>\n<p>The existing backtrace generation mechanism is extended to be fully aware of continuations: When generating backtraces, the entire chain of continuation is traversed, not just the stack frames of the currently active stack/continuation.</p>\n<h3>Entering/Exiting Wasm</h3>\n<p>Prior to this PR, there were two separate mechanisms that save and restore some state of the runtime when entering/exiting Wasm:</p>\n<ol>\n<li>The functions <code>enter_wasm</code> and <code>exit_wasm</code> in <code>func.rs</code></li>\n<li><code>CallThreadState</code> saves and restores (on <code>drop</code>) parts of the <code>VMStoreContext</code></li>\n</ol>\n<p>This PR consolidates these two mechanism, because it requires some additional state to be updated and restored on enter/exit:<br>\nthe type <code>wasmtime::runtime::func::EntryStoreContext</code> now stores all of the required runtime state and ensures that it's restored when exiting Wasm.</p>\n<h3>Tables</h3>\n<ul>\n<li>The runtime part for resizing and filling tables containing continuations is added.</li>\n<li>Note that there is a potentially controversial change to how the pooling allocator works for tables: Since a <code>VMContObj</code> is 2 pointers wide, the maximum size of an entry in a table doubles. As a result, this PR doubles the amount of virtual memory space occupied by the table pool (but the amount of pages actually used stays the same).<br>\n</li>\n</ul>\n</blockquote>",
        "id": 505267490,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741819453
    },
    {
        "content": "<p><strong>frank-emrich</strong> requested <a href=\"https://github.com/fitzgen\">fitzgen</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 505267495,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741819454
    },
    {
        "content": "<p><strong>frank-emrich</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-fuzz-reviewers\">wasmtime-fuzz-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 505267496,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741819454
    },
    {
        "content": "<p><strong>frank-emrich</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-default-reviewers\">wasmtime-default-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 505267497,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741819454
    },
    {
        "content": "<p><strong>frank-emrich</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 505267498,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741819454
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2719364182\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"fuzzing\", \"wasmtime:api\", \"wasmtime:c-api\", \"wasmtime:config\", \"wasmtime:ref-types\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: fuzzing, wasmtime:ref-types</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 505276585,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741823089
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2719481943\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<h4>Label Messager: wasmtime:config</h4>\n<p>It looks like you are changing Wasmtime's configuration options. Make sure to<br>\ncomplete this check list:</p>\n<ul>\n<li>\n<p>[ ] If you added a new <code>Config</code> method, you wrote extensive documentation for<br>\n      it.</p>\n<p>&lt;details&gt;</p>\n<p>Our documentation should be of the following form:</p>\n<p>```text<br>\nShort, simple summary sentence.</p>\n<p>More details. These details can be multiple paragraphs. There should be<br>\ninformation about not just the method, but its parameters and results as<br>\nwell.</p>\n<p>Is this method fallible? If so, when can it return an error?</p>\n<p>Can this method panic? If so, when does it panic?</p>\n<h1>Example</h1>\n<p>Optional example here.<br>\n```</p>\n<p>&lt;/details&gt;</p>\n</li>\n<li>\n<p>[ ] If you added a new <code>Config</code> method, or modified an existing one, you<br>\n  ensured that this configuration is exercised by the fuzz targets.</p>\n<p>&lt;details&gt;</p>\n<p>For example, if you expose a new strategy for allocating the next instance<br>\nslot inside the pooling allocator, you should ensure that at least one of our<br>\nfuzz targets exercises that new strategy.</p>\n<p>Often, all that is required of you is to ensure that there is a knob for this<br>\nconfiguration option in [<code>wasmtime_fuzzing::Config</code>][fuzzing-config] (or one<br>\nof its nested <code>struct</code>s).</p>\n<p>Rarely, this may require authoring a new fuzz target to specifically test this<br>\nconfiguration. See [our docs on fuzzing][fuzzing-docs] for more details.</p>\n<p>&lt;/details&gt;</p>\n</li>\n<li>\n<p>[ ] If you are enabling a configuration option by default, make sure that it<br>\n  has been fuzzed for at least two weeks before turning it on by default.</p>\n</li>\n</ul>\n<p>[fuzzing-config]: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194\">https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194</a><br>\n[fuzzing-docs]: <a href=\"https://docs.wasmtime.dev/contributing-fuzzing.html\">https://docs.wasmtime.dev/contributing-fuzzing.html</a></p>\n<hr>\n<p>&lt;details&gt;</p>\n<p>To modify this label's message, edit the &lt;code&gt;.github/label-messager/wasmtime-config.md&lt;/code&gt; file.</p>\n<p>To add new label messages or remove existing label messages, edit the<br>\n&lt;code&gt;.github/label-messager.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/label-messager-action\">Learn more.</a></p>\n<p>&lt;/details&gt;</p>\n</blockquote>",
        "id": 505287603,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741827944
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2722073269\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<p>Haven't dug into the details of the PR yet, but I have some initial questions after reading the OP.</p>\n<blockquote>\n<p>The stack memory used by each allocation (represented by type <code>ContinuationStack</code>) is always <code>mmap</code>-ed, with a guard page at the end. There is currently no support for growing stacks, or segmented stacks.</p>\n</blockquote>\n<p>Is there a particular reason this does not use the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/wasmtime/src/runtime/vm/instance/allocator.rs#L297-L309\"><code>InstanceAllocatorImpl::[de]allocate_fiber_stack</code></a> methods via <code>[store.engine().allocator().[de]allocate_fiber_stack()</code>](<a href=\"https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/wasmtime/src/engine.rs#L659\">https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/wasmtime/src/engine.rs#L659</a>)? That would make it so that this feature automatically integrates with the <code>wasmtime::Config</code>, its various knobs for stack sizes and such, and whether the pooling or on-demand allocator is in use.</p>\n<blockquote>\n<p>Note that there is a potentially controversial change to how the pooling allocator works for tables: Since a <code>VMContObj</code> is 2 pointers wide, the maximum size of an entry in a table doubles. As a result, this PR doubles the amount of virtual memory space occupied by the table pool (but the amount of pages actually used stays the same).</p>\n</blockquote>\n<p>Is this because <code>(ref cont)</code>/<code>VMContObj</code> tables are being shoe-horned into the same underlying representation as <code>anyref</code>/<code>externref</code>/<code>VMGcRef</code> tables? Because <code>VMContObj</code> has a different representation from <code>VMGcRef</code>, I think it would be best to add a new <code>wasmtime::runtime::vm::Table</code> variant for <code>VMContObj</code>, the same way that we have <a href=\"https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/wasmtime/src/runtime/vm/table.rs#L144-L147\">different variants for <code>VMGcRef</code> tables versus <code>*const VMFuncRef</code> tables</a>.</p>\n</blockquote>",
        "id": 505481656,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741886383
    },
    {
        "content": "<p>fitzgen edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2722073269\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<p>Haven't dug into the details of the PR yet, but I have some initial questions after reading the OP.</p>\n<blockquote>\n<p>The stack memory used by each allocation (represented by type <code>ContinuationStack</code>) is always <code>mmap</code>-ed, with a guard page at the end. There is currently no support for growing stacks, or segmented stacks.</p>\n</blockquote>\n<p>Is there a particular reason this does not use the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/wasmtime/src/runtime/vm/instance/allocator.rs#L297-L309\"><code>InstanceAllocatorImpl::[de]allocate_fiber_stack</code></a> methods via <a href=\"https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/wasmtime/src/engine.rs#L659\"><code>store.engine().allocator().[de]allocate_fiber_stack()</code></a>? That would make it so that this feature automatically integrates with the <code>wasmtime::Config</code>, its various knobs for stack sizes and such, and whether the pooling or on-demand allocator is in use.</p>\n<blockquote>\n<p>Note that there is a potentially controversial change to how the pooling allocator works for tables: Since a <code>VMContObj</code> is 2 pointers wide, the maximum size of an entry in a table doubles. As a result, this PR doubles the amount of virtual memory space occupied by the table pool (but the amount of pages actually used stays the same).</p>\n</blockquote>\n<p>Is this because <code>(ref cont)</code>/<code>VMContObj</code> tables are being shoe-horned into the same underlying representation as <code>anyref</code>/<code>externref</code>/<code>VMGcRef</code> tables? Because <code>VMContObj</code> has a different representation from <code>VMGcRef</code>, I think it would be best to add a new <code>wasmtime::runtime::vm::Table</code> variant for <code>VMContObj</code>, the same way that we have <a href=\"https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/wasmtime/src/runtime/vm/table.rs#L144-L147\">different variants for <code>VMGcRef</code> tables versus <code>*const VMFuncRef</code> tables</a>.</p>\n</blockquote>",
        "id": 505481855,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741886431
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2682837856\">PR review</a>:</p>\n<blockquote>\n<p>(review is still in progress, but I need to context switch for a little bit and might as well share what I have so far)</p>\n</blockquote>",
        "id": 505488482,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741888219
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994031798\">PR review comment</a>:</p>\n<blockquote>\n<p>Were these going to be removed in the next PR, or should they be removed now? Maybe throw an item into the meta task list if not now.</p>\n</blockquote>",
        "id": 505488483,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741888219
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994023305\">PR review comment</a>:</p>\n<blockquote>\n<p>Not something that needs to be handled in this PR, but there is no reason we can't enable GC and also maintain the existing memory management for continuations, where they have the same lifetime as the <code>Store</code>. We don't have to implement full GC of continuations before we allow enabling both GC and stack switching at the same time.</p>\n</blockquote>",
        "id": 505488484,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741888219
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994025479\">PR review comment</a>:</p>\n<blockquote>\n<p>FWIW, we already have <code>TRAP_INTERNAL_ASSERT</code> that we use for debug-only assertions inside JIT code.</p>\n</blockquote>",
        "id": 505488485,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741888220
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1993999187\">PR review comment</a>:</p>\n<blockquote>\n<p>I don't see a corresponding function definition in <code>crates/c-api</code>, I think it is missing?</p>\n</blockquote>",
        "id": 505488486,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741888220
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994038122\">PR review comment</a>:</p>\n<blockquote>\n<p>Ditto to the debug printing stuff in this file.</p>\n</blockquote>",
        "id": 505488487,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741888220
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994047818\">PR review comment</a>:</p>\n<blockquote>\n<p>fyi, I tend to do <code>log::trace!(...)</code> for debug prints (both temporary ones that I will remove, and for ones that are useful enough to keep in tree).</p>\n<p>when running the CLI, you can see them by setting the <code>WASMTIME_LOG=trace</code> env var, or only a specific crate/module via <code>WASMTIME_LOG=wasmtime::runtime::vm=trace</code>, or multiple crates/modules at different levels via <code>WASMTIME_LOG=debug,regalloc2=info,cranelift_codegen::machinst=trace</code>.</p>\n<p>When running tests instead of the CLI, <code>WASMTIME_LOG</code> becomes <code>RUST_LOG</code>. Most tests initialize the env-logger, but if you aren't seeing the logs, then you can put <code>let _ = env_logger::try_init();</code> at the start of the test (or ideally in a shared test helper function that a bunch of related tests already call at the beginning of their execution).</p>\n</blockquote>",
        "id": 505488488,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741888220
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994005205\">PR review comment</a>:</p>\n<blockquote>\n<p>At least for now, I'm not sure it is worth having separate config knobs for stacks created via <code>cont.new</code> versus API-level fibers. This effectively creates two different kinds of stacks in the system, and I'd prefer to try and keep things simple for as long as we can by having a single kind of stack that we config and allocate and handle in the system.</p>\n</blockquote>",
        "id": 505488489,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741888220
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1993999944\">PR review comment</a>:</p>\n<blockquote>\n<p>Similarly, I don't see a function definition for this one either.</p>\n</blockquote>",
        "id": 505488490,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741888220
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2682936294\">PR review</a>.</p>",
        "id": 505488988,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741888355
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994052700\">PR review comment</a>:</p>\n<blockquote>\n<ul>\n<li><a href=\"https://docs.wasmtime.dev/cli-logging.html?highlight=wasmtime_log#logging-in-the-wasmtime-cli\">https://docs.wasmtime.dev/cli-logging.html?highlight=wasmtime_log#logging-in-the-wasmtime-cli</a></li>\n<li><a href=\"https://docs.rs/log/latest/log/\">https://docs.rs/log/latest/log/</a></li>\n<li><a href=\"https://docs.rs/env_logger/latest/env_logger/\">https://docs.rs/env_logger/latest/env_logger/</a></li>\n</ul>\n</blockquote>",
        "id": 505488989,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741888356
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2683263159\">PR review</a>:</p>\n<blockquote>\n<p>(again, review still in progress, leaving intermediate notes)</p>\n</blockquote>",
        "id": 505528774,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741901055
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994276952\">PR review comment</a>:</p>\n<blockquote>\n<p>Reminder to fill this in.</p>\n</blockquote>",
        "id": 505528778,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741901056
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994301274\">PR review comment</a>:</p>\n<blockquote>\n<p>Two things:</p>\n<ol>\n<li>\n<p>Why does stack-switching need <code>std</code>?</p>\n</li>\n<li>\n<p>We should be able to enable stack-switching for a compiler-without-runtime build to be able to compile stack-switching Wasm to be run elsewhere, and similarly should be able to enable stack-switching in a runtime-without-compiler build to run elsewhere-compiled stack-switching Wasm modules. As written, enabling the stack-switching feature will always enable the runtime, making the compiler-without-runtime version impossible. That is, unless compilation of stack-switching isn't gated on any cargo feature, but that is kind of funky given that this cargo feature exists and I expect users would think \"I want to compile Wasm programs that use stack-switching, therefore I will enable this feature\". This is a long way of basically saying, I think this should not unconditionally enable the runtime and, once compilation is added in the next PR, we ultimately end up with something like this:</p>\n<p><code>rust\n stack-switching = [\n   \"wasmtime-cranelift?/stack-switching\",\n ]\n </code></p>\n</li>\n</ol>\n<p>Neither of these things necessarily needs to be addressed now, before this PR merges, but it may end up being easier doing it now before more stuff gets entangled, making it harder to pull the <code>cfg</code>s apart.</p>\n</blockquote>",
        "id": 505528779,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741901056
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994284468\">PR review comment</a>:</p>\n<blockquote>\n<p>This seems unused. Does it get used in follow up PRs?</p>\n</blockquote>",
        "id": 505528780,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741901056
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994275126\">PR review comment</a>:</p>\n<blockquote>\n<p>Because (AFAICT) these don't contain any <code>usize</code>s or pointers or anything else that changes with the target's word size, you could move them into the <code>wasmtime_environ</code> crate as</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(u32)]</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">enum</span><span class=\"w\"> </span><span class=\"nc\">VMControlEffect</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">Return</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>and avoid the wordy and kind of annoying split between the definitions of the <code>enum</code>s and their discriminants.</p>\n</blockquote>",
        "id": 505528781,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741901056
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994242838\">PR review comment</a>:</p>\n<blockquote>\n<p>These sorts of config knobs that need to exist at the <code>wasmtime_environ</code> level usually go inside <a href=\"https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/environ/src/tunables.rs#L61\"><code>wasmtime_environ::Tunables</code></a>. Unless there is a reason not to do that here, we should follow the existing convention.</p>\n</blockquote>",
        "id": 505528782,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741901056
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994278109\">PR review comment</a>:</p>\n<blockquote>\n<p>Nitpick: both the <code>Engine</code> and <code>Module</code> variants are interned, so perhaps we can rename this method to <code>unwrap_module_type_index</code>?</p>\n</blockquote>",
        "id": 505528783,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741901056
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994316481\">PR review comment</a>:</p>\n<blockquote>\n<p>This <code>mem::drop</code> dance is kind of funky -- can we instead pass ownership into <code>catch_traps</code> and let it handle the dropping, if necessary? Or are there callers that need to do different things?</p>\n</blockquote>",
        "id": 505528785,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741901056
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994302972\">PR review comment</a>:</p>\n<blockquote>\n<p>You'll also want to add some CI checks for these features being enabled/disabled in various combinations like this:</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/.github/workflows/main.yml#L363-L365\">https://github.com/bytecodealliance/wasmtime/blob/main/.github/workflows/main.yml#L363-L365</a></p>\n</blockquote>",
        "id": 505528786,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741901056
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994318754\">PR review comment</a>:</p>\n<blockquote>\n<p>If they are written to directly from Wasm JIT code, then probably yes. This struct should also be <code>#[repr(C)]</code> in that case.</p>\n<p>If it is not written to directly from Wasm, then it would only need to be unsafe cells if you are ever violating Rust's mutable/exclusive xor immutable/shared semantics.</p>\n<p>I haven't read enough of these changes to say any more than that yet.</p>\n</blockquote>",
        "id": 505528787,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741901056
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994314431\">PR review comment</a>:</p>\n<blockquote>\n<p>Can you run the function call microbenchmarks on <code>main</code> and on this branch? I want to make sure that we aren't regressing performance here, as this path is very hot, and if we are we may need to figure out how to <code>cfg(...)</code> some of this stuff so that it only happens when the <code>stack-switching</code> feature is enabled.</p>\n<p>This will run the microbenchmarks and will check the results for statistical significance:</p>\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\">$ </span>git<span class=\"w\"> </span>checkout<span class=\"w\"> </span>main\n<span class=\"gp\">$ </span>cargo<span class=\"w\"> </span>bench<span class=\"w\"> </span>--bench<span class=\"w\"> </span>call<span class=\"w\"> </span>--<span class=\"w\"> </span>--save-baseline<span class=\"w\"> </span>main\n<span class=\"gp\">$ </span>git<span class=\"w\"> </span>checkout<span class=\"w\"> </span>stack-switching-infra\n<span class=\"gp\">$ </span>cargo<span class=\"w\"> </span>bench<span class=\"w\"> </span>--bench<span class=\"w\"> </span>call<span class=\"w\"> </span>--<span class=\"w\"> </span>--baseline<span class=\"w\"> </span>main\n</code></pre></div>\n<p>I can help figure things out if we need to do something here.</p>\n</blockquote>",
        "id": 505528788,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741901056
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1994307521\">PR review comment</a>:</p>\n<blockquote>\n<p>Can you add an item to the meta task list for the embedder API, if you haven't already?</p>\n</blockquote>",
        "id": 505528789,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741901056
    },
    {
        "content": "<p>dhil submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2684615307\">PR review</a>.</p>",
        "id": 505606657,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741938645
    },
    {
        "content": "<p>dhil created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1995037265\">PR review comment</a>:</p>\n<blockquote>\n<p>I think this is a stray declaration from some of our downstream experiments. It has been needed to capture the C shadow stack pointer, that clang generates. It must be kept in sync with the stack switching done by the engine. To be clear, this is just due to the fact that clang doesn't know about stack switching.</p>\n</blockquote>",
        "id": 505606658,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741938645
    },
    {
        "content": "<p>dhil submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2684616778\">PR review</a>.</p>",
        "id": 505606732,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741938678
    },
    {
        "content": "<p>dhil created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1995038075\">PR review comment</a>:</p>\n<blockquote>\n<p>Same reason as above.</p>\n</blockquote>",
        "id": 505606737,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741938679
    },
    {
        "content": "<p>dhil edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1995038075\">PR review comment</a>.</p>",
        "id": 505606769,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741938696
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2685935473\">PR review</a>.</p>",
        "id": 505704341,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741966240
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1995785334\">PR review comment</a>:</p>\n<blockquote>\n<p>FWIW, exposing these things the C API would be good in general, so if you want to do it here or in a new PR, you're more than welcome to!</p>\n</blockquote>",
        "id": 505704346,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741966240
    },
    {
        "content": "<p>dhil submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2685944790\">PR review</a>.</p>",
        "id": 505705218,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741966456
    },
    {
        "content": "<p>dhil created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1995790671\">PR review comment</a>:</p>\n<blockquote>\n<p>Yes sure! I am leaning towards adding this in a follow-up PR focused on the C API. What do you think @frank-emrich ?</p>\n</blockquote>",
        "id": 505705220,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741966456
    },
    {
        "content": "<p>dhil submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2685952192\">PR review</a>.</p>",
        "id": 505705789,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741966621
    },
    {
        "content": "<p>dhil created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1995794668\">PR review comment</a>:</p>\n<blockquote>\n<p>As I discussed with @alexcrichton (<a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177/files#r1965733715\">https://github.com/bytecodealliance/wasmtime/pull/10177/files#r1965733715</a>), I'd be OK with no bespoke stack switching configuration for now.</p>\n</blockquote>",
        "id": 505705792,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741966621
    },
    {
        "content": "<p>dhil submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2686046884\">PR review</a>.</p>",
        "id": 505713355,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741968559
    },
    {
        "content": "<p>dhil created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1995849919\">PR review comment</a>:</p>\n<blockquote>\n<p>This is an interesting question, which Frank and I have discussed in the past. If my memory serves me right, then our layout is slightly different. However perhaps we can unify the layouts (or we can perhaps simply adopt the fibers' layout). I am not too sure about the implications, I think @frank-emrich has the key knowledge to best answer this question.</p>\n</blockquote>",
        "id": 505713359,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741968559
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2686386725\">PR review</a>.</p>",
        "id": 505737221,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741975145
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1996033098\">PR review comment</a>:</p>\n<blockquote>\n<p>The automatic pooling allocator integration would also get you fast allocation of new stacks from a pool, which would look nice on your benchmarks and what have you ;)</p>\n</blockquote>",
        "id": 505737222,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741975145
    },
    {
        "content": "<p>dhil submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2689906130\">PR review</a>.</p>",
        "id": 506104741,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1742206799
    },
    {
        "content": "<p>dhil created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1998410307\">PR review comment</a>:</p>\n<blockquote>\n<p>My take is that they shouldn't make it into the <code>main</code> branch -- probably a stray include?</p>\n</blockquote>",
        "id": 506104745,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1742206800
    },
    {
        "content": "<p>dhil submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2689913062\">PR review</a>.</p>",
        "id": 506105093,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1742206880
    },
    {
        "content": "<p>dhil created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1998413738\">PR review comment</a>:</p>\n<blockquote>\n<p>Yes, agreed! I totally see the appeal!</p>\n</blockquote>",
        "id": 506105096,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1742206881
    },
    {
        "content": "<p>dhil submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2689926506\">PR review</a>.</p>",
        "id": 506105823,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1742207051
    },
    {
        "content": "<p>dhil created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r1998420814\">PR review comment</a>:</p>\n<blockquote>\n<p>Yes, it gets used during the code translation. It should arguably be added along with it in the next patch.</p>\n</blockquote>",
        "id": 506105825,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1742207051
    },
    {
        "content": "<p>frank-emrich <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2781576511\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<p>(Sorry for the long delay, I've moved to London and started a new job, where I needed to settle in first)</p>\n<p>@fitzgen </p>\n<blockquote>\n<p>Is there a particular reason this does not use the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/wasmtime/src/runtime/vm/instance/allocator.rs#L297-L309\">InstanceAllocatorImpl::[de]allocate_fiber_stack</a> methods via <a href=\"https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/wasmtime/src/engine.rs#L659\">store.engine().allocator().[de]allocate_fiber_stack()</a>? That would make it so that this feature automatically integrates with the wasmtime::Config, its various knobs for stack sizes and such, and whether the pooling or on-demand allocator is in use.</p>\n</blockquote>\n<p>The reason we do not use these in verbatim is that our stacks are not the same as <code>wasmtime_fiber::FiberStack</code>. Trying to make our stacks compatible with that type would be quite difficult and IMO not worth the effort.<br>\nHowever, our medium-term plan was to add similar allocation and deallocation functions to <code>InstanceAllocatorImpl</code>. This shouldn't be too much work, but something we didn't see through for now. In particular, @dhil is very interested in restoring support for pooled allocation of stack. We had implemented our own interface for that (outside of <code>InstanceAllocatorImpl</code>) and it greatly improves performance in those use cases where you frequently (de-) allocate continuations.</p>\n<blockquote>\n<p>Is this because (ref cont)/VMContObj tables are being shoe-horned into the same underlying representation as anyref/externref/VMGcRef tables? Because VMContObj has a different representation from VMGcRef, I think it would be best to add a new wasmtime::runtime::vm::Table variant for VMContObj, the same way that we have <a href=\"https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/wasmtime/src/runtime/vm/table.rs#L144-L147\">different variants for VMGcRef tables versus *const VMFuncRef tables</a>.</p>\n</blockquote>\n<p>We actually extend <code>StaticTable</code> and <code>TableElement</code> in that file with appropriate variants for our types. The problem is that in <a href=\"https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/wasmtime/src/runtime/vm/instance/allocator/pooling/table_pool.rs#L32\">TablePool::new</a> we need to <code>mmap</code> enough memory to hold <code>limits.total_tables</code> * <code>limits.table_elements</code> entries, independent from what data is stored in those tables. In order to support tables storing continuations pointers, this effectively doubles the required size of the mmapped area. </p>\n</blockquote>",
        "id": 510511187,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743966570
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2745221603\">PR review</a>.</p>",
        "id": 510511609,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743966886
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2030235967\">PR review comment</a>:</p>\n<blockquote>\n<p>From a technical perspective, there is no need for us to have our own config setting for the stack size. <br>\nI guess the reason we didn't just re-use the existing <code>stack_size</code> option is that the latter always felt like a soft limit to me: AFAIK you can still occupy stack space beyond that limit, for example with host functions.<br>\nBut I have no strong feelings about re-using the existing <code>stack_size</code> config option, or merging our <code>stack_switching_stack_size</code> with <code>async_stack_size</code>.<br>\n</p>\n</blockquote>",
        "id": 510511611,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743966886
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2745223300\">PR review</a>.</p>",
        "id": 510512056,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743967249
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2030237283\">PR review comment</a>:</p>\n<blockquote>\n<p>Good question! These only exist for some hacky debug printing code that should not end up in <code>main</code>. Initially, when we thought that there would only be a single, big PR, the plan was to keep them during reviewing, and then remove them at the last moment before merging. Now that we will land this in smaller pieces, we could either remove them now, or once all PRs from the series have landed.</p>\n<p>The reason why we don't want to land this is explained <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177/files#diff-0c7bbb4f13d0c3d3403d05e6d5f32beee56eb14e2f64f37f5b2a8b2ee6e78fc2R61\">here</a>: On the codegen side, we just emit the addresses of Rust string literals as literals into generated code, with no relocation information. So this crashes and burns if you ever try to re-use the same generated code from a different invocation of <code>wamtime</code>.</p>\n</blockquote>",
        "id": 510512058,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743967250
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2745223780\">PR review</a>.</p>",
        "id": 510512193,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743967360
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2030237817\">PR review comment</a>:</p>\n<blockquote>\n<p>Haha, these were in <code>wasmtime_environ</code> originally, but then @alexcrichton suggested moving them into the runtime. I don't mind it either way.</p>\n</blockquote>",
        "id": 510512194,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743967360
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2745268657\">PR review</a>.</p>",
        "id": 510518460,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743972187
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2030265551\">PR review comment</a>:</p>\n<blockquote>\n<p>Yeah, that <code>drop</code> call is definitely not pretty. We could get away with not explicitly calling <code>drop</code>, but managing the scopes here slightly differently. But that seems equally funky.</p>\n<p>The main reason for all this new <code>EntryStoreContext</code> business is the following:  Previously, there were two places that do some updates to the runtime on entering and exiting Wasm: In <code>catch_traps</code> (together with <code>CallThreadState</code>'s <code>drop</code>) and here in <code>func.rs</code> (using <code>enter_wasm</code>/<code>exit_wasm</code>). I believe @alexcrichton mentioned that this split is mostly for legacy reasons due to how to things were separated into different crates until recently.</p>\n<p>For stack switching, we now require an additional update to the runtime on entering and exiting. Intuitively, it felt to me like these changes should be made in <code>enter_wasm</code>/<code>exit_wasm</code>, but that doesn't quite work: We need to undo these changes if you <code>panic</code> out of a Wasm execution, so I would indeed need to do all of this in <code>catch_traps</code> instead, so that <code>CallThreadState</code>'s <code>drop</code> can do the steps needed on exiting the runtime.</p>\n<p>But updating the stack chain in <code>catch_traps</code> to signal that we are entering Wasm seemed awkward to me, so I decided to just consolidate all the logic for changes that need to happen on entering and exiting Wasm into one place, which resulted in the birth of <code>EntryStoreContext</code>.</p>\n<p>TL;DR Technically, all that's needed for stack switching could all be done in <code>catch_traps</code>, but that felt like it's morally the wrong spot to me.</p>\n<p>Any suggestions? Should I just move it to <code>catch_traps</code>?<br>\n</p>\n</blockquote>",
        "id": 510518461,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743972188
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2784204672\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<blockquote>\n<p>(Sorry for the long delay, I've moved to London and started a new job, where I needed to settle in first)</p>\n</blockquote>\n<p>No worries. Congrats on the move and the new gig!</p>\n<blockquote>\n<p>The reason we do not use these in verbatim is that our stacks are not the same as <code>wasmtime_fiber::FiberStack</code>. Trying to make our stacks compatible with that type would be quite difficult and IMO not worth the effort.</p>\n</blockquote>\n<p>I'd like to dive more into this because I would (perhaps naively?) assume that there is no fundamental reason they couldn't be the same. This is also one of the biggest concerns I have about the the stack-switching implementation: the complexity of having multiple kinds of stacks that the runtime must manage; when there are different kinds of resources, we will eventually need different config knobs for tuning them; and etc. Basically, this feels like a bunch of cognitive overhead for both maintainers and users. Keeping things uniform keeps things simpler. For example, <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9350\">https://github.com/bytecodealliance/wasmtime/issues/9350</a> (which is admittedly a beast of a PR; I have been splitting it into smaller pieces and landing those incrementally) will ultimately reduce complexity in Wasmtime by unifying our handling of Wasm linear memories and GC heaps. I just point this out so that you know I'm not trying to pick on you, and that I am attempting to hold myself to these standards as well.</p>\n<p>But perhaps I am missing some key point that makes it so that these stack-switching stacks and fiber stacks really do have different requirements that do not overlap enough that sharing an implementation makes sense?</p>\n<p>You say it would be quite difficult to unify them, can you expand on what difficulties your foresee?</p>\n<blockquote>\n<p>In particular, @dhil is very interested in restoring support for pooled allocation of stack. We had implemented our own interface for that (outside of <code>InstanceAllocatorImpl</code>) and it greatly improves performance in those use cases where you frequently (de-) allocate continuations.</p>\n</blockquote>\n<p>Totally, that's exactly what I'd expect: a free list pop should be much faster than <code>mmap</code>, especially under load in a concurrent, multi-threaded embedding of Wasmtime.</p>\n<blockquote>\n<p>We actually extend <code>StaticTable</code> and <code>TableElement</code> in that file with appropriate variants for our types. The problem is that in <a href=\"https://github.com/bytecodealliance/wasmtime/blob/9da52ede33a9f8996832b0210579ef15296addbd/crates/wasmtime/src/runtime/vm/instance/allocator/pooling/table_pool.rs#L32\">TablePool::new</a> we need to <code>mmap</code> enough memory to hold <code>limits.total_tables</code> * <code>limits.table_elements</code> entries, independent from what data is stored in those tables. In order to support tables storing continuations pointers, this effectively doubles the required size of the mmapped area.</p>\n</blockquote>\n<p>Ah okay, I get it now. You're right that we definitely don't want to cut the capacity of all existing tables in half in order to support a proposal that 99% of users won't be leveraging yet.</p>\n<p>Two things:</p>\n<ol>\n<li>And this is a pre-existing issue, that calculation of table size should be a little more robust, and use something like <code>mem::size_of::&lt;TableElementUnion&gt;()</code> so that it is more future-proof for changes like we have here where we are adding new kinds of table elements.</li>\n<li>We could plumb through a boolean for whether the stack-switching proposal is enabled to this method, or the whole <code>WasmFeatures</code> or something, and then adjust the size of a single element in the table size calculation based on that value.</li>\n</ol>\n<p>In the meantime, halving the capacity just for continuation tables (rather than all other existing tables) is fine. And we can do the above suggestions in follow up PRs.</p>\n</blockquote>",
        "id": 510739526,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744050362
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2747767766\">PR review</a>.</p>",
        "id": 510742925,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744051548
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2031809149\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>AFAIK you can still occupy stack space beyond that limit, for example with host functions.</p>\n</blockquote>\n<p>We are generally a little loosey-goosey with our nomenclature here, but to make things precise for a moment:</p>\n<ul>\n<li>\"Host functions\" = functions defined in native code by the Wasmtime embedder (e.g. via <code>wasmtime::Func::new</code>) and imported by Wasm</li>\n<li>\"libcalls\" = various bits of Wasm functionality (e.g. <code>memory.grow</code>) that are not implemented inline in JIT code, but instead in native functions inside of Wasmtime's runtime.</li>\n</ul>\n<p>libcalls are part of Wasmtime's trusted compute base, host functions are not (modulo some hand waving around their usage of <code>unsafe</code>).</p>\n<p>Given all that: we will execute libcalls on async fibers, but will never execute host functions on async fibers. When Wasm calls an imported host function, we first switch from the async fiber to the native stack, then run the host function, and finally switch back to the Wasm's async fiber stack to pass the function results back to Wasm JIT code.</p>\n<p>A libcall should never access stack memory beyond the <code>async_stack_size</code> limit (and we rely on guard pages to help enforce this). The Wasm JIT code is given <code>max_wasm_stack</code> bytes for its own use, it must always be true that <code>async_stack_size &gt; max_wasm_stack</code>, and therefore that leaves <code>async_stack_size - max_wasm_stack</code> bytes of stack space for libcalls in the worst case.</p>\n<p>This is all a little bit of an aside and I'm mostly just explaining all this to make sure we are on the same page here. I don't think any of this needs to change for stack-switching, and I would also expect that we would call libcalls, but never host functions, on stack-switching stacks, same way we do things on our async fibers.</p>\n</blockquote>",
        "id": 510742927,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744051548
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2747776855\">PR review</a>.</p>",
        "id": 510743472,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744051733
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2031814713\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>The reason why we don't want to land this is explained <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177/files#diff-0c7bbb4f13d0c3d3403d05e6d5f32beee56eb14e2f64f37f5b2a8b2ee6e78fc2R61\">here</a>: On the codegen side, we just emit the addresses of Rust string literals as literals into generated code, with no relocation information. So this crashes and burns if you ever try to re-use the same generated code from a different invocation of <code>wamtime</code>.</p>\n</blockquote>\n<p>Ah okay! Yes, definitely should not land these bits in that case.</p>\n</blockquote>",
        "id": 510743474,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744051733
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2747779590\">PR review</a>.</p>",
        "id": 510743682,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744051807
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2031816413\">PR review comment</a>:</p>\n<blockquote>\n<p>Ha, lets keep it as-is for now then. I don't want to make you bounce back and forth.</p>\n</blockquote>",
        "id": 510743683,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744051807
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2747806472\">PR review</a>.</p>",
        "id": 510746019,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744052481
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2031832400\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>The main reason for all this new <code>EntryStoreContext</code> business is the following: Previously, there were two places that do some updates to the runtime on entering and exiting Wasm: In <code>catch_traps</code> (together with <code>CallThreadState</code>'s <code>drop</code>) and here in <code>func.rs</code> (using <code>enter_wasm</code>/<code>exit_wasm</code>).</p>\n<p>...</p>\n<p>Any suggestions? Should I just move it to <code>catch_traps</code>?</p>\n</blockquote>\n<p>Do you mind splitting out just the <code>EntryStoreContext</code> bits (without even the stack chain preservation) into its own PR? I think that would help me get a better grasp of these refactorings and provide better review and feedback, especially since the wasm entry/exit paths are both very fiddly and also perf sensitive.</p>\n<p>I do like the idea of unifying these code paths a lot, but I just want to be very careful about changes to them in general. Honestly, it is fairly likely that we won't change the mechanisms any further than what you have already done in this PR here, but it would help a lot with alleviating my nibbling paranoia that we are introducing subtle bugs or perf regressions.</p>\n<p>And I apologize for asking you to keep splitting these PRs even finer-grained. I know it can be a pain (again, see <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10503\">https://github.com/bytecodealliance/wasmtime/pull/10503</a>) but it is super super super helpful for reviewers and making sure that we are following along with all the changes. Thanks!</p>\n</blockquote>",
        "id": 510746020,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744052481
    },
    {
        "content": "<p>frank-emrich <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2817337818\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<p>@fitzgen </p>\n<blockquote>\n<p>I'd like to dive more into this because I would (perhaps naively?) assume that there is no fundamental reason they couldn't be the same. This is also one of the biggest concerns I have about the the stack-switching implementation: the complexity of having multiple kinds of stacks that the runtime must manage; when there are different kinds of resources, we will eventually need different config knobs for tuning them; and etc. Basically, this feels like a bunch of cognitive overhead for both maintainers and users. Keeping things uniform keeps things simpler. For example, #9350 (which is admittedly a beast of a PR; I have been splitting it into smaller pieces and landing those incrementally) will ultimately reduce complexity in Wasmtime by unifying our handling of Wasm linear memories and GC heaps. I just point this out so that you know I'm not trying to pick on you, and that I am attempting to hold myself to these standards as well.</p>\n<p>But perhaps I am missing some key point that makes it so that these stack-switching stacks and fiber stacks really do have different requirements that do not overlap enough that sharing an implementation makes sense?</p>\n<p>You say it would be quite difficult to unify them, can you expand on what difficulties your foresee?</p>\n</blockquote>\n<p>I totally get the wish to make things more maintainable by avoiding duplicating as much stack management logic as possible.</p>\n<p><strong>The short answer is:</strong> If we had a <code>FiberStack</code> type that means \"just a big chunk of memory used for an independent stack, allocated with the virtual memory mechanism of the current platform\" we could share them between our stack switching implementation and <code>wasmtime_fiber</code>. But in its current form, the <code>wasmtime_fiber::FiberStack</code> is just naturally tailored to be used together with <code>wasmtime::Fiber</code>, and bakes in details about how stack switching is done there.</p>\n<p><strong>Longer answer:</strong> Currently, <code>wasmtime_fiber::FiberStack</code>  is just a wrapper around a platform specific implementation. If we look at <code>unix::FiberStack</code>, the documentation there shows how a <code>unix::FiberStack</code> is used by a <code>unix::Fiber</code>. This influences the layout of the data at the top of the stack (see the diagram in crates/fiber/src/unix.rs). In contrast, our layout of the header near the top of a stack is different (see crates/wasmtime/src/runtime/vm/stack_switching/stack/unix.rs).</p>\n<p>For example, <code>wasmtime_fiber::FiberStack</code> expects that the <code>wasmtime_fiber_switch</code> function stores the IP and RP on the actual stack where we left off on the stack we depart. In contrast, when you, me and @alexcrichton discussed the  <code>stack_switch</code> CLIF instruction we decided that it would be nicer to store only the data GPRs on the stack itself, and write the remaining data (like IP, RBP) elsewhere. We now write this to the header of the stack near its top.</p>\n<p>It may be possible to move both implementations (i.e., <code>wasmtime_fiber</code> and our stack switching) closer to each other, so that they used the exact same layout of <code>FiberStack</code>, but that may require some compromising, ultimately making things more brittle. For example, both implementations would need to agree on a type for passing status information and payloads (see <code>wasmtime_fiber::RunResult</code>). Do let me know if you would like me to elaborate on the details of what would be required further. </p>\n<p>If we leave the Unix world, things become even more complicated: The Windows implementation of <code>wasmtime_fiber::FiberStack</code> doesn't manage the stack memory directly (making <code>wasmtime_fiber::FiberStack</code> mostly just a dummy), and <code>wasmtime_fiber::Fiber</code> uses the Windows Fiber API to create and run stacks. My plan for the Windows implementation of the stack switching proposal was not to use that API, but do the stack switching in generated code. Thus, there is quite a difference between what <code>wasmtime_fiber::FiberStack</code> currently does on Windows, and what we'd need.</p>\n</blockquote>",
        "id": 513306583,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745182840
    },
    {
        "content": "<p>frank-emrich <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2817340658\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<p>@fitzgen Regarding tables with continuations</p>\n<blockquote>\n<p>Ah okay, I get it now. You're right that we definitely don't want to cut the capacity of all existing tables in half in order to support a proposal that 99% of users won't be leveraging yet.</p>\n<p>[...] We could plumb through a boolean for whether the stack-switching proposal is enabled to this method, or the whole WasmFeatures or something, and then adjust the size of a single element in the table size calculation based on that value.</p>\n<p>In the meantime, halving the capacity just for continuation tables (rather than all other existing tables) is fine. And we can do the above suggestions in follow up PRs.</p>\n</blockquote>\n<p>Just halving the max allowed capacity for the time being and then plumbing through whether the stack switching feature is enabled in the longer terms sounds good to me.</p>\n</blockquote>",
        "id": 513307108,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745183271
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2780334761\">PR review</a>.</p>",
        "id": 513308266,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745184229
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2051810167\">PR review comment</a>:</p>\n<blockquote>\n<p>I've run these commands, the results are here:<br>\n<a href=\"https://gist.github.com/frank-emrich/f7f80adc8005900a3e245d2400149b38\">https://gist.github.com/frank-emrich/f7f80adc8005900a3e245d2400149b38</a></p>\n<p>(But no comparing the  <code>stack-switching-infra</code> branch against actual <code>main</code>, but the merge base with <code>main</code>, since <code>main</code> has moved forward quite a bit since the last merge)</p>\n<p>I'm not quite sure how to interpret the output, would you mind having a look?</p>\n<p>I will re-run this once I follow through with your <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2031832400\">suggestion</a> of splitting out most of the <code>EntryStoreContext</code> into a separate PR.<br>\n</p>\n</blockquote>",
        "id": 513308267,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745184230
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 513383439,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745233829
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 513474804,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745272077
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2782349269\">PR review</a>.</p>",
        "id": 513478950,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745274433
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2053063541\">PR review comment</a>:</p>\n<blockquote>\n<p>No problem, making the changes to this critical bit of code more reviewable is perfectly sensible. I've created a PR with the <code>EntryStoreContext</code> stuff minus stack-switching fields here: #10626<br>\nOnce that is landed it will be easy to see what additional stuff this PR needs to add to <code>EntryStoreContext</code> (not much, really)</p>\n</blockquote>",
        "id": 513478952,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745274434
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2784700221\">PR review</a>.</p>",
        "id": 513656049,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745339873
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2054472967\">PR review comment</a>:</p>\n<blockquote>\n<p>Are these benchmark results for this whole branch, or for just the <code>EntryStoreContext</code> changes in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10626\">https://github.com/bytecodealliance/wasmtime/pull/10626</a>?</p>\n<p>Unfortunately, it looks like there are a bunch of regressions, and enough of them that it doesn't seem likely to be a statistical fluke. But that doesn't mean that this is all a non-starter. What this likely means is that there are some functions that need to be marked <code>#[inline]</code> and/or split into fast and slow paths, roughly like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[inline]</span>\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Bar</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">is_foo_enabled</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">foo_slow_path</span><span class=\"p\">()</span>\n<span class=\"p\">}</span>\n\n<span class=\"cp\">#[inline(never)]</span>\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">foo_slow_path</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Bar</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>A good place to start addressing this would be in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10626\">https://github.com/bytecodealliance/wasmtime/pull/10626</a>, since the set of changes is smaller and easier to get a handle on the total effect of changes. I can help out and do a little profiling later today.</p>\n<p>The workflow is basically run a regressing benchmark <a href=\"https://bheisler.github.io/criterion.rs/book/user_guide/profiling.html\">in profiling mode</a> and attach <code>perf</code>/<code>samply</code>/instruments/vtune/whatever your profiler of choice is, look at the top self-time functions, and then check whether it is necessary to be called (i.e. can't be conditional on some feature being used), whether it is being inlined, whether it can be split into fast and slow paths, etc...</p>\n<p>Again, I can do a bit of this later today, so don't stress out too much. I don't want to hold these PRs up.</p>\n</blockquote>",
        "id": 513656050,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745339873
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2821901150\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<blockquote>\n<p>Just halving the max allowed capacity for the time being and then plumbing through whether the stack switching feature is enabled in the longer terms sounds good to me.</p>\n</blockquote>\n<p>Just making sure we are on the same page: specifically only continuation-ref tables should have their capacity halved. <code>funcref</code> and <code>VMGcRef</code> tables should be unaffected.</p>\n</blockquote>",
        "id": 513656879,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745340121
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 513734917,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745359583
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2843261658\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<blockquote>\n<p>It may be possible to move both implementations (i.e., <code>wasmtime_fiber</code> and our stack switching) closer to each other, so that they used the exact same layout of <code>FiberStack</code>, but that may require some compromising, ultimately making things more brittle. For example, both implementations would need to agree on a type for passing status information and payloads (see <code>wasmtime_fiber::RunResult</code>). Do let me know if you would like me to elaborate on the details of what would be required further.</p>\n</blockquote>\n<p>I guess that what I am imagining is that, despite whatever headers or whatnot that they layer onto the stack, they share the same underying mechanism (and <code>Config</code> knobs and all that) to allocate/deallocate them and manage them in the runtime (i.e. they come from the same pool when using the pooling allocator). This would <em>not</em> require that we unify their stack switching code paths (since one is in a mix of Rust code and inline assembly and the other is implemented in JIT code) but it would mean that we would have some kind of <code>VMRawStack</code> type or some such that manages the underlying memory allocation/<code>mmap</code>/fiber, is allocated/deallocated via the <code>InstanceAllocator</code> trait, the pooling allocator (for example) would pool these objects, and then both <code>wasmtime_fiber::FiberStack</code> and <code>ContinuationStack</code> would be thin-ish wrappers around that <code>VMRawStack</code> allocation.</p>\n<p>That said, this refactoring doesn't need to happen now, before this PR merges. I think it can be left for follow ups. However, we wouldn't do things like enable the stack-switching feature by default in Wasmtime, for example, until after this was resolved.</p>\n<blockquote>\n<p>If we leave the Unix world, things become even more complicated: The Windows implementation of <code>wasmtime_fiber::FiberStack</code> doesn't manage the stack memory directly (making <code>wasmtime_fiber::FiberStack</code> mostly just a dummy), and <code>wasmtime_fiber::Fiber</code> uses the Windows Fiber API to create and run stacks. My plan for the Windows implementation of the stack switching proposal was not to use that API, but do the stack switching in generated code. Thus, there is quite a difference between what <code>wasmtime_fiber::FiberStack</code> currently does on Windows, and what we'd need.</p>\n</blockquote>\n<p>My understanding of the constraints for Windows is that, even if we emit inline code for bookkeeping the metadata required in Windows, the allocation and deallocation of fiber stacks must happen through <code>CreateFiber[Ex]</code> (or <code>ConvertThreadToFiber</code>) and <code>DeleteFiber</code>. In this case, having a shared <code>VMRawStack</code> that understands and abstracts this stuff away should hopefully actually make things easier for us here.</p>\n<hr>\n<p>Anyways, let me know when all the <code>TODO</code>s and previous comments have been addressed, and this is ready for another round of review. Thanks!</p>\n</blockquote>",
        "id": 515397449,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746046592
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 519921929,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747948468
    },
    {
        "content": "<p>posborne <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2905359053\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<p>@fitzgen I (hopefully) have addressed all the review comments outstanding on this, though happy to address anything I missed or new things that need to be addressed.  I'm working on getting a merge of upstream back into the branch validated which I'll use as a base to get criterion numbers to compare to see what perf regressions we might need to fix up.</p>\n<p>With the pooling allocator for tables, I did some small renaming -- the change will eagerly use as much space as is available in the allocated pages rather than being strictly half; in general, I don't think this will cause confusion for users.  Another approach could be to just move to have consumers specify the number of bytes / pages for tables rather than number of (nominal) elements to avoid the mildly awkward dance that is now present.</p>\n</blockquote>",
        "id": 520103539,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748022941
    },
    {
        "content": "<p>posborne updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 520725415,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748366160
    },
    {
        "content": "<p>posborne updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 520726662,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748366637
    },
    {
        "content": "<p>posborne updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 520750834,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748376065
    },
    {
        "content": "<p><strong>posborne</strong> requested <a href=\"https://github.com/abrown\">abrown</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 520753460,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748377228
    },
    {
        "content": "<p>posborne updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 520753461,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748377228
    },
    {
        "content": "<p><strong>posborne</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers\">wasmtime-compiler-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 520753462,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748377228
    },
    {
        "content": "<p>posborne updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 520764188,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748382257
    },
    {
        "content": "<p>posborne updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 520764876,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748382667
    },
    {
        "content": "<p>posborne updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 520765387,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748382908
    },
    {
        "content": "<p>posborne updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 520927844,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748448266
    },
    {
        "content": "<p>posborne <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2916963770\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<p>Apologies on the noise; I'm going to move testing to a fork short term to push through hopefully the last set of changes to do a more complete conditional compilation pass based on what is done for gc.</p>\n</blockquote>",
        "id": 520933811,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748450195
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2917084214\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<blockquote>\n<p>@fitzgen I (hopefully) have addressed all the review comments outstanding on this, though happy to address anything I missed or new things that need to be addressed.</p>\n</blockquote>\n<p>Great! I'll give another round of review in that case.</p>\n<blockquote>\n<p>Another approach could be to just move to have consumers specify the number of bytes / pages for tables rather than number of (nominal) elements to avoid the mildly awkward dance that is now present.</p>\n</blockquote>\n<p>Yes, this is what we should probably do (in a different / follow up PR)</p>\n</blockquote>",
        "id": 520941846,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748453078
    },
    {
        "content": "<p>posborne updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 520959550,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748460132
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2878772963\">PR review</a>:</p>\n<blockquote>\n<p>Looking good! I have a ton of comments below, they are all nitpicks really, so this should be good to land as soon as they are fixed.</p>\n<p>Thanks everyone!</p>\n</blockquote>",
        "id": 521172081,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553349
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114262097\">PR review comment</a>:</p>\n<blockquote>\n<p>Can you add an offset assertion for this field to to the <code>test_vmstore_context::field_offsets</code> test just below here?</p>\n<p>And similar for all the other new offset definitions in environ, we want to make sure that they actually match our expectations at runtime.</p>\n</blockquote>",
        "id": 521172082,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553349
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114307132\">PR review comment</a>:</p>\n<blockquote>\n<p>Ditto</p>\n</blockquote>",
        "id": 521172083,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553349
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114246729\">PR review comment</a>:</p>\n<blockquote>\n<p>Very nitty pick: weird to have an empty line after a <code>#[cfg(...)]</code>, better to have it right on top of the thing it is conditionally turning on/off.</p>\n</blockquote>",
        "id": 521172084,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553349
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114306005\">PR review comment</a>:</p>\n<blockquote>\n<p>Slightly cleaner / more idiomatic to use <code>if let Some</code> to avoid the <code>unsafe</code> constructor and <code>.cast::&lt;T&gt;()</code> to avoid <code>as</code> conversions which can be a little wider and more footgun-y than desirable:</p>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>    let init_value = if let Some(contref) = NonNull::new(init_value_contref.cast::&lt;VMContRef&gt;()) {\n        // ...\n    } else {\n        None\n    };\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 521172085,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553349
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114329856\">PR review comment</a>:</p>\n<blockquote>\n<p>Can we rename this to something like <code>VMHostArray</code> or something like that so that readers do not mistake it for the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/be0ba4b83e60c17d49b3c7149334fbf587487cbc/crates/wasmtime/src/runtime/vm/gc/enabled/arrayref.rs#L23\"><code>wasmtime::runtime::vm::gc::VMArrayRef</code></a> type?</p>\n</blockquote>",
        "id": 521172087,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114338559\">PR review comment</a>:</p>\n<blockquote>\n<p>I don't think this is necessary (anymore)? I don't see any casts below.</p>\n<p>If I am just missing it, can we put the <code>allow</code> right on the cast, instead of on the whole function? Or alternatively define and use a helper like <a href=\"https://github.com/bytecodealliance/wasmtime/blob/be0ba4b83e60c17d49b3c7149334fbf587487cbc/crates/wasmtime/src/runtime/vm/gc/enabled.rs#L28\">https://github.com/bytecodealliance/wasmtime/blob/be0ba4b83e60c17d49b3c7149334fbf587487cbc/crates/wasmtime/src/runtime/vm/gc/enabled.rs#L28</a></p>\n</blockquote>",
        "id": 521172088,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114315046\">PR review comment</a>:</p>\n<blockquote>\n<p>Each (non-absent) <code>VMContRef</code> has a pointer to the last ancestor, not just the youngest <code>VMContRef</code>, right?</p>\n<p>If so, it probably makes sense to depict that in this ascii diagram:</p>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>///                 |---|   VMContRef    |\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 521172089,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114375774\">PR review comment</a>:</p>\n<blockquote>\n<p>Hmm... This is a little scary. I think that ideally we should never be running <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2031809149\">host functions</a> on a continuation stack (as opposed to libcalls, which can (potentially temporarily before switching to the native stack) execute on the fiber stack).</p>\n<p>In general, our invariants for async code and our existing fiber stacks, in order to support suspension, are that we always switch off the async stack and back to the native stack to run host functions, let them suspend and do async-y / event-loop-y stuff, and when Wasm is finally resumed we switch back to the fiber stack. The invariants here around which methods expect certain stack state are pretty subtle and not always super well documented, and this is kind of making me nervous again about the split between continuation vs fiber stacks.</p>\n<p>Growing memory, for example, might try to stack switch back to the main thread to run the host's async limiter hook (if configured) and then when that resolves will try and switch back to the wasm fiber stack to continue the memory growth. I think that pair of operations is currently safe to perform from a non-fiber stack, and I think we will switch back to the correct place. But I am not 100% confident. A test case that configures an async limiter, runs Wasm that creates and switches to a new continuation stack and then does a <code>memory.grow</code> from that continuation stack is something we should definitely have, at minimum.</p>\n<p>I just pinged @alexcrichton about this and he also pointed out that if we are calling host code on continuation stacks, we won't ever be able to have Wasm stacks that look different from native stacks (no resizable stacks (modulo virtual memory tricks) or segmented stacks, continuation stacks must have a guard page at the end, etc...). That is all probably okay, but we should be aware of the constraints we are adopting for ourselves here.</p>\n</blockquote>",
        "id": 521172090,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114524893\">PR review comment</a>:</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html#method.next_multiple_of\">https://doc.rust-lang.org/nightly/std/primitive.usize.html#method.next_multiple_of</a></p>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>            size.next_multiple_of(page_size)\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 521172091,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114532570\">PR review comment</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>                let target = tos.sub(tos_neg_offset).cast::&lt;usize&gt;();\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 521172092,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114531365\">PR review comment</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>                usize::try_from(tos).unwrap() - 0x20 - s\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 521172093,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114508664\">PR review comment</a>:</p>\n<blockquote>\n<p><code>VMRuntimeLimits</code> was renamed to <code>VMStoreContext</code>, so this (and elsewhere in this comment) should be updated accordingly.</p>\n</blockquote>",
        "id": 521172094,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114344806\">PR review comment</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>/// Additionally, a `CommonStackInformation` object is associated with\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 521172095,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114530826\">PR review comment</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>            let s = usize::try_from(args_capacity).unwrap() * std::mem::size_of::&lt;ValRaw&gt;();\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 521172096,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114554741\">PR review comment</a>:</p>\n<blockquote>\n<p>Ugh, annoying that <code>.max()</code> is not <code>const</code></p>\n</blockquote>",
        "id": 521172097,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114284567\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind turning this <code>if</code> into a <code>match</code> and then adding the comments for why we can skip tracing for the other states into each of the relevant match arms? This will be a little more future proof in the face of evolving states.</p>\n</blockquote>",
        "id": 521172098,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114535252\">PR review comment</a>:</p>\n<blockquote>\n<p>\"It must never return\" but then at the bottom there is a comment that \"after this function returns, ...\"</p>\n<p>Which is it supposed to be?</p>\n</blockquote>",
        "id": 521172099,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114546818\">PR review comment</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>#[cfg(feature = \"pooling-allocator\")]\n</code></pre></div>\n<p>perhaps?</p>\n</blockquote>",
        "id": 521172101,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114563436\">PR review comment</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>    #[cfg(feature = \"gc\")]\n</code></pre></div>\n<p>perhaps?</p>\n</blockquote>",
        "id": 521172102,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114569602\">PR review comment</a>:</p>\n<blockquote>\n<p>Can you add a TODO item to the stack-switching implementation meta issue to extend our stack-capturing fuzzer to capture backtraces across stack suspensions and assert that the backtrace is still what we expect it to be?</p>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/fuzzing/src/generators/stacks.rs\">https://github.com/bytecodealliance/wasmtime/blob/main/crates/fuzzing/src/generators/stacks.rs</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/fuzzing/src/oracles/stacks.rs\">https://github.com/bytecodealliance/wasmtime/blob/main/crates/fuzzing/src/oracles/stacks.rs</a></li>\n</ul>\n</blockquote>",
        "id": 521172103,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114747895\">PR review comment</a>:</p>\n<blockquote>\n<p>Can this be rewritten to use <a href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.chunks\">slice::chunks</a> and <code>zip</code>? And also narrow the <code>unsafe</code> to just the relevant blocks (because I had a hard time figuring out why it was needed at a glance). I think this would make the code a bit safer and easier to read. Something like this (although preserving comments where appropriate):</p>\n<p><div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>        for (conts, parent_limits) in continuations_vec.chunks(2).zip(stack_limits_vec.iter().skip(1)) {\n            let continuation = conts[0];\n            let continuation = unsafe { &amp;*continuation };\n\n            let parent_limits = unsafe { &amp;*parent_limits };\n\n            let parent_continuation = conts.get(1).map(|p| unsafe { &amp;*p });\n\n            // ...\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 521172104,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114561780\">PR review comment</a>:</p>\n<blockquote>\n<p>Table changes look good to me <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n</blockquote>",
        "id": 521172105,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114310111\">PR review comment</a>:</p>\n<blockquote>\n<p>Might also make sense to have a <code>fn VMContObj::from_raw_parts(value: *mut u8, revision: u64) -&gt; Option&lt;Self&gt;</code> helper method or something to avoid repeating these same few lines all over the place</p>\n</blockquote>",
        "id": 521172106,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748553350
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2879692842\">PR review</a>.</p>",
        "id": 521176352,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748555341
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114801811\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>Each (non-absent) VMContRef has a pointer to the last ancestor, not just the youngest VMContRef, right?</p>\n</blockquote>\n<p>No, it's just the youngest one that has the <code>last_ancestor</code> pointer set. That may seem a bit odd, but we would never read the <code>last_ancestor</code> field of the intermediate VMContRefs and it would be quite cumbersome to set these pointers on the intermediate continuations when suspending.</p>\n<p>At least we can express precisely when the <code>last_ancestor</code> field contains usable data <br>\nin terms of the continuation's state (as represented by <code>my_vmcontref.common_stack_information.state</code>). There's a comment with the details on the <code>last_ancestor</code> field in the struct definition.<br>\n</p>\n</blockquote>",
        "id": 521176353,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748555342
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2879703777\">PR review</a>.</p>",
        "id": 521177149,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748555749
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114809507\">PR review comment</a>:</p>\n<blockquote>\n<p>Ha, well spotted! I must have forgotten updating the comment here, <code>fiber_start</code> is allowed to return now because <code>wasmtime_continuation_start</code> contains the logic for going back to the parent these days.</p>\n</blockquote>",
        "id": 521177150,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748555749
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2879735799\">PR review</a>.</p>",
        "id": 521179786,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748557032
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2114830776\">PR review comment</a>:</p>\n<blockquote>\n<p>Ah, sorry, I must have overlooked your last sentence in the linked thread:</p>\n<blockquote>\n<p>[...] and I would also expect that we would call libcalls, but never host functions, on stack-switching stacks, same way we do things on our async fibers </p>\n</blockquote>\n<p>We do indeed allow calling host functions from our continuation stacks at the moment, and even re-entering Wasm from such a host function leading to calls chains chains of the following shape:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">   </span><span class=\"n\">Wasm</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"p\">)</span>\n<span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">Wasm</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">continuation</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">host</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">continuation</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">Wasm</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">continuation</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">Wasm</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">continuation</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">host</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">continuation</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"o\">..</span><span class=\"p\">.</span>\n</code></pre></div>\n<p>I think @dhil had a use-case where allowing such re-entrance is useful, but I see how running host functions on continuation stacks has its problems.</p>\n<p>It's easy to check if we are currently running on a continuation stack, but that would have to happen at every call to a host function, right? But I guess there must already be such a check for whether we are on a Fiber stack (for the async feature) that we can adapt?<br>\n</p>\n</blockquote>",
        "id": 521179787,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748557032
    },
    {
        "content": "<p>posborne created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2116508881\">PR review comment</a>:</p>\n<blockquote>\n<p>Patch will land in a new <code>VMContObj::from_raw_parts</code> impl.</p>\n</blockquote>",
        "id": 521358565,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748633057
    },
    {
        "content": "<p>posborne submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2882317654\">PR review</a>.</p>",
        "id": 521358566,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748633057
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2882340183\">PR review</a>.</p>",
        "id": 521360070,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748633718
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2116522964\">PR review comment</a>:</p>\n<blockquote>\n<p>Those sequence of calls should definitely be supported, but ideally we would automatically switch to the native host stack and then back again while executing the actual host functions. That said, I think this PR is fine for now, and this is something we can address in the future.</p>\n<blockquote>\n<p>It's easy to check if we are currently running on a continuation stack, but that would have to happen at every call to a host function, right? But I guess there must already be such a check for whether we are on a Fiber stack (for the async feature) that we can adapt?</p>\n</blockquote>\n<p>We don't dynamically check, we have different paths for constructing async and sync <code>wasmtime::Func</code>s (and we have various assertions that the constructor you use matches the engine's config):</p>\n<ul>\n<li>The sync version invokes the host function directly after marshalling arguments</li>\n<li>The async version <a href=\"https://github.com/bytecodealliance/wasmtime/blob/90a2351b4f9aa70bfdda81ad4f4713e1b97f6936/crates/wasmtime/src/runtime/func.rs#L566\">uses <code>block_on</code></a> to <a href=\"https://github.com/bytecodealliance/wasmtime/blob/90a2351b4f9aa70bfdda81ad4f4713e1b97f6936/crates/wasmtime/src/runtime/store/async_.rs#L798\">automatically suspend</a> the current fiber and switch back to the native host stack (via coordination with the original <a href=\"https://github.com/bytecodealliance/wasmtime/blob/90a2351b4f9aa70bfdda81ad4f4713e1b97f6936/crates/wasmtime/src/runtime/store/async_.rs#L221\"><code>on_fiber</code></a> caller; we have similar sync vs async paths for calling into Wasm, each of which also assert that the version used matches the engine's config, and the async path takes care to <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasmtime/src/runtime/func.rs#L1170\">alway use <code>on_fiber</code></a>)</li>\n</ul>\n</blockquote>",
        "id": 521360072,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748633718
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2116522964\">PR review comment</a>.</p>",
        "id": 521360261,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748633773
    },
    {
        "content": "<p>posborne submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2882348052\">PR review</a>.</p>",
        "id": 521360688,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748633972
    },
    {
        "content": "<p>posborne created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2116528071\">PR review comment</a>:</p>\n<blockquote>\n<p>Looking at this again, this whole <code>match_feature!</code> should be dropped at is now covered by an earlier chunk of code (basically doing the macro by hand to support both features).  Good catch.</p>\n</blockquote>",
        "id": 521360689,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748633972
    },
    {
        "content": "<p>posborne submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2889431324\">PR review</a>.</p>",
        "id": 521810222,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748887109
    },
    {
        "content": "<p>posborne created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2121818475\">PR review comment</a>:</p>\n<blockquote>\n<p>@fitzgen  In addressing the latest review items, I'm trying to work out what I should target in terms of conversions of types into usize.  I see a few cases with what I believe is the requested conversion.</p>\n<ul>\n<li><code>T -&gt; usize</code> where <code>T: TryInto&lt;usize&gt;</code>: For any of these types (e.g. u32, u8, ...) we want to do a <code>usize::try_from(value).unwrap()</code> rather than a cast.  I'm assuming that the these will compile down to a cast when optimized for types (like u32 on any architecture with a 32-bit+ word size) but we prefer a panic if somehow the code were compiled for a target with a 16-bit pointer width (and a value that doesn't fit).</li>\n<li>Pointers: A cast using <code>as usize</code> is OK for these.</li>\n</ul>\n<p>I'll admit the <code>TryFrom</code>/<code>unwrap</code> for types like u32 feels gross to me with it being preferred to fail compilation for types that can't be converted always be cast correctly.</p>\n<p>As an aside, I did to a quick check in godbolt to confirm that the <code>TryFrom</code> for <code>u32 -&gt; usize</code> does optimize out, so shouldn't be a perf impact, so I suppose this is mostly a readabilty/cosmetic concern.</p>\n<hr>\n<p>In this particular case <code>tos</code> is a <code>*mut u8</code> so the <code>TryFrom</code> approach isn't available and I'm assuming it should remain an <code>as usize</code> cast.</p>\n</blockquote>",
        "id": 521810223,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748887109
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2890008621\">PR review</a>.</p>",
        "id": 521848978,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748900277
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2122203565\">PR review comment</a>:</p>\n<blockquote>\n<p>Here are the general rules to follow:</p>\n<p>First, if there are infallible <code>From</code>/<code>Into</code> impls available, use those.</p>\n<p>For conversions with <code>usize</code>, Rust doesn't add/remove infallible conversions to <code>u32</code>/<code>u64</code> depending on the target, so that source code is more portable by default. In these cases, we should use <code>TryFrom</code>/<code>TryInto</code> and <code>unwrap()</code>, and the compiler will boil it all away, as you mentioned.</p>\n<p>For other technically-fallible conversions that shouldn't actually fail due to program invariants, like <code>u64</code> to <code>u32</code> where we know we never exceed <code>u32::MAX</code>, we should also use <code>TryFrom</code>/<code>TryInto</code> and <code>unwrap()</code> so that things fail loudly if our invariants aren't upheld.</p>\n<p>For conversions to <code>usize</code> from pointers, we use <code>as</code> today, but eventually should be using <code>ptr.addr()</code> and strict provenance APIs once we can rely on Rust 1.84 and greater.</p>\n<hr>\n<p>If I messed up any specific review comment, feel free to just leave a comment on that explaining my whoopsie, as long as we are abiding by the above general rules.</p>\n</blockquote>",
        "id": 521848979,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748900277
    },
    {
        "content": "<p>posborne submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2890040686\">PR review</a>.</p>",
        "id": 521850627,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748901006
    },
    {
        "content": "<p>posborne created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2122224625\">PR review comment</a>:</p>\n<blockquote>\n<p>Thanks for the guidance, makes sense to me; I talked a bit with @sunfishcode in our 1:1 about strict provenance this afternoon as well, so thanks for covering that.  I'll update based on those recommendations.</p>\n</blockquote>",
        "id": 521850632,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748901007
    },
    {
        "content": "<p>posborne submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2890051011\">PR review</a>.</p>",
        "id": 521851481,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748901368
    },
    {
        "content": "<p>posborne created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2122231259\">PR review comment</a>:</p>\n<blockquote>\n<p>It does appear that the wasmtime MSRV on main is now 1.85.0 which should mean that we could rely on the stabilized strict provenance APIs (or use <code>sptr::Strict</code>).</p>\n</blockquote>",
        "id": 521851482,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748901368
    },
    {
        "content": "<p>posborne updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 522414969,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749058347
    },
    {
        "content": "<p>posborne updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 522415611,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749058540
    },
    {
        "content": "<p>posborne submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2897570281\">PR review</a>.</p>",
        "id": 522415708,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749058571
    },
    {
        "content": "<p>posborne created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2127112001\">PR review comment</a>:</p>\n<blockquote>\n<p>Adopted this general approach, worked out well.</p>\n</blockquote>",
        "id": 522415710,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749058571
    },
    {
        "content": "<p>posborne submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2897577770\">PR review</a>.</p>",
        "id": 522416174,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749058730
    },
    {
        "content": "<p>posborne created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2127116191\">PR review comment</a>:</p>\n<blockquote>\n<p>The tests in the environ crate for stack switching seemed to cover the other cases already; I did land a commit reorganizing the location of the tests there to be in their own module to aid discovery and be a bit more in line with the prevailing pattern for test inclusion.</p>\n<p>Let me know if those don't cover what you had in mind for assertions for the environ bits.</p>\n</blockquote>",
        "id": 522416175,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749058730
    },
    {
        "content": "<p>posborne <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2940867994\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<p>@fitzgen I think there's now changes to address the latest round of feedback; with how gh permissions work I can't directly modify the description for the tracking issue but I have notes and will add a comment with the new items to add that a maintainer or @frank-emrich  should be able to pull into the description body.</p>\n</blockquote>",
        "id": 522416889,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749058970
    },
    {
        "content": "<p>posborne submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2897598950\">PR review</a>.</p>",
        "id": 522417808,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749059255
    },
    {
        "content": "<p>posborne created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2127129892\">PR review comment</a>:</p>\n<blockquote>\n<p>Missed this in my first pass; should land a patch shortly with this change.</p>\n</blockquote>",
        "id": 522417810,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749059255
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2897723505\">PR review</a>:</p>\n<blockquote>\n<p>LGTM modulo the comment that you forgot to address</p>\n</blockquote>",
        "id": 522426151,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749061999
    },
    {
        "content": "<p>posborne updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 522433546,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749064498
    },
    {
        "content": "<p>posborne submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2897838639\">PR review</a>.</p>",
        "id": 522433725,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749064575
    },
    {
        "content": "<p>posborne created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2127274040\">PR review comment</a>:</p>\n<blockquote>\n<p>Updated now; there wasn't a previous document comment on <code>VMStackState::Returned</code> which I grouped with Fresh but didn't dig into that case in detail not being particularly familiar with the gc impl at this point.</p>\n</blockquote>",
        "id": 522433726,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749064575
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2898124715\">PR review</a>:</p>\n<blockquote>\n<p>This all looks good to me as well, thanks again for pushing on this to everyone involved!</p>\n<p>One minor thing I noticed reading over this and I also filed a few points in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10248\">https://github.com/bytecodealliance/wasmtime/issues/10248</a> under miscellaneous TODOs at the end</p>\n</blockquote>",
        "id": 522464234,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749077226
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2127451083\">PR review comment</a>:</p>\n<blockquote>\n<p>Should this be left out?</p>\n</blockquote>",
        "id": 522464236,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749077227
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#issuecomment-2941831546\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>:</p>\n<blockquote>\n<p>(I'm going to go ahead and flag this for merge though to carry through Nick's approval, my small thing can be fixed after)</p>\n</blockquote>",
        "id": 522464280,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749077253
    },
    {
        "content": "<p>alexcrichton merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388\">PR #10388</a>.</p>",
        "id": 522466336,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749078494
    },
    {
        "content": "<p>posborne created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#discussion_r2129173147\">PR review comment</a>:</p>\n<blockquote>\n<p>Yeah, missed these when I removed most of the other bespoke debug assertion bits; will add to #10248 TODOs.</p>\n</blockquote>",
        "id": 522623771,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749138716
    },
    {
        "content": "<p>posborne submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10388#pullrequestreview-2900880774\">PR review</a>.</p>",
        "id": 522623774,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749138717
    }
]