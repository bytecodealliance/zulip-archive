[
    {
        "content": "<p>rikhuijzer opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10527\">issue #10527</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>As a feature request, I was thinking that it might be useful for Wasmtime to support an allowlist for domains that the wasm may connect to. This would be similar to the <code>Content-Security-Policy</code> in browsers.</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>cargo<span class=\"w\"> </span>component<span class=\"w\"> </span>sometool<span class=\"w\"> </span>--allow-domains<span class=\"o\">=</span><span class=\"s2\">\"wasmtime.dev,webassembly.org\"</span>\n</code></pre></div>\n<h4>Benefit</h4>\n<p>The benefit would be additional security. As recently was shown again with the attack on the <a href=\"https://semgrep.dev/blog/2025/popular-github-action-tj-actionschanged-files-is-compromised/\">tj-actions/changed-files</a>, attackers can use supply chain attacks to obtain secrets. In this particular attack they used the GitHub Actions logs, but sending them to their own servers has happened before as well.</p>\n<h4>Alternatives</h4>\n<p>Alternatively, this could be ensured during compile time? I haven't seen a tool for it yet but I can imagine it's would be possible.</p>\n<p>If this feature request is not considered a good feature then please feel free to close this issue.</p>\n</blockquote>",
        "id": 510360367,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1743850377
    },
    {
        "content": "<p>rajatjindal <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10527#issuecomment-2788867528\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10527\">issue #10527</a>:</p>\n<blockquote>\n<p>I had similar thoughts and had started work on <a href=\"https://github.com/rajatjindal/spin-trigger-ghaction\">https://github.com/rajatjindal/spin-trigger-ghaction</a> but didn't finish it yet.</p>\n</blockquote>",
        "id": 511116596,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744189290
    },
    {
        "content": "<p>rikhuijzer <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10527#issuecomment-2788935218\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10527\">issue #10527</a>:</p>\n<blockquote>\n<blockquote>\n<p>I had similar thoughts and had started work on <a href=\"https://github.com/rajatjindal/spin-trigger-ghaction\">https://github.com/rajatjindal/spin-trigger-ghaction</a> but didn't finish it yet.</p>\n</blockquote>\n<p>Very nice. Iâ€™m very supportive of any attempt at improving GitHub Actions security.</p>\n<p>For clarification though, my feature request here is not necessarily about GitHub Actions. The aim is to restrict wasm executables privileges. Currently, http can either be allowed or disallowed, but I can imagine that more fine-grained settings could be useful to avoid a random dependency sending data to some malicious server.</p>\n</blockquote>",
        "id": 511119409,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744190051
    },
    {
        "content": "<p>pchickey closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10527\">issue #10527</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>As a feature request, I was thinking that it might be useful for Wasmtime to support an allowlist for domains that the wasm may connect to. This would be similar to the <code>Content-Security-Policy</code> in browsers.</p>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>cargo<span class=\"w\"> </span>component<span class=\"w\"> </span>sometool<span class=\"w\"> </span>--allow-domains<span class=\"o\">=</span><span class=\"s2\">\"wasmtime.dev,webassembly.org\"</span>\n</code></pre></div>\n<h4>Benefit</h4>\n<p>The benefit would be additional security. As recently was shown again with the attack on the <a href=\"https://semgrep.dev/blog/2025/popular-github-action-tj-actionschanged-files-is-compromised/\">tj-actions/changed-files</a>, attackers can use supply chain attacks to obtain secrets. In this particular attack they used the GitHub Actions logs, but sending them to their own servers has happened before as well.</p>\n<h4>Alternatives</h4>\n<p>Alternatively, this could be ensured during compile time? I haven't seen a tool for it yet but I can imagine it's would be possible.</p>\n<p>If this feature request is not considered a good feature then please feel free to close this issue.</p>\n</blockquote>",
        "id": 511502761,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744316994
    },
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10527#issuecomment-2795090572\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10527\">issue #10527</a>:</p>\n<blockquote>\n<p>I'm pretty sure the HTTP allowlist issue has been discussed before, but I can't find it in our issue tracker.</p>\n<p>In short: right now you can't enforce an http domain allowlist with the wasmtime-cli, and I don't think we are going to add support for it in the near future.</p>\n<p>If you want to solve this problem with wasmtime today, you will need to make your own wasmtime embedding, and customize your implementation of <a href=\"https://docs.rs/wasmtime-wasi-http/31.0.0/wasmtime_wasi_http/trait.WasiHttpView.html#method.send_request\">https://docs.rs/wasmtime-wasi-http/31.0.0/wasmtime_wasi_http/trait.WasiHttpView.html#method.send_request</a> to first check that the authority matches some allowlist stored in your context, and if accepted pass the request to <a href=\"https://docs.rs/wasmtime-wasi-http/31.0.0/wasmtime_wasi_http/types/fn.default_send_request.html\">https://docs.rs/wasmtime-wasi-http/31.0.0/wasmtime_wasi_http/types/fn.default_send_request.html</a> which provides the default implementation of that method.</p>\n<p>In general we want wasmtime-cli to provide a useful way to run components, but it isn't intended to be configured to handle \"policies\" such as network allow lists or deny lists. For now, if you want to add access control policies, you need to do so in the host by using the wasmtime, wasmtime-wasi, and wasmtime-wasi-http crates directly. Those crates have Rust APIs are much richer than we can expose through the cli, and the overwhelming share of production uses of wasmtime are by way of custom embeddings of those crates, rather than through the cli tool.</p>\n<p>Specifically to the case of access control policies, the Bytecode Alliance vision is that this problem will be solvable with <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/examples/LinkTimeVirtualization.md\">component model virtualization</a>, where you can take a component that imports <a href=\"https://github.com/WebAssembly/wasi-http/blob/main/wit/handler.wit#L25-L49\"><code>wasi:http/outgoing-handler</code> </a> and compose it with a component that both exports and imports that same interface, applying the policy and proxying the rest to the imported interface. (There is an early attempt at this at <a href=\"https://github.com/bytecodealliance/WASI-Virt\">https://github.com/bytecodealliance/WASI-Virt</a> but its not production ready.) The big roadblock is that in WASI 0.2, component composition doesn't work out very well in practice, because readiness, streams and futures are taken care of through resources, which ends up making composition quite inefficient unwieldy. We are resolving the design problems that make this difficult in the Component Model and WASI 0.3 by providing first-class support for async in the Component Model. This work is still under development and is expected to ship in the next few months. Once the standard and its host implementations ship, then folks will have time to revisit the WASI-Virt project and/or build other ways to add policies to components, and you'll be able to apply an ACL to a component before running it in wasmtime-cli, or in any other wasi host implementation.</p>\n<p>I'm going to close this issue because this answer describes both a workaround and the way a better answer will be available in the future, but I'm happy to continue discussion here and help you understand this issue more.</p>\n</blockquote>",
        "id": 511502763,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744316995
    },
    {
        "content": "<p>rikhuijzer <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10527#issuecomment-2795138695\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10527\">issue #10527</a>:</p>\n<blockquote>\n<p>@pchickey Thank you for the in-depth clarification. Very useful. I also like it that you closed it. Clear communication. I appreciate that. <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>\n</blockquote>",
        "id": 511505857,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744318271
    }
]