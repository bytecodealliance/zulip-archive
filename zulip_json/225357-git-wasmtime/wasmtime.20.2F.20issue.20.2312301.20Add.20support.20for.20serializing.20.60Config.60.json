[
    {
        "content": "<p>gpace1 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12301\">issue #12301</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Add serialization or some other form of line-wire data type to support transferring <code>wasmtime::Config</code> between devices.</p>\n<h4>Benefit</h4>\n<p>(Unless I'm misunderstanding something) In order to cross precompile right now, the <code>wasmtime</code> engine must know the target's configuration of its <code>wasmtime</code> Engine. By providing serialization to <code>Config</code> the compiling device can query the target for their <code>Config</code> and create an <code>Engine</code> using what it received.</p>\n<p>In a simple scenario:</p>\n<ul>\n<li>Device <code>A </code>is the compiler</li>\n<li>Device <code>B</code> is the target</li>\n</ul>\n<p>1) <code>A</code> and <code>B</code> connect but otherwise <code>A</code> knows nothing about <code>B</code> except that it's has <code>wasmtime</code><br>\n2) <code>B</code> sends its configuration to <code>A</code><br>\n3) <code>A</code> creates an Engine from <code>B</code>'s config and precompiles a component for <code>B</code><br>\n4) <code>A</code> sends the precompiled component to <code>B</code></p>\n<p>Without step 2 device <code>A</code> wouldn't know how to configure it's <code>Engine</code> for <code>B</code>. Even when knowing the target for <code>B</code> it seems it still wouldn't fully be aware of everything (not) supported by <code>B</code> (e.g. GC).</p>\n<h4>Implementation</h4>\n<p>The simplest would be to derive <code>serde</code> for <code>Config</code> and all inner types.</p>\n</blockquote>",
        "id": 567071841,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1767933220
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12301#issuecomment-3729545203\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12301\">issue #12301</a>:</p>\n<blockquote>\n<p>For this we've historically been hesitant to do this for <code>Config</code> directly due to its unstable-representation-nature, but what we do support is <a href=\"https://docs.rs/wasmtime-cli-flags/latest/wasmtime_cli_flags/struct.CommonOptions.html\"><code>wasmtime_cli_flags::CommonOptions</code></a> supports serde and can be used to create a <code>Config</code>. That means that you can at least deserialize configuration into a <code>Config</code>. Not everything in <code>Config</code>, however, can be represented with Serde.</p>\n<p>Would that work for your use case? Or perhaps something built on and/or adjacent to that would work?</p>\n</blockquote>",
        "id": 567175009,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1767974639
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12301#issuecomment-3729953194\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12301\">issue #12301</a>:</p>\n<blockquote>\n<blockquote>\n<p>due to its unstable-representation-nature</p>\n</blockquote>\n<p>FWIW, if the <code>wasmtime_cli_flags::CommonOptions</code> approach is not possible, I could potentially be convinced of adding serialization/deserialization to <code>wasmtime::Config</code> itself, with the understanding that it would only be binary compatible with that _exact_ <code>wasmtime</code> version (not something we would make promises about across patch releases) and we would presumably add the version to the encoding and check it on decoding.</p>\n</blockquote>",
        "id": 567197650,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1767980774
    },
    {
        "content": "<p>gpace1 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12301#issuecomment-3730069673\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12301\">issue #12301</a>:</p>\n<blockquote>\n<p>I'm in no rush to have what I requested supported, as for now I've got control over devices A &amp; B in my scenario.</p>\n<p>The issue is in the future I would like to support B being from an \"infinity-pool\" of third-party devices. The vast majority of which will probably be embedded, so I'm predicting there to be quite the variety of configurations.</p>\n<p>Running into versioning problems is always going to be an issue, let alone <code>wasmtime</code> what I'm doing has its own issues. Device A will support multiple different versions of <code>wasmtime</code>, and it's perfectly fine for device A to reject B if it doesn't support the version of its configuration.</p>\n</blockquote>",
        "id": 567237324,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1767983004
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12301#issuecomment-3730500017\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12301\">issue #12301</a>:</p>\n<blockquote>\n<p>My hunch is what you'll want is <code>wasmtime_cli_flags::CommonOptions</code> and that should work for your approach. That way you can have a configuration file per-configuration/device which is sent to the central server which dispatches based on wasmtime version which then further loads the configuration for the compilation.</p>\n</blockquote>",
        "id": 567259071,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1767991170
    },
    {
        "content": "<p>gpace1 closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12301\">issue #12301</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Add serialization or some other form of line-wire data type to support transferring <code>wasmtime::Config</code> between devices.</p>\n<h4>Benefit</h4>\n<p>(Unless I'm misunderstanding something) In order to cross precompile right now, the <code>wasmtime</code> engine must know the target's configuration of its <code>wasmtime</code> Engine. By providing serialization to <code>Config</code> the compiling device can query the target for their <code>Config</code> and create an <code>Engine</code> using what it received.</p>\n<p>In a simple scenario:</p>\n<ul>\n<li>Device <code>A </code>is the compiler</li>\n<li>Device <code>B</code> is the target</li>\n</ul>\n<p>1) <code>A</code> and <code>B</code> connect but otherwise <code>A</code> knows nothing about <code>B</code> except that it's has <code>wasmtime</code><br>\n2) <code>B</code> sends its configuration to <code>A</code><br>\n3) <code>A</code> creates an Engine from <code>B</code>'s config and precompiles a component for <code>B</code><br>\n4) <code>A</code> sends the precompiled component to <code>B</code></p>\n<p>Without step 2 device <code>A</code> wouldn't know how to configure it's <code>Engine</code> for <code>B</code>. Even when knowing the target for <code>B</code> it seems it still wouldn't fully be aware of everything (not) supported by <code>B</code> (e.g. GC).</p>\n<h4>Implementation</h4>\n<p>The simplest would be to derive <code>serde</code> for <code>Config</code> and all inner types.</p>\n</blockquote>",
        "id": 567270198,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1767996711
    },
    {
        "content": "<p>gpace1 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12301#issuecomment-3730739613\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12301\">issue #12301</a>:</p>\n<blockquote>\n<p>I think you're right and <code>CommonOptions</code> will work for what I want to do.</p>\n</blockquote>",
        "id": 567270199,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1767996712
    }
]