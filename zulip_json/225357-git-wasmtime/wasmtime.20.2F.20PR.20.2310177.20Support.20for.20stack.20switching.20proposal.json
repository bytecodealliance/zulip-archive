[
    {
        "content": "<p>frank-emrich opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a> from <code>dhil:stack-switching</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>This PR adds support for the <a href=\"https://github.com/WebAssembly/stack-switching\">Wasm stack switching proposal</a>. The explainer document for the proposal is <a href=\"https://github.com/WebAssembly/stack-switching/blob/main/proposals/stack-switching/Explainer.md\">here</a>.</p>\n<p>This means that the following instructions are added: <code>cont.new</code>, <code>resume</code>, <code>suspend</code>, <code>cont.bind</code>.<br>\nThe instruction <code>resume.throw</code>, which is part of the proposal but relies on exception handling, is currently unsupported.</p>\n<p>This was developed together with @dhil.</p>\n<h3>General implementation notes</h3>\n<p>In Wasm, continuations are represented by values of type <code>(ref $ct)</code>, where <code>$ct</code> is a new composite type/heap type for continuations.<br>\nIn the implementation, these are represented by values of type <code>VMContObj</code>. These are fat pointers, consisting of a sequence counter, and a pointer to a <code>VMContRef</code>. The latter type is used for the actual representation of continuations.<br>\nThe sequence counter part of <code>VMContObj</code>s is used to check that every continuation value can only be used once.</p>\n<p>The <code>StoreOpaque</code> is extended to contain a \"stack chain\": It indicates what stack we are currently executing on. Logically, this is a linked list of stacks, since each continuation has a parent field. The chain stored in the <code>StoreOpaque</code> always ends with a value representing the initial stack. This is the stack we were on when entering Wasm, which will usually be the main stack. </p>\n<h3>Memory Management</h3>\n<p>Currently, memory management is very basic: The <code>StoreOpaque</code> provides a new method for allocation a new <code>VMContRef</code>, and keeps track of all continuations created this way. Continuations are never deallocated at the moment, meaning that they live until the store itself is deallocated. </p>\n<p>The stack memory used by each allocation (represented by type <code>ContinuationStack</code>) is always <code>mmap</code>-ed, with a guard page at the end. There is currently no support for growing stacks, or segmented stacks.</p>\n<h3>Backtrace generation</h3>\n<p>The existing backtrace generation mechanism is extended to be fully aware of continuations: When generating backtraces, the entire chain of continuation is traversed, not just the stack frames of the currently active stack/continuation.</p>\n<h3>Integration with GC</h3>\n<p>Integration with the GC proposal is limited, but should at least be safe:</p>\n<ul>\n<li>Programs where continuation objects would be stored inside GC objects (structs, arrays, ...) are rejected</li>\n<li>During GC, all stack frames of all continuations are inspected when looking for GC roots.</li>\n</ul>\n<h3>Entering/Exiting Wasm</h3>\n<p>Before this PR, there are two separate mechanism that save and restore some state of the runtime when entering/exiting Wasm:</p>\n<ol>\n<li>The functions <code>enter_wasm</code> and <code>exit_wasm</code> in <code>func.rs</code></li>\n<li><code>CallThreadState</code> saves and restores (on <code>drop</code>) parts of the <code>VMRuntimeLimits</code></li>\n</ol>\n<p>This PR consolidates these two mechanism, because it requires some additional state to be updated and restored on enter/exit:<br>\nthe type <code>wasmtime::runtime::func::RuntimeEntryState</code> now stores all of the required runtime state and ensures that it's restored when exiting Wasm.</p>\n<h3>Tags</h3>\n<p>Since the stack switching proposal extends the notion of tags introduced by the exception handling proposal, it adds the necessary machinery for importing, exporting, and defining tags.<br>\n</p>\n</blockquote>",
        "id": 497507291,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738607847
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 497511594,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738609295
    },
    {
        "content": "<p>frank-emrich edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>This PR adds support for the <a href=\"https://github.com/WebAssembly/stack-switching\">Wasm stack switching proposal</a>. The explainer document for the proposal is <a href=\"https://github.com/WebAssembly/stack-switching/blob/main/proposals/stack-switching/Explainer.md\">here</a>.</p>\n<p>This means that the following instructions are added: <code>cont.new</code>, <code>resume</code>, <code>suspend</code>, <code>cont.bind</code>.<br>\nThe instruction <code>resume.throw</code>, which is part of the proposal but relies on exception handling, is currently unsupported.</p>\n<p>This was developed together with @dhil.</p>\n<h3>General implementation notes</h3>\n<p>In Wasm, continuations are represented by values of type <code>(ref $ct)</code>, where <code>$ct</code> is a new composite type/heap type for continuations.<br>\nIn the implementation, these are represented by values of type <code>VMContObj</code>. These are fat pointers, consisting of a sequence counter, and a pointer to a <code>VMContRef</code>. The latter type is used for the actual representation of continuations.<br>\nThe sequence counter part of <code>VMContObj</code>s is used to check that every continuation value can only be used once.</p>\n<p>The <code>StoreOpaque</code> is extended to contain a \"stack chain\": It indicates what stack we are currently executing on. Logically, this is a linked list of stacks, since each continuation has a parent field. The chain stored in the <code>StoreOpaque</code> always ends with a value representing the initial stack. This is the stack we were on when entering Wasm, which will usually be the main stack. </p>\n<h3>Memory Management</h3>\n<p>Currently, memory management is very basic: The <code>StoreOpaque</code> provides a new method for allocation a new <code>VMContRef</code>, and keeps track of all continuations created this way. Continuations are never deallocated at the moment, meaning that they live until the store itself is deallocated. </p>\n<p>The stack memory used by each allocation (represented by type <code>ContinuationStack</code>) is always <code>mmap</code>-ed, with a guard page at the end. There is currently no support for growing stacks, or segmented stacks.</p>\n<h3>Backtrace generation</h3>\n<p>The existing backtrace generation mechanism is extended to be fully aware of continuations: When generating backtraces, the entire chain of continuation is traversed, not just the stack frames of the currently active stack/continuation.</p>\n<h3>Integration with GC</h3>\n<p>Integration with the GC proposal is limited, but should at least be safe:</p>\n<ul>\n<li>Programs where continuation objects would be stored inside GC objects (structs, arrays, ...) are rejected</li>\n<li>During GC, all stack frames of all continuations are inspected when looking for GC roots.</li>\n</ul>\n<h3>Entering/Exiting Wasm</h3>\n<p>Prior to this PR, there were two separate mechanisms that save and restore some state of the runtime when entering/exiting Wasm:</p>\n<ol>\n<li>The functions <code>enter_wasm</code> and <code>exit_wasm</code> in <code>func.rs</code></li>\n<li><code>CallThreadState</code> saves and restores (on <code>drop</code>) parts of the <code>VMRuntimeLimits</code></li>\n</ol>\n<p>This PR consolidates these two mechanism, because it requires some additional state to be updated and restored on enter/exit:<br>\nthe type <code>wasmtime::runtime::func::RuntimeEntryState</code> now stores all of the required runtime state and ensures that it's restored when exiting Wasm.</p>\n<h3>Tags</h3>\n<p>Since the stack switching proposal extends the notion of tags introduced by the exception handling proposal, it adds the necessary machinery for importing, exporting, and defining tags.<br>\n</p>\n</blockquote>",
        "id": 497512281,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738609525
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2632034916\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\", \"cranelift:area:x64\", \"wasmtime:c-api\", \"wasmtime:ref-types\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: wasmtime:ref-types</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 497527737,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738615479
    },
    {
        "content": "<p>frank-emrich edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>This PR adds support for the <a href=\"https://github.com/WebAssembly/stack-switching\">Wasm stack switching proposal</a>. The explainer document for the proposal is <a href=\"https://github.com/WebAssembly/stack-switching/blob/main/proposals/stack-switching/Explainer.md\">here</a>.</p>\n<p>This means that the following instructions are added: <code>cont.new</code>, <code>resume</code>, <code>suspend</code>, <code>switch</code>, and <code>cont.bind</code>.<br>\nThe instruction <code>resume.throw</code>, which is part of the proposal but relies on exception handling, is currently unsupported.</p>\n<p>This was developed together with @dhil.</p>\n<h3>General implementation notes</h3>\n<p>In Wasm, continuations are represented by values of type <code>(ref $ct)</code>, where <code>$ct</code> is a new composite type/heap type for continuations.<br>\nIn the implementation, these are represented by values of type <code>VMContObj</code>. These are fat pointers, consisting of a sequence counter, and a pointer to a <code>VMContRef</code>. The latter type is used for the actual representation of continuations.<br>\nThe sequence counter part of <code>VMContObj</code>s is used to check that every continuation value can only be used once.</p>\n<p>The <code>StoreOpaque</code> is extended to contain a \"stack chain\": It indicates what stack we are currently executing on. Logically, this is a linked list of stacks, since each continuation has a parent field. The chain stored in the <code>StoreOpaque</code> always ends with a value representing the initial stack. This is the stack we were on when entering Wasm, which will usually be the main stack. </p>\n<h3>Memory Management</h3>\n<p>Currently, memory management is very basic: The <code>StoreOpaque</code> provides a new method for allocation a new <code>VMContRef</code>, and keeps track of all continuations created this way. Continuations are never deallocated at the moment, meaning that they live until the store itself is deallocated. </p>\n<p>The stack memory used by each allocation (represented by type <code>ContinuationStack</code>) is always <code>mmap</code>-ed, with a guard page at the end. There is currently no support for growing stacks, or segmented stacks.</p>\n<h3>Backtrace generation</h3>\n<p>The existing backtrace generation mechanism is extended to be fully aware of continuations: When generating backtraces, the entire chain of continuation is traversed, not just the stack frames of the currently active stack/continuation.</p>\n<h3>Integration with GC</h3>\n<p>Integration with the GC proposal is limited, but should at least be safe:</p>\n<ul>\n<li>Programs where continuation objects would be stored inside GC objects (structs, arrays, ...) are rejected</li>\n<li>During GC, all stack frames of all continuations are inspected when looking for GC roots.</li>\n</ul>\n<h3>Entering/Exiting Wasm</h3>\n<p>Prior to this PR, there were two separate mechanisms that save and restore some state of the runtime when entering/exiting Wasm:</p>\n<ol>\n<li>The functions <code>enter_wasm</code> and <code>exit_wasm</code> in <code>func.rs</code></li>\n<li><code>CallThreadState</code> saves and restores (on <code>drop</code>) parts of the <code>VMRuntimeLimits</code></li>\n</ol>\n<p>This PR consolidates these two mechanism, because it requires some additional state to be updated and restored on enter/exit:<br>\nthe type <code>wasmtime::runtime::func::RuntimeEntryState</code> now stores all of the required runtime state and ensures that it's restored when exiting Wasm.</p>\n<h3>Tags</h3>\n<p>Since the stack switching proposal extends the notion of tags introduced by the exception handling proposal, it adds the necessary machinery for importing, exporting, and defining tags.<br>\n</p>\n</blockquote>",
        "id": 497628412,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738664481
    },
    {
        "content": "<p>frank-emrich edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>This PR adds support for the <a href=\"https://github.com/WebAssembly/stack-switching\">Wasm stack switching proposal</a>. The explainer document for the proposal is <a href=\"https://github.com/WebAssembly/stack-switching/blob/main/proposals/stack-switching/Explainer.md\">here</a>.</p>\n<p>This means that the following instructions are added: <code>cont.new</code>, <code>resume</code>, <code>suspend</code>, <code>switch</code>, and <code>cont.bind</code>.<br>\nThe instruction <code>resume.throw</code>, which is part of the proposal but relies on exception handling, is currently unsupported.</p>\n<p>This was developed together with @dhil.</p>\n<h3>General implementation notes</h3>\n<p>In Wasm, continuations are represented by values of type <code>(ref $ct)</code>, where <code>$ct</code> is a new composite type/heap type for continuations.<br>\nIn the implementation, these are represented by values of type <code>VMContObj</code>. These are fat pointers, consisting of a sequence counter, and a pointer to a <code>VMContRef</code>. The latter type is used for the actual representation of continuations.<br>\nThe sequence counter part of <code>VMContObj</code>s is used to check that every continuation value can only be used once.</p>\n<p>The <code>StoreOpaque</code> is extended to contain a \"stack chain\": It indicates what stack we are currently executing on. Logically, this is a linked list of stacks, since each continuation has a parent field. The chain stored in the <code>StoreOpaque</code> always ends with a value representing the initial stack. This is the stack we were on when entering Wasm, which will usually be the main stack. </p>\n<h3>Memory Management</h3>\n<p>Currently, memory management is very basic: The <code>StoreOpaque</code> provides a new method for allocation a new <code>VMContRef</code>, and keeps track of all continuations created this way. Continuations are never deallocated at the moment, meaning that they live until the store itself is deallocated. </p>\n<p>The stack memory used by each allocation (represented by type <code>ContinuationStack</code>) is always <code>mmap</code>-ed, with a guard page at the end. There is currently no support for growing stacks, or segmented stacks.</p>\n<h3>Backtrace generation</h3>\n<p>The existing backtrace generation mechanism is extended to be fully aware of continuations: When generating backtraces, the entire chain of continuation is traversed, not just the stack frames of the currently active stack/continuation.</p>\n<h3>Integration with GC</h3>\n<p>Integration with the GC proposal is limited, but should at least be safe:</p>\n<ul>\n<li>Programs where continuation objects would be stored inside GC objects (structs, arrays, ...) are rejected</li>\n<li>During GC, all stack frames of all continuations are inspected when looking for GC roots.</li>\n</ul>\n<h3>Entering/Exiting Wasm</h3>\n<p>Prior to this PR, there were two separate mechanisms that save and restore some state of the runtime when entering/exiting Wasm:</p>\n<ol>\n<li>The functions <code>enter_wasm</code> and <code>exit_wasm</code> in <code>func.rs</code></li>\n<li><code>CallThreadState</code> saves and restores (on <code>drop</code>) parts of the <code>VMRuntimeLimits</code></li>\n</ol>\n<p>This PR consolidates these two mechanism, because it requires some additional state to be updated and restored on enter/exit:<br>\nthe type <code>wasmtime::runtime::func::RuntimeEntryState</code> now stores all of the required runtime state and ensures that it's restored when exiting Wasm.</p>\n<h3>Tags</h3>\n<p>Since the stack switching proposal extends the notion of tags introduced by the exception handling proposal, it adds the necessary machinery for importing, exporting, and defining tags.</p>\n<h3>Limitations</h3>\n<p>The limitations are as follows, some of which were mentioned above:</p>\n<ul>\n<li><code>resume.throw</code> needs to be implemented once exception handling is there</li>\n<li>Full integration with GC and support for deallocating continuations</li>\n<li>The only supported platform at the moment are unix-like x64 systems. I'm planning to change that soon, this won't require big changes to what's in this PR at the moment.<br>\n</li>\n</ul>\n</blockquote>",
        "id": 497685876,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738680914
    },
    {
        "content": "<p>frank-emrich <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2634249295\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>There are currently a few test failures that I 'm hoping to get some help with:</p>\n<ul>\n<li>I don't understand <code>cargo vet</code> well enough to know what's up, but the problem should be fairly benign: We are using <code>memoffset</code> in a different crate now, but from what I can tell, it has already been vetted for use in this project.</li>\n<li>There are some build failures due to the new instructions not being supported on all platforms. In general, we've added a Wasm feature and a cargo feature for stack switching. My plan was that all stack switching tests would be skipped if the <code>stack-switching</code> cargo feature is not enabled. That's easy to do for the <code>all</code> test suite, but I'm not sure what the best approach is for the <code>wast</code> tests to achieve this. Am I understanding correctly that the <code>wast</code> test suite always currently runs all tests, independently from what cargo features are enabled?</li>\n</ul>\n<p>As a general, so far most of the stack switching code is compiled even if the cargo feature is disabled. It would be possible to get more aggressive with conditional compilation, but this requires some ugly special casing in <code>backtrace.rs</code>. Happy for suggestions if people would like to see more conditional compilation or are happy with keeping it minimal.</p>\n</blockquote>",
        "id": 497688026,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738681447
    },
    {
        "content": "<p>frank-emrich edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2634249295\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>There are currently a few test failures that I 'm hoping to get some help with:</p>\n<ul>\n<li>I don't understand <code>cargo vet</code> well enough to know what's up, but the problem should be fairly benign: We are using <code>memoffset</code> in a different crate now, but from what I can tell, it has already been vetted for use in this project.</li>\n<li>There are some build failures due to the new instructions not being supported on all platforms. In general, we've added a Wasm feature and a cargo feature for stack switching. My plan was that all stack switching tests would be skipped if the <code>stack-switching</code> cargo feature is not enabled. That's easy to do for the <code>all</code> test suite, but I'm not sure what the best approach is for the <code>wast</code> tests to achieve this. Am I understanding correctly that the <code>wast</code> test suite always currently runs all tests, independently from what cargo features are enabled?</li>\n</ul>\n<p>As a general, so far most of the stack switching code is compiled even if the cargo feature is disabled. It would be possible to get more aggressive with conditional compilation, but this requires some ugly special casing in <code>backtrace.rs</code>. Happy for suggestions if people would like to see more conditional compilation or are happy with keeping it minimal.</p>\n<p>Also, I had to re-bless most of the disas tests since the layout of the <code>VMContext</code> change due to the addition of some new fields. That has increased the surface area of this PR even more.</p>\n</blockquote>",
        "id": 497688432,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738681556
    },
    {
        "content": "<p>frank-emrich edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2634249295\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>There are currently a few test failures that I 'm hoping to get some help with:</p>\n<ul>\n<li>I don't understand <code>cargo vet</code> well enough to know what's up, but the problem should be fairly benign: We are using <code>memoffset</code> in a different crate now, but from what I can tell, it has already been vetted for use in this project.</li>\n<li>There are some build failures due to the new instructions not being supported on all platforms. In general, we've added a Wasm feature and a cargo feature for stack switching. My plan was that all stack switching tests would be skipped if the <code>stack-switching</code> cargo feature is not enabled. That's easy to do for the <code>all</code> test suite, but I'm not sure what the best approach is for the <code>wast</code> tests to achieve this. Am I understanding correctly that the <code>wast</code> test suite always currently runs all tests, independently from what cargo features are enabled?</li>\n</ul>\n<p>As a general, so far most of the stack switching code is compiled even if the cargo feature is disabled. It would be possible to get more aggressive with conditional compilation, but this requires some ugly special casing in <code>backtrace.rs</code>. Happy for suggestions if people would like to see more conditional compilation or are happy with keeping it minimal.</p>\n<p>Also, I had to re-bless most of the <code>disas</code> tests since the layout of the <code>VMContext</code> change due to the addition of some new fields. That has increased the surface area of this PR even more.</p>\n</blockquote>",
        "id": 497688481,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738681568
    },
    {
        "content": "<p>frank-emrich edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2634249295\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>There are currently a few test failures that I 'm hoping to get some help with:</p>\n<ul>\n<li>I don't understand <code>cargo vet</code> well enough to know what's up, but the problem should be fairly benign: We are using <code>memoffset</code> in a different crate now, but from what I can tell, it has already been vetted for use in this project.</li>\n<li>There are some build failures due to the new instructions not being supported on all platforms. In general, we've added a Wasm feature and a cargo feature for stack switching. My plan was that all stack switching tests would be skipped if the <code>stack-switching</code> cargo feature is not enabled. That's easy to do for the <code>all</code> test suite, but I'm not sure what the best approach is for the <code>wast</code> tests to achieve this. Am I understanding correctly that the <code>wast</code> test suite always currently runs all tests, independently from what cargo features are enabled?</li>\n</ul>\n<p>As a general note, so far most of the stack switching code is compiled even if the cargo feature is disabled. It would be possible to get more aggressive with conditional compilation, but this requires some ugly special casing in <code>backtrace.rs</code>. Happy for suggestions if people would like to see more conditional compilation or are happy with keeping it minimal.</p>\n<p>Also, I had to re-bless most of the <code>disas</code> tests since the layout of the <code>VMContext</code> change due to the addition of some new fields. That has increased the surface area of this PR even more.</p>\n</blockquote>",
        "id": 497725896,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738692030
    },
    {
        "content": "<p>frank-emrich edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>This PR adds support for the <a href=\"https://github.com/WebAssembly/stack-switching\">Wasm stack switching proposal</a>. The explainer document for the proposal is <a href=\"https://github.com/WebAssembly/stack-switching/blob/main/proposals/stack-switching/Explainer.md\">here</a>.</p>\n<p>This means that the following instructions are added: <code>cont.new</code>, <code>resume</code>, <code>suspend</code>, <code>switch</code>, and <code>cont.bind</code>.<br>\nThe instruction <code>resume.throw</code>, which is part of the proposal but relies on exception handling, is currently unsupported.</p>\n<p>This was developed together with @dhil.</p>\n<h3>General implementation notes</h3>\n<p>In Wasm, continuations are represented by values of type <code>(ref $ct)</code>, where <code>$ct</code> is a new composite type/heap type for continuations.<br>\nIn the implementation, these are represented by values of type <code>VMContObj</code>. These are fat pointers, consisting of a sequence counter, and a pointer to a <code>VMContRef</code>. The latter type is used for the actual representation of continuations.<br>\nThe sequence counter part of <code>VMContObj</code>s is used to check that every continuation value can only be used once.</p>\n<p>The <code>StoreOpaque</code> is extended to contain a \"stack chain\": It indicates what stack we are currently executing on. Logically, this is a linked list of stacks, since each continuation has a parent field. The chain stored in the <code>StoreOpaque</code> always ends with a value representing the initial stack. This is the stack we were on when entering Wasm, which will usually be the main stack. </p>\n<h3>Memory Management</h3>\n<p>Currently, memory management is very basic: The <code>StoreOpaque</code> provides a new method for allocation a new <code>VMContRef</code>, and keeps track of all continuations created this way. Continuations are never deallocated at the moment, meaning that they live until the store itself is deallocated. </p>\n<p>The stack memory used by each allocation (represented by type <code>ContinuationStack</code>) is always <code>mmap</code>-ed, with a guard page at the end. There is currently no support for growing stacks, or segmented stacks.</p>\n<h3>Backtrace generation</h3>\n<p>The existing backtrace generation mechanism is extended to be fully aware of continuations: When generating backtraces, the entire chain of continuation is traversed, not just the stack frames of the currently active stack/continuation.</p>\n<h3>Integration with GC</h3>\n<p>Integration with the GC proposal is limited, but should at least be safe:</p>\n<ul>\n<li>Programs where continuation objects would be stored inside GC objects (structs, arrays, ...) are rejected</li>\n<li>During GC, all stack frames of all continuations are inspected when looking for GC roots.</li>\n</ul>\n<h3>Entering/Exiting Wasm</h3>\n<p>Prior to this PR, there were two separate mechanisms that save and restore some state of the runtime when entering/exiting Wasm:</p>\n<ol>\n<li>The functions <code>enter_wasm</code> and <code>exit_wasm</code> in <code>func.rs</code></li>\n<li><code>CallThreadState</code> saves and restores (on <code>drop</code>) parts of the <code>VMRuntimeLimits</code></li>\n</ol>\n<p>This PR consolidates these two mechanism, because it requires some additional state to be updated and restored on enter/exit:<br>\nthe type <code>wasmtime::runtime::func::RuntimeEntryState</code> now stores all of the required runtime state and ensures that it's restored when exiting Wasm.</p>\n<h3>Tags</h3>\n<p>Since the stack switching proposal extends the notion of tags introduced by the exception handling proposal, it adds the necessary machinery for importing, exporting, and defining tags.</p>\n<h3>Limitations</h3>\n<p>The limitations are as follows, some of which were mentioned above:</p>\n<ul>\n<li><code>resume.throw</code> needs to be implemented once exception handling is there</li>\n<li>Full integration with GC and support for deallocating continuations</li>\n<li>The only supported platform at the moment are unix-like x64 systems. I'm planning to change that soon as follow-up PRs, this won't require big changes to what's in this PR at the moment.</li>\n<li>Neither Winch or Pulley are supported at the moment.<br>\n</li>\n</ul>\n</blockquote>",
        "id": 497735085,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738695351
    },
    {
        "content": "<p>frank-emrich edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2634249295\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>There are currently a few test failures that I 'm hoping to get some help with:</p>\n<ul>\n<li>I don't understand <code>cargo vet</code> well enough to know what's up, but the problem should be fairly benign: We are using <code>memoffset</code> in a different crate now, but from what I can tell, it has already been vetted for use in this project.</li>\n<li>There are some build failures due to the new instructions not being supported on all platforms. In general, we've added a Wasm feature and a cargo feature for stack switching. My plan was that all stack switching tests would be skipped if the <code>stack-switching</code> cargo feature is not enabled. That's easy to do for the <code>all</code> test suite, but I'm not sure what the best approach is for the <code>wast</code> tests to achieve this. Am I understanding correctly that the <code>wast</code> test suite always currently runs all tests, independently from what cargo features are enabled?</li>\n</ul>\n<p>As a general note, so far most of the stack switching code is compiled even if the cargo feature is disabled. It would be possible to get more aggressive with conditional compilation, but this requires some ugly special casing in <code>backtrace.rs</code>. Happy for suggestions if people would like to see more conditional compilation or are happy with keeping it minimal.</p>\n<p>Also, I had to re-bless most of the <code>disas</code> tests since the layout of the <code>VMContext</code> changed due to the addition of some new fields. That has increased the surface area of this PR even more.</p>\n</blockquote>",
        "id": 497862311,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738752490
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2637483440\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<blockquote>\n<ul>\n<li>Am I understanding correctly that the <code>wast</code> test suite always currently runs all tests, independently from what cargo features are enabled?</li>\n</ul>\n</blockquote>\n<p>That is correct, and we assert that tests that \"should\" fail do in fact fail. This way, if we fix bugs or expand support, we won't accidentally and silently miss out on tests for those things.</p>\n<p>This should be fine for your stack switching tests, as long as you</p>\n<ul>\n<li>mark the tests as \"should fail\" on supported platforms, and</li>\n<li>return an error or some sort (rather than unsafely segfault or whatever) when processing Wasm that uses this proposal on an unsupported platform/configuration.</li>\n</ul>\n<p>See <a href=\"https://github.com/bytecodealliance/wasmtime/blob/d7d605c236a857a4019aa39850e9dd6a6597ece1/crates/wast-util/src/lib.rs#L280\">https://github.com/bytecodealliance/wasmtime/blob/d7d605c236a857a4019aa39850e9dd6a6597ece1/crates/wast-util/src/lib.rs#L280</a></p>\n</blockquote>",
        "id": 497938674,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738774247
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 498347906,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738937003
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 498357275,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738939756
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 499097049,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739307496
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 499107777,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739312086
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 499286564,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739380360
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 499291724,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739381862
    },
    {
        "content": "<p><strong>frank-emrich</strong> has marked <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a> as ready for review.</p>",
        "id": 499297435,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739383634
    },
    {
        "content": "<p><strong>frank-emrich</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 499297437,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739383636
    },
    {
        "content": "<p><strong>frank-emrich</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-fuzz-reviewers\">wasmtime-fuzz-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 499297438,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739383636
    },
    {
        "content": "<p><strong>frank-emrich</strong> requested <a href=\"https://github.com/fitzgen\">fitzgen</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 499297439,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739383637
    },
    {
        "content": "<p><strong>frank-emrich</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers\">wasmtime-compiler-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 499297440,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739383637
    },
    {
        "content": "<p><strong>frank-emrich</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 499297441,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739383637
    },
    {
        "content": "<p><strong>frank-emrich</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-default-reviewers\">wasmtime-default-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 499297444,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739383638
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2654555585\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>Oh sorry I should have left a note here but I think I forgot. I was out last week for a company offsite and I'm out this week for the CG meeting, but I plan on getting to this next week. I want to make sure I've got plenty of time to sit down and go through this, but wanted to give a heads-up that I'll be looking into it next week at the earliest.</p>\n<p>Also to reiterate: thank you so much for this! Thanks for wrestling with CI as well, much appreciated!</p>\n</blockquote>",
        "id": 499303402,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739385646
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#pullrequestreview-2618463280\">PR review</a>:</p>\n<blockquote>\n<p>Ok I think I've seen about half of the files of this PR (excluding auto-updates in tests) so wanted to leave an initial round of comments/thoughts.</p>\n<p>At a high-level everything here looks reasonable to me so far. I haven't dug into the actual implementation details of stack switching though and have for this been focusing on the integration points with the rest of Wasmtime. I left a lot of comments along the lines of \"file an issue to point a comment to this\" and I think it might make the most sense to have a single tracking issue for follow-up work on stack-switching. That can have a lot of various checkboxes for the logical work items remaining (e.g. contref in the gc heap, in the embedding API, windows support, etc).</p>\n<p>Additionally at a high-level I want to also ask you what your own time allowance is for landing this? This is, as expected, a large PR which is going to take some time to land. I suspect it'll take me on the order of ~days of review to get through the the real \"meat\" of stack switching and I'll likely have comments from all that as well. If, however, you're running short on time for this that's ok too!</p>\n<p>Basically what I want to ask is: do you have time allocated for the back-and-forth of review here? It's hard to predict exactly how long it will take but my gut is that it'll be a nontrivial amount of time. If you don't have time for this I think that's also totally ok. I'll probably still continue to review all this and I'll try to find time in the coming future to work on addressing many of these items myself. </p>\n<p>In an ideal world this PR would be split up into chunks and landed piecemeal, for example parsing support, then compiling support, then maybe an instruction-at-a-time for each piece, etc. Splitting this up is no easy task though so I don't want to ask this lightly of you, and you also know much better than I about if it even could be split up and where it could be split.  Part of this is that GitHub does not make reviewing large PRs easy (e.g. every time I add a comment it takes ~5 seconds for the comment box to appear), and overall it's easier to focus on smaller changes to ensure that as little as possible slips through the cracks.</p>\n<p>Basically tl;dr; I've left a lot of comments below but it doesn't have to be you alone addressing them. If you're running low on time to allocate to this work I think we can try to be accomodating in assisting to landing this.</p>\n</blockquote>",
        "id": 499821435,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956525119\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind filing an issue about this and tagging with with <code>// FIXME(#NNN): ...</code></p>\n</blockquote>",
        "id": 499821436,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956555793\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind translating this <code>TODO</code> and the above one to a <code>FIXME</code> with a filed issue?</p>\n</blockquote>",
        "id": 499821437,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956553077\">PR review comment</a>:</p>\n<blockquote>\n<p>I think this comment is a copy/paste from a historical version, mind updating it to just say that pulley doesn't support stack-switching/exceptions at this time?</p>\n</blockquote>",
        "id": 499821438,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956544588\">PR review comment</a>:</p>\n<blockquote>\n<p>I think it's fine to leave this as-is, the <code>#[cfg]</code> here is only to handle the conditionally defined functions on <code>wasmtime::Config</code> but it looks like <code>wasm_stack_switching</code> is unconditionally defined so it's ok to unconditionally thread through the boolean to there here. The <code>wasmtime::Config</code> can then handle validation of ensuring various dependent proposals are all enabled.</p>\n</blockquote>",
        "id": 499821440,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956556765\">PR review comment</a>:</p>\n<blockquote>\n<p>Like above, mind tagging this with <code>// FIXME(#nnn): ...</code>?</p>\n</blockquote>",
        "id": 499821441,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956555471\">PR review comment</a>:</p>\n<blockquote>\n<p>Given that tags are \"just\" a type, while this follows the pattern of other imports I think this might be able to be deleted to use <code>VMTagDefinition</code> instead? Or basically otherwise only contain a <code>VMSharedTypeIndex</code>. Although I haven't reviewed the rest of this PR yet so I'm not sure if the pointers here are necessary for something else.</p>\n</blockquote>",
        "id": 499821442,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956553801\">PR review comment</a>:</p>\n<blockquote>\n<p>copy/pasting the other <code>unsafe impl VmSafe</code> comments should be sufficient here, basically it's <code>#[repr(C)]</code> and the internals are all <code>VmSafe</code></p>\n</blockquote>",
        "id": 499821443,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956557360\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind folding these all up into the arm above as more <code>| ...</code> patterns?</p>\n</blockquote>",
        "id": 499821444,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956558383\">PR review comment</a>:</p>\n<blockquote>\n<p>Still getting to the rest of the review in this PR, but for this <code>NOTE</code> is that still applicable? (or maybe just a vestige of an old iteration?)</p>\n</blockquote>",
        "id": 499821445,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956564398\">PR review comment</a>:</p>\n<blockquote>\n<p>Is this comment still applicable? My guess is probably \"no\" and it could be dropped, but wanted to confirm.</p>\n</blockquote>",
        "id": 499821446,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956568131\">PR review comment</a>:</p>\n<blockquote>\n<p>For this we'll want to return a first-class error instead of panicking to gracefully handle modules that do this.</p>\n</blockquote>",
        "id": 499821447,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956558981\">PR review comment</a>:</p>\n<blockquote>\n<p>For this I'd expect \"yes\" if continuations are stored on the GC heap, but if they're not stored on the GC heap then this is correctly <code>false</code> </p>\n</blockquote>",
        "id": 499821448,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956569126\">PR review comment</a>:</p>\n<blockquote>\n<p>Same as above, we'll want to return a gracefull error on this.</p>\n<p>Also as I'm typing this commet out I'm realizing that it'd be good to have <code>// FIXME(#NNN)</code> issue references pointing to an open issue for these bits and pieces of stack switching that aren't supported yet. (e.g. an open issue for GC/stack-switching integration)</p>\n</blockquote>",
        "id": 499821449,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956562048\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind fleshing out this TODO comment? (a FIXME is fine, no need to fix it in this PR per se)</p>\n</blockquote>",
        "id": 499821450,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956565040\">PR review comment</a>:</p>\n<blockquote>\n<p>Instead of taking <code>index: u32</code> here and below could this take <code>TypeIndex</code> directly?</p>\n</blockquote>",
        "id": 499821451,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956572098\">PR review comment</a>:</p>\n<blockquote>\n<p>Historically for me at least \"LSB\" typically means \"least significant bits\" as opposed to \"least significant byte\" which I think you're referring to here. Mind switching this to talk about the \"low 32 bits\" and the \"high 32 bits\"?</p>\n</blockquote>",
        "id": 499821452,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956576117\">PR review comment</a>:</p>\n<blockquote>\n<p>For this I might also recommend the <code>isplit</code> instruction which in effect does the same thing but is a bit more efficient to represent. (that takes a 128-bit value and splits it into low/high 64-bit halves)</p>\n</blockquote>",
        "id": 499821453,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956569460\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind folding this arm into the previous one to make it clear it's all handled the same way?</p>\n</blockquote>",
        "id": 499821455,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956573299\">PR review comment</a>:</p>\n<blockquote>\n<p>Tiny note, but we try to avoid <code>as</code> casts where possible because they can be lossy. I haven't made it to <code>stack_switching_environ</code>-the-module yet but to avoid the <code>as</code> cast here you can:</p>\n<ul>\n<li>If the type is <code>u32</code>-or-smaller, use <code>i64::from(...)</code> instead</li>\n<li>If the type is <code>u64</code>, then use <code>CONTROL_EFFECT_RESUME_DISCRIMINANT.signed()</code> to avoid <code>as</code></li>\n</ul>\n<p>(just a minor nit here, not major)</p>\n</blockquote>",
        "id": 499821456,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564772
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956578498\">PR review comment</a>:</p>\n<blockquote>\n<p>This I think will need some updates. Endianness should only come into play when storing/loading from memory as opposed to the in-register 128-bit logical value. A CLIF i128 should have the same logical value regardless of platform endianness.</p>\n<p>I'm also a bit suspicious of the handling of smaller-than-64-bit platforms both here and below. Overall it seems like this may need some refactoring? To know for sure I'll need to read more of this PR msyelf</p>\n</blockquote>",
        "id": 499821458,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956564061\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind fleshing out the \"todo\"s here? Here instead of panicking we'll want to return a first-class error to gracefully reject modules that contain <code>resume.throw</code> instructions (but returning an error is of course ok for now)</p>\n</blockquote>",
        "id": 499821459,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956579823\">PR review comment</a>:</p>\n<blockquote>\n<p>For this, similar to above, I'd recommend using <code>iconcat</code> instead of a sequence of or/shift/bor/etc. That should be a bit easier to generate good code for and have the same logical result.</p>\n<p>Also, like above, ideally endianness shouldn't factor into this helper at all. I suspect that endianness came into the picture during CI getting s390x working, and if that's the case I can try to help out to debug where the endianness needs to be factored in otherwise.</p>\n</blockquote>",
        "id": 499821460,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956582447\">PR review comment</a>:</p>\n<blockquote>\n<p>For this mind returning a first-class error with a <code>// FIXME(...)</code>?</p>\n</blockquote>",
        "id": 499821461,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956582095\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind expanding this comment? (I'm not familiar myself with <code>set_branched_to_exit</code> so I'm not actually sure what this is doing myself)</p>\n</blockquote>",
        "id": 499821462,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956584637\">PR review comment</a>:</p>\n<blockquote>\n<p>For this, and the new intrinsics below, mind adding <code>#[cfg(feature = \"stack-switching\")]</code> to avoid needing to define the intrinsics if it's disabled at compile time?</p>\n</blockquote>",
        "id": 499821463,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956586479\">PR review comment</a>:</p>\n<blockquote>\n<p>I suspect it's probably ok to remove this <code>TODO</code> now?</p>\n</blockquote>",
        "id": 499821464,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956584218\">PR review comment</a>:</p>\n<blockquote>\n<p>Given the comment I suspect these were intended to be deleted</p>\n</blockquote>",
        "id": 499821465,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956580937\">PR review comment</a>:</p>\n<blockquote>\n<p>I commented in a few places above this as well, but mind tagging this with a <code>// FIXME</code> pointing to an open issue?</p>\n</blockquote>",
        "id": 499821466,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956586828\">PR review comment</a>:</p>\n<blockquote>\n<p>Should be safe to delete now</p>\n</blockquote>",
        "id": 499821467,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956585392\">PR review comment</a>:</p>\n<blockquote>\n<p>I think these two cases might be dead code now?</p>\n</blockquote>",
        "id": 499821468,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956589438\">PR review comment</a>:</p>\n<blockquote>\n<p>Stray change?</p>\n</blockquote>",
        "id": 499821469,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956591593\">PR review comment</a>:</p>\n<blockquote>\n<p>Adding a note on these that they might be removable.</p>\n</blockquote>",
        "id": 499821471,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956587175\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind folding these two arms together?</p>\n</blockquote>",
        "id": 499821472,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956600152\">PR review comment</a>:</p>\n<blockquote>\n<p>Question on this: we've already got <code>wasmtime::Config::wasm_stack_size</code>, so given that do you feel it's still necessary to have a separate config knob for continuation stacks? For example do continuation stacks want to be smaller than wasm stacks most of the time? Or was this mostly for testing?</p>\n<p>(I'm fine either way just curious to poke at this a bit)</p>\n</blockquote>",
        "id": 499821473,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956589720\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind fleshing this out? It should be ok to drop the <code>_idx</code> parameter as well if not needed</p>\n</blockquote>",
        "id": 499821474,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956588098\">PR review comment</a>:</p>\n<blockquote>\n<p>Stray change? (maybe necessary during some refactoring but perhaps no longer?)</p>\n</blockquote>",
        "id": 499821475,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956590954\">PR review comment</a>:</p>\n<blockquote>\n<p>For this I'm not sure how easy it will be but we'll want to return an error here instead of panicking. That would involve changing this function to return <code>Result&lt;u32&gt;</code>, however, and then updating all callers to propagate errors too. Depending on how big a refactoring that is it's also fine to leave this tagged as <code>// FIXME(...)</code> pointing to an issue.</p>\n</blockquote>",
        "id": 499821476,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956591998\">PR review comment</a>:</p>\n<blockquote>\n<p>At least in theory these are all already in the prelude of Rust itself so I don't think you should need to explicitly import them.</p>\n</blockquote>",
        "id": 499821477,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956604476\">PR review comment</a>:</p>\n<blockquote>\n<p>Since this is more of a runtime thing than a compile-time thing, which is mostly what <code>wasmtime-environ</code> is concerned with, could this move to <code>wasmtime::runtime::vm</code> or somewhere internally there?</p>\n<p>That would then also enable using <code>SendSyncPtr&lt;T&gt;</code> which would avoid the need for the <code>unsafe impl {Send,Sync}</code> below.</p>\n</blockquote>",
        "id": 499821478,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956604865\">PR review comment</a>:</p>\n<blockquote>\n<p>I think nowadays it should be safe to remove this since <code>StackLimits</code> will naturally implement these traits.</p>\n</blockquote>",
        "id": 499821479,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956605421\">PR review comment</a>:</p>\n<blockquote>\n<p>Would it make sense to move these into <code>enum State</code> directly as fields on the <code>Parent</code> variant?</p>\n</blockquote>",
        "id": 499821481,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956601624\">PR review comment</a>:</p>\n<blockquote>\n<p>You can also do this without <code>unsafe</code> as <code>*self as i32</code></p>\n</blockquote>",
        "id": 499821482,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956615020\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind fleshing out this comment?</p>\n</blockquote>",
        "id": 499821483,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956608359\">PR review comment</a>:</p>\n<blockquote>\n<p>To confirm, is this read by Cranelift-generated code? If not, it should be safe to drop the <code>#[repr(C)]</code>. If so, more questions!</p>\n<ul>\n<li>Could this move to <code>wasmtime::runtime::vm::*</code>? Most runtime-y things live there instead of in <code>wasmtime-environ</code> which is more-or-less \"stuff needed at compile time\" but that's it.</li>\n<li>Data structures read by Cranelift-generated code we idiomatically try to prefix with \"VM\", so this'd be called <code>VMCommonStackInformation</code></li>\n</ul>\n</blockquote>",
        "id": 499821484,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956612254\">PR review comment</a>:</p>\n<blockquote>\n<p>Ah ok I see that this might be why the structures above are defined in this module rather than in the <code>wasmtime</code> crate.</p>\n<p>For this though I think we'll want to replace this infrastructure with what we have in <code>VMOffsets</code>. To handle cross-compilation correctly we can't use utilities like <code>size_of</code> or <code>offset_of!</code> here. Instead we have to manually calculate sizes in <code>VMOffsets</code> and then in the <code>wasmtime</code> crate in <code>vmcontext.rs</code> we test all the methods to ensure that the offsets calculated actually match the current host.</p>\n<p>This is a relatively large refactoring to all of this support (e.g. instead of <code>const</code>-per-offset it'd be method-per-offset on <code>VMOffsets</code> instead, or <code>HostPtr</code>). In that sense I can also help take care of this too.</p>\n</blockquote>",
        "id": 499821486,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956613270\">PR review comment</a>:</p>\n<blockquote>\n<p>Similar to above this ideally would live in some place like <code>vmcontext/stack_switching.rs</code> and would have a \"VM\" prefix to indicate it's read from compiled wasm code (if it's read from compiled code)</p>\n</blockquote>",
        "id": 499821487,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956602700\">PR review comment</a>:</p>\n<blockquote>\n<p>One thing perhaps worth pointing out here is that one issue we've seen in the past is that using <code>usize</code> in <code>wasmtime-environ</code> can be a bit funky because <code>wasmtime-environ</code> is used in situations such as cross-compiling where the host/target have differing pointer sizes. If possible this'd ideally use something fixed-size like a <code>u32</code>, but I'm not sure how many other casts that would then require.</p>\n</blockquote>",
        "id": 499821488,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956663027\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind tagging this with a <code>// FIXME</code> and an issue to touch it up later?</p>\n</blockquote>",
        "id": 499821489,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956665439\">PR review comment</a>:</p>\n<blockquote>\n<p>This'll definitely want to avoid <code>pub</code>, but <code>pub(crate)</code> is fine to access it throughout this crate.</p>\n</blockquote>",
        "id": 499821490,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956618024\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind prefixing this with <code>unwrap_*</code> to signal that it's a panicking method? Also the <code>todo!()</code> below might be able to switch to a <code>panic!(...)</code> nowadays</p>\n</blockquote>",
        "id": 499821491,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956614643\">PR review comment</a>:</p>\n<blockquote>\n<p>This ends up affecting the public API of Wasmtime, so would it be possible to leave this out? E.g. was this only needed during development? Or still needed?</p>\n</blockquote>",
        "id": 499821492,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956665037\">PR review comment</a>:</p>\n<blockquote>\n<p>This feels a bit suspicious to me so I'm leaving a note to myself here to revisit this once I've seen more of this PR</p>\n</blockquote>",
        "id": 499821493,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956669409\">PR review comment</a>:</p>\n<blockquote>\n<p>One other piece of validation (which might belong in <code>Engine::_check_compatible_with_native_host</code> perhaps) is to ensure that if stack-switching is enabled that <code>#[cfg(feature = \"stack-switching\")]</code> is also enabled. Otherwise that represents a host that has enabled the wasm feature but not compile-time support so it'd probably be good to return a first-class error in such a situation.</p>\n</blockquote>",
        "id": 499821494,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956665868\">PR review comment</a>:</p>\n<blockquote>\n<p>Would it make sense to tag this with <code>#[cfg(feature = \"stack-switching\")]</code>?</p>\n</blockquote>",
        "id": 499821495,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956662409\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind tagging this with a FIXME pointing to an issue?</p>\n</blockquote>",
        "id": 499821496,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564774
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956619294\">PR review comment</a>:</p>\n<blockquote>\n<p>Artifact of development?</p>\n</blockquote>",
        "id": 499821497,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564774
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956666249\">PR review comment</a>:</p>\n<blockquote>\n<p>Like above, mind tagging this as <code>#[cfg(feature = \"stack-switching\")]</code>?</p>\n</blockquote>",
        "id": 499821498,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564774
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956662120\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind adding some docs above this explaining what this is gating?</p>\n</blockquote>",
        "id": 499821499,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564774
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956561176\">PR review comment</a>:</p>\n<blockquote>\n<p>I haven't gotten to the full PR yet but from some of the translation methods below it looks like the fat pointers of continuations aren't stored on the GC heap so this is correctly <code>false</code></p>\n</blockquote>",
        "id": 499821505,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564775
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956671478\">PR review comment</a>:</p>\n<blockquote>\n<p>Since this is just an internal method it might make sense to delete this and update callers to not use it?</p>\n</blockquote>",
        "id": 499821506,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564775
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956670960\">PR review comment</a>:</p>\n<blockquote>\n<p>Like above for globals the panic here is fine for now but this'd be good to tag with a <code>// FIXME</code> pointing to an issue</p>\n</blockquote>",
        "id": 499821507,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564775
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956672021\">PR review comment</a>:</p>\n<blockquote>\n<p>As a heads-up I think this may no longer be necessary after <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10223\">https://github.com/bytecodealliance/wasmtime/pull/10223</a> landed.</p>\n</blockquote>",
        "id": 499821508,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564775
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956674143\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind tagging this with a <code>// FIXME</code> pointing to an issue?</p>\n</blockquote>",
        "id": 499821509,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564775
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1956670497\">PR review comment</a>:</p>\n<blockquote>\n<p>This location unfortunately can't easily be switched to returning a <code>Result</code> so panicking makes sense to me, but mind tagging this with <code>// FIXME(...)</code> pointing to an issue?</p>\n</blockquote>",
        "id": 499821511,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739564776
    },
    {
        "content": "<p>frank-emrich <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2663075610\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>@alexcrichton</p>\n<p>Thanks so much for having a look at this already!</p>\n<p>Regarding my own time commitment for this PR: I'm starting a new job in mid March, so things are looking as follows:</p>\n<ul>\n<li>Until end of February: Focusing exclusively on getting this PR in shape</li>\n<li>First two weeks of March: Working on this PR, but some distractions due to moving, etc.</li>\n<li>From mid March: There will be an initial period of me settling in at my new job during which I can't do much on this. After that the Wasmtime/stack switching work will not part of my day job anymore, but I'll still be around to help out, address bugs, etc. I also have a few things on top of the current PR already done or planned that I want to add at that stage (aarch64 support, Windows support, better DWARF support, ....).</li>\n</ul>\n<p>@dhil should also be able to help out here and there.</p>\n<blockquote>\n<p>In an ideal world this PR would be split up into chunks and landed piecemeal, for example parsing support, then compiling support, then maybe an instruction-at-a-time for each piece, etc.</p>\n</blockquote>\n<p>I think there was just a bit of a miscommunication between me and @dhil. I thought you wanted to see this as one big chunk. There's a simple way in which this PR could be split up, leading to a sequence of PRs as follows:</p>\n<ol>\n<li>Integrate tag support, with nothing stack switching related, yet.</li>\n<li>Add dummy field to VMContext with the size and position that the stack switching field will later occupy. This way, all the changes to the disas tests will happen in this PR. I'm not sure if the disas tests actually contribute to Github choking on this PR, but at least getting them out of the way will reduce the amount of conflicts coming in.</li>\n<li>Everything except the actual Wasm -&gt; CLIF translation. This will be a big chunk where most of the integration of stack switching with the rest of Wasmtime goes.</li>\n<li>The Wasm -&gt; CLIF translation. This will mostly be what's currently in <code>crates/cranelift/src/stack_switching/</code>, in particular <code>instructions.rs</code>. The latter is 2500 LOC, so reviewing that separately seems worthwhile. I may even be able to split this up further.</li>\n</ol>\n<p>This is far from perfect because PR 3 and 4 will still be large and not really split along separate features of the stack switching implementation, but at least that split up would be easy for me to do. I may discover some more chunks that can be factored out into separate PRs on the way.</p>\n<p>My only concerns about this is the following: Given that Github doesn't really support stacked PRs, we would work through these 4+ PRs linearly, making it difficult to point at why we need something in the next PR.  <br>\nOn the other hand, I could just put a branch somewhere that shows everything that's still missing at any point so you can have a look at how something will be used in the remaining PRs.</p>\n<p>Please let me know what you think. I will also make sure to work through the comments you already added to this PR so they don't get lost if we do decide to split this PR.</p>\n</blockquote>",
        "id": 500182040,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739797733
    },
    {
        "content": "<p>frank-emrich edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2663075610\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>@alexcrichton</p>\n<p>Thanks so much for having a look at this already!</p>\n<p>Regarding my own time commitment for this PR: I'm starting a new job in mid March, so things are looking as follows:</p>\n<ul>\n<li>Until end of February: Focusing exclusively on getting this PR in shape</li>\n<li>First two weeks of March: Working on this PR, but some distractions due to moving, etc.</li>\n<li>From mid March: There will be an initial period of me settling in at my new job during which I can't do much on this. After that the Wasmtime/stack switching work will not part of my day job anymore, but I'll still be around to help out, address bugs, etc. I also have a few things on top of the current PR already done or planned that I want to add at that stage (aarch64 support, Windows support, better DWARF support, ....).</li>\n</ul>\n<p>@dhil should also be able to help out here and there.</p>\n<blockquote>\n<p>In an ideal world this PR would be split up into chunks and landed piecemeal, for example parsing support, then compiling support, then maybe an instruction-at-a-time for each piece, etc.</p>\n</blockquote>\n<p>I think there was just a bit of a miscommunication between me and @dhil. I thought you wanted to see this as one big chunk. There's a simple way in which this PR could be split up, leading to a sequence of PRs as follows:</p>\n<ol>\n<li>Integrate tag support, with nothing stack switching related, yet.</li>\n<li>Add dummy field to VMContext with the size and position that the stack switching field will later occupy. This way, all the changes to the disas tests will happen in this PR. I'm not sure if the disas tests actually contribute to Github choking on this PR, but at least getting them out of the way will reduce the amount of conflicts coming in.</li>\n<li>Everything except the actual Wasm -&gt; CLIF translation. This will be a big chunk where most of the integration of stack switching with the rest of Wasmtime goes.</li>\n<li>The Wasm -&gt; CLIF translation. This will mostly be what's currently in <code>crates/cranelift/src/stack_switching/</code>, in particular <code>instructions.rs</code>. The latter is 2500 LOC, so reviewing that separately seems worthwhile. I may even be able to split this up further.</li>\n</ol>\n<p>This is far from perfect because PR 3 and 4 will still be large and not really split along separate features of the stack switching implementation, but at least that split up would be easy for me to do. I may discover some more chunks that can be factored out into separate PRs on the way.</p>\n<p>My only concerns about this is the following: Given that Github doesn't really support stacked PRs, we would work through these 4+ PRs linearly, making it difficult to point at why we need something in the next PR.  <br>\nOn the other hand, I could just put a branch somewhere that shows everything that's still missing at any point so you can have a look at how something will be used in the remaining PRs.</p>\n<p>Please let me know what you think. I will also make sure to work through the comments you already added to this PR so they don't get lost if we do decide to split this PR.</p>\n<p>Edit: One concern I forgot to mention regarding splitting this PR up is testing: We only have a few scattered unit tests, most of our testing happens through whole Wasm programs. That means that if we split the PR, we will only be able to add tests in the end, when all pieces are in place. </p>\n</blockquote>",
        "id": 500208856,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739803818
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#pullrequestreview-2621990805\">PR review</a>.</p>",
        "id": 500278129,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739828415
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1958795026\">PR review comment</a>:</p>\n<blockquote>\n<p>This was just a note to ourselves that we made this field <code>pub(crate)</code> because we access it from our code. For example, we call <code>crate::value_type</code> a few times, which requires a <code>&amp;dyn TargetIsa</code>. But I'm happy to leave a mental note here that we should double-check if that's really necessary</p>\n</blockquote>",
        "id": 500278133,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739828415
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#pullrequestreview-2622012482\">PR review</a>.</p>",
        "id": 500280739,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739829630
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1958808044\">PR review comment</a>:</p>\n<blockquote>\n<p>Sorry, there's one thing I forgot to mention in the overall PR description: There is currently some debugging logic left in this PR, you will run into it when looking at <code>instructions.rs</code>: We have added <code>emit_debug_println!</code> and <code>emit_debug_assert!</code>. Their implementation is too hacky to keep in the final version that we merge, but I'm hoping to keep them until the very end and only rip them out when the rest of the code is ready. They are incredibly helpful while I may need to make any kind of changes to the code.</p>\n<p>Anything that has something like \"delete me\" in the name is related to this debugging code.<br>\n</p>\n</blockquote>",
        "id": 500280740,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739829631
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#pullrequestreview-2622013789\">PR review</a>.</p>",
        "id": 500280881,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739829688
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1958808692\">PR review comment</a>:</p>\n<blockquote>\n<p>This is also an instance of \"debugging code that I would like to keep around until the rest of the PR is ready to merge\"</p>\n</blockquote>",
        "id": 500280882,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739829688
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#pullrequestreview-2622020304\">PR review</a>.</p>",
        "id": 500281818,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739830137
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1958812931\">PR review comment</a>:</p>\n<blockquote>\n<p>Yes, that's absolutely the reason why some of the types that should morally live in the runtime/wasmtime crate are defined here, just to make these offset definitions easier.</p>\n<p>I actually suspected that the module here would have to be merge into (something like) <code>VMOffsets</code>, there's a comment a few lines above saying that.</p>\n<p>I'm happy to do that refactoring, but just a few questions:<br>\nShould I actually integrate all the offsets for these types here into <code>VMOffsets</code> (or more accurately, the <code>PtrSize</code> trait)? Or was your suggestion to re-create similar infrastructure elsewhere? I'm mostly asking because AFAIK all the types that <code>vmoffsets.rs</code> talks about have the <code>VM*</code> prefix. There's nothing really stopping us from adding that prefix to our own types, but I'm unsure if that prefix carries more meaning and may be inappropriate for our types.<br>\n</p>\n</blockquote>",
        "id": 500281819,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739830138
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#pullrequestreview-2622020544\">PR review</a>.</p>",
        "id": 500281848,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739830153
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1958813104\">PR review comment</a>:</p>\n<blockquote>\n<p>Yes, definitely! See my comment on the <code>delete_me_*</code> libcalls </p>\n</blockquote>",
        "id": 500281850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739830153
    },
    {
        "content": "<p>frank-emrich edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1958813104\">PR review comment</a>.</p>",
        "id": 500281906,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739830180
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#pullrequestreview-2622027729\">PR review</a>.</p>",
        "id": 500282928,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739830684
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1958817590\">PR review comment</a>:</p>\n<blockquote>\n<p>Yes, this is ugly. This is basically just a way of saying \"give me the size of a <code>ValRaw</code>\", without having access to that type here.<br>\nThe reason we need that size is that all continuation payloads (arguments to continuations, return values from continuations, values provided by <code>suspend</code>, etc) are currently written to and then read from buffers containing <code>ValRaw</code>. Let's keep this comment open, we will certainly be re-visiting that discussion when you have a look at <code>instructions.rs</code>.</p>\n</blockquote>",
        "id": 500282929,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739830684
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2666400897\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<blockquote>\n<p>Regarding my own time commitment for this PR</p>\n</blockquote>\n<p>Ok that all sounds good, thanks! (very helpful to set expectations!)</p>\n<blockquote>\n<p>I think there was just a bit of a miscommunication between me and @dhil.</p>\n</blockquote>\n<p>Oh no that's on me. I remember telling @dhil that and I think I was just basically wrong, so that's on me for leading y'all astray. Given the size of this (not just the auto-updated tests but also the scale of the implementation) along with the subtelty of the implementation in retrospect I just didn't account for that and misled y'all. If possible I think the best way to handle this would be to peel off PRs from this one and submit them independently.</p>\n<p>Overall my goal is to ensure that we get a good chance to review everything coming in and reducing the chance of something being lost by accident due to being overlooked. For coordination what I would imagine is that it's completely reasonable to have lightly, if at all, tested intermediate states. Additionally it's totally reasonable to leave a \"hole\" in the code with something like <code>// more coming soon ...</code> (e.g. making a hole in the <code>VMContext</code> for the stack-switching state necessary for a future PR). Let's keep this PR open so it can be cross-referenced if needed, and this can be rebased occasionally as smaller pieces are landed.</p>\n<p>Does that seem ok? It's a similar strategy we're taking for landing <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9582\">async component model support in Wasmtime</a> where it's landing piece-by-piece. Each piece is not 100% thoroughly tested but the  \"final PR\" has lots of tests. We try to keep track of outstanding TODO items in issues occasionally and otherwise are ok deferring work to a future PR which has more tests and more fully justifies a prior design.</p>\n<p>Your sequence of PRs makes sense to me as well. I'd mostly defer to y'all for pieces to split up as you're the most familiar with the implementation, and if something seems too big I can bring it up during the review but by naturally splitting this up I think most slicing/dicing will be quite reasonable.</p>\n</blockquote>",
        "id": 500474455,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739900019
    },
    {
        "content": "<p>frank-emrich <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2666937613\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<blockquote>\n<p>Overall my goal is to ensure that we get a good chance to review everything coming in and reducing the chance of something being lost by accident due to being overlooked.</p>\n</blockquote>\n<p>Yes, absolutely. I'm happy to do the necessary chopping. I'll create a tracking issue describing the bigger picture and where we currently are regarding the PRs that have and haven't landed at any time.</p>\n<p>The outline of PRs I mentioned in my previous comment will still lead to fairly large ones, but I will see if there's potential to split this up further and wait for your feedback once I've split off a candidate for a PR.</p>\n<p>Also, sorry for making you wade through lots of <code>todo!()</code>,  <code>unimplemented!()</code> and other little things that we hadn't resolved before creating this PR.</p>\n</blockquote>",
        "id": 500511451,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739913072
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2667171982\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>Sounds good! It's ok to skip the step of writing out a plan in an issue and then executing on the plan, we can work on making sure things are documented before you wind down but up until then it's ok if it's just in a few heads. In that sense no need to exhaustively document \"here's the round peg that's gonna fit in that round hole\" and we can just have one issue for tracking known items that are already in-tree.</p>\n<p>And please no apologies necessary! Landing big changes I've found is always a bit of an art and if anything I'm the one who led you astray by being overconfident!</p>\n</blockquote>",
        "id": 500531805,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739922221
    },
    {
        "content": "<p>frank-emrich submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#pullrequestreview-2626720741\">PR review</a>.</p>",
        "id": 500644466,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739970045
    },
    {
        "content": "<p>frank-emrich created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1961639866\">PR review comment</a>:</p>\n<blockquote>\n<p>This comment is actually still applicable, but it's a relatively minor point.</p>\n<p>What's happening here is the following: For the translation of some instructions, like <code>resume</code>, we need access to the <code>VMRuntimeLimits</code>. That means that if a Wasm function contains certain instructions, we would like to use the the <code>vmruntime_limits_ptr</code> <code>ir::Value</code> in <code>FuncEnvironment</code>.<br>\nHowever, the code here must decide whether or not to call <code>declare_vmruntime_limits_ptr</code> without knowing if the function body contains such an instruction (and it seems like a bad idea to traversing the body of the function just for this).</p>\n<p>What we currently do is just to re-load the pointer to the <code>VMRuntimeLimits</code> every time we need it (basically just inlining the same <code>load</code> as the one in <code>declare_vmruntime_limits_ptr</code>) and hoping that the optimizer may catch cases where we do this more than once per function.</p>\n<p>I'm not sure if it's worth to update <code>declare_vmruntime_limits_ptr</code> so that it doesn't define <code>vmruntime_limits_ptr</code> in the function prelude, but instead make it an <code>Option</code> that's set the first time someone needs the value.</p>\n</blockquote>",
        "id": 500644468,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739970046
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 500721856,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739991658
    },
    {
        "content": "<p>dhil submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#pullrequestreview-2627811621\">PR review</a>.</p>",
        "id": 500729260,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739994294
    },
    {
        "content": "<p>dhil created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1962274442\">PR review comment</a>:</p>\n<blockquote>\n<p>A tag is more than a wasm type. It is a nominal entity and its unique identity is important. Basically we get a unique identity by picking backing on pointer equality.</p>\n<p>I think we can get rid of the vmctx, potentially. Though we can discuss the best course of action here. I have pulled the tag stuff into its own patch which I will open tomorrow when I have had a chance to look at the tests.</p>\n</blockquote>",
        "id": 500729262,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739994294
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2669829259\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"fuzzing\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: fuzzing</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 500748367,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740001481
    },
    {
        "content": "<p>frank-emrich <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2669974774\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<p>Converting this back to a draft now because it will be split up into multiple PRs.</p>\n<p>Over the next few weeks, I expect to rebase this PR whenever parts of it have landed. This way, this PR will always contain whatever is left.</p>\n<p>I've also created issue #10248 to track the overall status. I will also use that issue in various FIXMEs for missing features.</p>\n</blockquote>",
        "id": 500761263,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740006905
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 500761937,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740007244
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 500936153,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740073164
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 500980817,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740090259
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 500986860,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740092824
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#issuecomment-2673176656\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>:</p>\n<blockquote>\n<h4>Label Messager: wasmtime:config</h4>\n<p>It looks like you are changing Wasmtime's configuration options. Make sure to<br>\ncomplete this check list:</p>\n<ul>\n<li>\n<p>[ ] If you added a new <code>Config</code> method, you wrote extensive documentation for<br>\n      it.</p>\n<p>&lt;details&gt;</p>\n<p>Our documentation should be of the following form:</p>\n<p>```text<br>\nShort, simple summary sentence.</p>\n<p>More details. These details can be multiple paragraphs. There should be<br>\ninformation about not just the method, but its parameters and results as<br>\nwell.</p>\n<p>Is this method fallible? If so, when can it return an error?</p>\n<p>Can this method panic? If so, when does it panic?</p>\n<h1>Example</h1>\n<p>Optional example here.<br>\n```</p>\n<p>&lt;/details&gt;</p>\n</li>\n<li>\n<p>[ ] If you added a new <code>Config</code> method, or modified an existing one, you<br>\n  ensured that this configuration is exercised by the fuzz targets.</p>\n<p>&lt;details&gt;</p>\n<p>For example, if you expose a new strategy for allocating the next instance<br>\nslot inside the pooling allocator, you should ensure that at least one of our<br>\nfuzz targets exercises that new strategy.</p>\n<p>Often, all that is required of you is to ensure that there is a knob for this<br>\nconfiguration option in [<code>wasmtime_fuzzing::Config</code>][fuzzing-config] (or one<br>\nof its nested <code>struct</code>s).</p>\n<p>Rarely, this may require authoring a new fuzz target to specifically test this<br>\nconfiguration. See [our docs on fuzzing][fuzzing-docs] for more details.</p>\n<p>&lt;/details&gt;</p>\n</li>\n<li>\n<p>[ ] If you are enabling a configuration option by default, make sure that it<br>\n  has been fuzzed for at least two weeks before turning it on by default.</p>\n</li>\n</ul>\n<p>[fuzzing-config]: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194\">https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194</a><br>\n[fuzzing-docs]: <a href=\"https://docs.wasmtime.dev/contributing-fuzzing.html\">https://docs.wasmtime.dev/contributing-fuzzing.html</a></p>\n<hr>\n<p>&lt;details&gt;</p>\n<p>To modify this label's message, edit the &lt;code&gt;.github/label-messager/wasmtime-config.md&lt;/code&gt; file.</p>\n<p>To add new label messages or remove existing label messages, edit the<br>\n&lt;code&gt;.github/label-messager.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/label-messager-action\">Learn more.</a></p>\n<p>&lt;/details&gt;</p>\n</blockquote>",
        "id": 501006609,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740103754
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 501121340,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740149203
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 501127191,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740150824
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#pullrequestreview-2633405511\">PR review</a>.</p>",
        "id": 501130477,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740151855
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1965686876\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>Should I actually integrate all the offsets for these types here into VMOffsets (or more accurately, the PtrSize trait)?</p>\n</blockquote>\n<p>Yeah let's do that. That's the conventional location we have for dealing with offsets-of-things in compiled code, so I think keeping it all in one place is best.</p>\n<blockquote>\n<p>There's nothing really stopping us from adding that prefix to our own types, but I'm unsure if that prefix carries more meaning and may be inappropriate for our types.</p>\n</blockquote>\n<p>Oh no special meaning yeah, just our convention for \"this datatype is read by both compiled code and the host\" and then we try to group things together where it makes sense</p>\n</blockquote>",
        "id": 501130479,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740151856
    },
    {
        "content": "<p>dhil created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#discussion_r1965733715\">PR review comment</a>:</p>\n<blockquote>\n<p>I think we need some knobs for continuation stacks, e.g. limit the number of allocated stacks. I think the stack size can be useful, but perhaps its use is rather limited until we have implemented growable stacks. I think we also want to land a pooling allocator for continuation stacks, as it is necessary to obtain decent performance on the workloads we have been benchmarking. </p>\n<p>Though, I'd be quite happy to simply use <code>wasm_stack_size</code> and keep the specific stack switching config downstream for now.</p>\n</blockquote>",
        "id": 501135408,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740153300
    },
    {
        "content": "<p>dhil submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177#pullrequestreview-2633483971\">PR review</a>.</p>",
        "id": 501135410,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740153301
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 501688028,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740446082
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 501844485,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740499327
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 504065534,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741344913
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 504172486,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741376942
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 504186811,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741382657
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 505224900,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741806275
    },
    {
        "content": "<p>frank-emrich updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">PR #10177</a>.</p>",
        "id": 513472180,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745270730
    }
]