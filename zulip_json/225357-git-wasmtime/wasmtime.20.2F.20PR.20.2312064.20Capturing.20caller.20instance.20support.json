[
    {
        "content": "<p>gionut opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a> from <code>elasticproject-eu:component-attestation</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>Previous conversation about this pull request available at:<br>\n<a href=\"#narrow/channel/217126-wasmtime/topic/New.20functionality.20useful.20for.20attestation/with/553956315\">https://bytecodealliance.zulipchat.com/#narrow/channel/217126-wasmtime/topic/New.20functionality.20useful.20for.20attestation/with/553956315</a></p>\n<p>Also there is a discussion about request of this feature available at:<br>\n<a href=\"#narrow/channel/217126-wasmtime/topic/Getting.20component.20information.20on.20host.20calls/with/558000999\">https://bytecodealliance.zulipchat.com/#narrow/channel/217126-wasmtime/topic/Getting.20component.20information.20on.20host.20calls/with/558000999</a></p>\n<h3>Summary</h3>\n<p>We have modified Wasmtime to expose the identity of the caller identity to host function implementations, in order to support functionality such as remote attestation or component-specific access control policies.  This includes both the addition of an extended host function API for embedders that provides the caller identity, as well as analysis of components during compilation in order to capture enough structure to allow the caller to be identified within the application.  </p>\n<hr>\n<h3>Goal</h3>\n<p>To provide a supported way for embedders to identify which part of a multi-component Wasm application has called a host function. This can serve a number of purposes, but in our case the goal is to enable a platform to implement Wasm-aware _attestation_ functionality.</p>\n<p>Attestation allows one platform, the prover, to prove properties of its state to another platform, the verifier.  A common property to prove is the hashes of the code running on the platform, and to link them to e.g. a TLS handshake, that allows a client to obtain a guarantee such as \"at the other end of this TLS connection is application X\".</p>\n<p>Since WebAssembly provides individual sandboxes for each core module instance, we can meaningfully attest the identity of a piece of code at the granularity of a core module, rather than treating the application as a monolithic whole.  This allows for libraries and applications that use attestation to be transparently composed into larger systems while maintaining their individual identities.</p>\n<p>To achieve this, we require two main additions to Wasmtime, and this PR is oriented towards these two goals:</p>\n<ol>\n<li>\n<p>When a component is loaded, we need to extract enough information on its internal structure to allow the embedder to work out which part of the application called a host function.</p>\n</li>\n<li>\n<p>We need to extend the host function API to allow the implementation to identify the source of the function call, in a backwards-compatible manner.</p>\n</li>\n</ol>\n<hr>\n<h3>General implementation notes</h3>\n<ol>\n<li><strong>Component structure analysis</strong></li>\n</ol>\n<p>This is implemented in _crates/environ/src/component/dfg.rs_, _‎crates/environ/src/component/info.rs_, and _‎crates/environ/src/component/translate/inline.rs_. And the public API is at _‎crates/wasmtime/src/runtime/component/component.rs_.</p>\n<p>During component compilation/instantiation, we track the creation of core module instances and the resolution of their imports/exports.  These instances are named using a sequence of indices that uniquely identify its location relative to the top-level component (e.g. [5.1] is the first core module instance in the fifth component instantiated in the top-level component).</p>\n<p>In many applications, linking the caller back to this identifier will be enough, and probably we will end up minimising these changes down to this.  However, this ties the identity of part of the application to its location in the component hierarchy.  We might expect that some future applications may rearrange the component hierarchy, e.g. in order to optimise an application binary for size, or to distribute an application across several physical machines.  We therefore aim to represent the application at a lower level.</p>\n<p>For each imported core function, we record which core module instance it ultimately comes from, following the same resolution steps that the inliner uses.  The result is an <em>instantiation graph</em> whose nodes are core module instances and whose edges represent dependency and call relationships as resolved by Wasmtime.</p>\n<p>The result is an accurate graph of how core module instances are wired together at runtime inside a component (after linking, lowering, aliasing, etc.), along with identifiers that allow parts of the graph to be identified with their location in the component hierarchy, allowing comparison with a reference binary, even if its overall structure is completely different to a mangled binary loaded at runtime.</p>\n<p>The instantiation graph is exposed via a method _<code>Component::component_structure</code>_ that allows embedders (or tools) to obtain the instantiation graph structure of the runtime structure.</p>\n<ol start=\"2\">\n<li><strong>Caller-aware host functions</strong></li>\n</ol>\n<p>This is implemented in _crates/wasmtime/src/runtime/component/linker.rs_ and _crates/wasmtime/src/runtime/component/func/host.rs‎_ and hidden behind the feature flag <code>caller</code>.</p>\n<p>We introduce new <code>func_wrap</code> variants (identified by the suffix <code>_caller</code>) in the component linker that allow a host function to receive not only its usual arguments, but also an identifier for the calling component/core module instance.</p>\n<p>We capture the runtime index OptionsIndex that, in combination with an <code>Instance</code>, identifies the core module in the <code>Store</code>. We then correlate this index with the identifier sequence described above.  It is important to note that the naming matches the components' index spaces used by wasmtime and present in WebAssembly Text Format (WAT). Using this we can correlate the calling instance with its instantiation in the component binary.</p>\n</blockquote>",
        "id": 558610763,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763716261
    },
    {
        "content": "<p><strong>gionut</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>.</p>",
        "id": 558610764,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763716261
    },
    {
        "content": "<p><strong>gionut</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>.</p>",
        "id": 558610765,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763716261
    },
    {
        "content": "<p>gionut updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>.</p>",
        "id": 558628481,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763721681
    },
    {
        "content": "<p>gionut updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>.</p>",
        "id": 558633088,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763723023
    },
    {
        "content": "<p>gionut updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>.</p>",
        "id": 558635661,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763723861
    },
    {
        "content": "<p>gionut updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>.</p>",
        "id": 558666227,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763733589
    },
    {
        "content": "<p>gionut updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>.</p>",
        "id": 558671057,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763734830
    },
    {
        "content": "<p>gionut updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>.</p>",
        "id": 558672901,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763735324
    },
    {
        "content": "<p>gionut updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>.</p>",
        "id": 558697694,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763741298
    },
    {
        "content": "<p>gionut updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>.</p>",
        "id": 558821783,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763824814
    },
    {
        "content": "<p>gionut updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>.</p>",
        "id": 558986660,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763975765
    },
    {
        "content": "<p><strong>gionut</strong> has marked <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a> as ready for review.</p>",
        "id": 558990556,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763976827
    },
    {
        "content": "<p><strong>gionut</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-default-reviewers\">wasmtime-default-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>.</p>",
        "id": 558990558,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763976828
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064#issuecomment-3571542628\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>:</p>\n<blockquote>\n<p>Thask for opening the PR here!</p>\n<p>I've been discussing the general topic of this with @tschneidereit recently as we were thinking of using something like this in Spin as well, but we ended up ultimately concluding that this is a host-side superpower which we don't want to leverage. Specifically thsi is adding functionality in Wasmtime which is impossible to polyfill with components themselves, meaning that this behavior is host-specific and relies on host superpowers. That's no the end of the world per se, but it would basically mean that this ideally needs to stay contained and not in widespread use because it may not be implementable on other runtimes (e.g. a hypothetical native web browser implementation).</p>\n<p>The main alternative to this approach is to, when you have N components importing a piece of functionality, compose that in such a way where N pieces of functionality are imported. That differs from composition today where only a single piece of functionality is imported as all the components are union'd together. This would enable the host to know which component is doing the call, for example. Something like this has the added benefit of not needing the various bits and pieces of infrastructure here to map the caller identifer to something within a component since the embedder knows the structure of the component by construction and would know which import goes where.</p>\n<p>The downside of this alternative is that tooling today isn't quite ready to handle all of this. There's a known minor extension to the component model as well which is known to make a feature like this much easier to work with at the tooling layer as well. In that sense I want to acknowledge that what I'm laying out as an alternative is not necessarily easy to achieve today.<br>\n</p>\n</blockquote>",
        "id": 559086743,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764000101
    },
    {
        "content": "<p>LachlanGunn <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064#issuecomment-3575466120\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>:</p>\n<blockquote>\n<p>Thanks for the feedback!</p>\n<blockquote>\n<p>The downside of this alternative is that tooling today isn't quite ready to handle all of this. There's a known minor extension to the component model as well which is known to make a feature like this much easier to work with at the tooling layer as well. In that sense I want to acknowledge that what I'm laying out as an alternative is not necessarily easy to achieve today.</p>\n</blockquote>\n<p>Sorry for my ignorance, but which extension is this?</p>\n<p>I understand correctly, the idea would be then that:</p>\n<p>1. When you compose the components together, you write your WAC script so that each component names its attestation interface import independently.<br>\n  2.  The embedder, when it loads the component,<br>\n      a. Does its own binary analysis replicating what we have in this PR to work out which import comes from which component/module down in the structure.<br>\n      b. Separately satisfies each of these imports, e.g. with a closure that maps the import to the component identity found in the previous step and calls the real implementation.</p>\n<p>The challenge then would be that you would need a way to tie all of these different imports to the underlying host interface, so that the linker has some way of knowing that they're all meant to go to the same place even though they're independent interfaces.  Is this what the component model extension that you mention does?  Or is there some trick to this that I'm missing?</p>\n<p>Assuming we can overcome this, we might be able to rework our code into something like that, at least if I've understood correctly what you mean.  Having this visible at the component model level might help with some of the other challenges in designing an attestation interface that tried to avoid digressing into here.</p>\n</blockquote>",
        "id": 560143860,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764074540
    },
    {
        "content": "<p>LachlanGunn edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064#issuecomment-3575466120\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>:</p>\n<blockquote>\n<p>Thanks for the feedback!</p>\n<blockquote>\n<p>The downside of this alternative is that tooling today isn't quite ready to handle all of this. There's a known minor extension to the component model as well which is known to make a feature like this much easier to work with at the tooling layer as well. In that sense I want to acknowledge that what I'm laying out as an alternative is not necessarily easy to achieve today.</p>\n</blockquote>\n<p>Sorry for my ignorance, but which extension is this?</p>\n<p>I understand correctly, the idea would be then that:</p>\n<p>1. When you compose the components together, you write your WAC script so that each component names its attestation interface import independently.<br>\n  2.  The embedder, when it loads the component,<br>\n      a. Does its own binary analysis replicating what we have in this PR to work out which import comes from which component/module down in the structure.<br>\n      b. Separately satisfies each of these imports, e.g. with a closure that maps the import to the component identity found in the previous step and calls the real implementation.</p>\n<p>The challenge then would be that you would need a way to tie all of these different imports to the underlying host interface, so that the linker has some way of knowing that they're all meant to go to the same place even though they're independent interfaces.  Is this what the component model extension that you mention does?  Or is there some trick to this that I'm missing?</p>\n<p>Assuming we can overcome this, we might be able to rework our code into something like that, at least if I've understood correctly what you mean.  Having this visible at the component model level might help with some of the other challenges in designing an attestation interface that tried to avoid digressing into here.</p>\n<p><strong>Edit:</strong> Actually, thinking about it a little longer, we might be able to hack this together by parsing the component in the embedder, independently mangling each leaf component's import of the host function to a different host function, then reassembling the binary and loading it with stock Wasmtime. I wouldn't call it a pretty solution, but it would make it portable to any runtime at least. </p>\n</blockquote>",
        "id": 560439028,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764176307
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064#issuecomment-3598098585\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12064\">PR #12064</a>:</p>\n<blockquote>\n<p>Oh no worries and no ignorance on your part. I'm not actually sure if there's a corresponding component-model issue or PR, but the rough idea is that you should be able to import the same interface twice in a component:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>world foo {\n    import upstream1: wasi:http/handler;\n    import upstream2: wasi:http/handler;\n}\n</code></pre></div>\n<p>The rough idea is that composing with wac could produce such a component with this interface. The other rough idea is that composition would be a trusted process so the host would understand that <code>upstream1</code> goes to its desired location and <code>upstream2</code> goes to its desired component as well. So less so on the binary analysis side of things and more correct-by-construction. (although binary analysis should always be possible still)</p>\n<blockquote>\n<p>The challenge then would be that you would need a way to tie all of these different imports to the underlying host interface, so that the linker has some way of knowing that they're all meant to go to the same place even though they're independent interfaces. Is this what the component model extension that you mention does? Or is there some trick to this that I'm missing?</p>\n</blockquote>\n<p>The (again, rough) thinking is that the embedder would specify \"I expect this interface to possibly be replicated under different names\" which means that in bindings generation all functions would receive a first parameter which is the string that they were imported under (e.g. <code>\"upstream1\"</code> and <code>\"upstream2\"</code> above). The host implementation would then dispatch based on this string.</p>\n</blockquote>",
        "id": 561240906,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764612373
    }
]