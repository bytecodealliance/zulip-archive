[
    {
        "content": "<p>MangoPeachGrape opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11437\">issue #11437</a>:</p>\n<blockquote>\n<p>(Part of the outstanding items of the component model: <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8036#issuecomment-3129666977\">https://github.com/bytecodealliance/wasmtime/issues/8036#issuecomment-3129666977</a>)</p>\n<p>See previous comments: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11055#issue-3151376309\">https://github.com/bytecodealliance/wasmtime/pull/11055#issue-3151376309</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11055#issuecomment-2980677120\">https://github.com/bytecodealliance/wasmtime/pull/11055#issuecomment-2980677120</a></p>\n<hr>\n<p>My current limited understanding is that there should be a type that holds the resource's <code>ForeignData</code>, which is then inserted to the <code>ResourceTable</code>. Lets call this type <code>CApiResource</code>.</p>\n<p>When a function is called, we get a <code>ResourceAny</code>, that can be then <code>res.try_into_resource::&lt;CApiResource&gt;(&amp;mut store)</code>, and then <code>store.data().table.get(&amp;capi_res)</code>.</p>\n<p>But that brings up the question: What should be passed to C?</p>\n<ul>\n<li>Should it be the <code>ResourceAny</code> somehow boxed into a C type?</li>\n<li>Should it be the contents of the <code>CApiResource</code> already fetched from the <code>ResourceTable</code>, so the data pointer to data, and the embedder specified resource type integer?</li>\n<li>Should it just be the resource representation <code>u32</code> index?</li>\n<li>Something else?</li>\n</ul>\n<p>The same question exists in the reverse direction, when the C API wants to return a new resource.</p>\n<p>I also seem to read that <code>ResourceAny::resource_drop()</code> must be called at the end. Does this mean after calling the embedder's callback, we have to iterate the arguments, match if resource, and call this?</p>\n<p>Please note that I don't know much about working with resources, so I might be going at this at the wrong way.</p>\n</blockquote>",
        "id": 534637221,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755256908
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11437#issuecomment-3191802805\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11437\">issue #11437</a>:</p>\n<blockquote>\n<p>Fair warning on this: resources are subtle and tricky in ways that don't often become apparent until later. I unfortunately don't have time to champion/design a full implementation here but I can try to help out where I can with thoughts/feedback. This'll likely be both a learning process for both you and me as we figure out how best to represent this in the C API and it may require some adjustments over time. Basically I don't think that the Rust API as-is today is perfect for providing a reasonable C API and may need changes, but I'm not sure exactly how. I'll also admit that I'm re-paging-in all this context too, so apologies if this is a bit verbose.</p>\n<p>Today there are two ways to represent a resource in the Rust API of Wasmtime: <code>Resource&lt;T&gt;</code> and <code>ResourceAny</code>. Both are glorified wrappers over a 32-bit index which is \"guarded\" with type information.  The use case of each though is somewhat subtle.</p>\n<p><code>Resource&lt;T&gt;</code> is ubiquitously used for host bindings in WASI impementations and <code>bindgen!</code>-generated bindings. The <code>T</code> type is only used for a <code>TypeId</code> and is pretty arbitrary, but in wasmtime-wasi it's often used to match the type of something stored in a <code>ResourceTable</code>. They need not necessarily be equivalent, however. The other assertion of <code>Resource&lt;T&gt;</code> is \"I'm the host and I know what I'm doing\" in particular around destructors. It's assume that the host knows how to \"destroy\" the resource (which is, after all, just an index). More-or-less <code>Resource&lt;T&gt;</code> is a free-floating 32-bit index which is almost entirely disconnected from Wasmtime's state management meaning the host can do whatever it wants and has no destructor requirement.</p>\n<p><code>ResourceAny</code> is used, as the name might imply, to represent any possible resource. This notably includes guest-defined resources in addition to host-defined resources. The reason this has a destructor requirement is for the guest-defined case. This also has a destructor requirement as <code>ResourceAny</code> has some indexes/connection to host-defined state within Wasmtime (e.g. the \"host tables\"). This state is severed with <code>Resource&lt;T&gt;</code> but still present with <code>ResourceAny</code>.</p>\n<p>IMO neither of these are perfectly suitable for usage in the C API:</p>\n<ul>\n<li><code>Resource&lt;T&gt;</code> isn't great because <code>T</code> has to be defined statically. This means that the C API would only be able to define one type of resource which I don't think is suitable because then there's no protection about using the correct type of resource. </li>\n<li><code>Resource&lt;T&gt;</code> is good, however, in that it's \"just an index\" disconnected from other bits. I like this aspect because hosts don't have to worry about destructors or anything like that, so I think we do want something like <code>Resource&lt;T&gt;</code>.</li>\n<li><code>ResourceAny</code> isn't great as it's too general. It represents any possible resource, including guest resources, which has the burdensome requirement of needing a destructor to fully clean up after itself.</li>\n</ul>\n<p>After thinking about this for a bit I think we need some Rust API changes and careful modeling in C API. What I'm imagining looks like:</p>\n<ol>\n<li><code>wasmtime_component_valunion_t</code> is extended with a resource field which is more-or-less <code>ResourceAny</code>. This would be some sort of opaque structure and boxed up <code>ResourceAny</code> most likely. This would indeed have a requirement that it must be operated on to be properly cleaned up (beyond <code>*_delete</code> to avoid host memory leaks).</li>\n<li><code>wasmtime_component_resource_any_t</code>, let's say, would be C bindings for the <code>ResourceAny</code> type. This notably includes the <code>owned</code> and <code>resource_drop</code> methods. Eventually could bind <code>ty</code> too, but that's ok to not dig in too deeply at this time.</li>\n<li>\n<p>A new API will be added to the Rust crate to support multiple types of resources in the C API:</p>\n<ul>\n<li>A new <code>fn ResourceType::runtime_typed(i: u32) -&gt; ResourceType</code> will be added. This is similar to <code>ResourceType::Host(TypeId)</code> but it'll just be <code>ResourceType::RuntimeTyped(u32)</code>.</li>\n<li>This new resource type will be used to represent C API resources defined with a 32-bit integer as their \"type\", in an RTTI-like fashion.</li>\n<li>A new <code>ResourceRuntimeTyped</code> will be added. This'll more-or-less be an exact copy of <code>Resource&lt;T&gt;</code> except that type-checks look for <code>ResourceType::RuntimeTyped</code> instead of <code>ResourceType::Host</code></li>\n<li><code>ResourceAny</code> will have new conversion between <code>ResourceRuntimeTyped</code> in the same manner as <code>Resource&lt;T&gt;</code></li>\n<li>This effectively means that <code>ResourceAny</code> sort of has two subclasses of <code>Resource&lt;T&gt;</code> and <code>ResourceRuntimeTyped</code> in a sense.</li>\n<li>The naming \"runtime typed\" probably wants bikeshedding...</li>\n</ul>\n</li>\n<li>\n<p><code>wasmtime_component_resource_any_t</code> will have conversions to/from <code>wasmtime_component_resource_t</code> which would be a binding to <code>ResourceRuntimeTyped</code> in Rust. These conversions would take the type as an argument for example to say \"I'm asserting that this <code>ResourceAny</code> is of runtime type 4\". Conversion to <code>wasmtime_component_resource_t</code> would \"consume\" the original <code>ResourceAny</code> and release the host from its destructor requirement in the exact same way as <code>Resource&lt;T&gt;</code>.</p>\n</li>\n<li><code>wasmtime_component_resource_t</code> would have index/type accessors both operating on 32-bit integers, and then the embedding host would be able to do whatever it wants at that point.</li>\n<li><code>wasmtime_component_linker_instance_add_resource</code> would be added taking a 32-bit integer which would call <code>LinkerInstance::resource</code> with <code>ResourceType::runtime_typed(...)</code>. That would define the host destructor for a resource as well as the type information.</li>\n<li>Host functions in C would almost always convert <code>wasmtime_component_resource_any_t</code> to <code>wasmtime_component_resource_t</code> and could then do whatever indexing they want.</li>\n<li>Host embeddings in C could use <code>wasmtime_component_resource_any_t</code> when they invoke a wasm function to handle the case that the resource may be owned by wasm and thus needs to behave and operate like <code>ResourceAny</code>.</li>\n</ol>\n<hr>\n<p>Ok that's a lot of words and I didn't necessarily directly answer any of your questions. How's that all sound though? I realize this may be pretty opaque if you're new to resources (it took me a long time to get comfortable, and I still need time to \"boot back up\"). I'm more than happy to help explain anything else too.</p>\n</blockquote>",
        "id": 534671335,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755271579
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasmtime:c-api label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11437\">Issue #11437</a>.</p>",
        "id": 535590186,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755817141
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasm-proposal:component-model label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11437\">Issue #11437</a>.</p>",
        "id": 535590187,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755817142
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11437#issuecomment-3419211112\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11437\">issue #11437</a>:</p>\n<blockquote>\n<p>My step (3) from above, a relatively meaty step, is done in #11885. I'll be trying to tackle this in the near future next.</p>\n</blockquote>",
        "id": 545802309,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760849110
    },
    {
        "content": "<p>fitzgen closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11437\">issue #11437</a>:</p>\n<blockquote>\n<p>(Part of the outstanding items of the component model: <a href=\"https://github.com/bytecodealliance/wasmtime/issues/8036#issuecomment-3129666977\">https://github.com/bytecodealliance/wasmtime/issues/8036#issuecomment-3129666977</a>)</p>\n<p>See previous comments: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11055#issue-3151376309\">https://github.com/bytecodealliance/wasmtime/pull/11055#issue-3151376309</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11055#issuecomment-2980677120\">https://github.com/bytecodealliance/wasmtime/pull/11055#issuecomment-2980677120</a></p>\n<hr>\n<p>My current limited understanding is that there should be a type that holds the resource's <code>ForeignData</code>, which is then inserted to the <code>ResourceTable</code>. Lets call this type <code>CApiResource</code>.</p>\n<p>When a function is called, we get a <code>ResourceAny</code>, that can be then <code>res.try_into_resource::&lt;CApiResource&gt;(&amp;mut store)</code>, and then <code>store.data().table.get(&amp;capi_res)</code>.</p>\n<p>But that brings up the question: What should be passed to C?</p>\n<ul>\n<li>Should it be the <code>ResourceAny</code> somehow boxed into a C type?</li>\n<li>Should it be the contents of the <code>CApiResource</code> already fetched from the <code>ResourceTable</code>, so the data pointer to data, and the embedder specified resource type integer?</li>\n<li>Should it just be the resource representation <code>u32</code> index?</li>\n<li>Something else?</li>\n</ul>\n<p>The same question exists in the reverse direction, when the C API wants to return a new resource.</p>\n<p>I also seem to read that <code>ResourceAny::resource_drop()</code> must be called at the end. Does this mean after calling the embedder's callback, we have to iterate the arguments, match if resource, and call this?</p>\n<p>Please note that I don't know much about working with resources, so I might be going at this at the wrong way.</p>\n</blockquote>",
        "id": 546569590,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1761177869
    }
]