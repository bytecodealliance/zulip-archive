[
    {
        "content": "<p><a href=\"https://github.com/tschneidereit\">tschneidereit</a> added the wasmtime label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637\">Issue #10637</a>.</p>",
        "id": 513592638,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745323890
    },
    {
        "content": "<p>tschneidereit opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637\">issue #10637</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Over in #10620, @pchickey proposed stabilizing the format of <code>--invoke</code>. I think that makes sense, but it also caused me to revisit an idea I've had for a long time now: what if we taught <code>wasmtime</code> to generate nice, idiomatic CLIs from WIT exports?</p>\n<p>To illustrate the idea, here's a simple example:</p>\n<p>For this wit</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>/// A collection of tools that foo\nexport interface tools {\n  /// A foo function that foos as and bs into strings\n  foo: func(a: u32, b: string) -&gt; string;\n}\n</code></pre></div>\n<p>Wasmtime could generate this CLI interface:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">$</span><span class=\"w\"> </span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">cli</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">help</span>\n<span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">collection</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">tools</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">foo</span>\n<span class=\"n\">Usage</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">cli</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">COMMAND</span><span class=\"o\">&gt;</span>\n\n<span class=\"n\">Commands</span><span class=\"p\">:</span>\n<span class=\"w\">  </span><span class=\"nc\">foo</span><span class=\"w\">    </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">foos</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"n\">into</span><span class=\"w\"> </span><span class=\"n\">strings</span>\n\n<span class=\"n\">Options</span><span class=\"p\">:</span>\n<span class=\"w\">  </span><span class=\"o\">-</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">help</span><span class=\"w\">     </span><span class=\"n\">Print</span><span class=\"w\"> </span><span class=\"n\">help</span>\n<span class=\"w\">  </span><span class=\"o\">-</span><span class=\"n\">V</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">version</span><span class=\"w\">  </span><span class=\"n\">Print</span><span class=\"w\"> </span><span class=\"n\">version</span>\n\n<span class=\"cp\">$</span><span class=\"w\"> </span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">cli</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">help</span>\n<span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">foos</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">bs</span><span class=\"w\"> </span><span class=\"n\">into</span><span class=\"w\"> </span><span class=\"n\">strings</span>\n\n<span class=\"n\">Usage</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">cli</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">OPTIONS</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">A</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">B</span><span class=\"p\">]</span>\n\n<span class=\"n\">Arguments</span><span class=\"p\">:</span>\n<span class=\"w\">  </span><span class=\"p\">[</span><span class=\"n\">A</span><span class=\"p\">]</span><span class=\"w\">  </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"o\">-</span><span class=\"n\">bit</span><span class=\"w\"> </span><span class=\"n\">integer</span>\n<span class=\"w\">  </span><span class=\"p\">[</span><span class=\"n\">B</span><span class=\"p\">]</span><span class=\"w\">  </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"n\">string</span>\n\n<span class=\"n\">Options</span><span class=\"p\">:</span>\n<span class=\"o\">..</span><span class=\"p\">.</span>\n\n<span class=\"cp\">$</span><span class=\"w\"> </span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"n\">cli</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"w\"> </span><span class=\"s\">\"or is it?\"</span>\n<span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">number</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">very</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"o\">?</span>\n</code></pre></div>\n<p>Lots of interesting questions around how to handle <code>arg-name: option&lt;ty&gt;</code> (turn into <code>--arg-name</code>?), more complex input types (e.g. accept file names, URLs, and pipes as inputs for streams?), satisfying imports, and others, but I think this would have a lot of potential.</p>\n<h4>Benefit</h4>\n<p>This would make it very easy to create simple CLI tools as components. What's more, nothing about these components would be specific to CLIs, necessarily. Instead, the same component could also be used as a building block for creating a web service, or as part of some data processing pipeline, etc.</p>\n<h4>Implementation</h4>\n<p>This being an idea more than a plan, I haven't dug into the implementation too much. The biggest issue I can foresee is defining good mappings from various input types (such as \"just a string\", filenames, URLs, pipes) to component types. Wasmtime would effectively have to act as a user agent, providing mappings from the shell domain into the component model domain.</p>\n<h4>Alternatives</h4>\n<p>Do nothing: this isn't some kind of urgent, mission-critical need.<br>\n</p>\n</blockquote>",
        "id": 513592643,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745323891
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637#issuecomment-2821158982\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637\">issue #10637</a>:</p>\n<blockquote>\n<p>CC @tpmccallum, since you've worked on <code>--invoke</code> support for components, and might find this interesting.</p>\n</blockquote>",
        "id": 513594959,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745324525
    },
    {
        "content": "<p>tpmccallum <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637#issuecomment-2849735118\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637\">issue #10637</a>:</p>\n<blockquote>\n<p>Thanks @tschneidereit - I do find this interesting. This is a great idea.<br>\nI will think about this and work to contribute something back in the next week or so.<br>\nChat soon.<br>\nTim</p>\n</blockquote>",
        "id": 516088862,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746410377
    },
    {
        "content": "<p>tpmccallum <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637#issuecomment-2850790042\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637\">issue #10637</a>:</p>\n<blockquote>\n<p>Hi @tschneidereit,<br>\nI was just digging into the implementation today and had the following suggestions for discussion.</p>\n<p><strong>Config</strong><br>\nPerhaps we can add <code>wit-component</code>, <code>wit-parser</code> and <code>wasm-wave</code> to the dependencies:</p>\n<div class=\"codehilite\" data-code-language=\"TOML\"><pre><span></span><code><span class=\"n\">wit-component</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"0.229.0\"</span>\n<span class=\"n\">wit-parser</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"0.229.0\"</span>\n<span class=\"n\">wasm-wave</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s2\">\"0.229.0\"</span>\n</code></pre></div>\n<p><strong>Parsing</strong><br>\nHaving <code>wit-component</code> and <code>wit-parser</code> usage at the CLI level should let us interact with types, i.e. <a href=\"https://docs.rs/wit-parser/0.229.0/wit_parser/enum.FunctionKind.html\">FunctionKind</a>, <a href=\"https://docs.rs/wit-parser/0.229.0/wit_parser/enum.WasmExportKind.html\">WasmExportKind</a>, <a href=\"https://docs.rs/wit-parser/0.229.0/wit_parser/struct.Docs.html\">description/contents String</a>, etc.</p>\n<p><strong>Generate CLI interface</strong><br>\nPerhaps this can work both ways, i.e., if I understand your idea. I think that wasmtime can load and parse <code>.wasm</code>, which will allow the user to see details (available exported functions and their arguments/types), etc. Perhaps some helper functions in the <code>src/commands/run.rs</code>, such as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">extract_wit_definitions</span><span class=\"p\">(</span><span class=\"n\">component</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"n\">Resolve</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">World</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">     </span><span class=\"c1\">// Learn about the component</span>\n<span class=\"w\">    </span><span class=\"c1\">// -- implement --</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">generate_component_cli</span><span class=\"p\">(</span><span class=\"n\">world</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">World</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">resolve</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Resolve</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">Command</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// Fabricate valid commands that the user can call</span>\n<span class=\"w\">    </span><span class=\"c1\">// -- implement --</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">parse_component_arg</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">wit_parser</span><span class=\"p\">::</span><span class=\"n\">Type</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">wasmtime</span><span class=\"p\">::</span><span class=\"n\">component</span><span class=\"p\">::</span><span class=\"n\">Val</span><span class=\"o\">&gt;</span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// Ensure that we have the component runtime values that are available</span>\n<span class=\"w\">    </span><span class=\"c1\">// --implement</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p><strong>WAVE</strong><br>\nI am not fully across <code>wasm-wave</code>. It looks like <a href=\"https://docs.rs/wasm-wave/0.229.0/wasm_wave/wasm/enum.WasmTypeKind.html\">WasmTypeKind</a>  human-readable WAVE values (for use in the CLI input/output) and <a href=\"https://docs.wasmtime.dev/api/wasmtime/component/enum.Val.html\">Wasmtime Component Val</a> (for machine use inside Rust/Wasmtime runtime) are defined enough to facilitate mappings. </p>\n<p>Perhaps using WAVE can facilitate the mappings from the shell domain into the component model domain.</p>\n<p>This is a really cool idea that you had. This is just scratching the surface to see if using these tools and this approach is in the right ballpark (and what you intended as part of the implementation). Would love to hear your thoughts. Also super happy to start working on implementing when we align our thoughts a bit more.</p>\n<p>Tim</p>\n</blockquote>",
        "id": 516178741,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746446936
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637#issuecomment-2850895379\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637\">issue #10637</a>:</p>\n<blockquote>\n<p>Hey @tpmccallum, I'm really happy you like the idea! And thank you for digging in and thinking about it in more detail.</p>\n<blockquote>\n<p>Perhaps using WAVE can facilitate the mappings from the shell domain into the component model domain.</p>\n</blockquote>\n<p>That is absolutely what I had in mind, yes. I don't think we should necessarily use WAVE exactly as-is and without any additions, but it's a great basis. Additions are certainly needed for things like interpreting different things (such as pipes, paths, and URLs) as input or output streams, and probably more.</p>\n<blockquote>\n<p>Perhaps we can add <code>wit-component</code>, <code>wit-parser</code> and <code>wasm-wave</code> to the dependencies:</p>\n</blockquote>\n<p>These are all already either direct or indirect dependencies for <code>wasmtime</code>, so nothing needs to be added there :)</p>\n<blockquote>\n<p>I think that wasmtime can load and parse <code>.wasm</code>, which will allow the user to see details (available exported functions and their arguments/types), etc. Perhaps some helper functions in the <code>src/commands/run.rs</code>, such as:</p>\n</blockquote>\n<p>I'm not sure if you're proposing the expose these functions and have developers have to explicitly call them to interact with components via the CLI? In any case, my thinking is that all of this should happen under the hood and automatically, without the developer needing to do anything.</p>\n</blockquote>",
        "id": 516187404,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746449458
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637#issuecomment-2850900422\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637\">issue #10637</a>:</p>\n<blockquote>\n<p>One general comment: if we want to pursue this, we should absolutely have an <a href=\"https://github.com/bytecodealliance/rfcs/\">RFC</a> for it: this is big enough and has a sufficiently open design space that we should get alignment on it before potentially wasting a lot of effort on an implementation that people would later disagree with.</p>\n<p>That doesn't preclude experimentation, of course, but I do think it should come before trying to get anything into a shippable state.</p>\n</blockquote>",
        "id": 516187767,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746449570
    },
    {
        "content": "<p>tpmccallum <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637#issuecomment-2854195693\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637\">issue #10637</a>:</p>\n<blockquote>\n<p>Hi @tschneidereit,</p>\n<p>That all makes sense. Thanks!</p>\n<p>I agree that all of this should happen under the hood automatically. I am just experimenting locally, whereby the <code>src/commands/run.rs</code> intercepts the <code>wasmtime</code> command <strong>only</strong> when:</p>\n<ul>\n<li>a <code>.wasm</code> file is passed in, <strong>and</strong> </li>\n<li>when the <code>help</code> subcommand (<code>--help</code>/ -h) is present. </li>\n</ul>\n<p>The experimental code calls those niche helper functions only when the above conditions are met. It is important to note that the experimental changes only affect passive interactions (parsing/printing), and actual execution/invocation behaviour is not altered (from the current <code>wasmtime run</code> behaviour) in any way.</p>\n<p>Agree that an RFC is a great path forward. If my messages are on point with your idea, I would be very happy to create a draft RFC tomorrow as a PR to the <code>rfcs</code> repository. Appreciate you are busy and this would be my pleasure.</p>\n<hr>\n<p>Over and above this passive parsing/printing, I think your idea has deeper and more powerful potential. I am trying to get my head around the implications of this automatic parsing/learning and how the idea provides transparency to a level where the coupling is as loose as can be.  For example, with this new way of thinking (about the component as a well-defined shared contract), frameworks (like Spin, which executes logic based on triggers, etc.) can now dynamically adapt their behaviour to the component's capabilities on the fly (rather than using explicit hardcoded names and/or custom glue). I would like to still keep thinking about this; very interesting. I digress ...</p>\n<p>Am I correct in saying that while there might be more to this idea, the RFC may perhaps just cater for the <code>wasmtime cli.wasm --help</code> and <code>wasmtime cli.wasm foo --help</code> examples. Or do you think we could/should tackle this additional potential in the same RFC?</p>\n</blockquote>",
        "id": 516416487,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746530336
    },
    {
        "content": "<p>tpmccallum edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637#issuecomment-2854195693\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10637\">issue #10637</a>:</p>\n<blockquote>\n<p>Hi @tschneidereit,</p>\n<p>That all makes sense. Thanks!</p>\n<p>I agree that all of this should happen under the hood automatically. I am just experimenting locally, whereby the <code>src/commands/run.rs</code> intercepts the <code>wasmtime</code> command <strong>only</strong> when:</p>\n<ul>\n<li>a <code>.wasm</code> file is passed in, <strong>and</strong> </li>\n<li>when the <code>help</code> subcommand (<code>--help</code>/ <code>-h</code>) is present. </li>\n</ul>\n<p>The experimental code calls those niche helper functions only when the above conditions are met. It is important to note that the experimental changes only affect passive interactions (parsing/printing), and actual execution/invocation behaviour is not altered (from the current <code>wasmtime run</code> behaviour) in any way.</p>\n<p>Agree that an RFC is a great path forward. If my messages are on point with your idea, I would be very happy to create a draft RFC tomorrow as a PR to the <code>rfcs</code> repository. Appreciate you are busy, and this would be my pleasure.</p>\n<hr>\n<p>Over and above this passive parsing/printing, I think your idea has deeper and more powerful potential. I am trying to get my head around the implications of this automatic parsing/learning and how the idea provides transparency to a level where the coupling is as loose as can be.  For example, with this new way of thinking (about the component as a well-defined shared contract), frameworks (like Spin, which executes logic based on triggers, etc.) can now dynamically adapt their behaviour to the component's capabilities on the fly (rather than using explicit hardcoded names and/or custom glue). I would like to still keep thinking about this; very interesting. I digress ...</p>\n<p>Am I correct in saying that while there might be more to this idea, the RFC may perhaps just cater for the <code>wasmtime cli.wasm --help</code> and <code>wasmtime cli.wasm foo --help</code> examples. Or do you think we could/should tackle this additional potential in the same RFC?</p>\n</blockquote>",
        "id": 516416644,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746530378
    }
]