[
    {
        "content": "<p>github-actions[bot] opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12592\">issue #12592</a>:</p>\n<blockquote>\n<blockquote>\n<p>Integer overflow in <code>BytesMut::reserve</code></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Details</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Package</td>\n<td><code>bytes</code></td>\n</tr>\n<tr>\n<td>Version</td>\n<td><code>1.10.1</code></td>\n</tr>\n<tr>\n<td>URL</td>\n<td><a href=\"https://github.com/advisories/GHSA-434x-w66g-qw3r\">https://github.com/advisories/GHSA-434x-w66g-qw3r</a></td>\n</tr>\n<tr>\n<td>Date</td>\n<td>2026-02-03</td>\n</tr>\n<tr>\n<td>Patched versions</td>\n<td><code>&gt;=1.11.1</code></td>\n</tr>\n<tr>\n<td>Unaffected versions</td>\n<td><code>&lt;1.2.1</code></td>\n</tr>\n</tbody>\n</table>\n<p>In the unique reclaim path of <code>BytesMut::reserve</code>, the condition</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v_capacity</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">gt</span><span class=\"p\">;</span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">new_cap</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">offset</span>\n</code></pre></div>\n<p>uses an unchecked addition. When <code>new_cap + offset</code> overflows <code>usize</code> in release builds, this condition may incorrectly pass, causing <code>self.cap</code> to be set to a value that exceeds the actual allocated capacity. Subsequent APIs such as <code>spare_capacity_mut()</code> then trust this corrupted <code>cap</code> value and may create out-of-bounds slices, leading to UB.</p>\n<p>This behavior is observable in release builds (integer overflow wraps), whereas debug builds panic due to overflow checks.</p>\n<h2>PoC</h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"p\">::</span><span class=\"o\">*</span><span class=\"p\">;</span>\n\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">BytesMut</span><span class=\"p\">::</span><span class=\"n\">from</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">amp</span><span class=\"p\">;</span><span class=\"n\">b</span><span class=\"o\">&amp;</span><span class=\"n\">quot</span><span class=\"p\">;</span><span class=\"n\">hello</span><span class=\"w\"> </span><span class=\"n\">world</span><span class=\"o\">&amp;</span><span class=\"n\">quot</span><span class=\"p\">;[</span><span class=\"o\">..</span><span class=\"p\">]);</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">split_off</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Ensure b becomes the unique owner of the backing storage</span>\n<span class=\"w\">    </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Trigger overflow in new_cap + offset inside reserve</span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">reserve</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">::</span><span class=\"n\">MAX</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// This call relies on the corrupted cap and may cause UB &amp;amp; HBO</span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">put_u8</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"o\">&amp;</span><span class=\"p\">#</span><span class=\"mi\">39</span><span class=\"p\">;</span><span class=\"n\">h</span><span class=\"o\">&amp;</span><span class=\"p\">#</span><span class=\"mi\">39</span><span class=\"p\">;);</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<h1>Workarounds</h1>\n<p>Users of <code>BytesMut::reserve</code> are only affected if integer overflow checks are configured to wrap. When integer overflow is configured to panic, this issue does not apply.</p>\n<p>See <a href=\"https://rustsec.org/advisories/RUSTSEC-2026-0007.html\">advisory page</a> for additional details.<br>\n</p>\n</blockquote>",
        "id": 573846652,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771028241
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12592\">issue #12592</a>:</p>\n<blockquote>\n<blockquote>\n<p>Integer overflow in <code>BytesMut::reserve</code></p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>Details</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Package</td>\n<td><code>bytes</code></td>\n</tr>\n<tr>\n<td>Version</td>\n<td><code>1.10.1</code></td>\n</tr>\n<tr>\n<td>URL</td>\n<td><a href=\"https://github.com/advisories/GHSA-434x-w66g-qw3r\">https://github.com/advisories/GHSA-434x-w66g-qw3r</a></td>\n</tr>\n<tr>\n<td>Date</td>\n<td>2026-02-03</td>\n</tr>\n<tr>\n<td>Patched versions</td>\n<td><code>&gt;=1.11.1</code></td>\n</tr>\n<tr>\n<td>Unaffected versions</td>\n<td><code>&lt;1.2.1</code></td>\n</tr>\n</tbody>\n</table>\n<p>In the unique reclaim path of <code>BytesMut::reserve</code>, the condition</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">v_capacity</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">gt</span><span class=\"p\">;</span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">new_cap</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">offset</span>\n</code></pre></div>\n<p>uses an unchecked addition. When <code>new_cap + offset</code> overflows <code>usize</code> in release builds, this condition may incorrectly pass, causing <code>self.cap</code> to be set to a value that exceeds the actual allocated capacity. Subsequent APIs such as <code>spare_capacity_mut()</code> then trust this corrupted <code>cap</code> value and may create out-of-bounds slices, leading to UB.</p>\n<p>This behavior is observable in release builds (integer overflow wraps), whereas debug builds panic due to overflow checks.</p>\n<h2>PoC</h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"p\">::</span><span class=\"o\">*</span><span class=\"p\">;</span>\n\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">BytesMut</span><span class=\"p\">::</span><span class=\"n\">from</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">amp</span><span class=\"p\">;</span><span class=\"n\">b</span><span class=\"o\">&amp;</span><span class=\"n\">quot</span><span class=\"p\">;</span><span class=\"n\">hello</span><span class=\"w\"> </span><span class=\"n\">world</span><span class=\"o\">&amp;</span><span class=\"n\">quot</span><span class=\"p\">;[</span><span class=\"o\">..</span><span class=\"p\">]);</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">split_off</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Ensure b becomes the unique owner of the backing storage</span>\n<span class=\"w\">    </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Trigger overflow in new_cap + offset inside reserve</span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">reserve</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">::</span><span class=\"n\">MAX</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">);</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// This call relies on the corrupted cap and may cause UB &amp;amp; HBO</span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">put_u8</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"o\">&amp;</span><span class=\"p\">#</span><span class=\"mi\">39</span><span class=\"p\">;</span><span class=\"n\">h</span><span class=\"o\">&amp;</span><span class=\"p\">#</span><span class=\"mi\">39</span><span class=\"p\">;);</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<h1>Workarounds</h1>\n<p>Users of <code>BytesMut::reserve</code> are only affected if integer overflow checks are configured to wrap. When integer overflow is configured to panic, this issue does not apply.</p>\n<p>See <a href=\"https://rustsec.org/advisories/RUSTSEC-2026-0007.html\">advisory page</a> for additional details.<br>\n</p>\n</blockquote>",
        "id": 573855724,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771036189
    }
]