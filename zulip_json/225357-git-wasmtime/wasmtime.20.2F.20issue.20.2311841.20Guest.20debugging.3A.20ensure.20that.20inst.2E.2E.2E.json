[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">issue #11841</a>:</p>\n<blockquote>\n<p>(carried over from <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11769#discussion_r2412214550\">this review discussion</a> on #11769)</p>\n<p>Currently, guest-debug instrumentation stores all local/stack values in a stackslot for observability by the debugger. This works well for primitives like integers/floats/vectors, and is fine for GC refs when the GC is not moving (i.e. tracing only observes the roots read-only) because the values also exist elsewhere in the program; but will be a problem once the GC becomes a moving GC.</p>\n</blockquote>",
        "id": 544440929,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760317894
    },
    {
        "content": "<p><a href=\"https://github.com/cfallin\">cfallin</a> added the bug label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">Issue #11841</a>.</p>",
        "id": 544440930,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760317894
    },
    {
        "content": "<p><a href=\"https://github.com/cfallin\">cfallin</a> removed the bug label from <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">Issue #11841</a>.</p>",
        "id": 544440935,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760317903
    },
    {
        "content": "<p><a href=\"https://github.com/cfallin\">cfallin</a> added the wasmtime:debugging label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">Issue #11841</a>.</p>",
        "id": 544440936,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760317903
    },
    {
        "content": "<p><a href=\"https://github.com/cfallin\">cfallin</a> added the wasmtime:ref-types label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">Issue #11841</a>.</p>",
        "id": 544440943,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760317912
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841#issuecomment-3395579075\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">issue #11841</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"wasmtime:ref-types\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: wasmtime:ref-types</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 544440978,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760317956
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841#issuecomment-3395581142\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">issue #11841</a>:</p>\n<blockquote>\n<p>Now that I write this out, I think actually we need to root GC refs properly in the instrumentation slot; DCE could otherwise remove the parts of the original program that would keep the ref rooted.</p>\n</blockquote>",
        "id": 544441069,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760318070
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841#issuecomment-3398533280\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">issue #11841</a>:</p>\n<blockquote>\n<p>Semi-related to this issue: we could extend <code>ir::UserStackMapEntry</code> to have an opaque, user-defined <code>u32</code> if necessary. Right now, the only way to differentiate different entries is via their type, but if we need to have different kinds of stack map entries that happen to have the same <code>ir::Type</code>, we could use this hypothetical <code>u32</code>.</p>\n<p>But actually I think maybe all that is necessary here is to call the same underlying DFG APIs that the safepoints-insertion pass in the frontend does, so that the locals and operand stack slots that exist for the debug instrumentation have associated stack map entries recorded.</p>\n</blockquote>",
        "id": 544600969,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760378326
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841#issuecomment-3398801692\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">issue #11841</a>:</p>\n<blockquote>\n<p>Ah, so I've implemented actual rooting <a href=\"https://github.com/cfallin/wasmtime/commit/66e650522ea98758c39ea766c6a7906a1949036d\">here</a> as part of the draft PR that follows instrumentation; it ended up being simpler to use the frame tables to walk the slots than to try to conmingle the two concepts somehow in the metadata or implementation. That commit has a <code>Fixes #11841</code> that should close this once the followup happens :-)</p>\n</blockquote>",
        "id": 544611692,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760384118
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841#issuecomment-3399148128\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">issue #11841</a>:</p>\n<blockquote>\n<p>That seems like a fair amount of machinery that I think could be replaced by a call to <a href=\"https://docs.rs/cranelift-codegen/0.124.1/cranelift_codegen/ir/dfg/struct.DataFlowGraph.html#method.append_user_stack_map_entry\">https://docs.rs/cranelift-codegen/0.124.1/cranelift_codegen/ir/dfg/struct.DataFlowGraph.html#method.append_user_stack_map_entry</a> at the appropriate places and then we get to reuse the existing stack maps infrastructure? Introducing new FP-indexing and pointer arithmetic and all that seems a bit extra if it isn't actually necessary in this case.</p>\n<blockquote>\n<p>it ended up being simpler to use the frame tables to walk the slots than to try to conmingle the two concepts somehow in the metadata or implementation.</p>\n</blockquote>\n<p>I feel like I must be misunderstanding something because I feel that the approach in that commit is the one that is mixing up two concepts: the GC's stack walking now needs to query and interpret two sources of truth (stack map metadata and debug info metadata) to find live GC references on the stack. On the flipside, I would expect that by adding stack map entries for the stack slot offsets that contain live GC refs, we keep one source of truth for stack tracing, and we do not conflate debug info and stack maps. The debugger uses debug info, the GC uses stack maps.</p>\n</blockquote>",
        "id": 544624176,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760391676
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841#issuecomment-3399244193\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">issue #11841</a>:</p>\n<blockquote>\n<p>Ah, it appears that I had misremembered how stackmaps worked -- I had been imagining there was a separate stackslot and I'd have to add some new kind of entry to refer to my stackslot; but indeed not the case, I can refer to any stackslot+offset. I'll update it -- thanks!</p>\n</blockquote>",
        "id": 544629483,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760394408
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">issue #11841</a>:</p>\n<blockquote>\n<p>(carried over from <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11769#discussion_r2412214550\">this review discussion</a> on #11769)</p>\n<p>Currently, guest-debug instrumentation stores all local/stack values in a stackslot for observability by the debugger. This works well for primitives like integers/floats/vectors, and is fine for GC refs when the GC is not moving (i.e. tracing only observes the roots read-only) because the values also exist elsewhere in the program; but will be a problem once the GC becomes a moving GC.</p>\n</blockquote>",
        "id": 544875141,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760503304
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841#issuecomment-3404500131\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11841\">issue #11841</a>:</p>\n<blockquote>\n<p>This was closed in #11769.</p>\n</blockquote>",
        "id": 544875142,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760503304
    }
]