[
    {
        "content": "<p>Timmmm opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10218\">issue #10218</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>It would be nice if <a href=\"https://docs.rs/wasmtime/latest/wasmtime/component/struct.Component.html\"><code>Component</code></a> could provide access to custom sections (see <a href=\"https://developer.mozilla.org/en-US/docs/WebAssembly/Reference/JavaScript_interface/Module/customSections_static\">the Javascript API</a>).</p>\n<h4>Benefit</h4>\n<p>Allows you to access custom sections. For me specifically, I'm writing a better version of pre-commit using WASI and I'm planning to store metadata about how to run the linter in a custom section.</p>\n<h4>Implementation</h4>\n<p>I think <code>wasmtime</code> uses <code>wasmparser</code> which can already parse these, so it just needs to be exposed somehow. I think the biggest question is where the data is stored. I assume <code>Component</code> discards all the data it has read after compilation, and it doesn't know in advance whether you want to keep the custom sections or not... I dunno I'm not familiar enough with the implementation to say more.</p>\n<h4>Alternatives</h4>\n<p>My current solution is to use <code>wasmparser</code> to parse the file a second time, but it would be nice to not have to do this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">read_metadata</span><span class=\"p\">(</span><span class=\"n\">wasm_path</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Path</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">MyMetadata</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">fs</span><span class=\"p\">::</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">wasm_path</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// TODO: Don't read all into memory... but it's probably fine and</span>\n<span class=\"w\">    </span><span class=\"c1\">// wasmparser doesn't provide a handy parse_reader() method.</span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">parser</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">payload</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">parser</span><span class=\"p\">.</span><span class=\"n\">parse_all</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">payload</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">Payload</span><span class=\"p\">::</span><span class=\"n\">CustomSection</span><span class=\"p\">(</span><span class=\"n\">section</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">section</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"my_metadata\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">serde_json</span><span class=\"p\">::</span><span class=\"n\">from_slice</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">MyMetadata</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">section</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">())</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"p\">}</span>\n<span class=\"w\">            </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"n\">bail</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"No metadata section found in the wasm file\"</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 498969469,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739267876
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10218#issuecomment-2651252297\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10218\">issue #10218</a>:</p>\n<blockquote>\n<p>I think this is reasonable to have in Wasmtime, yeah, although personally I'd hope that we could get away with a signature such as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">custom_sections</span><span class=\"p\">(</span><span class=\"n\">module</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>(or something like that)</p>\n<p>Ideally we wouldn't need to preserve all custom sections in the compiled artifact just to support an optional API, but we could also provide methods to optionally include them for example through <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.CodeBuilder.html\"><code>CodeBuilder</code></a>. </p>\n<p>Components are an interesting case here because components themselves have custom sections as well as the modules internally. That means that the custom section you could be searching for could be anywhere within a component and returning where exactly in the component a custom section was found is an interesting API design question. </p>\n<p>Overall I'm kind of on the fence about this. On one hand it's not too too hard to add a dependency on <code>wasmparser</code> (you can even <a href=\"https://github.com/bytecodealliance/wasmtime/blob/6eb3155e23e47e087bef5fada84746197cb2fff7/crates/wasmtime/Cargo.toml#L342-L356\">pick it up through Wasmtime</a>) but on the other hand if this is expected from engines (by proxy from JS) then it's also not too hard to support in Wasmtime. One perhaps middle-ground is to provide the api in Wasmtime but basically ignore the component-specific problem of \"where was the custom section found?\" and defer that to manual usage of <code>wasmparser</code></p>\n</blockquote>",
        "id": 499042258,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739289495
    },
    {
        "content": "<p><a href=\"https://github.com/fitzgen\">fitzgen</a> added the enhancement label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10218\">Issue #10218</a>.</p>",
        "id": 502345945,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740679264
    },
    {
        "content": "<p><a href=\"https://github.com/fitzgen\">fitzgen</a> added the wasmtime:api label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10218\">Issue #10218</a>.</p>",
        "id": 502345947,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740679264
    },
    {
        "content": "<p><a href=\"https://github.com/fitzgen\">fitzgen</a> added the wasmtime label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10218\">Issue #10218</a>.</p>",
        "id": 502345950,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1740679264
    }
]