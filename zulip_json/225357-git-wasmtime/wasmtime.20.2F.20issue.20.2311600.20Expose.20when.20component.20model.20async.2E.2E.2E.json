[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11600\">issue #11600</a>:</p>\n<blockquote>\n<p>Today <code>Func::call_concurrent</code> will resolve when the guest invokes <code>task.return</code>, but the guest can continue running. This concept, supported by the component model, should be modeled in Wasmtime's embedder API as well. For example the return value of <code>call_concurrent</code> could always return a <code>WasmTask</code> argument (or something like that) which can then be used to await with an <code>&amp;Accessor</code> just as a function could be called concurrently. This would enable the embedder to, optionally, explicitly wait on guests that would like to continue running. Additionally the embedder could learn about traps during this time frame, but no other results would come out of the guest.</p>\n</blockquote>",
        "id": 537536788,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756925829
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasmtime:api label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11600\">Issue #11600</a>.</p>",
        "id": 537536789,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756925829
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasm-proposal:component-model-async label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11600\">Issue #11600</a>.</p>",
        "id": 537536791,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756925829
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11600#issuecomment-3268266260\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11600\">issue #11600</a>:</p>\n<blockquote>\n<p>This makes a lot of sense! As an embedder I would expect to be able to acquire a construct similar to <a href=\"https://docs.rs/tokio/latest/tokio/task/struct.JoinSet.html\">https://docs.rs/tokio/latest/tokio/task/struct.JoinSet.html</a></p>\n</blockquote>",
        "id": 538325124,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757371457
    },
    {
        "content": "<p>alexcrichton assigned dicej to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11600\">issue #11600</a>.</p>",
        "id": 538469290,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757432727
    },
    {
        "content": "<p>dicej closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11600\">issue #11600</a>:</p>\n<blockquote>\n<p>Today <code>Func::call_concurrent</code> will resolve when the guest invokes <code>task.return</code>, but the guest can continue running. This concept, supported by the component model, should be modeled in Wasmtime's embedder API as well. For example the return value of <code>call_concurrent</code> could always return a <code>WasmTask</code> argument (or something like that) which can then be used to await with an <code>&amp;Accessor</code> just as a function could be called concurrently. This would enable the embedder to, optionally, explicitly wait on guests that would like to continue running. Additionally the embedder could learn about traps during this time frame, but no other results would come out of the guest.</p>\n</blockquote>",
        "id": 538736477,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757537385
    }
]