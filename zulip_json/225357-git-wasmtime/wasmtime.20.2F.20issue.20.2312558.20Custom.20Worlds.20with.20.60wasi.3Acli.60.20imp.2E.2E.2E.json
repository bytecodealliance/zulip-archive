[
    {
        "content": "<p>luoluoyuyu opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12558\">issue #12558</a>:</p>\n<blockquote>\n<h2>Description</h2>\n<p>I am building a plugin system where the Guest components are compiled using <strong>TinyGo</strong>. Since TinyGo's runtime initialization relies heavily on WASI P2, my custom world <strong>must</strong> include <code>include wasi:cli/imports@0.2.0;</code>. Otherwise, the TinyGo component fails to initialize.</p>\n<p>However, the current developer experience for this specific (and very common) use case is quite painful. Even with the <code>with</code> mapping in the <code>bindgen!</code> macro and implementing <code>WasiView</code> for my <code>HostState</code>, I am still forced to manually implement all the generated traits for <code>wasi:*</code> interfaces just to \"delegate\" them back to the <code>wasmtime-wasi</code> implementation.</p>\n<h2>The Problem</h2>\n<p>If I have a minimalist WIT like this:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>package test:pkg@0.1.0;\n\ninterface data {\n    resource store {\n        constructor(name: string);\n    }\n}\n\nworld processor {\n    // Required for TinyGo support\n    include wasi:cli/imports@0.2.0;\n\n    import data;\n    export process: func(data: list&lt;u8&gt;) -&gt; result&lt;_, string&gt;;\n}\n</code></pre></div>\n<p>Even though <code>wasmtime-wasi</code> already provides a complete implementation for every WASI interface included above, I find myself writing dozens of lines of repetitive boilerplate just to bridge the gap in Rust:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// This feels like unnecessary boilerplate</span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"p\">::</span><span class=\"n\">pkg</span><span class=\"p\">::</span><span class=\"n\">processor</span><span class=\"p\">::</span><span class=\"n\">wasi</span><span class=\"p\">::</span><span class=\"n\">cli</span><span class=\"p\">::</span><span class=\"n\">stdout</span><span class=\"p\">::</span><span class=\"n\">Host</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyHost</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">get_stdout</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Resource</span><span class=\"o\">&lt;</span><span class=\"n\">OutputStream</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// I have to manually call the provided implementation</span>\n<span class=\"w\">        </span><span class=\"n\">wasmtime_wasi</span><span class=\"p\">::</span><span class=\"n\">bindings</span><span class=\"p\">::</span><span class=\"n\">cli</span><span class=\"p\">::</span><span class=\"n\">stdout</span><span class=\"p\">::</span><span class=\"n\">Host</span><span class=\"p\">::</span><span class=\"n\">get_stdout</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// ... and so on for every other WASI interface TinyGo needs (clocks, streams, etc.)</span>\n</code></pre></div>\n<p>Is there a more \"automated\" way to handle this? That is, when the Host has already provided WasiCtx and ResourceTable, bindgen! or Linker should be able to automatically identify and fulfill the requirements of these standard WASI imports without the developer having to write a large amount of repetitive boilerplate code.</p>\n</blockquote>",
        "id": 573121096,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770748765
    },
    {
        "content": "<p>luoluoyuyu edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12558\">issue #12558</a>:</p>\n<blockquote>\n<h2>Description</h2>\n<p>I am building a plugin system where the Guest components are compiled using <strong>TinyGo</strong>. Since TinyGo's runtime initialization relies heavily on WASI P2, my custom world <strong>must</strong> include <code>include wasi:cli/imports@0.2.0;</code>. Otherwise, the TinyGo component fails to initialize.</p>\n<p>However, the current developer experience for this specific (and very common) use case is quite painful. Even with the <code>with</code> mapping in the <code>bindgen!</code> macro and implementing <code>WasiView</code> for my <code>HostState</code>, I am still forced to manually implement all the generated traits for <code>wasi:*</code> interfaces just to \"delegate\" them back to the <code>wasmtime-wasi</code> implementation.</p>\n<h2>The Problem</h2>\n<p>If I have a WIT like this:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>package test:pkg@0.1.0;\n\ninterface data {\n    resource store {\n        constructor(name: string);\n    }\n}\n\nworld processor {\n    // Required for TinyGo support\n    include wasi:cli/imports@0.2.0;\n\n    import data;\n    export process: func(data: list&lt;u8&gt;) -&gt; result&lt;_, string&gt;;\n}\n</code></pre></div>\n<p>Even though <code>wasmtime-wasi</code> already provides a complete implementation for every WASI interface included above, I find myself writing dozens of lines of repetitive boilerplate just to bridge the gap in Rust:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// This feels like unnecessary boilerplate</span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"p\">::</span><span class=\"n\">pkg</span><span class=\"p\">::</span><span class=\"n\">processor</span><span class=\"p\">::</span><span class=\"n\">wasi</span><span class=\"p\">::</span><span class=\"n\">cli</span><span class=\"p\">::</span><span class=\"n\">stdout</span><span class=\"p\">::</span><span class=\"n\">Host</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyHost</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">get_stdout</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Resource</span><span class=\"o\">&lt;</span><span class=\"n\">OutputStream</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// I have to manually call the provided implementation</span>\n<span class=\"w\">        </span><span class=\"n\">wasmtime_wasi</span><span class=\"p\">::</span><span class=\"n\">bindings</span><span class=\"p\">::</span><span class=\"n\">cli</span><span class=\"p\">::</span><span class=\"n\">stdout</span><span class=\"p\">::</span><span class=\"n\">Host</span><span class=\"p\">::</span><span class=\"n\">get_stdout</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// ... and so on for every other WASI interface TinyGo needs (clocks, streams, etc.)</span>\n</code></pre></div>\n<p>Is there a more \"automated\" way to handle this? That is, when the Host has already provided WasiCtx and ResourceTable, bindgen! or Linker should be able to automatically identify and fulfill the requirements of these standard WASI imports without the developer having to write a large amount of repetitive boilerplate code.</p>\n</blockquote>",
        "id": 573121263,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770748818
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12558#issuecomment-3880760496\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12558\">issue #12558</a>:</p>\n<blockquote>\n<p>What I'd recommend here is to have a <code>world</code> that focuses on just your embedding, for example the <code>data</code> interface import and the <code>process</code> export. Wasmtime bindings would be generated using that <code>world</code>, and then there'd be a second world which <code>include</code>s this world and also has the WASI imports. This second world would be used for guest bindings generation, for example.</p>\n<p>This is also something we could improve in Wasmtime by souping up the <code>with</code> option, but that can get a bit gnarly sometimes. Would the <code>world</code> split work for your use case?</p>\n</blockquote>",
        "id": 573151690,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770758206
    },
    {
        "content": "<p>luoluoyuyu <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12558#issuecomment-3885350298\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12558\">issue #12558</a>:</p>\n<blockquote>\n<blockquote>\n<p>What I'd recommend here is to have a <code>world</code> that focuses on just your embedding, for example the <code>data</code> interface import and the <code>process</code> export. Wasmtime bindings would be generated using that <code>world</code>, and then there'd be a second world which <code>include</code>s this world and also has the WASI imports. This second world would be used for guest bindings generation, for example.</p>\n<p>This is also something we could improve in Wasmtime by souping up the <code>with</code> option, but that can get a bit gnarly sometimes. Would the <code>world</code> split work for your use case?</p>\n</blockquote>\n<p>Thank you for your answer, this solution can solve my problem very well.</p>\n</blockquote>",
        "id": 573324280,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770825338
    },
    {
        "content": "<p>luoluoyuyu closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12558\">issue #12558</a>:</p>\n<blockquote>\n<h2>Description</h2>\n<p>I am building a plugin system where the Guest components are compiled using <strong>TinyGo</strong>. Since TinyGo's runtime initialization relies heavily on WASI P2, my custom world <strong>must</strong> include <code>include wasi:cli/imports@0.2.0;</code>. Otherwise, the TinyGo component fails to initialize.</p>\n<p>However, the current developer experience for this specific (and very common) use case is quite painful. Even with the <code>with</code> mapping in the <code>bindgen!</code> macro and implementing <code>WasiView</code> for my <code>HostState</code>, I am still forced to manually implement all the generated traits for <code>wasi:*</code> interfaces just to \"delegate\" them back to the <code>wasmtime-wasi</code> implementation.</p>\n<h2>The Problem</h2>\n<p>If I have a WIT like this:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>package test:pkg@0.1.0;\n\ninterface data {\n    resource store {\n        constructor(name: string);\n    }\n}\n\nworld processor {\n    // Required for TinyGo support\n    include wasi:cli/imports@0.2.0;\n\n    import data;\n    export process: func(data: list&lt;u8&gt;) -&gt; result&lt;_, string&gt;;\n}\n</code></pre></div>\n<p>Even though <code>wasmtime-wasi</code> already provides a complete implementation for every WASI interface included above, I find myself writing dozens of lines of repetitive boilerplate just to bridge the gap in Rust:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// This feels like unnecessary boilerplate</span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"p\">::</span><span class=\"n\">pkg</span><span class=\"p\">::</span><span class=\"n\">processor</span><span class=\"p\">::</span><span class=\"n\">wasi</span><span class=\"p\">::</span><span class=\"n\">cli</span><span class=\"p\">::</span><span class=\"n\">stdout</span><span class=\"p\">::</span><span class=\"n\">Host</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyHost</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">get_stdout</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Resource</span><span class=\"o\">&lt;</span><span class=\"n\">OutputStream</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// I have to manually call the provided implementation</span>\n<span class=\"w\">        </span><span class=\"n\">wasmtime_wasi</span><span class=\"p\">::</span><span class=\"n\">bindings</span><span class=\"p\">::</span><span class=\"n\">cli</span><span class=\"p\">::</span><span class=\"n\">stdout</span><span class=\"p\">::</span><span class=\"n\">Host</span><span class=\"p\">::</span><span class=\"n\">get_stdout</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// ... and so on for every other WASI interface TinyGo needs (clocks, streams, etc.)</span>\n</code></pre></div>\n<p>Is there a more \"automated\" way to handle this? That is, when the Host has already provided WasiCtx and ResourceTable, bindgen! or Linker should be able to automatically identify and fulfill the requirements of these standard WASI imports without the developer having to write a large amount of repetitive boilerplate code.</p>\n</blockquote>",
        "id": 573324287,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770825340
    }
]