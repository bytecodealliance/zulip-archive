[
    {
        "content": "<p>tage64 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12502\">issue #12502</a>:</p>\n<blockquote>\n<p>I am ahead-of-time compiling wasm for RISC-V64 using Cranelift. The generated assembler performs a 64-bit load on a 4 B (not 8 B) aligned address. This is not allowed by the RISC-V spec although many processors does support it anyway. However our RISC-V implementation (NOEL-V) don't support misaligned memory accesses.</p>\n<p>Would it be possible for Cranelift or Wasmtime to replace misaligned memory accesses with manual load/store/shift instructions to allow ahead-of-time compilation on these platforms as well?</p>\n<p>It runs perfectly under Pulley but is ~15x slower compared to native speed.</p>\n</blockquote>",
        "id": 571656632,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770124184
    },
    {
        "content": "<p>tage64 edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12502\">issue #12502</a>:</p>\n<blockquote>\n<p>I am ahead-of-time compiling wasm for RISC-V64 using Cranelift. The generated assembly performs a 64-bit load on a 4 B (not 8 B) aligned address. This is not allowed by the RISC-V spec although many processors does support it anyway. However our RISC-V implementation (NOEL-V) don't support misaligned memory accesses.</p>\n<p>Would it be possible for Cranelift or Wasmtime to replace misaligned memory accesses with manual load/store/shift instructions to allow ahead-of-time compilation on these platforms as well?</p>\n<p>It runs perfectly under Pulley but is ~15x slower compared to native speed.</p>\n</blockquote>",
        "id": 571663013,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770125758
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the cranelift label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12502\">Issue #12502</a>.</p>",
        "id": 571691399,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770132413
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the cranelift:area:riscv64 label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12502\">Issue #12502</a>.</p>",
        "id": 571691402,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770132413
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12502#issuecomment-3842024915\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12502\">issue #12502</a>:</p>\n<blockquote>\n<p>This is, in theory, possible, but it'd be a fair bit of implementation work to do. Loads are tagged as aligned or not in Cranelift meaning we semantically know when to generate instructions for a misaligned load, but right now there's no codegen rules, in any backend, for generating misaligned loads and shifting the result. Implementing this would probably require a new risc-v feature in Cranelift for \"supports unaligned loads\", which would encompass today's behavior, and then when that feature is disabled new rules would be added to handle the misaligned load case.</p>\n<p>I'll note though that all loads from wasm must be assumed to have an alignment at 1 and dynamically at runtime we figure out what the alignment actually was. In the face of trapping accesses should we load too far beyond the end of an address it means that generating code for misaligned loads is probably infeasible in the long-term. I believe other wasm engines sometimes handle this use case with a signal handler that catches the misaligned access, performs the \"real\" accesses in the signal handler, and then resumes the instruction. Wasmtime isn't currently architected for that and would also require some significant refactoring on the Cranelift side of things to support that sort of translation.</p>\n<p>Overall this is likely a very significant chunk of implementation work, and for the niche nature of not supporting unaligned loads it's unlikely to get resolved any time soon. I'd recommend using Pulley for now in the meantime.</p>\n</blockquote>",
        "id": 571692601,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770132691
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12502#issuecomment-3842130423\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12502\">issue #12502</a>:</p>\n<blockquote>\n<p>FWIW, our RISC-V backend was initially developed for the <code>riscv64gc-unknown-linux-gnu</code> target, and on Linux, <a href=\"https://www.kernel.org/doc/html/v6.10/arch/riscv/uabi.html#misaligned-accesses\">misaligned loads/stores are guaranteed to work</a> (the base ISA spec, as I'm sure you know, <a href=\"https://riscv.github.io/riscv-isa-manual/snapshot/unprivileged/#ldst\">leaves it up to the EEI (execution environment interface)</a>). This may not help you if you're targeting an embedded environment of some sort with a <code>no_std</code> Wasmtime build but it at least gives an idea of our history and rationale.</p>\n<p>I'll second what Alex says about the implementation burden being high to do misalignment support in userspace software. I would suspect the \"easier\" approach to actually be to explode every load/store into byte-size pieces, as that would be localized to just the instruction lowerings. That would have pretty severe performance cost, but <em>maybe</em> not as bad as using Pulley (you'd have to experiment to know for sure). I don't think we'd upstream such a patch though.</p>\n</blockquote>",
        "id": 571698800,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770133925
    },
    {
        "content": "<p>tage64 closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12502\">issue #12502</a>:</p>\n<blockquote>\n<p>I am ahead-of-time compiling wasm for RISC-V64 using Cranelift. The generated assembly performs a 64-bit load on a 4 B (not 8 B) aligned address. This is not allowed by the RISC-V spec although many processors does support it anyway. However our RISC-V implementation (NOEL-V) don't support misaligned memory accesses.</p>\n<p>Would it be possible for Cranelift or Wasmtime to replace misaligned memory accesses with manual load/store/shift instructions to allow ahead-of-time compilation on these platforms as well?</p>\n<p>It runs perfectly under Pulley but is ~15x slower compared to native speed.</p>\n</blockquote>",
        "id": 572736630,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770633439
    },
    {
        "content": "<p>tage64 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12502#issuecomment-3870886269\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12502\">issue #12502</a>:</p>\n<blockquote>\n<p>Thanks for the explonation.</p>\n</blockquote>",
        "id": 572736634,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770633440
    }
]