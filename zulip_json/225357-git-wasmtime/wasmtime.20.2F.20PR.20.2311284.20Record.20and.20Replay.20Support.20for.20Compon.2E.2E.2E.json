[
    {
        "content": "<p>arjunr2 opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a> from <code>arjunr2:main</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<h2>Brief</h2>\n<p>This PR is intended to support deterministic record and replay (RR) of Wasm components intrinsically in Wasmtime, and received an initial round of discussion in the Wasmtime bi-weekly meeting on 07/18</p>\n<h2>Motivation</h2>\n<p>RR is a very useful primitive for improving the debugging story of Wasm in Wasmtime. Bugs that are often encountered in modules during deployment, can  In particular, it provides the foundation for the following (to name a few):</p>\n<ul>\n<li>Reverse-execution (a.k.a, time-travel) debugging</li>\n<li>Offline static/dynamic analysis of modules</li>\n<li>Profiling of module/runtime components</li>\n<li>Automatic extraction of differential unit-tests for system interfaces (e.g. WASI)</li>\n<li>Interposition points for targeted fuzzing of system interfaces and/or modules</li>\n</ul>\n<h2>Scope</h2>\n<p>This initial PR provides the base primitives for recording and replay events. It supports RR at all import function boundaries and lowering rules for component types. The RR event infrastructure is intended to be easily extensible to new event types as new use-cases emerge.</p>\n<h3>Primary Goals</h3>\n<ul>\n<li>Enabling low overhead (memory, compute, and trace size) recording and high-performance replay,</li>\n<li>Full determinism during replay that can run outside the embedder context.</li>\n<li>An engine-agnostic trace recording format -- the goal is to purely capture guest-host boundary crossings (import calls and component model interactions) that can be reasonably interpreted by another component model compliant engine. </li>\n</ul>\n<h3>Non-Goals (Subject to Discussion)</h3>\n<ul>\n<li>A human readable trace format. This belong better in something like wit-bindgen, and/or as an independent tool over the low-level trace</li>\n<li>Replay support for updated versions of a recorded module -- this requires a much more coordinated effort from the producers as well to make this practically useful.</li>\n</ul>\n<h2>Initial Performance Numbers</h2>\n<p>Some initial runs on compression libraries like <code>zstd</code> show a 4-5% overhead on recording logic, excluding the disk I/O. This seems reasonable at the moment and likely doesn't need further optimization unless there are explicit use-cases. </p>\n<h2>Minor Todo</h2>\n<p>The following (minor) additions will be made in the coming days prior to potential merging:</p>\n<ul>\n<li>Encoding hashes of modules in the recorded trace for validation </li>\n<li>Generic writers/readers for <code>RecordBuffer</code> and <code>ReplayBuffer</code></li>\n</ul>\n<h2>Questions for Maintainers</h2>\n<ul>\n<li>Do we get wasip1 for free by recording/replay at this level?</li>\n<li>What's typically the most idiomatic way to serialize anyhow:Errors? </li>\n</ul>\n</blockquote>",
        "id": 529536765,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752881192
    },
    {
        "content": "<p><strong>arjunr2</strong> requested <a href=\"https://github.com/pchickey\">pchickey</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 529536766,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752881192
    },
    {
        "content": "<p><strong>arjunr2</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 529536767,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752881192
    },
    {
        "content": "<p>arjunr2 edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>:</p>\n<blockquote>\n<h2>Brief</h2>\n<p>This PR is intended to support deterministic record and replay (RR) of Wasm components intrinsically in Wasmtime, and received an initial round of discussion in the Wasmtime bi-weekly meeting on 07/17</p>\n<h2>Motivation</h2>\n<p>RR is a very useful primitive for improving the debugging story of Wasm in Wasmtime. Bugs that are often encountered in modules during deployment, can  In particular, it provides the foundation for the following (to name a few):</p>\n<ul>\n<li>Reverse-execution (a.k.a, time-travel) debugging</li>\n<li>Offline static/dynamic analysis of modules</li>\n<li>Profiling of module/runtime components</li>\n<li>Automatic extraction of differential unit-tests for system interfaces (e.g. WASI)</li>\n<li>Interposition points for targeted fuzzing of system interfaces and/or modules</li>\n</ul>\n<h2>Scope</h2>\n<p>This initial PR provides the base primitives for recording and replay events. It supports RR at all import function boundaries and lowering rules for component types. The RR event infrastructure is intended to be easily extensible to new event types as new use-cases emerge.</p>\n<h3>Primary Goals</h3>\n<ul>\n<li>Enabling low overhead (memory, compute, and trace size) recording and high-performance replay,</li>\n<li>Full determinism during replay that can run outside the embedder context.</li>\n<li>An engine-agnostic trace recording format -- the goal is to purely capture guest-host boundary crossings (import calls and component model interactions) that can be reasonably interpreted by another component model compliant engine. </li>\n</ul>\n<h3>Non-Goals (Subject to Discussion)</h3>\n<ul>\n<li>A human readable trace format. This belong better in something like wit-bindgen, and/or as an independent tool over the low-level trace</li>\n<li>Replay support for updated versions of a recorded module -- this requires a much more coordinated effort from the producers as well to make this practically useful.</li>\n</ul>\n<h2>Initial Performance Numbers</h2>\n<p>Some initial runs on compression libraries like <code>zstd</code> show a 4-5% overhead on recording logic, excluding the disk I/O. This seems reasonable at the moment and likely doesn't need further optimization unless there are explicit use-cases. </p>\n<h2>Minor Todo</h2>\n<p>The following (minor) additions will be made in the coming days prior to potential merging:</p>\n<ul>\n<li>Encoding hashes of modules in the recorded trace for validation </li>\n<li>Generic writers/readers for <code>RecordBuffer</code> and <code>ReplayBuffer</code></li>\n</ul>\n<h2>Questions for Maintainers</h2>\n<ul>\n<li>Do we get wasip1 for free by recording/replay at this level?</li>\n<li>What's typically the most idiomatic way to serialize anyhow:Errors? </li>\n</ul>\n</blockquote>",
        "id": 529537233,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752881707
    },
    {
        "content": "<p>arjunr2 edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>:</p>\n<blockquote>\n<h2>Brief</h2>\n<p>This PR is intended to support deterministic record and replay (RR) of Wasm components intrinsically in Wasmtime, and received an initial round of discussion in the Wasmtime bi-weekly meeting on 07/17</p>\n<h2>Motivation</h2>\n<p>RR is a very useful primitive for improving the debugging story of Wasm in Wasmtime. Bugs that are often encountered in modules during deployment, can  In particular, it provides the foundation for the following (to name a few):</p>\n<ul>\n<li>Reverse-execution (a.k.a, time-travel) debugging</li>\n<li>Offline static/dynamic analysis of modules</li>\n<li>Profiling of module/runtime components</li>\n<li>Automatic extraction of differential unit-tests for system interfaces (e.g. WASI)</li>\n<li>Interposition points for targeted fuzzing of system interfaces and/or modules</li>\n</ul>\n<h2>Scope</h2>\n<p>This initial PR provides the base primitives for recording and replay events. It supports RR at all import function boundaries and lowering rules for component types. The RR event infrastructure is intended to be easily extensible to new event types as new use-cases emerge.</p>\n<h3>Primary Goals</h3>\n<ul>\n<li>Enabling low overhead (memory, compute, and trace size) recording and high-performance replay,</li>\n<li>Full determinism during replay that can run outside the embedder context.</li>\n<li>An engine-agnostic trace recording format -- the goal is to purely capture guest-host boundary crossings (import calls and component model interactions) that can be reasonably interpreted by another component model compliant engine. </li>\n</ul>\n<h3>Non-Goals (Subject to Discussion)</h3>\n<ul>\n<li>A human readable trace format. This belong better in something like wit-bindgen, and/or as an independent tool over the low-level trace</li>\n<li>Replay support for updated versions of a recorded module -- this requires a much more coordinated effort from the producers as well to make this practically useful.</li>\n</ul>\n<h2>Initial Performance Numbers</h2>\n<p>Some initial runs on compression libraries like <code>zstd</code> show a 4-5% overhead on recording logic, excluding the disk I/O. This seems reasonable at the moment and likely doesn't need further optimization unless there are explicit use-cases. </p>\n<h2>Minor Todo</h2>\n<p>The following (minor) additions will be made in the coming days prior to potential merging:</p>\n<ul>\n<li>Encoding hashes of modules in the recorded trace for validation </li>\n<li>Generic writers/readers for <code>RecordBuffer</code> and <code>ReplayBuffer</code></li>\n<li>Feature gating all of RR</li>\n</ul>\n<h2>Questions for Maintainers</h2>\n<ul>\n<li>Do we get wasip1 for free by recording/replay at this level?</li>\n<li>What's typically the most idiomatic way to serialize anyhow:Errors? </li>\n</ul>\n</blockquote>",
        "id": 529537271,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752881753
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#issuecomment-3091405501\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>:</p>\n<blockquote>\n<h4>Label Messager: wasmtime:config</h4>\n<p>It looks like you are changing Wasmtime's configuration options. Make sure to<br>\ncomplete this check list:</p>\n<ul>\n<li>\n<p>[ ] If you added a new <code>Config</code> method, you wrote extensive documentation for<br>\n      it.</p>\n<p>&lt;details&gt;</p>\n<p>Our documentation should be of the following form:</p>\n<p>```text<br>\nShort, simple summary sentence.</p>\n<p>More details. These details can be multiple paragraphs. There should be<br>\ninformation about not just the method, but its parameters and results as<br>\nwell.</p>\n<p>Is this method fallible? If so, when can it return an error?</p>\n<p>Can this method panic? If so, when does it panic?</p>\n<h1>Example</h1>\n<p>Optional example here.<br>\n```</p>\n<p>&lt;/details&gt;</p>\n</li>\n<li>\n<p>[ ] If you added a new <code>Config</code> method, or modified an existing one, you<br>\n  ensured that this configuration is exercised by the fuzz targets.</p>\n<p>&lt;details&gt;</p>\n<p>For example, if you expose a new strategy for allocating the next instance<br>\nslot inside the pooling allocator, you should ensure that at least one of our<br>\nfuzz targets exercises that new strategy.</p>\n<p>Often, all that is required of you is to ensure that there is a knob for this<br>\nconfiguration option in [<code>wasmtime_fuzzing::Config</code>][fuzzing-config] (or one<br>\nof its nested <code>struct</code>s).</p>\n<p>Rarely, this may require authoring a new fuzz target to specifically test this<br>\nconfiguration. See [our docs on fuzzing][fuzzing-docs] for more details.</p>\n<p>&lt;/details&gt;</p>\n</li>\n<li>\n<p>[ ] If you are enabling a configuration option by default, make sure that it<br>\n  has been fuzzed for at least two weeks before turning it on by default.</p>\n</li>\n</ul>\n<p>[fuzzing-config]: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194\">https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194</a><br>\n[fuzzing-docs]: <a href=\"https://docs.wasmtime.dev/contributing-fuzzing.html\">https://docs.wasmtime.dev/contributing-fuzzing.html</a></p>\n<hr>\n<p>&lt;details&gt;</p>\n<p>To modify this label's message, edit the &lt;code&gt;.github/label-messager/wasmtime-config.md&lt;/code&gt; file.</p>\n<p>To add new label messages or remove existing label messages, edit the<br>\n&lt;code&gt;.github/label-messager.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/label-messager-action\">Learn more.</a></p>\n<p>&lt;/details&gt;</p>\n</blockquote>",
        "id": 529545052,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752891919
    },
    {
        "content": "<p>arjunr2 edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>:</p>\n<blockquote>\n<h2>Brief</h2>\n<p>This PR is intended to support deterministic record and replay (RR) of Wasm components intrinsically in Wasmtime, and received an initial round of discussion in the Wasmtime bi-weekly meeting on 07/17</p>\n<h2>Motivation</h2>\n<p>RR is a very useful primitive for improving the debugging story of Wasm in Wasmtime. Bugs that are often encountered in modules during deployment can be deterministically reproduced.  In particular, it provides the foundation for the following (to name a few):</p>\n<ul>\n<li>Reverse-execution (a.k.a, time-travel) debugging</li>\n<li>Offline static/dynamic analysis of modules</li>\n<li>Profiling of module/runtime components</li>\n<li>Automatic extraction of differential unit-tests for system interfaces (e.g. WASI)</li>\n<li>Interposition points for targeted fuzzing of system interfaces and/or modules</li>\n</ul>\n<h2>Scope</h2>\n<p>This initial PR provides the base primitives for recording and replay events. It supports RR at all import function boundaries and lowering rules for component types. The RR event infrastructure is intended to be easily extensible to new event types as new use-cases emerge.</p>\n<h3>Primary Goals</h3>\n<ul>\n<li>Enabling low overhead (memory, compute, and trace size) recording and high-performance replay,</li>\n<li>Full determinism during replay that can run outside the embedder context.</li>\n<li>An engine-agnostic trace recording format -- the goal is to purely capture guest-host boundary crossings (import calls and component model interactions) that can be reasonably interpreted by another component model compliant engine. </li>\n</ul>\n<h3>Non-Goals (Subject to Discussion)</h3>\n<ul>\n<li>A human readable trace format. This belong better in something like wit-bindgen, and/or as an independent tool over the low-level trace</li>\n<li>Replay support for updated versions of a recorded module -- this requires a much more coordinated effort from the producers as well to make this practically useful.</li>\n</ul>\n<h2>Initial Performance Numbers</h2>\n<p>Some initial runs on compression libraries like <code>zstd</code> show a 4-5% overhead on recording logic, excluding the disk I/O. This seems reasonable at the moment and likely doesn't need further optimization unless there are explicit use-cases. </p>\n<h2>Minor Todo</h2>\n<p>The following (minor) additions will be made in the coming days prior to potential merging:</p>\n<ul>\n<li>Encoding hashes of modules in the recorded trace for validation </li>\n<li>Generic writers/readers for <code>RecordBuffer</code> and <code>ReplayBuffer</code></li>\n<li>Feature gating all of RR</li>\n</ul>\n<h2>Questions for Maintainers</h2>\n<ul>\n<li>Do we get wasip1 for free by recording/replay at this level?</li>\n<li>What's typically the most idiomatic way to serialize anyhow:Errors? </li>\n</ul>\n</blockquote>",
        "id": 530226610,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753219969
    },
    {
        "content": "<p>arjunr2 edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>:</p>\n<blockquote>\n<h2>Brief</h2>\n<p>This PR is intended to support deterministic record and replay (RR) of Wasm components intrinsically in Wasmtime, and received an initial round of discussion in the Wasmtime bi-weekly meeting on 07/17</p>\n<h2>Motivation</h2>\n<p>RR is a very useful primitive for improving the debugging story of Wasm in Wasmtime. Bugs that are often encountered in modules during deployment can be deterministically reproduced.  In particular, it provides the foundation for the following (to name a few):</p>\n<ul>\n<li>Reverse-execution (a.k.a, time-travel) debugging</li>\n<li>Offline static/dynamic analysis of prior module executions</li>\n<li>Profiling of module/runtime components</li>\n<li>Automatic extraction of differential unit-tests for system interfaces (e.g. WASI)</li>\n<li>Interposition points for targeted fuzzing of system interfaces and/or modules</li>\n</ul>\n<h2>Scope</h2>\n<p>This initial PR provides the base primitives for recording and replay events. It supports RR at all import function boundaries and lowering rules for component types. The RR event infrastructure is intended to be easily extensible to new event types as new use-cases emerge.</p>\n<h3>Primary Goals</h3>\n<ul>\n<li>Enabling low overhead (memory, compute, and trace size) recording and high-performance replay,</li>\n<li>Full determinism during replay that can run outside the embedder context.</li>\n<li>An engine-agnostic trace recording format -- the goal is to purely capture guest-host boundary crossings (import calls and component model interactions) that can be reasonably interpreted by another component model compliant engine. </li>\n</ul>\n<h3>Non-Goals (Subject to Discussion)</h3>\n<ul>\n<li>A human readable trace format. This belong better in something like wit-bindgen, and/or as an independent tool over the low-level trace</li>\n<li>Replay support for updated versions of a recorded module -- this requires a much more coordinated effort from the producers as well to make this practically useful.</li>\n</ul>\n<h2>Initial Performance Numbers</h2>\n<p>Some initial runs on compression libraries like <code>zstd</code> show a 4-5% overhead on recording logic, excluding the disk I/O. This seems reasonable at the moment and likely doesn't need further optimization unless there are explicit use-cases. </p>\n<h2>Minor Todo</h2>\n<p>The following (minor) additions will be made in the coming days prior to potential merging:</p>\n<ul>\n<li>Encoding hashes of modules in the recorded trace for validation </li>\n<li>Generic writers/readers for <code>RecordBuffer</code> and <code>ReplayBuffer</code></li>\n<li>Feature gating all of RR</li>\n</ul>\n<h2>Questions for Maintainers</h2>\n<ul>\n<li>Do we get wasip1 for free by recording/replay at this level?</li>\n<li>What's typically the most idiomatic way to serialize anyhow:Errors? </li>\n</ul>\n</blockquote>",
        "id": 530226696,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753220004
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 530619861,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753380548
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 530624652,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753382359
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229659862\">PR review comment</a>:</p>\n<blockquote>\n<p>Let's put \"required for faithful record/replay execution\" as a new paragraph below this -- it's true and useful information, but it's secondary to what the option actually does.</p>\n<p>Also, does \"required\" here mean that the user is required to configure it, or is it just describing a fact about this kind of configuration (and that is magically enabled some other way)?</p>\n<p>(Sorry for writing nits here -- this becomes public documentation so we want to be very clear/unambiguous!)</p>\n</blockquote>",
        "id": 530658442,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229640694\">PR review comment</a>:</p>\n<blockquote>\n<p>If the above refactor (replay as a separate subcommand, without an option to itself record) doesn't pan out, separately we should always error if conflicting options are set here (that is, both record and replay together).</p>\n</blockquote>",
        "id": 530658443,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229687431\">PR review comment</a>:</p>\n<blockquote>\n<p>We should add more documention here: what is the macro for, how is it used, generally what does it expand to at a high level?</p>\n<p>(It seems to dispatch to either adding a new event when recording, or advancing the trace and validating against it when replaying, right?)</p>\n</blockquote>",
        "id": 530658444,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229650603\">PR review comment</a>:</p>\n<blockquote>\n<p>I definitely appreciate the detailed feature-slicing here but I wonder if it might be a bit too much to be manageable internally -- perhaps we could have just <code>rr</code> and then <code>rr-validate</code>?</p>\n<p>Also: have you measured the impact of validation checks that are always compiled in but disabled dynamically?</p>\n</blockquote>",
        "id": 530658445,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229661003\">PR review comment</a>:</p>\n<blockquote>\n<p>Rather than \"repeal\", I might say \"disable\"?</p>\n</blockquote>",
        "id": 530658446,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229693133\">PR review comment</a>:</p>\n<blockquote>\n<p>Rather than conditionalizing individual statements, generally what we try to do for this sort of thing is conditionalize on function definitions, and write alternate (often empty) ones -- this keeps the flow a bit cleaner inside bodies. So something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[cfg(feature = </span><span class=\"s\">\"rr-type-validation\"</span><span class=\"cp\">)]</span>\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">validate</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* actually do it */</span><span class=\"w\"> </span><span class=\"p\">}</span>\n\n<span class=\"cp\">#[cfg(not(feature = </span><span class=\"s\">\"rr-type-validation\"</span><span class=\"cp\">))]</span>\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">validate</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* nothing */</span><span class=\"w\"> </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>on <code>event</code>'s impl, then always write <code>if r.validate { event.validate(...); }</code> here. This also avoids the awkward unused-variable warnings you're working around with the underscores here.</p>\n</blockquote>",
        "id": 530658447,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229644673\">PR review comment</a>:</p>\n<blockquote>\n<p>I'd be curious which parts of our implementation depend on <code>std</code> -- I would suspect not too many, once we factor out the filesystem-based trace-writer? It might be nice to separate that part so we can do recording in no-std environments (e.g. embedded use-cases) too.</p>\n</blockquote>",
        "id": 530658448,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229642720\">PR review comment</a>:</p>\n<blockquote>\n<p>Does this break our no-std build? If we need std for something we should put the feature down in the feature dependencies below (<code>std = [..., \"postcard/use-std\"]</code>).</p>\n</blockquote>",
        "id": 530658449,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229710971\">PR review comment</a>:</p>\n<blockquote>\n<p>Same comment here as above re: dispatching at a higher level.</p>\n<p>In general, the sense I'm getting is that this sequence evolved out of a desire to keep the overall shape the same, and add hooks where needed. But it seems to me that there are basically three possible flows at a high level:</p>\n<ul>\n<li>Normal host call;</li>\n<li>Host call, recorded;</li>\n<li>Replay of host call.</li>\n</ul>\n<p>Could we instead write three different <code>lower_results</code> implementations depending on our mode, and dispatch once on the mode in <code>call_host</code>, to avoid the maze of fine-grained conditionals?</p>\n</blockquote>",
        "id": 530658450,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229637295\">PR review comment</a>:</p>\n<blockquote>\n<p>High-level thoughts on command-line options:</p>\n<ul>\n<li>It makes sense to me that record is a <em>general</em> option that the user should be able to set on any Wasmtime subcommand that executes WebAssembly; this includes <code>wasmtime run</code>, <code>wasmtime serve</code>, and maybe others. (Curious: have you tried it on an HTTP server component?)</li>\n<li>However, replay is a <em>specific and separate</em> thing: for example, if I am replaying an HTTP server execution, I should not be spawning an actual HTTP server on the host side. Basically, the idea of replay is that it is replacing the \"real\" host with a trace, so it should be properly seen (I think) as a separate top-level driver.</li>\n</ul>\n<p>With that in mind, what do you think about turning replay into a command, rather than an option?</p>\n</blockquote>",
        "id": 530658451,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229696575\">PR review comment</a>:</p>\n<blockquote>\n<p>The \"arrow syntax\" here is a little too clever for my tastes at least -- it's not clear what is going on when I see that in the macro use-sites. I'd prefer the macro invocations to look as much like normal function calls as possible.</p>\n</blockquote>",
        "id": 530658452,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229706756\">PR review comment</a>:</p>\n<blockquote>\n<p>Just a hunch but after reading through this logic, I wonder: would it clean up the flow somewhat if we dispatched once on <code>ReturnMode</code> at the top level, then avoided all of the separate conditionals throughout the body? As-is, it's quite difficult to follow the different paths -- it seems somewhat decoupled and overly-abstracted.</p>\n</blockquote>",
        "id": 530658453,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229662520\">PR review comment</a>:</p>\n<blockquote>\n<p><code>s/rr/record_replay/</code>? Or better, separate <code>enable_record()</code> and <code>enable_replay</code> methods, each taking the data that goes into one arm of <code>RRConfig</code>?</p>\n</blockquote>",
        "id": 530658454,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229712923\">PR review comment</a>:</p>\n<blockquote>\n<p>s/interleave/interleaved/</p>\n</blockquote>",
        "id": 530658455,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229656953\">PR review comment</a>:</p>\n<blockquote>\n<p>A thought: right now we have a <code>RecordWriter</code> that sinks trace content at the level of pre-serialized bytes (and hence we take a serializer as a dependency). Would it make sense to have a sink that instead consumes Rust-typed records, and is itself in charge of serializing them? That would let us build other sorts of interesting filtering external to Wasmtime; and would also mean that the trace reading and writing backends could be used as libraries for tooling. It would push a <code>std</code> dependence out of the core, too.</p>\n<p>We could still provide fast default serialization/deserialization methods if we wanted (<code>Record::to_bytes()</code> / <code>Record::from_bytes()</code> or similar).</p>\n</blockquote>",
        "id": 530658456,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229702454\">PR review comment</a>:</p>\n<blockquote>\n<p>And in general actually, it might be good to have an explanatory comment here about record/replay hook points and what the sequences are, and how you're using macros to generalize over all of those.</p>\n<p>Something like:</p>\n<ul>\n<li>The sorts of events that need to be recorded and/or validated (e.g. write out a call sequence and note each point in the sequence)</li>\n<li>Somehow describe strategy here: you have two main macros that are invoked at the start and end of a host-function call, and a few different kinds of wrappers to record the important values within that span.</li>\n</ul>\n</blockquote>",
        "id": 530658457,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229643721\">PR review comment</a>:</p>\n<blockquote>\n<p>Also, in general, we should make this <code>optional = true</code> and then enable the postcard dep itself when rr feature(s) are turned on below.</p>\n</blockquote>",
        "id": 530658458,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229661749\">PR review comment</a>:</p>\n<blockquote>\n<p><code>check_determinism</code> sounds like it could be enabling some option on the runtime config -- usually for bool predicates we say <code>is_*</code>, so perhaps <code>is_determinism_enforced()</code>?</p>\n</blockquote>",
        "id": 530658459,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229653483\">PR review comment</a>:</p>\n<blockquote>\n<p>Is this \"metadata\" or is \"config\" a better name for it? Ordinarily I'd expect \"metadata\" to have something to do with the actual recorded content (\"meta\" to the \"data\"), e.g., module versions or something.</p>\n</blockquote>",
        "id": 530658460,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229665814\">PR review comment</a>:</p>\n<blockquote>\n<p>I like to avoid transmute whenever possible, as it is so easy to get wrong; could we instead add a member to the union that is the size of the whole union (e.g., 128 bits) and read out the content that way? It is still unsafe (because it's a union) but is a whole lot more constrained.</p>\n<p>Alternately, if you have to use transmute, an idiom we have in a bunch of places is <code>transmute::&lt;From, To&gt;(...)</code>, i.e., explicitly write out the types so we can be sure we're casting what we think we are (and not, e.g., accidentally casting a pointer itself rather than the contents at that pointer).</p>\n</blockquote>",
        "id": 530658462,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#pullrequestreview-3053431541\">PR review</a>:</p>\n<blockquote>\n<p>Initial review -- this is looking really good overall!</p>\n<p>My main high-level thought around the heart of the record/replay (the interaction with the component hostcall logic and lifting/lowering): there are a lot of fine-grained conditionals, and it's somewhat hard to trace, even though there are only three modes (running + recording, replaying, or just running). It feels like somehow we should be able to hoist the conditionals a bit more and then have straight-line sequences for each of those modes.</p>\n<p>A few other misc thoughts:</p>\n<ul>\n<li>We'll want to make sure we either plug all soundness holes or document them for the initial landing. We already know about component builtins (and their memory effects); we should ask around to ensure we catch any others.</li>\n<li>For core-wasm recording, I suspect we'll want to validate that there are no exported memories or tables.</li>\n<li>We should validate that the module is exactly the same on replay as on record -- I know you're working on adding hashing for this.</li>\n<li>Some comments below about <code>std</code> dependence -- we should ensure the core can work, serializing into memory, in a no-std build.</li>\n<li>We'll want at least @alexcrichton to give this a review as well, maybe after we try some of the refactors mentioned here.</li>\n</ul>\n<p>Thanks again!</p>\n</blockquote>",
        "id": 530658463,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229715865\">PR review comment</a>:</p>\n<blockquote>\n<p>It seems that the <code>_if</code> part of this combinator is mainly used to conditionalize running the closure on <code>add_validation</code>. Would it make sense to instead have <code>record_event</code> and <code>record_event_validation</code> entry points, or perhaps even just wrap the relevant callsites in <code>if r.add_validation { store.record_event(...); }</code>? In general I'm wary of complex type-generic closure-taking helpers like this unless they pay their way to a significant degree.</p>\n</blockquote>",
        "id": 530658464,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229703801\">PR review comment</a>:</p>\n<blockquote>\n<p>Can we add a doc-comment here describing why we need a separate <code>Replay</code> return-mode? (Basically, the effects of the return are handled by replaying the trace instead, right?)</p>\n</blockquote>",
        "id": 530658465,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2229651921\">PR review comment</a>:</p>\n<blockquote>\n<p>style nit: we end doc-comments with periods so <code>s/module/module./</code>. Likewise for the rest of the doc-comments in this diff (I see a few instances below too).</p>\n</blockquote>",
        "id": 530658467,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753396923
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 530662379,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753399087
    },
    {
        "content": "<p><strong>arjunr2</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-default-reviewers\">wasmtime-default-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 530662380,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753399087
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 530671522,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753404488
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 530824675,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753466926
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#issuecomment-3119894527\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>:</p>\n<blockquote>\n<blockquote>\n<p>We'll want at least @alexcrichton to give this a review as well, maybe after we try some of the refactors mentioned here.</p>\n</blockquote>\n<p>Happy to help out! (and agreed I'd like to once-over at some point)</p>\n<p>How about scheduling a call when y'all are ready with the 3 of us? That'd probably be best to draw attention to any various areas and for me to ask some questoins in a high-bandwidth way before going off to review on my own.</p>\n</blockquote>",
        "id": 530826582,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753467718
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#pullrequestreview-3056510102\">PR review</a>:</p>\n<blockquote>\n<p>Super excited for this!</p>\n<p>I think we should adjust the <code>#[cfg(...)]</code> options / cargo features a little bit. Instead of having a <code>cfg</code> feature for just type validation, but always including the general record-replay code in the build, I think we should have a <code>#[cfg(feature = \"rr\")]</code> cargo feature for controlling whether we are building in the ability to do any kind of record-replay at all. (We don't want to force the smallest embedded builds of Wasmtime to include record-replay infrastructure, for example.) And then, when record-replay support was included at compile time, we can have runtime boolean knobs for whether to do type validation and divergence-checking when replaying. </p>\n<p>Finally, in order to make it so that the whole core runtime isn't littered with <code>#[cfg(feature = \"rr\")]</code>, we can do something similar to what we do with <code>#[cfg(feature = \"gc\")]</code> and the <code>wasmtime::runtime::gc</code> submodule:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// crates/wasmtime/src/runtime/rr.rs</span>\n\n<span class=\"cp\">#[cfg(feature = </span><span class=\"s\">\"rr\"</span><span class=\"cp\">)]</span>\n<span class=\"k\">mod</span><span class=\"w\"> </span><span class=\"nn\">enabled</span><span class=\"p\">;</span>\n<span class=\"cp\">#[cfg(feature = </span><span class=\"s\">\"rr\"</span><span class=\"cp\">)]</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">enabled</span><span class=\"p\">::</span><span class=\"o\">*</span><span class=\"p\">;</span>\n\n<span class=\"cp\">#[cfg(not(feature = </span><span class=\"s\">\"rr\"</span><span class=\"cp\">))]</span>\n<span class=\"k\">mod</span><span class=\"w\"> </span><span class=\"nn\">disabled</span><span class=\"p\">;</span>\n<span class=\"cp\">#[cfg(not(feature = </span><span class=\"s\">\"rr\"</span><span class=\"cp\">))]</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">disabled</span><span class=\"p\">::</span><span class=\"o\">*</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>The <code>wasmtime::runtime::rr::enabled</code> submodule would have the actual record-replay implementation, and the <code>wasmtime::runtime::rr::disabled</code> submodule would have a stubbed out version of the same public API but without constructors and with every public type being a newtype of <a href=\"https://github.com/bytecodealliance/wasmtime/blob/0f457fad63258ef3354008eb2da188cae0a63686/crates/wasmtime/src/runtime/uninhabited.rs#L5\"><code>wasmtime::runtime::uninhabited::Uninhabited</code></a>. This pattern lets the core runtime usage of record-replay APIs look the same regardless whether we actually build in the code to do record-replay.</p>\n<p>The other thing I think we need before this can land is some kind of testing or fuzzing story. At minimum, we should (1) <a href=\"https://github.com/bytecodealliance/wasmtime/blob/815c10dea9cc130316ac9b58c4aaed3e97eb8760/crates/fuzzing/src/generators/config.rs#L541-L580\">make it so that the fuzzer can turn on recording during our existing fuzzing</a>, and (2) we should have a smoke test that records some kind of Wasm program and then replays it back again and asserts that we get the same result again. As a follow up, I think we should also generalize that smoke test into a new fuzz target where we take an arbitrary Wasm module generated by the fuzzer, record its execution, and then replay that execution and assert that we get the same results (we can mostly rely on enabling the internal type validation and divergence checks for these assertions).</p>\n<p>Let me know if any of this isn't clear or if I've overlooked something.</p>\n<p>Thanks!</p>\n</blockquote>",
        "id": 530841712,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753474317
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2231832329\">PR review comment</a>:</p>\n<blockquote>\n<p>I'll go a step further than @cfallin did regarding the macros: I don't think that they are paying for themselves at all. I think we could use regular function calls and get very close to the macros in brevity, but end up with something much easier to understand for readers:</p>\n<div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>    cx.0.host_func_entry_event(storage, &amp;types[ty.params])?;\n</code></pre></div>\n<p>And if we are concerned about the overhead of indexing into <code>types</code> here even when we aren't recording, then we could pass <code>types</code> and <code>ty.params</code> as two different arguments and the method would only index when recording was enabled. (Either way, we would probably want to mark the method as <code>#[inline]</code>.)</p>\n</blockquote>",
        "id": 530841713,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753474317
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2231849224\">PR review comment</a>:</p>\n<blockquote>\n<p>Nitpick: the <code>let _ =</code> shouldn't be necessary here (you may also need to remove the semicolon at the end of the <code>match</code>).</p>\n</blockquote>",
        "id": 530841714,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753474317
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2231862345\">PR review comment</a>:</p>\n<blockquote>\n<p>This should be <code>#[expect(unused_imports, reason = \"&lt;description of why&gt;\")]</code> so that when we fix the warning, the missing warning becomes a warning itself, so that we don't forget to remove the <code>allow</code>.</p>\n<p>If it is only unused in some <code>cfg</code>s, then we want to either <code>#[cfg(...)]</code> the imports appropriately, or use <code>#[cfg_attr(expect(unused_imports, reason = \"...\"))]</code>. In some scenarios one or the other makes more sense.</p>\n</blockquote>",
        "id": 530841715,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753474317
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2231901110\">PR review comment</a>:</p>\n<blockquote>\n<p>I don't think this is sound. Instead, I think we'll want something like this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">union</span><span class=\"w\"> </span><span class=\"nc\">SerializedValRaw</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">bytes</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">ValRawBytes</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">val</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">ValRaw</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">SerializedValRaw</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">ValRaw</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// Zero-initialize `self.bytes` to ensure that there are</span>\n<span class=\"w\">        </span><span class=\"c1\">// no undefined bytes in `self` and we don't ever try to</span>\n<span class=\"w\">        </span><span class=\"c1\">// read and serialize undefined data.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ret</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: it is safe to zero-initialize `u8` arrays.</span>\n<span class=\"w\">            </span><span class=\"n\">bytes</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">mem</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n<span class=\"w\">        </span><span class=\"n\">ret</span><span class=\"p\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">;</span>\n<span class=\"w\">        </span><span class=\"n\">ret</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">get_val</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">ValRaw</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: `self` is always initialized in `new` such</span>\n<span class=\"w\">        </span><span class=\"c1\">// that there is a valid `ValRaw` inside.</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">get_bytes</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">ValRawBytes</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: We take care to ensure that `self` has no</span>\n<span class=\"w\">        </span><span class=\"c1\">// undefined bytes in the constructor, so accessing the</span>\n<span class=\"w\">        </span><span class=\"c1\">// raw bytes representation of `ValRaw` is safe.</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">bytes</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 530841716,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753474317
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2231911973\">PR review comment</a>:</p>\n<blockquote>\n<p>Do we ever want to check if <em>either</em> recording or replaying is enabled and then take some action in both cases, rather than checking for just recording and then doing some recording-specific action or just checking replaying and then doing some replaying-specific action? I might be missing something, but I am not seeing any uses of this method.</p>\n</blockquote>",
        "id": 530841717,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753474317
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2231905777\">PR review comment</a>:</p>\n<blockquote>\n<p>Alternatively, if we don't pursue what @cfallin is sketching out, then I think we can just use <code>std::io::Write</code> directly rather than defining a new <code>RecordWriter</code> trait.</p>\n</blockquote>",
        "id": 530841718,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753474317
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2231918939\">PR review comment</a>:</p>\n<blockquote>\n<p>Yeah, actually we definitely want to enable record-replay in no-std long term, so I take back my previously suggested option of using <code>std::io::Write</code> instead of <code>RecordWriter</code> and agree that we should do something a little more generic, along the lines of what Chris suggested of having a trait method for appending each kind of event to the trace.</p>\n</blockquote>",
        "id": 530841719,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753474317
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2231821909\">PR review comment</a>:</p>\n<blockquote>\n<p>+1 to what @cfallin said about replay being a command, not an option.</p>\n</blockquote>",
        "id": 530841720,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753474318
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#issuecomment-3120505068\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>:</p>\n<blockquote>\n<blockquote>\n<p>How about scheduling a call when y'all are ready with the 3 of us? That'd probably be best to draw attention to any various areas and for me to ask some questoins in a high-bandwidth way before going off to review on my own.</p>\n</blockquote>\n<p>That'd be great! FWIW, I'm on PTO next week and the week after; please feel free to talk with Arjun directly before then if you both want, or I can join after Aug 11...</p>\n</blockquote>",
        "id": 530855165,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753480980
    },
    {
        "content": "<p>arjunr2 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#issuecomment-3120751286\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>:</p>\n<blockquote>\n<p>@alexcrichton @fitzgen I'll take a pass through the comments early next week, and perhaps we can find a time later next week that works</p>\n</blockquote>",
        "id": 530867853,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753488687
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#issuecomment-3121087395\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>:</p>\n<blockquote>\n<p>Sounds good! Feel free to ping me on Zulip when ready</p>\n</blockquote>",
        "id": 530882981,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753499607
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 531452039,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753733060
    },
    {
        "content": "<p>arjunr2 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#pullrequestreview-3064486912\">PR review</a>.</p>",
        "id": 531452751,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753733357
    },
    {
        "content": "<p>arjunr2 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2237764423\">PR review comment</a>:</p>\n<blockquote>\n<p>The reason I opted for macros was to prevent unnecessary duplication across <code>call_host</code> and <code>call_host_dynamic</code>, which seemed harder to parse at initial glance, at least earlier. I can do a refactor removing them now and take a look</p>\n</blockquote>",
        "id": 531452752,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753733357
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 531460768,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753736262
    },
    {
        "content": "<p>arjunr2 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2238133178\">PR review comment</a>:</p>\n<blockquote>\n<p>Replay in practice operates very similar to the <code>run</code> command and shares a lot of the top level command line options with it as well.</p>\n<p>The replay command as a result would be just a minor super-set of the <code>run</code> setup. It sort of makes sense to do one of two things:</p>\n<ul>\n<li>Have a top-level <code>replay</code> command, that just adds additional replay options, and calls <code>run</code> under the hood with it</li>\n<li>Add replay options perhaps just for the <code>run</code> command (as opposed to general options)</li>\n</ul>\n<p>Leaning towards the former since maybe in the future <code>replay</code> could support different modes of operation</p>\n</blockquote>",
        "id": 531493225,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753753375
    },
    {
        "content": "<p>arjunr2 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#pullrequestreview-3064944041\">PR review</a>.</p>",
        "id": 531493243,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753753386
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 531500622,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753757996
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 531502882,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753759516
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2240452198\">PR review comment</a>:</p>\n<blockquote>\n<blockquote>\n<p>Replay in practice operates very similar to the <code>run</code> command and shares a lot of the top level command line options with it as well.</p>\n</blockquote>\n<p>Shouldn't all the top-level options pretty much be fixed and effectively identical to whatever they were when the trace was recorded? When does it make sense to specify different options than were used when recording? If the answer is \"it doesn't make sense\" then I don't think we want to force users to manually provide the same options from before in the replay command.</p>\n</blockquote>",
        "id": 531658974,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753808479
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#pullrequestreview-3068440297\">PR review</a>.</p>",
        "id": 531658975,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753808479
    },
    {
        "content": "<p>arjunr2 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#pullrequestreview-3068515056\">PR review</a>.</p>",
        "id": 531663470,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753809878
    },
    {
        "content": "<p>arjunr2 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2240500104\">PR review comment</a>:</p>\n<blockquote>\n<p>I guess that's true for most options. I think the ones that might be usable are perhaps just profiling</p>\n</blockquote>",
        "id": 531663471,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753809878
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#pullrequestreview-3068683674\">PR review</a>.</p>",
        "id": 531672834,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753813053
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2240614258\">PR review comment</a>:</p>\n<blockquote>\n<p>Ah yeah great point, very cool to profile an execution after the fact and ignore I/O and the external world.</p>\n<p>I think we can probably add CLI options one at a time as they make sense to the replay command, and have the default[^0] be \"whatever was configured during the recording\".</p>\n<p>[^0] I think this is implicit/automatic in that the trace will reflect whatever configuration settings were in effect during recording? At least that is true for anything that affects execution.</p>\n</blockquote>",
        "id": 531672835,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753813053
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2240614258\">PR review comment</a>.</p>",
        "id": 531672865,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753813063
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 531720798,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753834435
    },
    {
        "content": "<p>arjunr2 submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#pullrequestreview-3069596701\">PR review</a>.</p>",
        "id": 531723460,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753836122
    },
    {
        "content": "<p>arjunr2 created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284#discussion_r2241296728\">PR review comment</a>:</p>\n<blockquote>\n<p>You're right, this is now obsolete and removed.</p>\n</blockquote>",
        "id": 531723463,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753836122
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 531962984,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753926653
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 531963598,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753927049
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 532205412,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754014177
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 532970038,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754418884
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 532995717,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754431380
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 532998169,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754433065
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 533004082,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754438293
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 533006850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754440789
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 533144843,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754498980
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 533180765,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754515031
    },
    {
        "content": "<p>arjunr2 updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">PR #11284</a>.</p>",
        "id": 533180899,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754515104
    }
]