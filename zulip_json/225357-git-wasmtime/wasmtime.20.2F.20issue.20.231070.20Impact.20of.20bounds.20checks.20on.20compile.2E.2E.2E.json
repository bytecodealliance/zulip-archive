[
    {
        "content": "<p>fitzgen closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1070\">issue #1070</a>:</p>\n<blockquote>\n<p>Cranelift uses arrays and indices extensively, rather than pointer-based data structures. This allows us to use 32-bit indices rather than 64-bit pointers on 64-bit platforms, and has some other nice properties, however these indices appear to Rust as random accesses, so they get bounds checked.</p>\n<p>The following patch to disable bounds checks in <code>PrimaryMap</code> speeds up Cranelift compile times by over 8%, which is considerable:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/lib/entity/src/primary.rs b/lib/entity/src/primary.rs</span>\n<span class=\"gh\">index 6d710c2e..911223bd 100644</span>\n<span class=\"gd\">--- a/lib/entity/src/primary.rs</span>\n<span class=\"gi\">+++ b/lib/entity/src/primary.rs</span>\n<span class=\"gu\">@@ -150,7 +150,7 @@ where</span>\n<span class=\"w\"> </span>    type Output = V;\n\n<span class=\"w\"> </span>    fn index(&amp;self, k: K) -&gt; &amp;V {\n<span class=\"gd\">-        &amp;self.elems[k.index()]</span>\n<span class=\"gi\">+        unsafe { self.elems.get_unchecked(k.index()) }</span>\n<span class=\"w\"> </span>    }\n<span class=\"w\"> </span>}\n\n<span class=\"gu\">@@ -160,7 +160,7 @@ where</span>\n<span class=\"w\"> </span>    K: EntityRef,\n<span class=\"w\"> </span>{\n<span class=\"w\"> </span>    fn index_mut(&amp;mut self, k: K) -&gt; &amp;mut V {\n<span class=\"gd\">-        &amp;mut self.elems[k.index()]</span>\n<span class=\"gi\">+        unsafe { self.elems.get_unchecked_mut(k.index()) }</span>\n<span class=\"w\"> </span>    }\n<span class=\"w\"> </span>}\n</code></pre></div>\n<p>Of course, this is not completely safe.</p>\n<p>But, the common pattern of these indices in Cranelift is to use them relatively safely. We don't use this indices for iterating; we use custom index types that don't even permit arithmetic. Most <code>PrimaryMap</code> keys are produced by <code>PrimaryMap</code> itself when we push new entries:</p>\n<p>let key = my_primary_map.push(x); // returns the key of the newly pushed element</p>\n<p>These keys are in bounds from the start.</p>\n<p>Yet, there are some ways things could go wrong. Besides a few minor details which a relatively easy to fix, there are a few deep problems. Nothing outright prevents keys from living across calls to <code>clear()</code>. Similarly, nothing prevents indices from living while we exit a <code>PrimaryMap</code>'s scope and then re-enter it, creating a new <code>PrimaryMap</code>. And, while we use distinct index types to catch using an index in the wrong map, and don't tend to use more than one instance of <code>PrimaryMap</code> with the same type at a time, nothing enforces that.</p>\n<p>We don't tend to do the kinds of things which would lead to trouble. But all the same, disabling the bounds checks is not completely safe.</p>\n<p>So I don't yet know what the best thing to do here is. Should we add a cargo feature to allow users to decide whether they want the safe or unsafe version? Is there a way to do what we're doing in Rust safely without paying for bounds checks? Should we re-architect Cranelift's core data structures to some other form?</p>\n<p>cc @nnethercote </p>\n</blockquote>",
        "id": 558490306,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763659961
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1070#issuecomment-3559250289\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1070\">issue #1070</a>:</p>\n<blockquote>\n<p>This is not worth making all of Cranelift unsafe, especially since these entity refs and arenas are directly exposed to users, not just an internal detail that we can make reasoned arguments about their correctness. So I will close this issue.</p>\n<p>That said, profiling to find any hot loops that are affected by these bounds checks and figuring out targeted solutions as necessary is very welcome.</p>\n</blockquote>",
        "id": 558490308,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763659962
    }
]