[
    {
        "content": "<p>IamTheCarl opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>To be able to interrupt and save the state of executing WASM code and then resume it later, possibly on a different host machine.</p>\n<h4>Benefit</h4>\n<p>I am writing an add on for the Open Computers mod in Minecraft. The mod adds tiny computers that can be programmed by the player. One of their features is that if you quit the game, when you resume later, the state of the machine is restored just as they left it.</p>\n<p>The default Lua interpreter uses a custom implementation of Lua that can save and restore its state like this.<br>\nThere's a small hand full of emulators that just save their memory and registers and restore them later.<br>\nI don't see a clear way to do this with wasmtime.</p>\n<p>I do see potential in this being useful for a tool similar to Jupyter. You could pause a computationally intensive task and resume it later, or a cloud could serialize a job, and send it to another machine to resume in the case of a scale up/down.</p>\n<h4>Implementation</h4>\n<p>I can see that modules can be serialized already. What really needs to be saved is the state of memory and execution.<br>\nJust dumping the memory into a byte array will be enough to save the memory. Saving the state is what looks hard to me.<br>\nDumping the registers to be restored later could work for a non-portable solution but something that can be restored on another machine of possibly a different architecture would be preferred.</p>\n<p>Unfortunately I don't know enough about wasmtime's implementation to give a fantastic recommendation here.</p>\n<h4>Alternatives</h4>\n<p>This is actually my fallback plan if the feature is rejected.</p>\n<p>If you can just serialize the memory of the WASM environment (actually this may already be possible, I just haven't tried yet) you could push the job of tracking state off onto a Rust module's async state machine. You would need a function that is called regularly to resume this state machine and the module would need to frequently interrupt itself so that this function can return to the host.</p>\n<p>The advantage here is that you don't need to worry about any kind of register. Saving the state is handled by the async state machine and you can just call that one function to run the state machine to resume the guest application.</p>\n<p>The disadvantage is that this is really only practical if the web assembly is written in Rust, and the person writing this Rust code must correctly write an async application.<br>\n</p>\n</blockquote>",
        "id": 243522399,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624371165
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866028522\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<blockquote>\n<p>To be able to interrupt and save the state of executing WASM code and then resume it later, possibly on a different host machine.</p>\n</blockquote>\n<p>The on a different host machine will require pessimizing optimizations such that between every instruction all locals and the full stack is known as different backends may optimize instructions in different ways and thus require different information to at a given point continue running. This will probably a significant perf hit. Alternatively interrupting could be limited to certain safepoints, allowing a much smaller perf hit.</p>\n<blockquote>\n<p>The default Lua interpreter uses a custom implementation of Lua that can save and restore its state like this.</p>\n</blockquote>\n<p>It is much easier to implement this in an interpreter than a compiler as an interpreter needs to keep all state, while a compiler will \"forget\" about state as soon as possible to reduce register pressure and will try to fold instructions together (and thus allow forgetting about certain locals) or mangle them in different ways.</p>\n</blockquote>",
        "id": 243523945,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624371775
    },
    {
        "content": "<p>IamTheCarl <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866037344\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<blockquote>\n<p>The on a different host machine will require pessimizing optimizations such that between every instruction all locals and the full stack is known as different backends may optimize instructions in different ways and thus require different information to at a given point continue running. This will probably a significant perf hit.</p>\n</blockquote>\n<p>I was worried that would be the problem.</p>\n<blockquote>\n<p>Alternatively interrupting could be limited to certain safepoints, allowing a much smaller perf hit.</p>\n</blockquote>\n<p>I could easily trick the user into having regular safe points by requiring them to regularly check into something like a watch dog timer. How would you suggest saving the state at these safe points?</p>\n</blockquote>",
        "id": 243525568,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624372418
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866074761\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<blockquote>\n<p>How would you suggest saving the state at these safe points?</p>\n</blockquote>\n<p>That will still require changes to Cranelift to allow for saving the state and restoring at such a safe point. The changes are just easier and with less of a perf hit than allowing it at arbitrary points.</p>\n</blockquote>",
        "id": 243531954,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624375022
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866113996\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>@IamTheCarl thanks for starting this conversation -- it's a really interesting one!</p>\n<p>I'm curious what sort of state-saves are actually necessary. As @bjorn3 says, very general snapshotting at arbitrary points is expensive; if we needed to do something like that, probably the better way would be to just save the registers, heap and stack, ensure we restore into the same generated code (this has limits wrt CPU features too, as mentioned above), and take care to make the stack <em>and register file</em> \"relocatable\", in the sense that they can be fixed up for other heap-base addresses on restore. (Some thoughts on that: to do so, probably the easiest way would be to tweak codegen so that the heap base always lives in one pinned register, and any address computation uses that as part of its address expression, so we never have intermediate pointers in registers or spilled to stack. Then we just have to fix up frame pointers and return-area pointers on the stack.)</p>\n<p>But there's a potentially much easier way: could we get away with only snapshotting when no Wasm frame is on the stack? In other words, when a call into the Wasm has returned all the way out? If so, then we don't have to worry about register or stack state at all; we can just snapshot the heap and globals. We could even restore with different generated code, on a different architecture or just with different CPU features.</p>\n<p>This is sort of like what Wizer does, so that's probably the place to look for more ideas. cc @fitzgen for more thoughts!</p>\n</blockquote>",
        "id": 243538030,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624377485
    },
    {
        "content": "<p>IamTheCarl <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866167893\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>That does sound a bit like my alternative solution.</p>\n<p>The idea was to regularly call a function that would let the guest run for a short bit and then return shortly after. It would be up to the developer of the guest code to keep track of the state between calls.<br>\nThis is inconvenient for the guest developer, since they need to write an application that can run in such an environment (some global mutable variables will be needed). In Rust, using async can make this pretty intuitive, but other languages like C would require they manually build their own state machine.</p>\n<p>Of course if we're taking it that far I could then even push off the job of serialization to the guest code. Just send it some kind of event \"shutdown now or you'll be force terminated\" and that'll give them just a moment to save their state before shutdown. This one is so simple to implement that wasmtime wouldn't even need any modifications, but it is also the most inconvenient for the developer of guest code.</p>\n</blockquote>",
        "id": 243547149,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624381463
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866190506\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<blockquote>\n<p>This is sort of like what Wizer does, so that's probably the place to look for more ideas. cc @fitzgen for more thoughts!</p>\n</blockquote>\n<p>Yeah, saving state without frames on the stack is pretty easy, and as Wizer shows, you don't even need to build that functionality into the engine itself, you can do it with the standard reflection APIs that engines expose and use Wasm itself as your snapshot format. You could even factor out the code from the data (snapshot) and make it so that you don't need to recompile the code for each snapshot, just reuse the already-compiled module from before and pass in new memory/globals for its imports.</p>\n<p>Binaryen's asyncify pass can help turn synchronous code into asynchronous code. If my understanding is correct, it lifts frame activations and their local values into linear memory and does some kind of CPS-esque transformation on the code. It might make assumptions about the Web or that you're also using Emscripten; not sure, I haven't actually used it. This might be one way to transform the Wasm so that code can be written synchronously but still make snapshotting with zero activations on the stack viable.</p>\n<hr>\n<p>One final thought: snapshotting at ~gc safe points could be made possible relatively easily if we spill <em>all</em> registers at safe points. This would be a config option, because we wouldn't want to do this unconditionally. But if we only have to capture and restore stack values, that seems like a much easier problem. Hard part is addressing native pointers. I don't have any good ideas here, but I think you may have some, @cfallin.</p>\n</blockquote>",
        "id": 243551759,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624383326
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866216062\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think you may have some, @cfallin.</p>\n</blockquote>\n<p>Indeed! This is the bit about \"no intermediate pointers in registers or the stack\" alluded to above. To add a bit more detail, just to get this written down:</p>\n<ul>\n<li>We need to be a little careful in legalization: where we have loads/stores that decompose into either <code>heap_addr</code> or <code>stack_addr</code> and a native-pointer load/store, we need to at least keep the ops close in the CLIF so that they can be pattern-matched, or ideally do codegen directly on the heap/stack-level ops without decomposing them.</li>\n<li>The goal is to turn every Wasm heap access into e.g. <code>ld rA, [rBase + rB]</code> where <code>rB</code> is a 32-bit Wasm pointer, and <code>rBase</code> is a fixed register that we decide and make non-allocatable. We make this part of an internal Wasmtime ABI, and set it before calling into Wasm. (This implies a little care taken w.r.t. hostcalls too but that's manageable I think.)</li>\n<li>Similarly, every stack-slot access turns into <code>ld rA, [sp + ...]</code>; we never copy <code>sp</code> to another register and compute an address based on it.</li>\n<li>We need to tweak the internal ABI to deal with return-area pointers (for multiple return values) slightly differently. Probably we just use a fixed offset from frame at entry, rather than passing an implicit arg with the pointer.</li>\n<li>Finally, either codegen without a frame pointer, or be prepared to fix up the frame-pointer chain on relocation.</li>\n</ul>\n<p>Given those codegen changes, the code is completely \"data-relocatable\": the <em>only</em> native-address-space pointers in the register file or on the stack at any time are in <code>sp</code> and <code>rBase</code>. If we set those to different values on Wasm re-start after moving data, we should be just fine.</p>\n<p>(Caveat: return addresses; if code is relocated too, probably best to retain frame-pointer chain, rewrite return addresses as relative to module base on snapshot, and re-add the new module base on restore.)</p>\n<p>Probably a few weeks' work but would be very useful even beyond this use-case!</p>\n</blockquote>",
        "id": 243556375,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624385276
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866249666\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<blockquote>\n<p>This is the bit about \"no intermediate pointers in registers or the stack\" alluded to above.</p>\n</blockquote>\n<p>Intermediate pointers are fine if they aren't used across a safe point or if it is the vmctx. In the former case they simply wouldn't need to be stored and in the later case the vmctx value can (and should) trivially be replaced with the newly allocated vmctx when loading.</p>\n<blockquote>\n<p>We need to tweak the internal ABI to deal with return-area pointers (for multiple return values) slightly differently. Probably we just use a fixed offset from frame at entry, rather than passing an implicit arg with the pointer.</p>\n</blockquote>\n<p>If this parameter is properly annotated it can be fixed up when loading too by looking at the caller.</p>\n<blockquote>\n<p>Finally, either codegen without a frame pointer, or be prepared to fix up the frame-pointer chain on relocation.</p>\n</blockquote>\n<p>The stack doesn't need to be copied verbatim. Only the known locations of spilled values, explicit stackslots (unused by wasm) and the return value need to be copied. The later can be stored as function index + callsite index.</p>\n</blockquote>",
        "id": 243563013,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624388221
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-866250632\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<blockquote>\n<p>Probably a few weeks' work but would be very useful even beyond this use-case!</p>\n</blockquote>\n<p>Yeah, might be useful for on stack replacement for eg speculative optimization or going from an interpreter to jitted code.</p>\n</blockquote>",
        "id": 243563225,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624388312
    },
    {
        "content": "<p>IamTheCarl <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-867857009\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>I am impressed with both the quick reply and eagerness to find solutions in this team.<br>\nI'm grateful.</p>\n<p>There's a lot of terminology here I'm unfamiliar with, so I'd like to check and make sure I'm following this conversation correctly.<br>\nIt sounds like your plan at the moment is to take a non-async WASM module and transform it into an async form before it even hits the JIT. I assume this will be implemented somewhere in the IR layer. That's pretty cool.</p>\n<p>It also sounds like you're having difficulty knowing how to serialize objects on the heap? I can understand why that would be an issue since you can't depend on getting those same addresses back.</p>\n<p>So what comes next?<br>\nI'd like to help but I feel I have a lot to catch up on to make a meaningful contribution.</p>\n</blockquote>",
        "id": 243825974,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624558827
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-867865009\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>@IamTheCarl it spawned an interesting discussion and one that's timely for other potential uses too, so thank you for starting it!</p>\n<blockquote>\n<p>non-async Wasm module and transform it</p>\n</blockquote>\n<p>Yes, this is probably the \"easiest\" solution (for some definition of easy) -- as @fitzgen suggested above, the Binaryen toolchain has an asyncify transform that might help turn arbitrary Wasm into something that would work with your \"call into and execute a bit of Wasm at a time\" approach; between those calls, all you need to save is the Wasm heap and globals, not any in-progress execution state such as registers or stack. I don't know much about this tool but it looks like there's a pretty comprehensive intro blog post here: <a href=\"https://kripken.github.io/blog/wasm/2019/07/16/asyncify.html\">https://kripken.github.io/blog/wasm/2019/07/16/asyncify.html</a></p>\n<p>The next step after that is to modify Wasmtime itself so that it generates code that allows for snapshotting and restoring, including the in-progress execution state. There are various tradeoffs here involving whether we want to allow restoring on a different machine architecture (hardest), or just with identical JIT'd code (easier); and whether we want to allow arbitrary interruption and checkpoint at any point (hardest, possibly pessimizes codegen), or checkpoint only at certain points, which we're calling \"safepoints\" above, in reference to some garbage-collector terminology (a bit easier). Anything along these lines though would not be a quick short-term solution for you, so I personally would suggest looking into the asyncify option, or perhaps just defining an execution model where control always returns from your Wasm module periodically.</p>\n</blockquote>",
        "id": 243827850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1624559670
    },
    {
        "content": "<p>RobDavenport <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1046026012\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<blockquote>\n<p>But there's a potentially much easier way: could we get away with only snapshotting when no Wasm frame is on the stack? In other words, when a call into the Wasm has returned all the way out? If so, then we don't have to worry about register or stack state at all; we can just snapshot the heap and globals.</p>\n</blockquote>\n<p>Does a method to do this currently exist? I'm exploring various wasm runtimes and have been unable to find such a feature supported as of yet. If not, how difficult would it be to implement? I may be able to take a look at it as it seems to be a heavily requested feature.</p>\n</blockquote>",
        "id": 272520666,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645279791
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1046058341\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>Isn't that what <a href=\"https://github.com/bytecodealliance/wizer\">wizer</a> does?</p>\n</blockquote>",
        "id": 272528666,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645289334
    },
    {
        "content": "<p>RobDavenport <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1046253419\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>Ahh silly me - I did a google search on wizer after seeing it mentioned before and came up with a completely different result. But yes it looks like it's quite similar to what I'm looking for. While the caveats don't work for my specific use case, (specifically, not being able to call imported functions), it does provide enough of an idea of how to proceed for now.</p>\n</blockquote>",
        "id": 272596455,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645368308
    },
    {
        "content": "<p>RobDavenport edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1046253419\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>Ahh silly me - I did a google search on wizer after seeing it mentioned before and came up with a completely different unrelated result. But yes it looks like it's quite similar to what I'm looking for. While the caveats don't work for my specific use case, (specifically, not being able to call imported functions during the init function), it does provide enough of an idea of how to proceed for now.</p>\n</blockquote>",
        "id": 272596481,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645368345
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1048002291\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>Indeed, Wizer came up in the above discussion as well; the main difference in my mind (at least as far as I can remember now) was whether this would be a more generic facility, with an API to snapshot/resume at arbitrary points. Wizer currently runs a <code>wizer.initialize</code> export, and doesn't allow calls to imports (or can allow WASI, as a special case), so it's targeted toward a \"precompute some state once\" use-case. I imagine it could be extended to be more general, of course!</p>\n<p>Interestingly there was a recent PR from @koute (#3691) that did snapshotting as well. The specific use case in that PR should I think be mostly covered by our recent instantiation-time improvements. But if snapshotting in a more general sense continues to arise as a need, at the Wasmtime API level, that could merit more discussion, I suppose.</p>\n<p>@RobDavenport I'm curious about your use-case here, on a few axes: (i) do you need continued snapshot/restore (i.e. multiple roundtrips), or just one initial snapshot and then restores from that? And (ii) does it need to be programmatic at the Wasmtime API level, or is a separate tool (e.g. Wizer) usable for you?</p>\n</blockquote>",
        "id": 272831789,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645548678
    },
    {
        "content": "<p>RobDavenport <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1050157608\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>Thanks for the question @cfallin , in my case I'm writing something like a game engine and using WASM as my game-logic code. As a need to support rollback multiplayer (like GGPO which is often used in emulators), I need to consistently store the entire state of the game for the past few frames, and, if a mis-prediction is detected, rollback to a confirmed synchronized state and re-simulate the rest of the frames (often more than one!) with the new input up until the current time.</p>\n<p>I was actually able to get this working for the most part by following the suggestions in this thread, along with some things from Wizer. Iterating through the instance's exports, cloning the memories and non-const globals, and then just saving them out as a <code>Box&lt;[u8]&gt;</code> via <code>data_unchecked()</code> or as a WASM <code>Value</code> enum along with the related keys. </p>\n<p>Loading saved globals is very straightforward and doesn't need any explanation. For memories, doing a <code>copy_from_slice</code> from the snapshot back into the \"hot\" memory, using the length of the snapshot so the copy function doesn't panic. I believe the snapshot's reserved memory size should always be equal to or less than the \"hot\" memory, since the WASM's host memory can only grow for a particular instance, and since that snapshot was an actual state the VM was in at one point, the internals should have already allocated enough space for it. </p>\n<p>I'm not sure how dangerous this might be since the WASM client script may be allocating or deallocating memory, but I'm under the assumption that since it's all lumped together and already allocated inside the WASM host VM then it should just work unless the instance or store are moved somehow.</p>\n<p>So to answer your questions... (i) Yes, multiple trips will be made, however at specific times determined by the host program <em>without</em> any call frames on the stack. These will always be going back in time, though, and then re-simulating and rewriting old snapshots as we progress. (ii) Actually I have no preference, as I was able to do it for my use case mentioned above. The reason I couldn't use Wizer in my case was I needed to allow the WASM code to make callbacks into the host for things like input handling or draw requests.</p>\n<p>However, I believe the original requester for this specifically wanted a way to be able to save/resume the WASM state on a fresh application or even potentially another machine. Unfortunately I'm not too familiar with how the internals work so I can't comment on the safety or feasibility of that, as my quick hack is only intended to work with a single module instance, on the same machine, during the same application lifetime.</p>\n</blockquote>",
        "id": 273132757,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1645728688
    },
    {
        "content": "<p>IamTheCarl <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1428765859\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>I'm curious if much work has been done on this.<br>\nI have another toy project idea where a feature like this could be useful.</p>\n<p>I saw that there now appears to be an async interface for wasmtime which I imagine would be useful for a feature like this.</p>\n</blockquote>",
        "id": 327656020,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676326456
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-1428800616\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>Not much has changed regarding the fundamentals here since the last comments; Wizer is still the state-of-the-art, and unfortunately we don't have anything built into Wasmtime itself for snapshotting.</p>\n</blockquote>",
        "id": 327659719,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1676328068
    },
    {
        "content": "<p>ZheniaZuser <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-2035169885\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>How hard it would be to make WASI WebGPU and File system to work well with this (properly resume from saved state)?</p>\n<p>This may be useful for workaround for Android's background app killing: An Android app that is made of wasm runtime and the wasm file that has most of the actual app's code. As soon as it goes to background, it would pause execution of the wasm (and its linked wasm-plugins, if any), and snapshot the state as soon as it goes to background, and then restore when user returns to the app.</p>\n</blockquote>",
        "id": 431141348,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712164901
    },
    {
        "content": "<p>ZheniaZuser edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-2035169885\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>How hard it would be to make WASI WebGPU and File system (assuming the FS will never be changed by any other process) to work well with this (properly resume from saved state)?</p>\n<p>This may be useful for workaround for Android's background app killing: An Android app that is made of wasm runtime and the wasm file that has most of the actual app's code. As soon as it goes to background, it would pause execution of the wasm (and its linked wasm-plugins, if any), and snapshot the state as soon as it goes to background, and then restore when user returns to the app.</p>\n</blockquote>",
        "id": 431141846,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712165108
    },
    {
        "content": "<p>ZheniaZuser edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-2035169885\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>How hard it would be to make WASI WebGPU and File system (assuming the FS will never be changed by any other process) to work well with this (properly resume from saved state)?</p>\n<p>This sounds like it may be useful for workaround for Android's background app killing: An Android app that is made of wasm runtime and the wasm file that has most of the actual app's code. As soon as it goes to background, it would pause execution of the wasm (and its linked wasm-plugins, if any), and snapshot the state as soon as it goes to background, and then restore when user returns to the app.</p>\n</blockquote>",
        "id": 431141897,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1712165136
    },
    {
        "content": "<p>nolag <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-2631503779\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>Would this be achievable if we limited it to a single host? My use case is to allow functionality similar to the <code>fork</code> command.  I provide an SDK that will make one of two calls based on the value returned from the host.  I then return the two different values to two executions.</p>\n<p>Right now, the potential workaround is to snapshot all values returned by all host calls, then create a new instance of the WASM, returning each of the snapshot values to it. I then return the first value to the original WASM and the second value to the new WASM. This works well when no long computation is done from within the WASM before the fork but is too timely when the WASM does long computations before the fork.</p>\n</blockquote>",
        "id": 497483376,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1738600521
    },
    {
        "content": "<p>SebastienGllmt <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-3651982279\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>Some thoughts on this in relation to recent work:</p>\n<ul>\n<li>with the new <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10177\">stack-switching</a> support, it's easier to define concrete points where you may want to serialize state and resume later (this is what you can do with Lua as was mentioned in the original issue, as Lua also supports coroutines). This is more efficient than trying to make state serializable between _any_ two opcodes (instead, just make it serializable at points that yield execution to the host)</li>\n<li>wasi p3 also introduced <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Concurrency.md\">concurrency</a> support including the ability to model coroutines (doesn't depend on the stack-switching proposal). Again, this can help define natural serialization point</li>\n<li>as an alternative to saving, there is now a standard <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11284\">replay format</a>, so instead of saving the state you can instead save a trace and the replay it on a different machine (of course, only efficient if your trace is not too long)</li>\n</ul>\n</blockquote>",
        "id": 563709371,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765742867
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-3652139324\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>I don't think that stack-switching or component-model async concurrency meaningfully change anything here. The core issues are still (i) serializing on-stack Wasm frames, and (ii) serializing external state, e.g. open files or other resources implemented via hostcalls.</p>\n<p>Stack-switching reifies a continuation as a thing to which one can hold a reference, but the stack is still a native stack with native pointers and frame layouts intricately tied to one set of modules in one compiled version of the code in one runtime process with specific addresses. Having a reference to all of that at the Wasm semantic level doesn't make the task of serialization easier. Similarly for first-class tasks with the async canonical ABI.</p>\n<p>I do have ideas around <em>in-process</em> snapshots that we can build on top of Arjun's record/replay work; the idea is that we would be restricted to the lifetime of one <code>Store</code>, so live pointers captured in a copy of the stack remain valid, then we can memcpy the stack contents and register state at will. But that also requires tying that snapshot to a point in a replay trace and rewinding to that point. We're likely to do this eventually to support reversible debugging. I don't think it addresses the specific requirement outlined above though, which is to support this while interacting with the outside world; because otherwise we would need an extension to the hostcall interface to somehow allow the runtime to communicate to a host resource implementation that state must be rewound.</p>\n</blockquote>",
        "id": 563712257,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765746511
    },
    {
        "content": "<p>SebastienGllmt <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-3652360824\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't think that stack-switching or component-model async concurrency meaningfully change anything here</p>\n</blockquote>\n<p>They help avoid serializing state at a bad time (where the definition of \"bad\" depends on the specific program). Instead of serializing at a random program counter your program happens to be at and hoping the program is resumable properly from there (which often requires not just the guest program to be in a specific state, but also the host and external resources), it gives developers an easier way to serialize at specific yield points they know are safe</p>\n<p>It's not that you can't define points where you think it's safe for your program to be serialized without coroutines. It's also not that coroutines magically give you a state that is easily serializable. It's just a convenient way to do it (which is why Lua coroutines are convenient for this)</p>\n</blockquote>",
        "id": 563717642,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765753832
    },
    {
        "content": "<p>SebastienGllmt edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-3652360824\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<blockquote>\n<p>I don't think that stack-switching or component-model async concurrency meaningfully change anything here</p>\n</blockquote>\n<p>They help avoid serializing state at a bad time (where the definition of \"bad\" depends on the specific program). Instead of serializing at a random program counter your program happens to be at and hoping the program is resumable properly from there (which often requires not just the guest program to be in a specific state, but also the host and external resources), it gives developers an easier way to serialize at specific yield points they know are safe</p>\n<p>It's not that you can't define points where you think it's safe for your program to be serialized without coroutines. It's also not that coroutines magically give you a state that is easily serializable. It's just a convenient interface to help doing it (which is why Lua coroutines are convenient for this)</p>\n</blockquote>",
        "id": 563718568,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765755149
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017#issuecomment-3652397918\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">issue #3017</a>:</p>\n<blockquote>\n<p>This issue is mainly discussing the difficulties in serializing host state. It sounds like you're implying that via the use of stack-switching, one could (somehow) rearchitect the interactions between guest and host so that there would be no active resources. Is that right? It's not clear to me how that would work.</p>\n<p>Also, as I mentioned above, any live stack at all poses a challenge. From a Wasm virtual machine semantic perspective, one <em>can</em> implement continuation suspend by reading out the native stack and saving it into a portable format, but no efficient implementation will do that. Wasmtime for example allocates separate native stacks; they are full of native pointers and arbitrary spilled register values that may point into the internals of VM data structures; having an isolated coroutine as a first class value does nothing to make it portably snapshottable/resumable.</p>\n</blockquote>",
        "id": 563719571,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765756503
    }
]