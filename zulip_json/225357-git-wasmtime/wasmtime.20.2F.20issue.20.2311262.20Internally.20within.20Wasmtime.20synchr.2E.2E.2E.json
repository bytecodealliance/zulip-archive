[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11262\">issue #11262</a>:</p>\n<blockquote>\n<p>In the spirit of making Wasmtime more sound internally over time this is a major thorn in our side right now. Many functions in Wasmtime are synchronous but they're actually asynchronous in nature due to the possibility that something could be context-switched away at any moment. These context switches are required to happen on a fiber and while I'm not aware of any issues internally within Wasmtime, this is, in my opinion, unnecessarily surprising. I would ideally like to move towards a world where Wasmtime actually uses <code>async</code> internally, not just for the <code>async</code> feature of wasm itself, and then in synchronous mode it asserts the future is always ready since there aren't any sources of blocking async.</p>\n<p>Concretely sources of surprising async-ness are:</p>\n<ul>\n<li>Async resource limiters</li>\n<li>Async GC</li>\n<li>Async call hooks </li>\n<li>... maybe more? this isn't intended to be exhaustive</li>\n</ul>\n<p>Concretely one location of unsoundness has to do with growth of tables and memories. For example memory growth requires a <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c3ac18b3e4fc3dacd83bbf9e1b0fefb0837a4607/crates/wasmtime/src/runtime/memory.rs#L602-L615\">split borrow</a> both of and within the store. The same is <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c3ac18b3e4fc3dacd83bbf9e1b0fefb0837a4607/crates/wasmtime/src/runtime/externals/table.rs#L275-L288\">true for tables</a>. This is due to the fact that the methods of growth require a <code>&amp;mut self</code> on the runtime data structure but also require, effectively, <code>&amp;mut StoreOpaque</code> to suspend the world. Given that memories/tables live within <code>&amp;mut StoreOpaque</code>, this is not a sound way to model this problem.</p>\n<p>Another concrete location of unsoundness is that <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c3ac18b3e4fc3dacd83bbf9e1b0fefb0837a4607/crates/wasmtime/src/runtime/vm/memory/shared_memory.rs#L77\">growth of a shared memory</a> suspends the stack with an rwlock write lock on the stack. This means that <code>unsafe impl Send for FiberFuture {}</code> is a lie because that's foundationally built on the premise that Wasmtime's own stack-local variables are all <code>Send</code>. This is effectively something that's impossible to guarantee and this hypothetically can result in locking an rwlock on one thread and unlocking it on another (technically UB, tested on glibc and other platforms to at least not behave badly for now). I was able to trivially detect this by migrating to <code>async fn</code>, however, as the compiler checks the send-ness of local variables.</p>\n<p>If hypothetically growth were to use an <code>async</code> fn I believe this would be sound. For example growth still requires a limiter, but there's no need to borrow the full store. This is morally a borrow of separate fields in the store, for example (a) the data/limiter and (b) the memory itself. That's sound to model in Wasmtime (albeit clunky).</p>\n<p>There are additional downsides to the way this is all implemented today such as async table/memory growth requiring a fiber. This doesn't actually execute any WebAssembly code yet we nonetheless require a fiber to satisfy how suspension works in an async context. This is, in my opinion, unnecessarily unsafe where we're suspending Rust frames on a stack when we don't really need to if things were actually modeled as an <code>async</code> function.</p>\n<hr>\n<p>I'll note that this issue is not going to be easy to solve. We can't \"simply go sprinkle some <code>async</code>\" as there are some fundamental blockers to that. The main one I ran into while attempting this is that <code>VMStore</code> is not <code>Send</code>. This is a trait object backed by any <code>Store&lt;T&gt;</code> for any <code>T</code> meaning that we don't know it's <code>Send</code> ahead of time. While everything in an async context is <code>Send</code> we don't know that for a sync context. I know of no fix for this other than adding <code>Store&lt;T: Send&gt;</code> everywhere, but that's a very heavy hammer and is not one we should reach for lightly.</p>\n</blockquote>",
        "id": 529174176,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752703925
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasmtime:unsafe-code label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11262\">Issue #11262</a>.</p>",
        "id": 529174177,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752703926
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11262\">issue #11262</a>:</p>\n<blockquote>\n<p>In the spirit of making Wasmtime more sound internally over time this is a major thorn in our side right now. Many functions in Wasmtime are synchronous but they're actually asynchronous in nature due to the possibility that something could be context-switched away at any moment. These context switches are required to happen on a fiber and while I'm not aware of any issues internally within Wasmtime, this is, in my opinion, unnecessarily surprising. I would ideally like to move towards a world where Wasmtime actually uses <code>async</code> internally, not just for the <code>async</code> feature of wasm itself, and then in synchronous mode it asserts the future is always ready since there aren't any sources of blocking async.</p>\n<p>Concretely sources of surprising async-ness are:</p>\n<ul>\n<li>Async resource limiters</li>\n<li>Async GC</li>\n<li>Async call hooks </li>\n<li>... maybe more? this isn't intended to be exhaustive</li>\n</ul>\n<p>Concretely one location of unsoundness has to do with growth of tables and memories. For example memory growth requires a <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c3ac18b3e4fc3dacd83bbf9e1b0fefb0837a4607/crates/wasmtime/src/runtime/memory.rs#L602-L615\">split borrow</a> both of and within the store. The same is <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c3ac18b3e4fc3dacd83bbf9e1b0fefb0837a4607/crates/wasmtime/src/runtime/externals/table.rs#L275-L288\">true for tables</a>. This is due to the fact that the methods of growth require a <code>&amp;mut self</code> on the runtime data structure but also require, effectively, <code>&amp;mut StoreOpaque</code> to suspend the world. Given that memories/tables live within <code>&amp;mut StoreOpaque</code>, this is not a sound way to model this problem.</p>\n<p>Another concrete location of unsoundness is that <a href=\"https://github.com/bytecodealliance/wasmtime/blob/c3ac18b3e4fc3dacd83bbf9e1b0fefb0837a4607/crates/wasmtime/src/runtime/vm/memory/shared_memory.rs#L77\">growth of a shared memory</a> suspends the stack with an rwlock write lock on the stack. This means that <code>unsafe impl Send for FiberFuture {}</code> is a lie because that's foundationally built on the premise that Wasmtime's own stack-local variables are all <code>Send</code>. This is effectively something that's impossible to guarantee and this hypothetically can result in locking an rwlock on one thread and unlocking it on another (technically UB, tested on glibc and other platforms to at least not behave badly for now). I was able to trivially detect this by migrating to <code>async fn</code>, however, as the compiler checks the send-ness of local variables.</p>\n<p>If hypothetically growth were to use an <code>async</code> fn I believe this would be sound. For example growth still requires a limiter, but there's no need to borrow the full store. This is morally a borrow of separate fields in the store, for example (a) the data/limiter and (b) the memory itself. That's sound to model in Wasmtime (albeit clunky).</p>\n<p>There are additional downsides to the way this is all implemented today such as async table/memory growth requiring a fiber. This doesn't actually execute any WebAssembly code yet we nonetheless require a fiber to satisfy how suspension works in an async context. This is, in my opinion, unnecessarily unsafe where we're suspending Rust frames on a stack when we don't really need to if things were actually modeled as an <code>async</code> function.</p>\n<hr>\n<p>I'll note that this issue is not going to be easy to solve. We can't \"simply go sprinkle some <code>async</code>\" as there are some fundamental blockers to that. The main one I ran into while attempting this is that <code>VMStore</code> is not <code>Send</code>. This is a trait object backed by any <code>Store&lt;T&gt;</code> for any <code>T</code> meaning that we don't know it's <code>Send</code> ahead of time. While everything in an async context is <code>Send</code> we don't know that for a sync context. I know of no fix for this other than adding <code>Store&lt;T: Send&gt;</code> everywhere, but that's a very heavy hammer and is not one we should reach for lightly.</p>\n</blockquote>",
        "id": 535412274,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755739061
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11262#issuecomment-3208609090\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11262\">issue #11262</a>:</p>\n<blockquote>\n<p>A lot of progress is now made on this issue starting in #11430 and ending in all the linked PRs from that PR.</p>\n<p>What remains is primarily async call hooks which I'm going to say we can leave as-is for now. Call hooks are far more scoped than the pervasiveness of resource limiters and GC, so I think there's much less benefit from moving them to \"true async\" and there's also more possible pitfalls for performance hits.</p>\n<p>Overall I'm personally satisfied with where we've ended up now, so I'm going to close this.</p>\n</blockquote>",
        "id": 535412276,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755739062
    }
]