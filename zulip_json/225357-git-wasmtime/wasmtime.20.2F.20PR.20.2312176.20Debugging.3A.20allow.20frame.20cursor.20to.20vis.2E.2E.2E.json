[
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/fitzgen\">fitzgen</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176\">PR #12176</a>.</p>",
        "id": 564188284,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765957457
    },
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176\">PR #12176</a> from <code>cfallin:debugging-host-sandwich</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>In the initial design for the <code>DebugFrameCursor</code>, I was concerned about the effects of host async on the stability of visiting earlier activations (see also the discussion of async combinators in #11896). The basic hypothesized problem was that when Wasm calls host-code calls Wasm, the sequence of activations on the stack is not even stable between async polls; so any debugger hook, which is an async function, should not be allowed to hold a frame cursor across a yield point since it could become invalidated if the next poll stacks up the activations differently.</p>\n<p>In further conversations it's become clear that this is not actually a possibility, for the simple reason that the inner re-entrant activations into the same store take full ownership (mutably reborrow) that store, and that mut reborrow becomes part of the future; so the exact chain of activations will remain in the same sequence when re-polled. Said another way, it is impossible at any given level of async host-code to create <em>more than one</em> future that re-enters the same store and somehow poll those in different orders at different times. The worst that a host-code async combinator can do is drop the future that re-enters the store. This drops and invalidates whatever frames a cursor held over a yield might be referencing, but it <em>also</em> drops the async invocation of the debugger hook itself, and due to lifetimes the cursor cannot escape that hook, so everything is still sound.</p>\n<p>This PR thus updates the <code>DebugFrameCursor</code> to visit all activations. I've generalized the backtrace code a bit to enable this, and built an internal <code>StoreBacktrace</code> that is an iterator over all activations associated with the store.</p>\n<p>At the <code>DebugFrameCursor</code> (public API) level, the two basic choices were to present a sentinel for host frame(s) explicitly and make all Wasm-specific accessors return <code>Option&lt;T&gt;</code>, or skip over host frames. I opted for the latter, with <code>move_to_parent()</code> returning an enum value now that indicates whether it moved to a new activation.</p>\n<p>A note regarding the <em>async</em> component ABI: once debugging is possible within a <code>run_concurrent</code> environment, it will again be the case that a single frame cursor should see only one activation, because each (re)-entry into the store becomes a new task, if my understanding is correct. At that time, we should build an API that lets the debugger see the activation for each task separately. That's a simpler model ultimately, and it will be nice when we move to it, but as long as we have the sync component ABI with async host code and the ability to stack activations as we do today, we need to provide the debugger this visibility.</p>\n<p>(Aside: why does the debugger <em>need</em> to see more than one activation? In addition to presenting a weird and incoherent view of the world to the user if we don't, it is also necessary to implement the \"next\" (step-over) debugger action, because otherwise a call to a host function that re-enters the store may lead to a state with fewer, but completely disjoint, stack frames on the \"one latest activation\" from which it's not possible to reason about whether we've left the called-into function yet.)</p>\n<p>&lt;!--<br>\nPlease make sure you include the following information:</p>\n<ul>\n<li>\n<p>If this work has been discussed elsewhere, please include a link to that<br>\n  conversation. If it was discussed in an issue, just mention \"issue #...\".</p>\n</li>\n<li>\n<p>Explain why this change is needed. If the details are in an issue already,<br>\n  this can be brief.</p>\n</li>\n</ul>\n<p>Our development process is documented in the Wasmtime book:<br>\n<a href=\"https://docs.wasmtime.dev/contributing-development-process.html\">https://docs.wasmtime.dev/contributing-development-process.html</a></p>\n<p>Please ensure all communication follows the code of conduct:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md\">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>\n--&gt;</p>\n</blockquote>",
        "id": 564188285,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765957458
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176\">PR #12176</a>.</p>",
        "id": 564188286,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765957458
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176\">PR #12176</a>.</p>",
        "id": 564188348,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765957489
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176\">PR #12176</a>.</p>",
        "id": 564188755,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765957663
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176\">PR #12176</a>.</p>",
        "id": 564189107,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765957849
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#pullrequestreview-3589254812\">PR review</a>.</p>",
        "id": 564324922,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765998549
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#discussion_r2628311558\">PR review comment</a>:</p>\n<blockquote>\n<p>Kind of feel like this constructor should be safe and the <code>StoreBacktrace::store_mut</code> method should be unsafe, since that is the thing that actually lets you get the mutable store and potentially mutate the stack.</p>\n</blockquote>",
        "id": 564324924,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765998550
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176\">PR #12176</a>.</p>",
        "id": 564343058,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766005789
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#pullrequestreview-3589678512\">PR review</a>.</p>",
        "id": 564343107,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766005814
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#discussion_r2628659814\">PR review comment</a>:</p>\n<blockquote>\n<p>Ah, that's a great point -- updated in 0e6ec66e1d.</p>\n</blockquote>",
        "id": 564343108,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766005814
    },
    {
        "content": "<p>cfallin has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176\">PR #12176</a>.</p>",
        "id": 564343126,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766005823
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176\">PR #12176</a>.</p>",
        "id": 564345153,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766006750
    },
    {
        "content": "<p>cfallin merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176\">PR #12176</a>.</p>",
        "id": 564350701,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766009215
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#pullrequestreview-3594941028\">PR review</a>.</p>",
        "id": 564554789,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766090110
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#discussion_r2632546359\">PR review comment</a>:</p>\n<blockquote>\n<p>Could you clarify what you're worried about with the <code>unsafe</code> here? I can't actually imagine anything myself that would, in safe code, do something that violates a stack trace. While the stack is sort of morally mutatable/owned by the store we don't allow arbitrary mutations anywhere. Allowing arbitrary mutations itself would be quite unsafe due to return pointers and such on the stack.</p>\n<p>Given that I would, perhaps naively, expect this to be able to be a safe function, which would in theory help clean up callers of this a bit too</p>\n</blockquote>",
        "id": 564554790,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766090111
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#pullrequestreview-3594970012\">PR review</a>.</p>",
        "id": 564564058,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766090650
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#discussion_r2632568277\">PR review comment</a>:</p>\n<blockquote>\n<p>I remember discussing this safety condition in an earlier PR, too, where we decided to keep this <code>unsafe</code> (constructing an iterator over the stack has always had an <code>unsafe</code>, it isn't new in this PR). It's forward-looking to APIs that might, e.g., allow for early returns or exception-throws to be enacted from within the debugger. That would undoubtedly require using a <code>raise</code>-libcall-like strategy to resume to the new execution point after returning into the breakpoint trampoline, but might edit stack frames in the meantime. It seems fine to me to say that we put <code>unsafe</code> on such APIs when they exist instead. Happy to clean this up in upcoming work.</p>\n</blockquote>",
        "id": 564564060,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766090650
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#pullrequestreview-3599649393\">PR review</a>.</p>",
        "id": 564757735,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766169897
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#discussion_r2635966507\">PR review comment</a>:</p>\n<blockquote>\n<p>I have vague recollections of that, but if this is actually <code>unsafe</code>, even in a forward looking way, then this needs to be deleted:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">static</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">AsContextMut</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">DebugFrameCursor</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">as_context_mut</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">StoreContextMut</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"p\">::</span><span class=\"n\">Data</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">StoreContextMut</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: `StoreContextMut` does not provide any methods that</span>\n<span class=\"w\">        </span><span class=\"c1\">// could remove frames from the stack, so the iterator remains</span>\n<span class=\"w\">        </span><span class=\"c1\">// valid.</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">StoreContextMut</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">.</span><span class=\"n\">store_mut</span><span class=\"p\">().</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>You're saying that looking forward we'll allow editing the stack which would make this genuinely unsafe, but this impl also is only possible to exist if there's not actually any unsafety. </p>\n<p>Something about this I think needs to be reconciled. Ideally the iterator would actually borrow the stack and would force a <code>.collect</code> or something like that into a vector so we wouldn't have to deal with these sorts of questions. I don't have all this in my head to know what the best route forward is, but I do think that something here needs to change as I believe this PR is otherwise self-contradictory where it's trying to future-proof against something that it's also saying can't ever happen.</p>\n</blockquote>",
        "id": 564757736,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766169898
    },
    {
        "content": "<p>alexcrichton edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#discussion_r2635966507\">PR review comment</a>.</p>",
        "id": 564757778,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766169914
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#pullrequestreview-3599718108\">PR review</a>.</p>",
        "id": 564761075,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766171360
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#discussion_r2636022258\">PR review comment</a>:</p>\n<blockquote>\n<p>I'm not sure I follow -- the suggestion I gave above was to make any methods that actually edit the stack <code>unsafe</code> rather than the cursor construction. Wouldn't that also be sufficient? In other words, you can get a <code>StoreContextMut</code> safely, you can create a cursor safely, but using mutable access to the store for nefarious bits that invalidate a cursor is still <code>unsafe</code>.</p>\n<p>A few other constraints:</p>\n<ul>\n<li>We can't collect into a vector first -- that makes the whole operation O(n) even if you only want to look at (e.g.) the latest frame. This is a hard constraint and was mentioned by Nick in initial frame-cursor review, as I had actually built it this way first before making it a true cursor...</li>\n<li>We need to provide mutable access to the store while the cursor exists because the debugger may want to use the values it pulls out to examine other bits of state, e.g. GC objects. This is also a hard constraint because it is needed for base functionality.</li>\n</ul>\n</blockquote>",
        "id": 564761076,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766171360
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#pullrequestreview-3600236081\">PR review</a>.</p>",
        "id": 564779629,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766180817
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#discussion_r2636391795\">PR review comment</a>:</p>\n<blockquote>\n<p>With stack editing things as <code>unsafe</code>, this API here is safe, right? That's mostly what I am trying to clarify.</p>\n</blockquote>",
        "id": 564779631,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766180817
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#pullrequestreview-3600256684\">PR review</a>.</p>",
        "id": 564780483,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766181331
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#discussion_r2636407391\">PR review comment</a>:</p>\n<blockquote>\n<p>Yep, exactly. So my suggestion from above is</p>\n<blockquote>\n<p>It seems fine to me to say that we put unsafe on such APIs when they exist instead. Happy to clean this up in upcoming work.</p>\n</blockquote>\n<p>So (i) this function is safe, (ii) <code>DebugFrameCursor</code> can still safely give us a <code>StoreContextMut</code>, and (iii) <code>unsafe</code> is used in the future for anything that might invalidate a cursor by editing frames. I think we're agreeing on that final state but let me know if I'm missing something :-)</p>\n</blockquote>",
        "id": 564780484,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766181331
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#pullrequestreview-3600292453\">PR review</a>.</p>",
        "id": 564781804,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766182061
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12176#discussion_r2636431864\">PR review comment</a>:</p>\n<blockquote>\n<p>Sounds good! Sorry just wasn't clear to me from your original comment, but all good nonetheless</p>\n</blockquote>",
        "id": 564781806,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1766182062
    }
]