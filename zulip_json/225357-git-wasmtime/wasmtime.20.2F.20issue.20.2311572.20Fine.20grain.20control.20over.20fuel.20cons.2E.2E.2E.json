[
    {
        "content": "<p>fuzing opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11572\">issue #11572</a>:</p>\n<blockquote>\n<p>We're hoping to migrate from wasmer to wasmtime but we need fine grained control over fuel consumption based on a per wasm operator usage pattern.</p>\n<p>In wasmer we can set a tunable cost function and then use a metering middleware function that might look something like......</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">cost_function</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Operator</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">u64</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">operator</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">Operator</span><span class=\"p\">::</span><span class=\"n\">LocalGet</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span><span class=\"p\">::</span><span class=\"n\">I32Const</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">Operator</span><span class=\"p\">::</span><span class=\"n\">I32Add</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Is something like this possible in wasmtime.</p>\n<p>Thank you for this great project.</p>\n</blockquote>",
        "id": 536861288,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756501204
    },
    {
        "content": "<p>fuzing edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11572\">issue #11572</a>:</p>\n<blockquote>\n<p>We're hoping to migrate from wasmer to wasmtime but we need fine grained control over fuel consumption based on a per wasm operator usage pattern.</p>\n<p>In wasmer we can set a tunable cost function and then use a metering middleware function.</p>\n<p>The cost function itself might look something like......</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">cost_function</span><span class=\"p\">(</span><span class=\"n\">operator</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Operator</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"kt\">u64</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">operator</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">Operator</span><span class=\"p\">::</span><span class=\"n\">LocalGet</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Operator</span><span class=\"p\">::</span><span class=\"n\">I32Const</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">Operator</span><span class=\"p\">::</span><span class=\"n\">I32Add</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Is something like this possible in wasmtime.</p>\n<p>Thank you for this great project.</p>\n</blockquote>",
        "id": 536861450,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756501271
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11572#issuecomment-3238298801\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11572\">issue #11572</a>:</p>\n<blockquote>\n<p>Something like this is theoretically possible, sure; the main questions would be around the API design and how we ensure that it remains reasonably stable and doesn't expose too much.</p>\n<p>I can imagine passing a <code>Box&lt;dyn Fn(&amp;Operator) -&gt; u64&gt;</code> on a <code>Config</code> used to compile code. That would have some performance impact on translation because of the dynamic dispatch, and would also expose that we use <code>wasmparser</code> under the hood, but maybe that's fine -- I see no issue; others chime in if they disagree.</p>\n<p>There are also questions around how much context is reasonable to give to this cost function -- I'm not sure what purpose your customization serves, but e.g. if you want to make integer adds very expensive for some reason, this is fine, whereas making calls to specific imports (or whatever) expensive may require more context about module contents.</p>\n<p>Then there are questions about the precise guarantees we provide: if we allow users to specify precise fuel amounts, is the expectation that the count will be exactly precise at every step? That does, e.g., constrain how we do batching of the updates somewhat.</p>\n<p>In the end, if that API is acceptable, it would come down to: would you be willing to contribute a PR?</p>\n</blockquote>",
        "id": 536863270,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756502335
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11572#issuecomment-3238349223\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11572\">issue #11572</a>:</p>\n<blockquote>\n<p>We would probably only expose this functionality when the <code>reexport-wasmparser</code> feature is enabled, because <code>Operator</code> in particular changes semi frequently as WIP Wasm specs evolve.</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/0744262f79e235b172331f5ba1a2c43b5aedcbfb/crates/wasmtime/Cargo.toml#L357-L371\">https://github.com/bytecodealliance/wasmtime/blob/0744262f79e235b172331f5ba1a2c43b5aedcbfb/crates/wasmtime/Cargo.toml#L357-L371</a></p>\n</blockquote>",
        "id": 536865020,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756503735
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11572#issuecomment-3238361477\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11572\">issue #11572</a>:</p>\n<blockquote>\n<p>Ah, yes, and also we would not want to re-export a single type without re-exporting the whole <code>wasmparser</code> crate so other types (used within <code>Operator</code> arms) could be named by the embedder as needed.</p>\n<p>(I forgot we had that feature -- I was even the one who added it, d'oh!)</p>\n</blockquote>",
        "id": 536865469,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756504091
    },
    {
        "content": "<p>fuzing <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11572#issuecomment-3238364406\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11572\">issue #11572</a>:</p>\n<blockquote>\n<p>Thanks for the quick feedback.  Your guess at our use-case is pretty accurate - we \"price\" expensive instructions at a higher rate than less expensive ones.</p>\n<p>No issues with the idea of a non-semver'ed re-export of wasmparser and that this feature would need to be opted into to make functionality like this work.</p>\n<p>I'll take a look at what it will take to generate a PR and then take a crack at it.</p>\n<p>Cheers, and thank you again for your lightning response.<br>\n</p>\n</blockquote>",
        "id": 536865626,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756504207
    }
]