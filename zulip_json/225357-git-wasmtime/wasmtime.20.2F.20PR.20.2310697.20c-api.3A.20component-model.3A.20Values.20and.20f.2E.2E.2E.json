[
    {
        "content": "<p>MangoPeachGrape opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a> from <code>MangoPeachGrape:c-api/component-model/val</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>Only contains primitive values and no docs as of now. Trying to gauge if this is correct way to approach this.</p>\n<p>Some things of note:</p>\n<ul>\n<li><code>wasmtime_component_valunion_t::boolean</code> instead of <code>::bool</code> because keyword.</li>\n<li><code>wasmtime_component_valunion_t::f32</code> and <code>WASMTIME_COMPONENT_F32</code> instead of <code>float32</code>, should this be changed to be consistent?</li>\n<li>C++20 needed for syntax used when creating <code>wasmtime_component_val_t</code> in the test, so I bumped to 20 only for tests. Is that fine? Could the whole project be bumped to 20?</li>\n</ul>\n<p>Also, is there any better way to test all values, other than copying the test for each kind of value?</p>\n</blockquote>",
        "id": 515111740,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745944600
    },
    {
        "content": "<p><strong>MangoPeachGrape</strong> requested <a href=\"https://github.com/pchickey\">pchickey</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 515111742,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745944600
    },
    {
        "content": "<p><strong>MangoPeachGrape</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 515111744,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745944600
    },
    {
        "content": "<p>MangoPeachGrape edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>Only contains primitive values and no docs as of now. Trying to gauge if this is the correct way to approach this.</p>\n<p>Some things of note:</p>\n<ul>\n<li><code>wasmtime_component_valunion_t::boolean</code> instead of <code>::bool</code> because keyword.</li>\n<li><code>wasmtime_component_valunion_t::f32</code> and <code>WASMTIME_COMPONENT_F32</code> instead of <code>float32</code>, should this be changed to be consistent?</li>\n<li>C++20 needed for syntax used when creating <code>wasmtime_component_val_t</code> in the test, so I bumped to 20 only for tests. Is that fine? Could the whole project be bumped to 20?</li>\n</ul>\n<p>Also, is there any better way to test all values, other than copying the test for each kind of value?</p>\n</blockquote>",
        "id": 515111815,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745944627
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 515150456,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745957864
    },
    {
        "content": "<p>ac000 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2840455044\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<blockquote>\n<p>Could the whole project be bumped to 20?</p>\n</blockquote>\n<p>My feeling is that is a bit too recent, even GCC 15.1 just released still _defaults_ to <code>-std=gnu++17</code> for C++. Though admittedly I don't really know which bits of wasmtime that would effect. Like how would that affect building wasmtime on older (but still supported, thinking Debian, RHEL etc) Linux distributions?.</p>\n<blockquote>\n<p>Also, is there any better way to test all values, other than copying the test for each kind of value?</p>\n</blockquote>\n<p>An array of structs of the values perhaps?</p>\n</blockquote>",
        "id": 515174738,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745969425
    },
    {
        "content": "<p><strong>pchickey</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 515177486,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745971242
    },
    {
        "content": "<p>MangoPeachGrape <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2841721397\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<blockquote>\n<p>My feeling is that is a bit too recent, even GCC 15.1 just released still defaults to -std=gnu++17 for C++. Though admittedly I don't really know which bits of wasmtime that would effect. Like how would that affect building wasmtime on older (but still supported, thinking Debian, RHEL etc) Linux distributions?.</p>\n</blockquote>\n<p>The feature used was 'designated initializer', which was implemented in gcc 8 and clang 10, in 2018 and 2020 respectively. AFAIK it would only be required for building tests, and when a consumer depends on the wasmtime-cpp project, as the build step for the C-API doesn't build any C++ code.</p>\n<p>Feel free to let me know if its too new/not wanted!</p>\n</blockquote>",
        "id": 515281301,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746013682
    },
    {
        "content": "<p>ac000 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2842050945\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<blockquote>\n<p>The feature used was 'designated initializer', which was implemented in gcc 8 and clang 10, in 2018 and 2020 </p>\n</blockquote>\n<p>Heh, only 20 years after C!</p>\n<blockquote>\n<p>respectively. AFAIK it would only be required for building tests, and when a consumer depends on the wasmtime-cpp project, as the build step for the C-API doesn't build any C++ code.</p>\n<p>Feel free to let me know if its too new/not wanted!</p>\n</blockquote>\n<p>Not that this is really any business of mine, but that's probably OK then, Debian 11 has GCC 10.x and Clang 11.x and RHEL/etc 8 has GCC 8.x</p>\n<p>B.t.w thanks for doing this work!<br>\n</p>\n</blockquote>",
        "id": 515309834,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746020852
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2842370881\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>On the PR at-hand here, one thing I am worried about with values is ownership of lists and transitive pointers. For example the string variant here is currently implemented as an owning pointer which means that even for invocations such as <code>wasmtime_component_func_call</code> it'll require that ownership is passed into the component. It also means that on the \"other half\", defining a function in a linker, ownership will be given and the calling code will be responsible for deallocating it. More-or-less this is I think the main sticking point of component model values and figuring this out will pave the way for the rest of the API.</p>\n<p>Historically I've thought that we want to not have ownership during <code>wasmtime_component_func_call</code> and maybe give ownership when wasm calls the host. That being said this strategy has a large downside of now <code>wasmtime_component_val_t</code> doesn't have static ownership semantics which makes it much more difficult to bind in languages and such. Static ownership semantics definitely makes the type more usable (as implemented here), but less efficient. </p>\n<p>Personally I'm sort of leaning towards this-style API that you've prototyped here. It's less efficient than a hypothetical alternative but the \"hypothetical alternative\" is IMO so unusable it's not worth pursuing (e.g. not being able to write down static semantics for a type and how it's owned).</p>\n<p>One way I can perhaps think about this API is that it's similar to <a href=\"https://docs.rs/wasmtime/latest/wasmtime/component/enum.Val.html\"><code>wasmtime::component::Val</code></a> which is intended for expressive power, not efficiency. The downside is that there's no way to implement a \"typed\" API in C so it means that this would be the only way to invoke a component, which isn't great. This is where I've historically gotten stuck...</p>\n<hr>\n<p>For your specific questions though:</p>\n<blockquote>\n<p>wasmtime_component_valunion_t::boolean instead of ::bool because keyword.</p>\n</blockquote>\n<p>sounds reasonable to me yeah</p>\n<blockquote>\n<p>wasmtime_component_valunion_t::f32 and WASMTIME_COMPONENT_F32 instead of float32, should this be changed to be consistent?</p>\n</blockquote>\n<p>The \"f32\" naming is the right naming to use, we just haven't completed the rename from \"float32\" to \"f32\" in all places yet (but if you see them feel free to flag them)</p>\n<blockquote>\n<p>C++20 needed for syntax used when creating wasmtime_component_val_t in the test, so I bumped to 20 only for tests. Is that fine? Could the whole project be bumped to 20?</p>\n</blockquote>\n<p>It seems reasonable to bump this for tests yeah if it works on CI given that it's test-only. I'm not really sure how this would impact consumers since this library is primarily built in Rust and otherwise just shipped as a bunch of headers, but we can handle anything in issues and such. As you say if <code>-DBUILD_TESTS=OFF</code>, which is the default, I think will handle most of the impact here.</p>\n<blockquote>\n<p>Also, is there any better way to test all values, other than copying the test for each kind of value?</p>\n</blockquote>\n<p>Given the dynamic ownership nature of values I think this is basically going to involve a lot of copy/paste. That's where I think C++ dtors can help a lot by reducing the amount of boilerplate, but that would also require binding in C++ APIs. Maybe something where tests are mostly calling a central helper function with a few customized callbacks? The callbacks would customize the module/value per-test in that case maybe?</p>\n<hr>\n<p>And as a final thought: a natural dual for this feature will be the ability to define host functions that can be called from wasm (e.g. defining a function in a component linker). I've personally found values tricky enough in the past that I've found it worthwhile to implement both calling wasm and wasm calling the host at the same time. If you'd like I think it'd be reasonable to include the basics of such infrastructure in this PR. If you'd prefer not to, however, I think it's reasonable to defer this to a future PR as well.</p>\n</blockquote>",
        "id": 515334202,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746026729
    },
    {
        "content": "<p>MangoPeachGrape <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2843306612\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<blockquote>\n<p>wasmtime_component_val_t doesn't have static ownership semantics which makes it much more difficult to bind in languages and such. Static ownership semantics definitely makes the type more usable</p>\n</blockquote>\n<blockquote>\n<p>It's less efficient than a hypothetical alternative</p>\n</blockquote>\n<p>Could you expand on what does the \"static ownership semantics\" and the \"hypothetical alternative\" mean?</p>\n<hr>\n<p>One idea that popped into my head was to have some helper functions for each type to lift/lower to the raw values, or maybe give access to the raw values? I have zero idea if that would be a valid approach. I might be missing something big, as I don't have much at all knowledge of the existing codebase.</p>\n</blockquote>",
        "id": 515400839,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746047871
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2843480466\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>Oh sure, by static ownership semantics I mean that a type always prescribes a particular way to manage its memory. For example <code>wasmtime_component_t</code> always requires that the caller deallocates it, no questions asked. this is also reflected in your <code>wasmtime_component_val_t</code> where the string variant is \"always owned\" and whenever it's passed along that's a transfer of ownership.</p>\n<p>This is in contrast to thinking I've had historically about component values. For example invoking a component function does not in theory require giving up ownership of anything. You could in theory pass in string pointers that aren't free'd by <code>wasmtime_component_func_call</code>. If we were to go down this road though this is the \"hypothetical alternative\" where all of a sudden the memory management of <code>wasmtime_component_val_t</code> is dependent on where the value came from. Sometimes it might be transferred by ownership, sometimes not. Personally I think such a system, while possibly more efficient, is too complex to reliably use correctly.</p>\n<p>Basically what you've sketched out here is I think a good idea and we should keep it this way.</p>\n<p>In terms of prototyping I think it might be useful to, here in this PR, sketch out not only the terminal types of <code>wasmtime_component_val_t</code> but something that also involves recursion, for example a <code>record</code> type. That might help sort out some of these questions perhaps?</p>\n</blockquote>",
        "id": 515408356,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746050974
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 516290133,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746476906
    },
    {
        "content": "<p>MangoPeachGrape <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2852280392\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>After thinking about this for few days, I started to dislike passing args as mut, and the forced allocation. For strings requiring the C-API to allocate a wasm_name_t isn't a big issue, as rust can use that allocation, but for lists and other values that isn't possible.</p>\n<p>What I tried to achiveve in this iteration is being able to create arguments for a function fully on the stack, and rust to be able to still return values.</p>\n<p>In practice this would mean that you need to call <code>wasmtime_component_val_delete()</code> on each return value that rust might have allocated.</p>\n<p>Please let me know if you feel like I'm going in the wrong direction!</p>\n</blockquote>",
        "id": 516292076,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746477591
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2854826110\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>This is possible yeah and it's the alternative I mentioned <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2842370881\">above</a> too. The main downside is that this is quite difficult to bind in other languages because the ownership semantics of <code>wasmtime_component_val_t</code> is not clear. Sometimes you need to call a destructor and sometimes not, and that makes it quite difficult to use correctly in any context, including bindings in other languages.</p>\n<p>This is basically where I've always stopped short historically in thinking about what this would look like. I get stuck here not knowing how best to bind component values. I've yet to find a scheme that feels like it balances pros/cons effectively unfortunately :(</p>\n<p>My best thinking at this time is that we should have two methods of calling component functions, similar to the <code>wasmtime_func_call{,_unchecked}</code>. One takes <code>wasmtime_component_val_t</code> which is flexible, but slow. This would look mostly like this PR <code>wasmtime_component_val_t</code> but it always has a destructor with it. How exactly that would work out I'm not entirely certain. The \"unchecked\" path though would take a \"canonical ABI blob\" which is  sort of a packed representation of the canonical ABI of a type, but for the host, and in theory has much lower overhead.</p>\n<p>Or... something like that, I really don't have concrete ideas about how best to progress here. I really am worried though about this style of API though in that I don't know how to bind it in languages like Python safely.</p>\n</blockquote>",
        "id": 516462739,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746542375
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 516505238,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746554691
    },
    {
        "content": "<p>MangoPeachGrape <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2855551920\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>Would something like this be an acceptable API for bindings in other languages:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"n\">wasmtime_component_val_t</span><span class=\"w\"> </span><span class=\"n\">argument</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">wasmtime_component_valrecord_new</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">argument</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">WASMTIME_COMPONENT_RECORD</span><span class=\"p\">);</span>\n<span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">argument</span><span class=\"p\">.</span><span class=\"n\">of</span><span class=\"p\">.</span><span class=\"n\">record</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">);</span>\n\n<span class=\"n\">wasm_name_new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">argument</span><span class=\"p\">.</span><span class=\"n\">of</span><span class=\"p\">.</span><span class=\"n\">record</span><span class=\"p\">.</span><span class=\"n\">ptr</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">name</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"first\"</span><span class=\"p\">)</span>\n<span class=\"n\">argument</span><span class=\"p\">.</span><span class=\"n\">of</span><span class=\"p\">.</span><span class=\"n\">record</span><span class=\"p\">.</span><span class=\"n\">ptr</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">val</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">WASMTIME_COMPONENT_U32</span><span class=\"p\">;</span>\n<span class=\"n\">argument</span><span class=\"p\">.</span><span class=\"n\">of</span><span class=\"p\">.</span><span class=\"n\">record</span><span class=\"p\">.</span><span class=\"n\">ptr</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">val</span><span class=\"p\">.</span><span class=\"n\">of</span><span class=\"p\">.</span><span class=\"n\">u32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"n\">wasm_name_new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">argument</span><span class=\"p\">.</span><span class=\"n\">of</span><span class=\"p\">.</span><span class=\"n\">record</span><span class=\"p\">.</span><span class=\"n\">ptr</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">name</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"second\"</span><span class=\"p\">)</span>\n<span class=\"n\">argument</span><span class=\"p\">.</span><span class=\"n\">of</span><span class=\"p\">.</span><span class=\"n\">record</span><span class=\"p\">.</span><span class=\"n\">ptr</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">val</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">WASMTIME_COMPONENT_U32</span><span class=\"p\">;</span>\n<span class=\"n\">argument</span><span class=\"p\">.</span><span class=\"n\">of</span><span class=\"p\">.</span><span class=\"n\">record</span><span class=\"p\">.</span><span class=\"n\">ptr</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">val</span><span class=\"p\">.</span><span class=\"n\">of</span><span class=\"p\">.</span><span class=\"n\">u32</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"n\">wasmtime_component_val_t</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{};</span>\n\n<span class=\"n\">wasmtime_component_func_call</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">argument</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">result</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span>\n\n<span class=\"n\">wasmtime_component_val_delete</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">argument</span><span class=\"p\">);</span>\n<span class=\"n\">wasmtime_component_val_delete</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">result</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>This kind of API would allow the record entries to be both heap allocated (like this example) or stack allocated (not calling <code>wasmtime_component_valrecord_new()</code> and <code>wasmtime_component_val_delete()</code>). I haven't looked at the Python bindings, does it allow having <code>wasmtime_component_val_t</code> on the stack, does that also have to be a pointer to heap?</p>\n<blockquote>\n<p>The \"unchecked\" path though would take a \"canonical ABI blob\" which is sort of a packed representation of the canonical ABI of a type, but for the host, and in theory has much lower overhead.</p>\n</blockquote>\n<p>I agree, that would be great in the long run.</p>\n<p>Why I leaned towards having the option for stack allocated values is that I thought it would make some cases simpler and faster, like:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"n\">wasmtime_component_valrecord_entry_t</span><span class=\"w\"> </span><span class=\"n\">entry</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">wasmtime_component_valrecord_entry_t</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">.</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"namee\"</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">val</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">WASMTIME_COMPONENT_U8</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">val</span><span class=\"p\">.</span><span class=\"n\">of</span><span class=\"p\">.</span><span class=\"n\">u8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">123</span><span class=\"p\">,</span>\n<span class=\"p\">};</span>\n<span class=\"n\">wasmtime_component_func_call</span><span class=\"p\">(</span>\n<span class=\"w\">    </span><span class=\"n\">func</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"n\">wasmtime_component_val_t</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">WASMTIME_COMPONENT_RECORD</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">of</span><span class=\"p\">.</span><span class=\"n\">record</span><span class=\"p\">.</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">entry</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">of</span><span class=\"p\">.</span><span class=\"n\">record</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"p\">},</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"o\">&amp;</span><span class=\"k\">return</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"mi\">1</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n<p>(not sure if that's 100% correct C syntax, but the idea should remain)</p>\n</blockquote>",
        "id": 516511167,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746556503
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2855853089\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>I think the trickier parts of memory management are going to come up during host-defined functions being inserted into a linker. For example when arguments are passed to the host, should the host or wasmtime deallocate them? When arguments are returned, does wasmtime need to deallocate them? The precise answer to this question ends up informing how difficult this is to bind in other languages.</p>\n<p>For other languages though I don't really have a concrete worry per se. Historically <code>wasmtime_val_t</code> had an allocation inside of it for <code>wasmtime_externref_t</code> which I remember being a huge pain binding. Everything got way easier when it became a bland <code>u32</code> from a guest bindings perspective. Unfortunately though I don't recall the exact pain and issues that I came up with. I think the only real way to bottom out such a concern would be to write such bindings, but I also don't think that's reasonable to expect of you.</p>\n<hr>\n<p>Perhaps though another radical alternative. This is something I've had rattling around in my head for awhile that I keep forgetting about and have also not fully fleshed out. What I'm imagining is something like this:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">typedef</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">wasmtime_component_vals</span><span class=\"w\"> </span><span class=\"n\">wasmtime_component_vals_t</span><span class=\"p\">;</span>\n<span class=\"k\">typedef</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">wasmtime_component_call</span><span class=\"w\"> </span><span class=\"n\">wasmtime_component_call_t</span><span class=\"p\">;</span>\n\n<span class=\"n\">wasmtime_component_call_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">call</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">wasmtime_component_func_call_start</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">func</span><span class=\"p\">);</span>\n<span class=\"n\">wasmtime_component_vals_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">params</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">wasmtime_component_call_params</span><span class=\"p\">(</span><span class=\"n\">call</span><span class=\"p\">);</span>\n<span class=\"c1\">// set the first parameter, in this case a `u32`</span>\n<span class=\"n\">wasmtime_component_vals_set_u32</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">);</span>\n<span class=\"c1\">// set the second parameter, in this case a `string`</span>\n<span class=\"n\">wasmtime_component_vals_set_string</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">my_variable_typed_as_wasm_name_t</span><span class=\"p\">);</span>\n<span class=\"c1\">// set the third parameter, in this case a `record point { x: u32, y: u32 }`</span>\n<span class=\"n\">wasmtime_component_vals_set_record</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"cm\">/*nfields=*/</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"c1\">// set \"x: 0\"</span>\n<span class=\"n\">wasmtime_component_vals_set_record_field</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x_as_wasm_name_t</span><span class=\"p\">);</span>\n<span class=\"n\">wasmtime_component_vals_set_u32</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"c1\">// set \"y: 1\"</span>\n<span class=\"n\">wasmtime_component_vals_set_record_field</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">y_as_wasm_name_t</span><span class=\"p\">);</span>\n<span class=\"n\">wasmtime_component_vals_set_u32</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// dispatch the call</span>\n<span class=\"n\">wasmtime_component_vals_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">results</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">wasmtime_component_call_finish</span><span class=\"p\">(</span><span class=\"n\">call</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// if the result is a u32</span>\n<span class=\"n\">wasmtime_component_vals_get_u32</span><span class=\"p\">(</span><span class=\"n\">results</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">ret</span><span class=\"p\">);</span>\n<span class=\"c1\">// if the result is a string</span>\n<span class=\"n\">wasmtime_component_vals_get_string</span><span class=\"p\">(</span><span class=\"n\">results</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">something_with_wasm_name_t</span><span class=\"p\">);</span>\n<span class=\"c1\">// etc ..</span>\n</code></pre></div>\n<p>The rough idea is that this is a much \"chattier\" C ABI boundary but is, in theory, much more flexible about where things are stored and how exactly the host represents things. The <code>wasmtime_component_vals_t</code> type is an \"iterator\" of sorts that walks over the structure of the type tree in tandem with where values are actually being stored in a WebAssembly module's linear memory and such. This would be, in essence, interleaving lowering code with actually storing into wasm linear memory.</p>\n<p>Actually implementing this would require new support on the Wasmtime side of things, which would arguably be a good thing as well. Whether or not this is a good idea I don't know, this definitely isn't a fully fleshed out idea. It would, however, remove the need for strict ownership around <code>wasmtime_component_val_t</code></p>\n</blockquote>",
        "id": 516526753,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746562580
    },
    {
        "content": "<p>MangoPeachGrape <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2855950113\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think the trickier parts of memory management are going to come up during host-defined functions being inserted into a linker. For example when arguments are passed to the host, should the host or wasmtime deallocate them? When arguments are returned, does wasmtime need to deallocate them? The precise answer to this question ends up informing how difficult this is to bind in other languages.</p>\n</blockquote>\n<p>These are the semantics I've been thinking of:</p>\n<ul>\n<li>When calling guest function, you own both the arguments and return values, so you need to clean both up (i.e. call <code>wasmtime_component_val_delete()</code>).</li>\n<li>When guest calls your host function, the arguments and return values will be owned by rust, so if you create a record return value (what would be <code>wasmtime_component_valrecord_new(/* size */)</code> from my last comment) and assign in to the return value array, then the rust side cleans it up after your function has executed.</li>\n</ul>\n<p>I feel like this is what I had initially, just that you need to clean up the arguments you pass to a function after calling it, which I feel should be fine, as return values would have had to been cleaned up anyway.</p>\n<blockquote>\n<p>Perhaps though another radical alternative. This is something I've had rattling around in my head for awhile that I keep forgetting about and have also not fully fleshed out. What I'm imagining is something like this:</p>\n</blockquote>\n<p>I see the idea, I'll need some time to properly think through it.</p>\n<p>I'll try to implement host functions now, to understand the problem better.</p>\n<p>How should testing of records be done? I've been doing using this guest component locally:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>record ccc {\n    value: u64,\n    multiplier: u64,\n}\n\nexport cccc: func(a: ccc) -&gt; ccc;\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">cccc</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Ccc</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">Ccc</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">Ccc</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">value</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">a</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">multiplier</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">multiplier</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">a</span><span class=\"p\">.</span><span class=\"n\">multiplier</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>... and then calling it and checking the return value. Is there any resonable way to test these kinds of values without a guest component written in a higher level language?<br>\nI saw the <code>/examples/component/</code> that used a guest component written in rust, should it be done similarly here?</p>\n</blockquote>",
        "id": 516532223,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746564791
    },
    {
        "content": "<p>MangoPeachGrape edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2855950113\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think the trickier parts of memory management are going to come up during host-defined functions being inserted into a linker. For example when arguments are passed to the host, should the host or wasmtime deallocate them? When arguments are returned, does wasmtime need to deallocate them? The precise answer to this question ends up informing how difficult this is to bind in other languages.</p>\n</blockquote>\n<p>These are the semantics I've been thinking of:</p>\n<ul>\n<li>When calling guest function, you own both the arguments and return values, so you need to clean both up (i.e. call <code>wasmtime_component_val_delete()</code>).</li>\n<li>When guest calls your host function, the arguments and return values will be owned by rust, so if you create a record return value (what would be <code>wasmtime_component_valrecord_new(/* size */)</code> from my last comment) and assign in to the return value array, then the rust side cleans it up after your function has executed.</li>\n</ul>\n<p>Edit: Just to be clear (because the current naming of <code>wasmtime_component_val_delete()</code> isn't great), <code>wasmtime_component_val_delete()</code> doesn't actually delete the pointer passed to it, it just calls the destructor on the pointer, which will delete the allocations inside the value, e.g. a record that has allocated entries.</p>\n<p>I feel like this is what I had initially, just that you need to clean up the arguments you pass to a function after calling it, which I feel should be fine, as return values would have had to been cleaned up anyway.</p>\n<blockquote>\n<p>Perhaps though another radical alternative. This is something I've had rattling around in my head for awhile that I keep forgetting about and have also not fully fleshed out. What I'm imagining is something like this:</p>\n</blockquote>\n<p>I see the idea, I'll need some time to properly think through it.</p>\n<p>I'll try to implement host functions now, to understand the problem better.</p>\n<p>How should testing of records be done? I've been doing using this guest component locally:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>record ccc {\n    value: u64,\n    multiplier: u64,\n}\n\nexport cccc: func(a: ccc) -&gt; ccc;\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">cccc</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Ccc</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">Ccc</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">Ccc</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">value</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">a</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">multiplier</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">multiplier</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">a</span><span class=\"p\">.</span><span class=\"n\">multiplier</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>... and then calling it and checking the return value. Is there any resonable way to test these kinds of values without a guest component written in a higher level language?<br>\nI saw the <code>/examples/component/</code> that used a guest component written in rust, should it be done similarly here?</p>\n</blockquote>",
        "id": 516532705,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746564997
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 516539501,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746568429
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 516540961,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746569201
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 516541612,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746569597
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2863525109\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>Those ownership semantics make sense to me, but they're a bit tricky to bind in a higher level language like Python. For example Python will have some sort of <code>Val</code> type which is the union <code>wasmtime_component_val_t</code> under the hood. When calling a function you'd provide a list of <code>Val</code> and get back a list of <code>Val</code>, and that particular one would have to be owned and managed in Python itself. When wasm calls back into the host, in this case Python, then you'd still get a list of <code>Val</code> and produce a list of <code>Val</code> but the ownership is different where Python can't persist the <code>Val</code> beyond the function call, for example, so various pointers would have to be invalidated just before the host function returns. This is all doable, but will be tricky basically.</p>\n<blockquote>\n<p>How should testing of records be done?</p>\n</blockquote>\n<p>Yeah it's possible to use the text format of components, albeit it's a bit verbose. You can get a bit of a feel for the text format for components from <a href=\"https://github.com/bytecodealliance/wasmtime/tree/main/tests/misc_testsuite/component-model\">this directory</a></p>\n</blockquote>",
        "id": 516927754,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746719141
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 517320983,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1746935917
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 517950801,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747185952
    },
    {
        "content": "<p>MangoPeachGrape <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2878386486\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>Wrote some tests for the complex types, tried to abstract away most of the creation. Followed the tests in <code>tests/all/component_model/</code> so I duplicated the <code>REALLOC_AND_FREE</code> helper. Not sure if its needed though, as the current tests only require one allocation. Could you look thoroughly through the test code, as I was not at all familiar with the text format.</p>\n<p>What's your current thoughts on the design? Do you think its good enough to go forward?</p>\n<p>I think one case is not covered: in a host function, setting the return value to the argument value, as doing <code>rets[0] = args[0]</code> would result in a double free. A <code>wasmtime_component_val_clone()</code> should fix this though.</p>\n</blockquote>",
        "id": 517952371,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747187085
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#pullrequestreview-2854440297\">PR review</a>:</p>\n<blockquote>\n<p>Ok thanks for being patient I was a bit too busy last week! Overall I think let's commit to this approach. This looks to be workable enough and if it's difficult to integrate into other languages we can tackle that then.</p>\n<p>Thank you again very much for working on this!</p>\n</blockquote>",
        "id": 519402240,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747751671
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#discussion_r2098127316\">PR review comment</a>:</p>\n<blockquote>\n<p>Can this get dropped? Cloning a raw pointer I think probably isn't the right implementation for this</p>\n</blockquote>",
        "id": 519402243,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747751672
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#discussion_r2098139884\">PR review comment</a>:</p>\n<blockquote>\n<p>Would it perhaps make sense to use the <code>declare_vecs!</code> macro for this?</p>\n</blockquote>",
        "id": 519402246,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747751672
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#discussion_r2098130775\">PR review comment</a>:</p>\n<blockquote>\n<p>Here I think it may be best to use <code>ptr::slice_from_raw_parts</code> to avoid making a safe slice, minor difference but a bit better safety-wise I think</p>\n</blockquote>",
        "id": 519402248,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747751673
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 519449855,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747765580
    },
    {
        "content": "<p>MangoPeachGrape <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2895436081\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>Oops... though I could rebase on top of main cleanly because I didn't get any conflicts, sorry.</p>\n</blockquote>",
        "id": 519450827,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747765918
    },
    {
        "content": "<p>MangoPeachGrape edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2895436081\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>Oops... thought I could rebase on top of main cleanly because I didn't get any conflicts, sorry.</p>\n</blockquote>",
        "id": 519450890,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747765928
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 519451085,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747766009
    },
    {
        "content": "<p>MangoPeachGrape submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#pullrequestreview-2855293669\">PR review</a>.</p>",
        "id": 519456044,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747767778
    },
    {
        "content": "<p>MangoPeachGrape created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#discussion_r2098674157\">PR review comment</a>:</p>\n<blockquote>\n<p>Using it to only define those two functions, or using it to define fully <code>wasmtime_component_vallist_t</code> and <code>wasmtime_component_valrecord_t</code>?<br>\nThat would also resolve the two issues above, but I personally feel that its a little bit more cumbersome API to use, but the consistency with other APIs might be worth more?</p>\n</blockquote>",
        "id": 519456045,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747767778
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#pullrequestreview-2855627433\">PR review</a>.</p>",
        "id": 519476548,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747776121
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#discussion_r2098898022\">PR review comment</a>:</p>\n<blockquote>\n<p>Hm good question. I was actually thinking of just <code>wasmtime_component_vallist_t</code>, but you've got a good point about records too. I do think that consistency would be pretty nice, so let's say we can represent both records and lists as C API lists?</p>\n</blockquote>",
        "id": 519476550,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747776122
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 519840626,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747921733
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 519843304,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747922384
    },
    {
        "content": "<p>MangoPeachGrape <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2901409429\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>Refactored to use <code>declare_vecs!</code>, but I'm not entirely happy with it:</p>\n<p><code>_new()</code>, <code>_empty()</code>, and <code>_uninit()</code> using an out param, instead of a return value, but I also understand the backward compatibility requirements of the other APIs...</p>\n<p><code>_copy()</code> and <code>_delete()</code> are duplicated for each inner type, like <code>wasmtime_component_vallist_copy()</code> and <code>wasmtime_component_valrecord_copy()</code>.<br>\nWhat I've been pondering is would it be simpler to have a \"global\" <code>wasmtime_component_val_copy()</code> instead? I can't seem to think of scenarios where an inner type <code>copy()</code> would be needed, but they might exist?</p>\n<hr>\n<p>Feel free to bikeshed all the names, like:<br>\n<code>wasmtime_component_vallist_t</code> vs <code>wasmtime_component_val_list_t</code> (i.e. should there be <code>_</code>)<br>\n<code>wasmtime_component_valrecord_entry_t</code> vs <code>wasmtime_component_valrecord_field_t</code> or something else?</p>\n<p>I also assume rest of the value types should come in a later PR?</p>\n</blockquote>",
        "id": 519847859,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747923567
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#pullrequestreview-2862024523\">PR review</a>:</p>\n<blockquote>\n<p>I think it's good to have <code>wasmtime_component_val_copy</code> but I also think it's good to have intermediate helpers as well in case they're needed, so personally I'm ok having both the top-level copy method plus helpers for intermediate ones as needed.</p>\n</blockquote>",
        "id": 519885831,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747934512
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#discussion_r2103056488\">PR review comment</a>:</p>\n<blockquote>\n<p>Oh I missed this from earlier, but ideally this would match Wasmtime's API where this wasn't bundled in here and instead this was a separate API call. This is ok to do as a follow-up though.</p>\n</blockquote>",
        "id": 519885832,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747934512
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#discussion_r2103057802\">PR review comment</a>:</p>\n<blockquote>\n<p>Could this use <code>WASM_DECLARE_VEC</code> from <code>wasm.h</code> to get the other helper functions as well?</p>\n</blockquote>",
        "id": 519885833,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747934512
    },
    {
        "content": "<p>MangoPeachGrape submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#pullrequestreview-2862110217\">PR review</a>.</p>",
        "id": 519891009,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747936332
    },
    {
        "content": "<p>MangoPeachGrape created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#discussion_r2103110839\">PR review comment</a>:</p>\n<blockquote>\n<p>I don't think so, as that adds a hardcoded \"wasm_\" prefix and \"_vec_t\" postfix, don't think those are desired? That's the shared C-API file, so it can't be modified, right?</p>\n</blockquote>",
        "id": 519891011,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747936332
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#pullrequestreview-2862120841\">PR review</a>.</p>",
        "id": 519891633,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747936594
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#discussion_r2103117389\">PR review comment</a>:</p>\n<blockquote>\n<p>Right yes good points, and you're right we can't modify it. Want to copy the macro definition over here to declare more of the other helper methods as well in that case?</p>\n</blockquote>",
        "id": 519891634,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747936594
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 519894491,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747937690
    },
    {
        "content": "<p>MangoPeachGrape submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#pullrequestreview-2862178889\">PR review</a>.</p>",
        "id": 519894897,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747937840
    },
    {
        "content": "<p>MangoPeachGrape created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#discussion_r2103150933\">PR review comment</a>:</p>\n<blockquote>\n<p>Done!</p>\n</blockquote>",
        "id": 519894898,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747937840
    },
    {
        "content": "<p>MangoPeachGrape submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#pullrequestreview-2862180622\">PR review</a>.</p>",
        "id": 519895050,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747937892
    },
    {
        "content": "<p>MangoPeachGrape created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#discussion_r2103152107\">PR review comment</a>:</p>\n<blockquote>\n<p>Will do in a follow-up, the next PR I guess?</p>\n</blockquote>",
        "id": 519895051,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747937893
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 519904790,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747941122
    },
    {
        "content": "<p>MangoPeachGrape <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2902297608\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>Hmm, the doxygen output for the component files don't show up like it does for other files..<br>\nSee <a href=\"https://docs.wasmtime.dev/c-api/component_2component_8h_source.html\">https://docs.wasmtime.dev/c-api/component_2component_8h_source.html</a></p>\n</blockquote>",
        "id": 519905310,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747941343
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 519905810,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747941545
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2902424895\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>Odd! Not that I'm enough of a doxygen expert to know why...</p>\n</blockquote>",
        "id": 519912522,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747944445
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 519916625,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747946033
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697#issuecomment-2902938435\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>:</p>\n<blockquote>\n<p>If this bounces again you can put <code>prtest:full</code> in a commit message somewhere and it'll run full CI on this PR instead of just a subset (avoids the need to have me in the middle of the iteration loop)</p>\n</blockquote>",
        "id": 519941730,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747960059
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 520019261,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1747995944
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 520055817,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748007321
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 520057717,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748007889
    },
    {
        "content": "<p>alexcrichton has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 520061596,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748008950
    },
    {
        "content": "<p>alexcrichton merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10697\">PR #10697</a>.</p>",
        "id": 520066491,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1748010404
    }
]