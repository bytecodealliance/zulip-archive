[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835\">issue #11835</a>:</p>\n<blockquote>\n<p>Most of the public API surface for working with Wasm-visible storage in Wasmtime takes an <code>AsContextMut</code> parameter. For random examples, <a href=\"https://docs.rs/wasmtime/37.0.1/wasmtime/struct.StructRef.html#method.field\"><code>StructRef::field</code></a>, <a href=\"https://docs.rs/wasmtime/37.0.1/wasmtime/struct.Memory.html#method.data\"><code>Memory::data</code></a>, and <a href=\"https://docs.rs/wasmtime/37.0.1/wasmtime/struct.Table.html#method.get\"><code>Table::get</code></a> all take either an <code>AsContext</code>/<code>AsContextMut</code> or an <code>Into&lt;StoreContext{,Mut}&gt;</code>.</p>\n<p>It makes sense that accessors require \"the store\" (in some vague sense) to access the linear memories, tables, and GC heap, because all of these units of storage are owned by the store.</p>\n<p>However, in the context of the guest-debugging API, it turns out that we need to expose an <code>AsContextMut</code> from the \"debug session\" handle type in #11826, because without that, while the debug session owns the store, there is no way to actually <em>do</em> anything with GC refs that one reads out, or read data in the linear memories, etc. In other words, regular debugger access will want to get at the guest's data and objects.</p>\n<p>Likewise, In #11769 I put accessors for the values on stack (locals and operand stack) directly on a <code>StackView</code>, and this suffices for core Wasm types (ints/floats/vectors) but as soon as one actually wants to examine a GC ref that one reads out, one will want an <code>AsContextMut</code>.</p>\n<p>This is possible (and I've done it in the draft #11826 in the latest commit), and I believe it's still sound (one can view a \"debugger pause\" as like a hostcall; so it morally has access to whatever a <code>Caller</code> has access to, and <code>Caller</code> impls <code>AsContextMut</code>), but I don't like it because it forces over-monomorphization: it means that the whole debugger API gets the <code>T</code> from the <code>Store</code>. It also interacts somewhat poorly with internals: for example, <code>AutoAssertNoGc</code> holds the <code>StoreOpaque</code>, but we actually want to hold the <code>StoreInner&lt;T&gt;</code> if we want to be able to pass out a <code>StoreContextMut</code>.</p>\n<p>It seems like we should define traits that morally wrap the <code>StoreOpaque</code>, and are sufficient to get at Wasm-accessible objects (linear memories, tables, GC), since none of those can be dependent on the host-side <code>T</code> anyway; and then add the right impls to make that automatically work as before with <code>AsContextMut</code>-types. Function calls still need the monomorphized <code>StoreContextMut</code> because a <code>Caller</code> can pop out the other end that needs the <code>T</code>. Stated succinctly: access to Wasm data should not need <code>T</code> so is not monomorphized; calls to Wasm code does need <code>T</code> so is monomorphized. Thoughts?</p>\n</blockquote>",
        "id": 544258485,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760135857
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835#issuecomment-3392502138\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835\">issue #11835</a>:</p>\n<blockquote>\n<p>(cc @alexcrichton @fitzgen)</p>\n</blockquote>",
        "id": 544258507,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760135871
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835#issuecomment-3392503632\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835\">issue #11835</a>:</p>\n<blockquote>\n<p>I'll throw out the names <code>AsOpaqueContext</code> / <code>AsOpaqueContextMut</code> with the full expectation that the bikeshed machinery will generate better names than that, if we go this way :-)</p>\n</blockquote>",
        "id": 544258607,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760135926
    },
    {
        "content": "<p><a href=\"https://github.com/cfallin\">cfallin</a> added the wasmtime:debugging label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835\">Issue #11835</a>.</p>",
        "id": 544261255,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760137545
    },
    {
        "content": "<p><a href=\"https://github.com/cfallin\">cfallin</a> added the wasmtime:api label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835\">Issue #11835</a>.</p>",
        "id": 544261256,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760137546
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835#issuecomment-3397914666\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835\">issue #11835</a>:</p>\n<blockquote>\n<p>My hunch is that this would not be easy to retrofit onto the preexisting API without redesigning/rethinking most of the rest of it. There's no concept, for example, of a <code>StoreOpaque</code> in Wasmtime's public API. That means that it would only possibly be introduced with these new <code>AsOpaque*</code> traits that would be implemented for various objects. If an API takes a <code>T: AsOpaque*</code>, though, then it probably also wants to take <code>T: AsContext*</code> which implies a number of blanket impls for these traits too. We would then, in theory, want to go back to all the preexisting APIs in Wasmtime and audit them to see if they need opaque-ness or not. Basically my hunch is that this would be a pretty large undertaking and not something we can just tack on relatively easily.</p>\n<p>That being said the technical points you're raising are still valid, but they can be solved today. Elsewhere the generic entrypoint with <code>T: AsContextMut</code> is dispatched with a one-liner to something that takes <code>&amp;StoreOpaque</code> or similar. That means that the cost of monomorphization is pretty minimal. Data-structure-wise if the <code>T</code> is irrelevant then there could be <code>struct ThingOpaque</code> which everything is implemented in terms of and <code>struct Thing&lt;T&gt;</code> with a <code>PhantomData&lt;T&gt;</code> or similar. Basically there's various ways to slice and dice the internal implementation to not plumb generics everywhere (which I agree is undesirable, that's the whole point <code>StoreOpaque</code> exists)</p>\n<blockquote>\n<p>This is possible (and I've done it in the draft <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">https://github.com/bytecodealliance/wasmtime/pull/11826</a> in the latest commit), and I believe it's still sound (one can view a \"debugger pause\" as like a hostcall; so it morally has access to whatever a Caller has access to, and Caller impls AsContextMut), but I don't like it because it forces over-monomorphization: it means that the whole debugger API gets the T from the Store. It also interacts somewhat poorly with internals: for example, AutoAssertNoGc holds the StoreOpaque, but we actually want to hold the StoreInner&lt;T&gt; if we want to be able to pass out a StoreContextMut.</p>\n</blockquote>\n<p>There's a lot competing here unfortunately. If the user-visible type is <code>AsContextMut</code>, then it's impossible to prevent <code>thing.as_context_mut().gc()</code> which means that <code>AutoAssertNoGc</code> can't be what's stored at-rest anyway. In general providing <code>AsContextMut</code> to a suspended computation is also something we've at least, so far, carefully not had to deal with. Not to say it can't be dealt with, but orthogonal to the monomorphization concerns we'll need to carefully map this out as it's a pretty major new power for embedders.</p>\n</blockquote>",
        "id": 544575668,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760368123
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835#issuecomment-3398091021\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835\">issue #11835</a>:</p>\n<blockquote>\n<blockquote>\n<p>There's a lot competing here unfortunately. If the user-visible type is <code>AsContextMut</code>, then it's impossible to prevent <code>thing.as_context_mut().gc()</code> which means that <code>AutoAssertNoGc</code> can't be what's stored at-rest anyway. In general providing <code>AsContextMut</code> to a suspended computation is also something we've at least, so far, carefully not had to deal with. Not to say it can't be dealt with, but orthogonal to the monomorphization concerns we'll need to carefully map this out as it's a pretty major new power for embedders.</p>\n</blockquote>\n<p>I was worried about that too -- but the mental breakthrough for me at least (after also writing the initial issue description, so this is new) came with thinking about debug-step yields as <em>hostcalls</em> rather than (say) future yields from a suspended computation. (That's what I meant by \"The dynamic store ownership protocol basically works with the safe Rust restrictions there too: one can get at the store only when the Wasm code yields, which is morally like a hostcall that passes a reborrowed &amp;mut Store back.\" over in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826#issuecomment-3395423839\">this comment</a> on the draft PR -- apologies for thinking spreading across two places!) In essence, think of every breakpoint sequence-point (a <code>ud2</code>/<code>brk</code>/... under the hood) or trapping load or whatever as morally containing an optional call that reborrows the store flowing through the Wasm code. The only difference is in the plumbing: the call happens through a mechanism of redirecting PC on a signal and taking the <code>*mut VMContext</code> from somewhere else (TLS).</p>\n<p>In that frame, I don't see this as any different from <code>Caller</code>. However your example of GC does raise one realization for me: this means that every trapping instruction, including sequence points, now needs to be a safepoint to the user-stack-map code. That's doable I think, and once we do that, I <em>believe</em> it's actually fine to have a GC happen while in a debug-step yield and while examining the stack: the GC values on the stack are rooted now, even in the instrumentation slots.</p>\n<p>If we agree that makes sense, I don't think we even <em>need</em> to make this distinction in the API for soundness, it's just a monomorphization-minimization thing. I'm actually somewhat ambivalent whether that matters much with the debug host happening mainly on developer platforms (since R/R covers capturing bugs on embedded and that shouldn't require the full instrumentation-based API).</p>\n</blockquote>",
        "id": 544583997,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760370839
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835#issuecomment-3398597560\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835\">issue #11835</a>:</p>\n<blockquote>\n<p>Ok yeah that all makes sense to me yeah. I also don't know of anything concretely bad that could happen if the store is accessed while wasm is suspended. I think I'm mostly just scared of it as it's a new \"superpower\" that we haven't previously provided access to.</p>\n</blockquote>",
        "id": 544603649,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760379687
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835#issuecomment-3398962899\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835\">issue #11835</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think I'm mostly just scared of it as it's a new \"superpower\" that we haven't previously provided access to.</p>\n</blockquote>\n<p>Yes, debuggers can mess with all your internals in potentially surprising and perhaps unpleasant ways. That's unfortunately just how it goes.</p>\n<p>But this does highlight that debugging APIs are a kind of \"new\"/\"separate\" API from the \"regular\" embedding API. Another example of this, beyond being able to pause and run host code that potentially mutates linear memory (for example) at non-call program points, is the ability to get and mutate non-exported entities. We want the debugger API to be able to enumerate/access/mutate <em>all</em> Wasm globals, tables, memories, functions, etc... and not <em>only</em> the ones that are explicitly exported. We also might want to allow the debugger APIs to mutate non-<code>mut</code> globals. We definitely want to give the debugger APIs the ability to call into and out of components in ways that would otherwise trap due to the enter/exit component flags.</p>\n<p>So given that these debugging APIs really do provide new abilities, I think we should also consider the idea that we might not want to reuse the existing types and methods for our new debugging APIs. Maybe we create <code>Debug{Store,Caller,Context}</code> types and the new debugging APIs explicitly take these things as context instead of a regular <code>Store</code> or whatever? And you only get these via the top-level callback/coroutine debugging APIs we are discussing in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11826\">https://github.com/bytecodealliance/wasmtime/pull/11826</a> ? These new types could use a lifetime, perhaps, to capture the invariants around where you are paused and when you can e.g. access a stack frame's locals.</p>\n<p>Not actually sure that bifurcating the APIs is the best way forward, but I think it is worth exploring the possibility.</p>\n</blockquote>",
        "id": 544617820,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760387371
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835#issuecomment-3399004338\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835\">issue #11835</a>:</p>\n<blockquote>\n<p>All of that could make a lot of sense, and I am just now realizing that indeed we'll need to have a way to get at at least private memories even for the most basic component-debugging use-case. (I was p1-brained and was assuming the memory would be exported; nope!) That said, I think there is also a kind of less abstracted way to get this:</p>\n<ul>\n<li>the <code>DebugSession</code> can directly have methods that reach into instances and provide a <code>Memory</code> or <code>Global</code> or Table<code> for a private entity. The resulting handle would work with all the same accessors that take a mut store as today; the only access control is at the point that one wants to get the handle. This replaces </code>DebugContext`, because there's really only one \"debug context\".</li>\n<li>we continue to provide the equivalent of <code>Caller</code> (<code>AsContextMut</code>) as an impl on the <code>DebugSession</code>; when it yields from <code>next</code> and we have mut access to it, we can use the session as context to get at data and mutate arbitrarily. In other words, not do the abstraction to avoid monomorphization that this issue initially suggested.</li>\n</ul>\n</blockquote>",
        "id": 544619038,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760388112
    },
    {
        "content": "<p>fitzgen edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835#issuecomment-3399004338\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835\">issue #11835</a>:</p>\n<blockquote>\n<p>All of that could make a lot of sense, and I am just now realizing that indeed we'll need to have a way to get at at least private memories even for the most basic component-debugging use-case. (I was p1-brained and was assuming the memory would be exported; nope!) That said, I think there is also a kind of less abstracted way to get this:</p>\n<ul>\n<li>the <code>DebugSession</code> can directly have methods that reach into instances and provide a <code>Memory</code> or <code>Global</code> or <code>Table</code> for a private entity. The resulting handle would work with all the same accessors that take a mut store as today; the only access control is at the point that one wants to get the handle. This replaces <code>DebugContext</code>, because there's really only one \"debug context\".</li>\n<li>we continue to provide the equivalent of <code>Caller</code> (<code>AsContextMut</code>) as an impl on the <code>DebugSession</code>; when it yields from <code>next</code> and we have mut access to it, we can use the session as context to get at data and mutate arbitrarily. In other words, not do the abstraction to avoid monomorphization that this issue initially suggested.</li>\n</ul>\n</blockquote>",
        "id": 544624297,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760391759
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11835\">issue #11835</a>:</p>\n<blockquote>\n<p>Most of the public API surface for working with Wasm-visible storage in Wasmtime takes an <code>AsContextMut</code> parameter. For random examples, <a href=\"https://docs.rs/wasmtime/37.0.1/wasmtime/struct.StructRef.html#method.field\"><code>StructRef::field</code></a>, <a href=\"https://docs.rs/wasmtime/37.0.1/wasmtime/struct.Memory.html#method.data\"><code>Memory::data</code></a>, and <a href=\"https://docs.rs/wasmtime/37.0.1/wasmtime/struct.Table.html#method.get\"><code>Table::get</code></a> all take either an <code>AsContext</code>/<code>AsContextMut</code> or an <code>Into&lt;StoreContext{,Mut}&gt;</code>.</p>\n<p>It makes sense that accessors require \"the store\" (in some vague sense) to access the linear memories, tables, and GC heap, because all of these units of storage are owned by the store.</p>\n<p>However, in the context of the guest-debugging API, it turns out that we need to expose an <code>AsContextMut</code> from the \"debug session\" handle type in #11826, because without that, while the debug session owns the store, there is no way to actually <em>do</em> anything with GC refs that one reads out, or read data in the linear memories, etc. In other words, regular debugger access will want to get at the guest's data and objects.</p>\n<p>Likewise, In #11769 I put accessors for the values on stack (locals and operand stack) directly on a <code>StackView</code>, and this suffices for core Wasm types (ints/floats/vectors) but as soon as one actually wants to examine a GC ref that one reads out, one will want an <code>AsContextMut</code>.</p>\n<p>This is possible (and I've done it in the draft #11826 in the latest commit), and I believe it's still sound (one can view a \"debugger pause\" as like a hostcall; so it morally has access to whatever a <code>Caller</code> has access to, and <code>Caller</code> impls <code>AsContextMut</code>), but I don't like it because it forces over-monomorphization: it means that the whole debugger API gets the <code>T</code> from the <code>Store</code>. It also interacts somewhat poorly with internals: for example, <code>AutoAssertNoGc</code> holds the <code>StoreOpaque</code>, but we actually want to hold the <code>StoreInner&lt;T&gt;</code> if we want to be able to pass out a <code>StoreContextMut</code>.</p>\n<p>It seems like we should define traits that morally wrap the <code>StoreOpaque</code>, and are sufficient to get at Wasm-accessible objects (linear memories, tables, GC), since none of those can be dependent on the host-side <code>T</code> anyway; and then add the right impls to make that automatically work as before with <code>AsContextMut</code>-types. Function calls still need the monomorphized <code>StoreContextMut</code> because a <code>Caller</code> can pop out the other end that needs the <code>T</code>. Stated succinctly: access to Wasm data should not need <code>T</code> so is not monomorphized; calls to Wasm code does need <code>T</code> so is monomorphized. Thoughts?</p>\n</blockquote>",
        "id": 545452704,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760653505
    }
]