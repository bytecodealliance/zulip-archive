[
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a> from <code>fitzgen:impl-oom-handling-secondary-map-from-scratch</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>I realized we need to adjust its <code>V: Clone</code> bound into <code>V: TryClone</code> which means<br>\nthat we can no longer actually just wrap an inner<br>\n<code>cranelift_entity::SecondaryMap&lt;K, V&gt;</code> and need to instead implement our<br>\nown. This also made me realize that we need <code>remove</code> to be fallible because,<br>\nwhen the entry being removed is in bounds, it overwrites the entry with the<br>\ndefault value, but that default value needs to be <code>TryClone</code>d now which is, of<br>\ncourse, a fallible operation.</p>\n<p>Depends on</p>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12615\">https://github.com/bytecodealliance/wasmtime/pull/12615</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12616\">https://github.com/bytecodealliance/wasmtime/pull/12616</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12617\">https://github.com/bytecodealliance/wasmtime/pull/12617</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12618\">https://github.com/bytecodealliance/wasmtime/pull/12618</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12619\">https://github.com/bytecodealliance/wasmtime/pull/12619</a></li>\n</ul>\n</blockquote>",
        "id": 574602999,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771448618
    },
    {
        "content": "<p>fitzgen requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>.</p>",
        "id": 574603002,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771448619
    },
    {
        "content": "<p>fitzgen requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-fuzz-reviewers\">wasmtime-fuzz-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>.</p>",
        "id": 574603003,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771448619
    },
    {
        "content": "<p>fitzgen requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers\">wasmtime-compiler-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>.</p>",
        "id": 574603005,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771448619
    },
    {
        "content": "<p>fitzgen requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>.</p>",
        "id": 574603007,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771448619
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<p>I realized we need to adjust its <code>V: Clone</code> bound into <code>V: TryClone</code> which means<br>\nthat we can no longer actually just wrap an inner<br>\n<code>cranelift_entity::SecondaryMap&lt;K, V&gt;</code> and need to instead implement our<br>\nown. This also made me realize that we need <code>remove</code> to be fallible because,<br>\nwhen the entry being removed is in bounds, it overwrites the entry with the<br>\ndefault value, but that default value needs to be <code>TryClone</code>d now which is, of<br>\ncourse, a fallible operation.</p>\n<p>Depends on</p>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12615\">https://github.com/bytecodealliance/wasmtime/pull/12615</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12616\">https://github.com/bytecodealliance/wasmtime/pull/12616</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12617\">https://github.com/bytecodealliance/wasmtime/pull/12617</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12619\">https://github.com/bytecodealliance/wasmtime/pull/12619</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12620\">https://github.com/bytecodealliance/wasmtime/pull/12620</a></li>\n</ul>\n</blockquote>",
        "id": 574606734,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771449976
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3923535952\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<p>I'll be honest in that I continue to not really understand <code>SecondaryMap</code> as a data structure as it seems so niche to almost never be applicable... Do we actually have any usages of the map which need this <code>TryClone</code> bound? Could we, for example, switch this a <code>Copy</code> bound on the key? </p>\n</blockquote>",
        "id": 574615848,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771453585
    },
    {
        "content": "<p>github-actions[bot] added the label <code>fuzzing</code> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>.</p>",
        "id": 574639995,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771468380
    },
    {
        "content": "<p>github-actions[bot] added the label <code>wasmtime:ref-types</code> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>.</p>",
        "id": 574639996,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771468380
    },
    {
        "content": "<p>github-actions[bot] added the label <code>cranelift</code> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>.</p>",
        "id": 574639997,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771468380
    },
    {
        "content": "<p>github-actions[bot] added the label <code>wasmtime:api</code> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>.</p>",
        "id": 574639998,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771468380
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3924342243\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"cranelift\", \"fuzzing\", \"wasmtime:api\", \"wasmtime:ref-types\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: fuzzing, wasmtime:ref-types</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 574640050,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771468424
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3928358555\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'll be honest in that I continue to not really understand <code>SecondaryMap</code> as a data structure as it seems so niche to almost never be applicable...</p>\n</blockquote>\n<p>It is for whenever you want to associate extra data with a <code>PrimaryMap</code>'s key on the side (sort of struct-of-arrays style), and it also supports use cases where potentially not every key has extra data / there is a default value for the extra data.</p>\n<p>For example, in the <code>TypeRegistry</code> we (morally) have a <code>PrimaryMap&lt;VMSharedTypeIndex, Arc&lt;WasmSubType&gt;&gt;</code> but we also want to be able to map from a type to its GC layout, if any, so we have a <code>SecondaryMap&lt;VMSharedTypeIndex, Option&lt;GcLayout&gt;&gt;</code> on the side as well.</p>\n<blockquote>\n<p>Do we actually have any usages of the map which need this <code>TryClone</code> bound? Could we, for example, switch this a <code>Copy</code> bound on the key?</p>\n</blockquote>\n<p>The key is already bounded by <code>EntityRef</code>, which implies <code>Copy</code>. The <code>TryClone</code> bound is for <em>values</em>. And yes, we do have non-<code>Copy</code> values in <code>SecondaryMap</code>s that need to be <code>try_clone</code>d (such as <code>GcLayout</code> in the previous example).</p>\n</blockquote>",
        "id": 574770864,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771518492
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3928394331\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<blockquote>\n<p>It is for whenever you want to associate extra data with a PrimaryMap's key on the side (sort of struct-of-arrays style), and it also supports use cases where potentially not every key has extra data / there is a default value for the extra data.</p>\n</blockquote>\n<p>To say it another way that may also help (I've had this question too in the past):</p>\n<ul>\n<li><code>PrimaryMap</code>s manage/allocate the ID space, and are dense (<code>Vec</code> internally);</li>\n<li><code>SecondaryMap</code>s are given existing IDs, and are dense;</li>\n<li><code>HashMap</code>s, the other corner in common use, are given existing IDs and are sparse.</li>\n</ul>\n<p>So in Cranelift we tend to use them where we know <em>most</em> IDs will have an entry. Using a <code>PrimaryMap</code> would be incorrect as it would allocate different IDs.</p>\n</blockquote>",
        "id": 574772180,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771518859
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>.</p>",
        "id": 574804257,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771528274
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3929451824\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<p>Setting aside my reservations about <code>SecondaryMap</code> for a second, my main concern here is duplication of data structures. I think it's fine and reasonable to have API duplication as we do today but implementation duplication feels a step too far. One possible way to resolve this is to implement today's <code>SecondaryMap</code> in terms of <code>KSecondaryMap</code> (assuming we go with <code>K*</code>), but I realize that this wouldn't be trivial given the lack of relationship between <code>Clone</code> and <code>TryClone</code>.</p>\n<p>Bringing back my reservations about <code>SecondaryMap</code>, the main thing I find weird about it is that it's sort of trying to be a <code>HashMap&lt;K, V&gt;</code> without exposing the fact that it's actually a dense map under the hood. The API surface area is focused around insert/remove/etc which gives it a feeling, in my opinion at least, of being more efficient than it actually is. I would personally prefer to see Wasmtime's <code>SecondaryMap</code>s modeled as a <code>PrimaryMap</code> instead with perhaps methods on <code>PrimaryMap</code> to do helper-like things such as (fill with N values of T then push this other value of T at the specified index). That, to me, would appropriately model the runtime behavior here where <code>insert</code> is O(N), not O(1).</p>\n<p>The reason I also bring this up is that I don't feel this extra data structure implementation is necessarily justified. In practice the default value for <code>V</code> is always <code>None</code> or <code>PackedOption::none()</code> for all <code>SecondaryMap</code>s in the <code>TypeRegistry</code>. That means that while I agree conceptually the bounds on <code>KSecondaryMap</code> should be <code>TryClone</code> we wouldn't actually benefit from such a generalization anywhere. Or did you run in to a case preexisting in Wasmtime where <code>V: TryClone</code> was needed since an allocation could fail? My assumption would be that if we modeled things as <code>PrimaryMap</code> it would more naturally lend itself where the secondary-map-like-helper-methods would take <code>V: TryClone</code> and work appropriately.</p>\n</blockquote>",
        "id": 574807226,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771529291
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3929526229\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<blockquote>\n<p>Bringing back my reservations about SecondaryMap, the main thing I find weird about it is that it's sort of trying to be a HashMap&lt;K, V&gt; without exposing the fact that it's actually a dense map under the hood. The API surface area is focused around insert/remove/etc which gives it a feeling, in my opinion at least, of being more efficient than it actually is. </p>\n</blockquote>\n<p>It might be good to understand whether this is the case or not more objectively. Picking one use-site in the type interner, for example, <a href=\"https://github.com/bytecodealliance/wasmtime/blob/fd7418ed5ce8cc254275c4f325beb0d88ec785a3/crates/environ/src/module_types.rs#L16\">here</a> (<code>ModuleTypes::trampoline_types</code>), it appears that there are entries for function types but not other (GC-related) types, is that right? If so we expect this to be dense-ish for core modules and non-GC-using components, but maybe not otherwise? Can we measure this? What other use-sites are there and how do they fare? (cc @fitzgen on this I guess)</p>\n<p>More broadly: I'm somewhat concerned that we're discussing the existential fate of <code>SecondaryMap</code> alongside and intertwined with questions of implementation strategy. It exists for good reason in Cranelift; the places where it's used, it is dense in practice (e.g.: a map of result value-lists for every <code>Inst</code>; every instruction has one of those, but the map is not in charge of ID allocation), and I would hope it's used for similar reasons in <code>wasmtime-environ</code>.</p>\n<p>And we should be clear about both asymptotic and implementation efficiency: (i) the <code>Vec</code> is much more efficient than a <code>HashMap</code> at such use-cases because it doesn't need to store the explicit keys, and access patterns are less random and involve less logic; (ii) the statement \"That, to me, would appropriately model the runtime behavior here where insert is O(N), not O(1).\" is incorrect for any key space whose size is linear in the input program: there can only be at most O(#keys) pushes onto the end of the <code>Vec</code>; new-key inserts are thus amortized O(1) and existing-key updates are deterministic O(1).</p>\n<p>I think we should satisfy ourselves that we do need the data structure, get everyone on that page, and then move discussion on toward only how to implement it.</p>\n</blockquote>",
        "id": 574809964,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771530258
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3929551206\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<p>Also: @alexcrichton in addition to thoughts on the above, could you clarify what you mean by \"model things as PrimaryMap\"? A SecondaryMap is fundamentally different in that it associates values with existing IDs, while a PrimaryMap allocates new IDs for values that are inserted, so one can't be replaced with the other.</p>\n</blockquote>",
        "id": 574810643,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771530505
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3930193405\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<p>Sorry I'm doing my best to disentangle my bias against <code>SecondaryMap</code> from my concerns here, and I'm not doing a great job. At a base level my main concern is this is (a) duplicating a data structure that (b) I don't think is necessary. Specifically the <code>V: TryClone</code> while semantically correct I don't think is ever exercised in practice because the default for these maps is always <code>None</code> or something where <code>Clone</code> at runtime is just shuffling bytes and doing no allocation. I don't think it's worth having an entire duplicate implementation of this data structure for a feature that's not actually used, personally.</p>\n<p>I still want to clarify, though, what's the imapct of not having this PR at all? Does this actively block some OOM-handling work for example? My current understanding is that this fixes a footgun with <code>KSecondaryMap</code>, but it's not a footgun that we're currently able to fire. If this actively unblocks something then the situation is different.</p>\n<hr>\n<p>Orthogonally it's probably most productive for me to just keep my concerns about <code>SecondaryMap</code> to myself. I understand its theoretical use as a data structure and I'm not advocating for its removal from Cranelift. I'd like to minimize/remove its usage from Wasmtime personally, but that's orthogonal to this PR itself.</p>\n</blockquote>",
        "id": 574825196,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771536497
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3930238816\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'd like to minimize/remove its usage from Wasmtime personally, but that's orthogonal to this PR itself.</p>\n</blockquote>\n<p>Well, I guess that's why I'm asking about value-presence density for the specific use-cases in Wasmtime above. The one that I linked for func-type trampolines should be dense for most modules today, so using a <code>HashMap</code> would be a performance regression (and <code>PrimaryMap</code> is not an option; it's semantically different). So I guess that's what I'm trying to understand: we want to remove it from Wasmtime because of some subjective feeling, or because we believe other uses of it are actually less efficient at runtime?</p>\n</blockquote>",
        "id": 574826046,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771536815
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3930387445\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<p>I'm not actaully sure  what the best data structure for Wasmtime is, but my assumption is that we'd replace it with <code>PrimaryMap</code>. My understanding is that a <code>SecondaryMap&lt;K, V&gt;</code> is actually a <code>PrimaryMap&lt;K, V&gt;</code> where <code>V</code> has some sort of sentinel meaning \"none\" (e.g. <code>Option&lt;T&gt;</code> or <code>PackedOption&lt;I&gt;</code>). Given that I don't understand why <code>PrimaryMap</code> is not an option, because that's already more-or-less the implementation details of <code>SecondaryMap</code>. If I'm not misunderstanding, this is why I find <code>SecondaryMap</code> confusing, it's a <code>PrimaryMap</code> in a thin veil.</p>\n<p>As for the best data structure, we can construct things every which way: modules with the <code>SecondaryMap</code> empty, modules with <code>SecondaryMap</code> being dense, and modules with <code>SecondaryMap</code> having a huge gap followed by a single entry. The rough saving grace today is that most <code>SecondaryMaps</code> (I think) are only needed for GC-related which is still off-by-default meaning most of this isn't used, so it doesn't end up mattering in practice currently as it's rarely used. In all of these situations though I don't think there's an obvious answer -- hash maps would excel in some use cases and fall down in others. <code>SecondaryMap</code> shines in some use caes and falls down in others too. Without changing the algorithmic constraints of lookup (e.g. going to O(log(n))) I don't think we have great options.</p>\n</blockquote>",
        "id": 574830203,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771538578
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3930410444\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<blockquote>\n<p>but my assumption is that we'd replace it with <code>PrimaryMap</code>. My understanding is that a <code>SecondaryMap&lt;K, V&gt;</code> is actually a <code>PrimaryMap&lt;K, V&gt;</code> where <code>V</code> has some sort of sentinel meaning \"none\" (e.g. <code>Option&lt;T&gt;</code> or <code>PackedOption&lt;I&gt;</code>). Given that I don't understand why <code>PrimaryMap</code> is not an option, because that's already more-or-less the implementation details of <code>SecondaryMap</code>. If I'm not misunderstanding, this is why I find <code>SecondaryMap</code> confusing, it's a <code>PrimaryMap</code> in a thin veil.</p>\n</blockquote>\n<p>OK, so there's the root of the misunderstanding: the above is not true; a <code>SecondaryMap</code> is not a <code>PrimaryMap</code> with presence. The difference is in the API: as described <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3928394331\">above</a>, a <code>SecondaryMap</code> does not allocate keys. You use a <code>PrimaryMap</code> when you want to create a collection of things and have the container give you IDs as handles. You use a <code>SecondaryMap</code> when you already have IDs (handles) and want to associate some other data with them. Using a <code>PrimaryMap</code> in that case makes no sense, because all you can do is add a new <code>V</code>, and the map will allocate some other arbitrary <code>K</code> for you.</p>\n<p>Given all that, a <code>SecondaryMap</code> can be compared to a <code>HashMap</code>. This is the difference between a map and a vector, basically, at the abstract datatype API level.</p>\n</blockquote>",
        "id": 574830951,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771538866
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3936743898\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<p>To avoid getting sidetracked too much, I do want to say again that my <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3930193405\">primary concern</a> above I've tried to disentangle from my thoughts on <code>SecondaryMap</code> -- specifically this is duplicating a data structure for a feature that I don't believe we use. I understand the \"close the footgun\" motivation but I don't think that alone is enough to motivate the duplication.</p>\n<hr>\n<p>Otherwise personally I'm not really sure how the detail of allocating IDs or not leads to a misunderstanding here. There's nothing stopping us from adding APIs to <code>PrimaryMap</code> which make it operate like a <code>SecondaryMap</code> in some situations. That IDs are allocated feels to be but a side effect of an operation already happening. To me the underlying data structure implementation and big-O of methods is way more important than the conceptual operation happening. For example I don't think it makes sense to say <code>PrimaryMap</code> is entirely unsuitable for doing <code>SecondaryMap</code>'s job when it's 1-2 methods away from being able to do that.</p>\n<p>My overall point is that <code>SecondaryMap</code> runs the risk of being a very bad <code>HashMap</code>. It operates reasonably enough as a <code>HashMap</code> in specific situations and can spectacularly fall down in others. Papering over this, in my opinion very important, detail is doing the collection a disservice. For example a more apt name would be something like <code>DenseMap</code> which emphasizes that it is only really intended when the key space is particularly dense. </p>\n</blockquote>",
        "id": 575016537,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771616399
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3937171052\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621\">PR #12621</a>:</p>\n<blockquote>\n<p>A few thoughts:</p>\n<ul>\n<li>Sure, we can add methods to <code>PrimaryMap</code> that implement <code>SecondaryMap</code>'s semantics. I had thought you were saying above to replace uses of <code>SecondaryMap</code> with <code>PrimaryMap</code> directly, which is what I was responding to. But there's nothing wrong with adding an \"insert this value at this specified ID\" method, which fills out the array as necessary to ensure the slot for that ID exists.</li>\n<li>I'd agree that building a fallible <code>SecondaryMap</code> on top of a fallible <code>PrimaryMap</code> could be a nice way of factoring things. I don't see any such thing in the tree right now but I haven't been tracking the full stream of these PRs in flight so correct me if I'm wrong and it does exist somewhere...</li>\n<li>Re: \"for a feature that I don't believe we use.\" -- I believe that fitzgen gave an example <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3928358555\">here</a> of a value-type that is not <code>Copy</code>, and so needs <code>Clone</code> (hence <code>TryClone</code> in the fallible universe).</li>\n<li>Re: \"the underlying data structure implementation and big-O of methods is way more important than the conceptual operation happening.\" -- sure, and this is why I asked for information about the use-cases and density of the maps' key-spaces <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12621#issuecomment-3929526229\">here</a>. As mentioned in that comment, <code>SecondaryMap</code> has overall time and space bounded by the size of the keyspace; so if we expect a number of entries to be O(n) for <code>n</code>-sized program, then it has the same asymptotic complexity as a hashmap (amortized O(1) per operation), and better (possibly much better) constant factors. If the keyspace is sparse, then of course this isn't true anymore. I suspect the use-cases are driven by observation that those constant factors are important, and we want the performance, and reverting to a hashmap would be a real perf loss; but we should evaluate that as part of an effort to understand whether we need this data structure.</li>\n</ul>\n</blockquote>",
        "id": 575028413,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771621764
    }
]