[
    {
        "content": "<p>lann opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11449\">issue #11449</a>:</p>\n<blockquote>\n<blockquote>\n<p>This is similar to #2640 but is about pull rather than push metrics.</p>\n</blockquote>\n<p>The pooling allocator has <a href=\"https://docs.rs/wasmtime/35.0.0/wasmtime/struct.PoolingAllocationConfig.html\">a bunch of configurable limits</a>. It can be difficult to understand the runtime behavior of a system to decide how to tune those limits, so it would be helpful to expose some runtime metrics to embedders.</p>\n<p>For the API, we could crib from <a href=\"https://docs.rs/tokio/1.47.1/tokio/runtime/struct.Runtime.html#method.metrics\">tokio</a> with something like <code>Engine::metrics(&amp;self) -&gt; RuntimeMetrics</code> and <code>RuntimeMetrics::pooling_allocator_live_core_instances(&amp;self) -&gt; u64</code>.</p>\n<p>I've been looking at the allocator code and I think I have a rough understanding of how to implement what I'm most interested in:</p>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/blob/1292237f809c20d7587bf6471e51fd5edf913ca9/crates/wasmtime/src/runtime/vm/instance/allocator/pooling.rs#L304-L305\"><code>live_core_instances</code> and <code>live_component_instances</code></a>: these are already atomics so should be straightforward to report</li>\n<li>Used memory slots: I _think_ the used slot count can be derived from the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/1292237f809c20d7587bf6471e51fd5edf913ca9/crates/wasmtime/src/runtime/vm/instance/allocator/pooling/memory_pool.rs#L82\">stripe allocator(s)</a>. That approach would require taking a <code>Mutex</code> which seems OK in this context as long as metrics reporting frequency is limited. Alternatively the used slot count could be tracked separately in a new atomic.</li>\n<li>Used table slots: looks like the same story as <code>MemoryPoll</code>, potentially tracking via the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/1292237f809c20d7587bf6471e51fd5edf913ca9/crates/wasmtime/src/runtime/vm/instance/allocator/pooling/table_pool.rs#L20\">allocator</a></li>\n</ul>\n</blockquote>",
        "id": 534976614,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755531318
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11449#issuecomment-3197804698\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11449\">issue #11449</a>:</p>\n<blockquote>\n<p>Sounds like a very reasonable design to me! The only thing I'd to a minor bikeshed on is something like <code>Engine::pooling_allocator_metrics(&amp;self) -&gt; Option&lt;PoolingAllocatorMetrics&gt;</code> to handle the defaults-vs-pooling distinction. A general <code>Engine::metrics</code> could focus on generic things like instance count perhaps which makes sense to track for all allocators instead of just pooling.</p>\n</blockquote>",
        "id": 534993135,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755537965
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11449\">issue #11449</a>:</p>\n<blockquote>\n<blockquote>\n<p>This is similar to #2640 but is about pull rather than push metrics.</p>\n</blockquote>\n<p>The pooling allocator has <a href=\"https://docs.rs/wasmtime/35.0.0/wasmtime/struct.PoolingAllocationConfig.html\">a bunch of configurable limits</a>. It can be difficult to understand the runtime behavior of a system to decide how to tune those limits, so it would be helpful to expose some runtime metrics to embedders.</p>\n<p>For the API, we could crib from <a href=\"https://docs.rs/tokio/1.47.1/tokio/runtime/struct.Runtime.html#method.metrics\">tokio</a> with something like <code>Engine::metrics(&amp;self) -&gt; RuntimeMetrics</code> and <code>RuntimeMetrics::pooling_allocator_live_core_instances(&amp;self) -&gt; u64</code>.</p>\n<p>I've been looking at the allocator code and I think I have a rough understanding of how to implement what I'm most interested in:</p>\n<ul>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/blob/1292237f809c20d7587bf6471e51fd5edf913ca9/crates/wasmtime/src/runtime/vm/instance/allocator/pooling.rs#L304-L305\"><code>live_core_instances</code> and <code>live_component_instances</code></a>: these are already atomics so should be straightforward to report</li>\n<li>Used memory slots: I _think_ the used slot count can be derived from the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/1292237f809c20d7587bf6471e51fd5edf913ca9/crates/wasmtime/src/runtime/vm/instance/allocator/pooling/memory_pool.rs#L82\">stripe allocator(s)</a>. That approach would require taking a <code>Mutex</code> which seems OK in this context as long as metrics reporting frequency is limited. Alternatively the used slot count could be tracked separately in a new atomic.</li>\n<li>Used table slots: looks like the same story as <code>MemoryPoll</code>, potentially tracking via the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/1292237f809c20d7587bf6471e51fd5edf913ca9/crates/wasmtime/src/runtime/vm/instance/allocator/pooling/table_pool.rs#L20\">allocator</a></li>\n</ul>\n</blockquote>",
        "id": 535717407,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755879939
    }
]