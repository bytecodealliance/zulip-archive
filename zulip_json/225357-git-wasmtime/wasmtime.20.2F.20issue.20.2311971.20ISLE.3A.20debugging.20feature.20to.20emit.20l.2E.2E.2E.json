[
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971\">issue #11971</a>:</p>\n<blockquote>\n<p>To assist with debugging ISLE (e.g. you expect a rule to match but it doesn't), the <code>isle</code> crate should have an option to emit <code>log</code> macro invocations in the generated code.</p>\n<p>I'm imagining we would emit the following logs, or something similar:</p>\n<ul>\n<li>\n<p><code>log::debug!(...)</code> at the start of a constructor, logging which constructor we are executing. (Ideally, we would also log the arguments given, but that would require that we know that the arguments implement <code>Debug</code>, which I don't think we do? Failing that, if we wanted to get real fancy, we could do the thing where you approximate specialization by making impls for <code>&amp;T</code>, <code>&amp;&amp;T</code>, etc...)</p>\n</li>\n<li>\n<p>Each predicate we test as part of a term's rules' LHSes would have an associated <code>log::trace!(...)</code> that details which predicate is executing and then whether it matched or not.</p>\n</li>\n<li>\n<p>In each rule's RHS we would <code>log::debug!(...)</code> which rule we end up executing.</p>\n</li>\n<li>\n<p>Possibly, if none of a term's rules match, we log that fact as well. Not sure if we have erased this information by the time we emit code or not though, so it might not be possible.</p>\n</li>\n</ul>\n<p>To make this even more readable when debugging, it would be nice if we kept a thread-local or something containing the ISLE stack depth and indented our logs by that amount, so that you could see which constructor invocations were nested within others.</p>\n</blockquote>",
        "id": 553435026,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762189488
    },
    {
        "content": "<p><a href=\"https://github.com/fitzgen\">fitzgen</a> added the isle label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971\">Issue #11971</a>.</p>",
        "id": 553435028,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762189488
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971#issuecomment-3481592164\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971\">issue #11971</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @cfallin, @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"isle\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>cfallin: isle</li>\n<li>fitzgen: isle</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 553435196,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762189536
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971#issuecomment-3481605059\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971\">issue #11971</a>:</p>\n<blockquote>\n<p>Thanks for writing this up! I agree we should do this; also it might be a good first issue (I'll add the tag). One particular thought on</p>\n<blockquote>\n<p>but that would require that we know that the arguments implement Debug, which I don't think we do?</p>\n</blockquote>\n<p>I don't see a problem with adding this requirement if we don't have it yet; we control the main/only user of ISLE, the set of types that flow across the Rust/ISLE boundary are fairly small, are mostly little newtype wrappers, and even the big ones (<code>BoxCallInfo</code> as a <code>Box</code> of <code>CallInfo</code> returned from a helper) should be printable.</p>\n</blockquote>",
        "id": 553435769,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762189714
    },
    {
        "content": "<p><a href=\"https://github.com/cfallin\">cfallin</a> added the good first issue label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971\">Issue #11971</a>.</p>",
        "id": 553435813,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762189730
    },
    {
        "content": "<p>fitzgen edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971\">issue #11971</a>:</p>\n<blockquote>\n<p>To assist with debugging ISLE (e.g. you expect a rule to match but it doesn't), the <code>isle</code> crate should have an option to emit <code>log</code> macro invocations in the generated code.</p>\n<p>I'm imagining we would emit the following logs, or something similar:</p>\n<ul>\n<li>\n<p><code>log::debug!(...)</code> at the start of a constructor, logging which constructor we are executing. (Ideally, we would also log the arguments given, but that would require that we know that the arguments implement <code>Debug</code>, which I don't think we do? Failing that, if we wanted to get real fancy, we could do the thing where you approximate specialization by making impls for <code>&amp;T</code>, <code>&amp;&amp;T</code>, etc...)</p>\n</li>\n<li>\n<p>Each predicate we test as part of a term's rules' LHSes would have an associated <code>log::trace!(...)</code> that details which predicate is executing and then whether it matched or not.</p>\n</li>\n<li>\n<p>In each rule's RHS we would <code>log::debug!(...)</code> which rule we end up executing.</p>\n</li>\n<li>\n<p>Possibly, if none of a term's rules match, we log that fact as well. Not sure if we have erased this information by the time we emit code or not though, so it might not be possible.</p>\n</li>\n</ul>\n<p>To make this even more readable when debugging, it would be nice if we kept a thread-local or something containing the ISLE stack depth and indented our logs by that amount, so that you could see which constructor invocations were nested within others.</p>\n<p>Anyways, once we had this knob in the ISLE compiler, we should add a cargo feature to <code>cranelift-codegen</code> which enables/disables it. (Or maybe we just reuse the existing <code>trace-log</code> feature?)</p>\n</blockquote>",
        "id": 553462330,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762197238
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the cranelift:E-compiler-easy label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971\">Issue #11971</a>.</p>",
        "id": 554150812,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762450328
    },
    {
        "content": "<p>bahbah94 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971#issuecomment-3506464914\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971\">issue #11971</a>:</p>\n<blockquote>\n<p>I can have a crack at this issue, will be going through the source code, any particular source file that is of interest, i would be happy to look into( I'm new to cranelift or compilers in general).</p>\n</blockquote>",
        "id": 554475330,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762601260
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971#issuecomment-3529317673\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971\">issue #11971</a>:</p>\n<blockquote>\n<p>@bahbah94 you'll want to look at the codegen from the ISLE-to-Rust compiler in <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/cranelift/isle/isle/src/codegen.rs\">this</a> file. That generates Rust source code that is then compiled as part of the main Cranelift crate.</p>\n</blockquote>",
        "id": 555438300,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763061245
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11971\">issue #11971</a>:</p>\n<blockquote>\n<p>To assist with debugging ISLE (e.g. you expect a rule to match but it doesn't), the <code>isle</code> crate should have an option to emit <code>log</code> macro invocations in the generated code.</p>\n<p>I'm imagining we would emit the following logs, or something similar:</p>\n<ul>\n<li>\n<p><code>log::debug!(...)</code> at the start of a constructor, logging which constructor we are executing. (Ideally, we would also log the arguments given, but that would require that we know that the arguments implement <code>Debug</code>, which I don't think we do? Failing that, if we wanted to get real fancy, we could do the thing where you approximate specialization by making impls for <code>&amp;T</code>, <code>&amp;&amp;T</code>, etc...)</p>\n</li>\n<li>\n<p>Each predicate we test as part of a term's rules' LHSes would have an associated <code>log::trace!(...)</code> that details which predicate is executing and then whether it matched or not.</p>\n</li>\n<li>\n<p>In each rule's RHS we would <code>log::debug!(...)</code> which rule we end up executing.</p>\n</li>\n<li>\n<p>Possibly, if none of a term's rules match, we log that fact as well. Not sure if we have erased this information by the time we emit code or not though, so it might not be possible.</p>\n</li>\n</ul>\n<p>To make this even more readable when debugging, it would be nice if we kept a thread-local or something containing the ISLE stack depth and indented our logs by that amount, so that you could see which constructor invocations were nested within others.</p>\n<p>Anyways, once we had this knob in the ISLE compiler, we should add a cargo feature to <code>cranelift-codegen</code> which enables/disables it. (Or maybe we just reuse the existing <code>trace-log</code> feature?)</p>\n</blockquote>",
        "id": 566702043,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1767781531
    }
]