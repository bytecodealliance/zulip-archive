[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10930\">issue #10930</a>:</p>\n<blockquote>\n<p>Discussed in today's Wasmtime meeting I'd like to open this issue on the topic of improving reliability of <code>apt-get install</code> in CI. The background here is:</p>\n<ul>\n<li>We build release binaries for Wasmtime in older docker images for increased glibc compatibility</li>\n<li>Release binaries start from \"blank\" older docker images and must, for example, <code>apt-get install</code> packages like <code>gcc</code></li>\n<li>This process of installation can fail, as seen on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10891\">https://github.com/bytecodealliance/wasmtime/issues/10891</a>, and can sometimes fail quite a lot<ul>\n<li>No concrete understanding of what's happening here, but hunch is that github actions runners got block-listed for awhile which meant that nothing worked.</li>\n</ul>\n</li>\n</ul>\n<p>There's three major ways we discussed of improving reliabilty here:</p>\n<h2>Use static linking for binaries</h2>\n<p>This would involve switching to <code>*-musl</code> targets in Rust instead of using <code>*-gnu</code> targets. While I at least personally know how to build static binaries on x86_64 I'm less certain that other architectures like s390x/aarch64/riscv64 are supported from the Rust side of things. This also comes with a downside of musl, for example, generally having poorer allocator performance than glibc. I'll note that I'm not too worried about binary size concerns with static linking in that the <code>wasmtime</code> binary is already quite large due to including all the features and so adding in musl wouldn't add too much on top.</p>\n<h2>Use pre-built docker images instead of blank ones</h2>\n<p>If we were, for example, to use <code>ghcr.io</code> then we could \"simply\" download the image and then run within that image, no package installation necessary. The assumption here is that downloading the image is probably more reliable than installing packages (especially if it's GitHub infrastructure already). The main downside with this (in my opinion) is orchestrating these images. We have a nice property today where if you want to change a docker image it can be done in the PR itself to this repository. Preserving this property, e.g. making it easy to change the images, can be somewhat difficult depending on the solution here.</p>\n<p>For example one option to do this is to move all our docker images to a separate repository. This repository would presumably, for each push to <code>main</code>, publish new docker images. This wouldn't happen too often but it would mean that changing something in this repository would require changes in two repositories and orchestrating that.</p>\n<p>Another possible option would be to build/publish images from this repository but that would require some degree of finesse and fanciness in <code>*.yml</code> CI configurations which at least I'm not personally certain how to do. (anyone else have experience with this?)</p>\n<h2>Use alternative package mirrors</h2>\n<p>Another option would be to expand the set of mirrors that are used by default for package installation. I believe that <code>archive.ubuntu.com</code> is used by default, and I don't think any other mirrors are enabled by default. Personally I don't actually even know how to concretely configure this beyond knowing that it should be possible. So sort of like the pre-built images, does anyone have experience with this? Should we drop some \"one liners\" in our images to, by default, pull in more mirrors? </p>\n</blockquote>",
        "id": 522631723,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749141218
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the ci label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10930\">Issue #10930</a>.</p>",
        "id": 522631724,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749141218
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10930#issuecomment-2945876665\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10930\">issue #10930</a>:</p>\n<blockquote>\n<p>In writing up <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10931\">https://github.com/bytecodealliance/wasmtime/issues/10931</a> I've realize that we can't drop the glibc builds in favor of musl because of the <code>libwasmtime.{a,so}</code> artifacts we produce which don't have the same flexibility of \"just needs to run\" as the <code>wasmtime</code> binary. So while we could only produce <code>wasmtime</code>-the-CLI as musl we'll still need to use glibc and musl for C API libraries we build</p>\n</blockquote>",
        "id": 522658350,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1749152343
    }
]