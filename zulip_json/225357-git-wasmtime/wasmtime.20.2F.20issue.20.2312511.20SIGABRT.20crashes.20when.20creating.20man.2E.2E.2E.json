[
    {
        "content": "<p>zacharywhitley opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<h1>SIGABRT crashes when creating many engines/modules due to GLOBAL_CODE registry address reuse</h1>\n<h2>Summary</h2>\n<p>When creating and destroying many <code>wasmtime::Engine</code> and <code>wasmtime::Module</code> instances in a single process, the <code>GLOBAL_CODE</code> registry's <code>assert!()</code> statements cause SIGABRT crashes after approximately 350-400 iterations. This is caused by virtual address reuse before Arc references are fully released.</p>\n<h2>Environment</h2>\n<ul>\n<li><strong>Wasmtime version</strong>: 41.0.1 (also confirmed in recent main)</li>\n<li><strong>Platform</strong>: macOS Darwin 24.5.0, Linux</li>\n<li><strong>Configuration</strong>: <code>signals_based_traps(false)</code> (required for JVM integration)</li>\n</ul>\n<h2>Reproduction</h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">wasmtime</span><span class=\"p\">::{</span><span class=\"n\">Config</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"p\">};</span>\n\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">wat</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"(module (func (export </span><span class=\"se\">\\\"</span><span class=\"s\">test</span><span class=\"se\">\\\"</span><span class=\"s\">) (result i32) i32.const 42))\"</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">500</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">config</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Config</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">config</span><span class=\"p\">.</span><span class=\"n\">signals_based_traps</span><span class=\"p\">(</span><span class=\"kc\">false</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">engine</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Engine</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">config</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_module</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Module</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">wat</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"c1\">// Engine and module dropped here</span>\n\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"mi\">100</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"fm\">eprintln!</span><span class=\"p\">(</span><span class=\"s\">\"Iteration {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Completed all iterations\"</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p><strong>Expected</strong>: All 500 iterations complete successfully.<br>\n<strong>Actual</strong>: Process aborts with SIGABRT around iteration 350-400.</p>\n<h2>Root Cause Analysis</h2>\n<h3>The Problem</h3>\n<p>In <code>crates/wasmtime/src/runtime/module/registry.rs</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">register_code</span><span class=\"p\">(</span><span class=\"n\">image</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Arc</span><span class=\"o\">&lt;</span><span class=\"n\">CodeMemory</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">address</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">prev</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">global_code</span><span class=\"p\">().</span><span class=\"n\">write</span><span class=\"p\">().</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">end</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">image</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">()));</span>\n<span class=\"w\">    </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">prev</span><span class=\"p\">.</span><span class=\"n\">is_none</span><span class=\"p\">());</span><span class=\"w\">  </span><span class=\"c1\">// ABORTS if duplicate key</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">unregister_code</span><span class=\"p\">(</span><span class=\"n\">address</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">global_code</span><span class=\"p\">().</span><span class=\"n\">write</span><span class=\"p\">().</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">end</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">code</span><span class=\"p\">.</span><span class=\"n\">is_some</span><span class=\"p\">());</span><span class=\"w\">  </span><span class=\"c1\">// ABORTS if key not found</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<h3>Why This Happens</h3>\n<ol>\n<li>Engine A allocates code memory at virtual address range <code>[0x1000, 0x2000)</code></li>\n<li><code>register_code</code> registers this with key <code>0x1FFF</code> (end - 1)</li>\n<li>Engine A is \"dropped\" but <code>Arc&lt;CodeMemory&gt;</code> references may still exist (from Module, Store, etc.)</li>\n<li>Engine B is created; the OS reuses virtual address <code>[0x1000, 0x2000)</code> for its code</li>\n<li><code>register_code</code> tries to insert key <code>0x1FFF</code> again</li>\n<li><code>assert!(prev.is_none())</code> fails → <strong>SIGABRT</strong></li>\n</ol>\n<p>The reverse can also happen:</p>\n<ol>\n<li>Old <code>Arc&lt;CodeMemory&gt;</code> finally deallocates, calling <code>unregister_code</code></li>\n<li>But the new engine already re-registered at that address</li>\n<li><code>unregister_code</code> removes the new engine's registration</li>\n<li>Later, new engine's drop calls <code>unregister_code</code></li>\n<li><code>assert!(code.is_some())</code> fails → <strong>SIGABRT</strong></li>\n</ol>\n<h3>Why ~350-400 Iterations?</h3>\n<p>This threshold corresponds to when virtual address reuse becomes statistically likely given:</p>\n<ul>\n<li>macOS/Linux mmap allocation patterns</li>\n<li>Accumulated Arc references not yet fully released by Rust's deferred deallocation</li>\n</ul>\n<h2>Proposed Fix</h2>\n<p>Make <code>register_code</code> and <code>unregister_code</code> idempotent by tracking registered addresses:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">registered_addresses</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span><span class=\"w\"> </span><span class=\"nc\">RwLock</span><span class=\"o\">&lt;</span><span class=\"n\">BTreeSet</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">REGISTERED</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">OnceLock</span><span class=\"o\">&lt;</span><span class=\"n\">RwLock</span><span class=\"o\">&lt;</span><span class=\"n\">BTreeSet</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">OnceLock</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"n\">REGISTERED</span><span class=\"p\">.</span><span class=\"n\">get_or_init</span><span class=\"p\">(</span><span class=\"nb\">Default</span><span class=\"p\">::</span><span class=\"n\">default</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">register_code</span><span class=\"p\">(</span><span class=\"n\">image</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Arc</span><span class=\"o\">&lt;</span><span class=\"n\">CodeMemory</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">address</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">address</span><span class=\"p\">.</span><span class=\"n\">is_empty</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">address</span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">address</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Check if already registered - make operation idempotent</span>\n<span class=\"w\">    </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">tracked</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">registered_addresses</span><span class=\"p\">().</span><span class=\"n\">write</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">tracked</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">end</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Already registered, skip</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">        </span><span class=\"n\">tracked</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">end</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"n\">global_code</span><span class=\"p\">().</span><span class=\"n\">write</span><span class=\"p\">().</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">end</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">image</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">()));</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">unregister_code</span><span class=\"p\">(</span><span class=\"n\">address</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Range</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">address</span><span class=\"p\">.</span><span class=\"n\">is_empty</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">address</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Check if registered - make operation idempotent</span>\n<span class=\"w\">    </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">tracked</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">registered_addresses</span><span class=\"p\">().</span><span class=\"n\">write</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">tracked</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">end</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Not registered, skip</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">        </span><span class=\"n\">tracked</span><span class=\"p\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">end</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"n\">global_code</span><span class=\"p\">().</span><span class=\"n\">write</span><span class=\"p\">().</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">end</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<h3>Why This Fix is Safe</h3>\n<ol>\n<li><strong>No functionality change</strong>: The registry still correctly tracks all live code regions</li>\n<li><strong>Minimal overhead</strong>: BTreeSet lookup is O(log n), same as the existing BTreeMap</li>\n<li><strong>Thread-safe</strong>: Uses the same RwLock pattern as the existing code</li>\n<li><strong>Backward compatible</strong>: No API changes</li>\n</ol>\n<h2>Impact</h2>\n<p>This issue affects:</p>\n<ul>\n<li><strong>JVM integrations</strong> (Java, Kotlin, Scala) where <code>signals_based_traps(false)</code> is required</li>\n<li><strong>Long-running servers</strong> that dynamically load/unload WASM modules</li>\n<li><strong>Test suites</strong> with many engine/module creation tests</li>\n<li><strong>Any application</strong> creating 350+ engines/modules in a single process</li>\n</ul>\n<h2>Workarounds</h2>\n<ol>\n<li><strong>Engine reuse</strong>: Share a singleton engine across the application (mitigates but doesn't eliminate)</li>\n<li><strong>Process isolation</strong>: Run tests in separate processes (inconvenient for CI)</li>\n</ol>\n<p>Neither workaround fully solves the issue for libraries that can't control caller behavior.</p>\n<h2>Related</h2>\n<ul>\n<li>Wasmtime's trap handling architecture in <code>docs/contributing-architecture.md</code></li>\n<li><code>ModuleRegistry</code> and <code>GLOBAL_MODULES</code> for similar patterns</li>\n</ul>\n<h2>Additional Context</h2>\n<p>We discovered this issue while building Java bindings for wasmtime (wasmtime4j). Our test suite has ~860 tests, many creating engines and modules. The suite consistently crashed around test 350-400 before we implemented this fix.</p>\n<p>We've been running with this fix in production and all tests now pass reliably.<br>\n</p>\n</blockquote>",
        "id": 571797260,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770166224
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3844750412\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<p>Thanks for the report, but I'd like to ask you to set aside the LLM on this. This is a lot of text to wade through, much of it I think is inaccurate, and it detracts from the problem you're having.</p>\n<p>Can you share your reproduction steps for this issue? I ran the program on macOS and Linux in debug and release mode and never got a crash. I ran ~5.5M iterations on Linux and also never saw a crash. Are you able to reproduce with the program listed here? If not can you share a stack trace or similar?</p>\n<p>This might be a problem with bindings to wasmtime from the JVM, such as a use-after-free in the C API, or something like that. If you're able to share more details about that it might help narrow it down.</p>\n</blockquote>",
        "id": 571801220,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770169132
    },
    {
        "content": "<p>zacharywhitley <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3848089974\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<p>Sorry about the wall of text. I'm running the rust api on osx. I'll fire up my Linux machine when I get home and try it here and see if I can get some more information. </p>\n<p>I'm working on wasmtime JVM bindings. I have both JNI and Panama interfaces and it's coming along fairly well. I while ago I went to use <a href=\"https://github.com/kawamuray/wasmtime-java\">https://github.com/kawamuray/wasmtime-java</a> and <a href=\"https://github.com/bluejekyll/wasmtime-java\">https://github.com/bluejekyll/wasmtime-java</a> and they worked as a proof of concept but they are very minimal implementations for <a href=\"https://github.com/semantalytics/stardog-webfunction-plugin\">https://github.com/semantalytics/stardog-webfunction-plugin</a> , They haven't been maintained in years and I always thought that they sold wasmtime short. I wanted to do something more than just a proof of concept and had a bunch of other ideas that I wanted to explore. </p>\n</blockquote>",
        "id": 571939897,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770218619
    },
    {
        "content": "<p>zacharywhitley edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3848089974\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<p>Sorry about the wall of text. I'm running the rust api on osx. I can't get to this until I get home this evening but when I do I'll get you some more information. </p>\n<p>I'm working on wasmtime JVM bindings. I have both JNI and Panama interfaces and it's coming along fairly well. I while ago I went to use <a href=\"https://github.com/kawamuray/wasmtime-java\">https://github.com/kawamuray/wasmtime-java</a> and <a href=\"https://github.com/bluejekyll/wasmtime-java\">https://github.com/bluejekyll/wasmtime-java</a> and they worked as a proof of concept but they are very minimal implementations for <a href=\"https://github.com/semantalytics/stardog-webfunction-plugin\">https://github.com/semantalytics/stardog-webfunction-plugin</a> , They haven't been maintained in years and I always thought that they sold wasmtime short. I wanted to do something more than just a proof of concept and had a bunch of other ideas that I wanted to explore. </p>\n</blockquote>",
        "id": 571949404,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770220704
    },
    {
        "content": "<p>zacharywhitley edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3848089974\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<p>I can't get to this until I get home this evening but when I do I'll get you some more information. </p>\n<p>I'm working on wasmtime JVM bindings. I have both JNI and Panama interfaces and it's coming along fairly well. I while ago I went to use <a href=\"https://github.com/kawamuray/wasmtime-java\">https://github.com/kawamuray/wasmtime-java</a> and <a href=\"https://github.com/bluejekyll/wasmtime-java\">https://github.com/bluejekyll/wasmtime-java</a> and they worked as a proof of concept but they are very minimal implementations for <a href=\"https://github.com/semantalytics/stardog-webfunction-plugin\">https://github.com/semantalytics/stardog-webfunction-plugin</a> , They haven't been maintained in years and I always thought that they sold wasmtime short. I wanted to do something more than just a proof of concept and had a bunch of other ideas that I wanted to explore. </p>\n</blockquote>",
        "id": 571949507,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770220730
    },
    {
        "content": "<p>zacharywhitley edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3848089974\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<p>I can't get to this until I get home this evening but when I do I'll get you some more information. </p>\n<p>I'm working on wasmtime JVM bindings. I have both JNI and Panama interfaces and it's coming along fairly well. I while ago I went to use <a href=\"https://github.com/kawamuray/wasmtime-java\">https://github.com/kawamuray/wasmtime-java</a> and <a href=\"https://github.com/bluejekyll/wasmtime-java\">https://github.com/bluejekyll/wasmtime-java</a> and they worked as a proof of concept but they are very minimal implementations for <a href=\"https://github.com/semantalytics/stardog-webfunction-plugin\">https://github.com/semantalytics/stardog-webfunction-plugin</a> , They haven't been maintained in years and I always thought that they sold wasmtime short. I wanted to do something more than just a proof of concept and had a bunch of other ideas that I wanted to explore so I started working on this project. </p>\n</blockquote>",
        "id": 571949754,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770220779
    },
    {
        "content": "<p>zacharywhitley <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3850759685\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<p>I’m a bit burned out on this and may be missing some nuance in the mechanistic explanation. The concrete, reproducible issue is that Wasmtime can SIGABRT via assert!(prev.is_none()) / assert!(code.is_some()) in GLOBAL_CODE under repeated create/drop churn. I've added tests to my branch. The problem does not manifest with Rust but will for any FFI. </p>\n<p>I have a patch that prevents the host abort by making (un)registration tolerant to collisions / missing entries. I’m happy to revise the explanation and/or adjust the fix to match the intended invariants — the main goal is ensuring a production embedder cannot be taken down by internal asserts.</p>\n</blockquote>",
        "id": 572048764,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770259314
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3853249278\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<p>@zacharywhitley I appreciate that you're trying what you can to address an issue you're running into, and we want to help as much as we can. However, precisely because Wasmtime is the kind of project where bugs can quickly turn into severe security or availability issues, we definitely can't land PRs that maintainers don't think are correct, and that no human (and in particular none of the project maintainers) fully understands. Otherwise we run the risk of the change causing unintended effects elsewhere.</p>\n<blockquote>\n<p>The problem does not manifest with Rust but will for any FFI.</p>\n</blockquote>\n<p>If you could provide a test case here that is reduced, ideally using a language like C or C++ that directly uses the FFI, and directly reproduces the issue, that would help greatly in understanding the underlying issue and fully addressing it. An LLM generated analysis of the cause isn't a replacement for that step, and puts a lot of burden on maintainers, as I'm sure you appreciate.</p>\n</blockquote>",
        "id": 572131125,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770293431
    },
    {
        "content": "<p>zacharywhitley <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3853381178\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<p>Totally appreciate that. I just wanted to make sure that I responded when I said that I would and I would be more than happy to assist as much as I can so that the wasmtime devs can devote as much time to wasmtime as possible. I'm a huge fan and have been using (and abusing) it quite a bit lately and having a great time. I just might take a little bit to work this up because this is a nights and weekends thing....for now. :) </p>\n</blockquote>",
        "id": 572136530,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770295099
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3854497830\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<p>One thing I might recommend is taking a close look at memory management in the FFI layer. A double-free (e.g. calling <code>wasmtime_*_free</code> twice on the asme object) could likely cause an issue like this. I'm not aware of any way to trigger these asserts from typical API usage, but invalid API usage, which would result in UB, could trigger something like this.</p>\n</blockquote>",
        "id": 572184760,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770306377
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3854836860\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<blockquote>\n<p>One thing I might recommend is taking a close look at memory management in the FFI layer. A double-free (e.g. calling <code>wasmtime_*_free</code> twice on the asme object) could likely cause an issue like this. I'm not aware of any way to trigger these asserts from typical API usage, but invalid API usage, which would result in UB, could trigger something like this.</p>\n</blockquote>\n<p>And running your FFI embedding with ASan can help surface these kinds of bugs in situations where they might otherwise silently go unnoticed in the moment and only cause problems much later down the line.</p>\n<p>FWIW, here are the cmake flags for building Wasmtime's C API with ASan:</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/72520ee5c2be0a01ea779d5fcde16d393973ba14/.github/workflows/main.yml#L691-L694\">https://github.com/bytecodealliance/wasmtime/blob/72520ee5c2be0a01ea779d5fcde16d393973ba14/.github/workflows/main.yml#L691-L694</a></p>\n</blockquote>",
        "id": 572199366,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770309602
    },
    {
        "content": "<p>zacharywhitley <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3861489550\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<p>Thanks for the suggestions, I’ve reduced this to a pure C API repro (no JVM, no GC) and updated the branch here:</p>\n<p><a href=\"https://github.com/tegmentum/wasmtime/tree/codex/create-minimal-rust-test-for-global_code-error\">https://github.com/tegmentum/wasmtime/tree/codex/create-minimal-rust-test-for-global_code-error</a></p>\n<p>Build + run (Linux):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">cmake</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"n\">crates</span><span class=\"o\">/</span><span class=\"n\">c</span><span class=\"o\">-</span><span class=\"n\">api</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">c</span><span class=\"o\">-</span><span class=\"n\">api</span><span class=\"o\">-</span><span class=\"n\">build</span><span class=\"o\">-</span><span class=\"n\">offline</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">DBUILD_TESTS</span><span class=\"o\">=</span><span class=\"n\">ON</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">DWASMTIME_CAPI_ENABLE_GTEST_TESTS</span><span class=\"o\">=</span><span class=\"n\">OFF</span>\n<span class=\"n\">cmake</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">build</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">c</span><span class=\"o\">-</span><span class=\"n\">api</span><span class=\"o\">-</span><span class=\"n\">build</span><span class=\"o\">-</span><span class=\"n\">offline</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">target</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"o\">-</span><span class=\"n\">global</span><span class=\"o\">-</span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">j4</span>\n<span class=\"n\">ctest</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">test</span><span class=\"o\">-</span><span class=\"n\">dir</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">c</span><span class=\"o\">-</span><span class=\"n\">api</span><span class=\"o\">-</span><span class=\"n\">build</span><span class=\"o\">-</span><span class=\"n\">offline</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">R</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"o\">-</span><span class=\"n\">global</span><span class=\"o\">-</span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">output</span><span class=\"o\">-</span><span class=\"n\">on</span><span class=\"o\">-</span><span class=\"n\">failure</span>\n</code></pre></div>\n<p>The test is contract-clean (each wasmtime_*_delete called exactly once; no use-after-delete; threads joined before teardown).</p>\n<p>On Linux this fails with a stable condition (expected 0 post-drop mapped addresses, got N) and under lldb consistently breaks in the threaded post-drop path.</p>\n<p>The /proc/self/maps check is included as extra evidence only. The core issue is that under repeated create/drop churn the GLOBAL_CODE invariants can be violated, leading to internal assert,</p>\n</blockquote>",
        "id": 572423227,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770396620
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3861712958\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<p>Thanks! The <code>test_unregisters_under_threaded_pressure</code> is the culprit in that test and it's been helpful to read over and poke at that locally. Unfortunately though I'm not sure this is enough of a smoking gun to know what to do in Wasmtime. This is using <code>/proc/self/maps</code> to show that something is still mapped after a module/engine are destroyed, but that's \"action at a distance\" of a sort where it's showing that Wasmtime might have problems but the problem still isn't within Wasmtime. My guess, without knowing specifics, is that <code>/proc/self/maps</code> is showing something stale rather than something that's up-to-date. My rough guess for that is that it has something to do with the fact that other threads in the same process also have <code>/proc/self/maps</code> open and there might be some sort of caching/queueing/etc at the kernel level. In Wasmtime though, as far as I can tell, we're correctly purging all mappings related to all modules.</p>\n<p>If what I'm suspecting is the case, however, then it would also mean that this shouldn't be a problem in Wasmtime. The kernel is responsible for ensuring that it only hands out unmapped mappings when we ask for a new mapping, so nothing should be overlapping accidentally or anything like that.</p>\n<p>Are you able to write up a test which aborts/panics within Wasmtime itself?</p>\n</blockquote>",
        "id": 572430906,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770398892
    },
    {
        "content": "<p>zacharywhitley <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511#issuecomment-3861813915\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12511\">issue #12511</a>:</p>\n<blockquote>\n<p>Thanks for taking a look. That makes sense, and I agree that /proc/self/maps is indirect evidence and not something Wasmtime should treat as a contract. I included it only as supporting information while trying to localize the behavior under pressure.</p>\n<p>The original symptom that led me here was Wasmtime aborting internally via the GLOBAL_CODE assertions (assert!(prev.is_none()) / assert!(code.is_some())) under repeated create/drop churn. The /proc/self/maps checks were added later to help understand timing and reuse, not as the primary failure condition.</p>\n<p>I can work on reducing this further to a test that triggers a panic/abort within Wasmtime itself (via the registry invariants), without relying on /proc/self/maps at all. I’ll follow up once I have that.</p>\n<p>Appreciate you digging into this, the feedback is helpful for narrowing what’s actually actionable on the Wasmtime side.</p>\n</blockquote>",
        "id": 572434961,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770400243
    }
]