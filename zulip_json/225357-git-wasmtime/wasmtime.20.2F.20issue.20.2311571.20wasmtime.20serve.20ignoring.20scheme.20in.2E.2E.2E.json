[
    {
        "content": "<p>sepointon opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11571\">issue #11571</a>:</p>\n<blockquote>\n<p>Thanks for filing a bug report! Please fill out the TODOs below.</p>\n<p><strong>Note: if you want to report a security issue, please read our <a href=\"https://bytecodealliance.org/security\">security policy</a>!</strong></p>\n<h3>Test Case</h3>\n<p><a href=\"https://gitlab.com/sampointon/wasmtime-url-print\">https://gitlab.com/sampointon/wasmtime-url-print</a></p>\n<h3>Steps to Reproduce</h3>\n<ol start=\"0\">\n<li>Check out the above repository.</li>\n<li><code>cargo build --target wasm32-wasip2</code></li>\n<li><code>wasmtime serve target/wasm32-wasip2/debug/wasmtime-url-print.wasm -S cli=y</code></li>\n<li>In a new terminal, manually send a HTTP/1.1 request with a scheme that's not <code>http</code> e.g. via netcat - example log (note the request line is in absolute-form):</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">$</span><span class=\"w\"> </span><span class=\"n\">nc</span><span class=\"w\"> </span><span class=\"n\">localhost</span><span class=\"w\"> </span><span class=\"mi\">8080</span>\n<span class=\"n\">GET</span><span class=\"w\"> </span><span class=\"n\">https</span><span class=\"p\">:</span><span class=\"c1\">//foo.example/bar HTTP/1.1</span>\n<span class=\"n\">Host</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">baz</span><span class=\"p\">.</span><span class=\"n\">example</span>\n\n<span class=\"n\">HTTP</span><span class=\"o\">/</span><span class=\"mf\">1.1</span><span class=\"w\"> </span><span class=\"mi\">200</span><span class=\"w\"> </span><span class=\"n\">OK</span>\n<span class=\"n\">content</span><span class=\"o\">-</span><span class=\"k\">type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">text</span><span class=\"o\">/</span><span class=\"n\">plain</span>\n<span class=\"n\">content</span><span class=\"o\">-</span><span class=\"n\">length</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">22</span>\n<span class=\"n\">date</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Fri</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">29</span><span class=\"w\"> </span><span class=\"n\">Aug</span><span class=\"w\"> </span><span class=\"mi\">2025</span><span class=\"w\"> </span><span class=\"mi\">17</span><span class=\"p\">:</span><span class=\"mi\">48</span><span class=\"p\">:</span><span class=\"mi\">48</span><span class=\"w\"> </span><span class=\"n\">GMT</span>\n\n<span class=\"n\">http</span><span class=\"p\">:</span><span class=\"c1\">//foo.example/bar</span>\n</code></pre></div>\n<h3>Expected Results</h3>\n<p>The <code>https</code> scheme in the request would be preserved.</p>\n<h3>Actual Results</h3>\n<p>The scheme was forcibly set to <code>http</code>.</p>\n<p>(I do note, happily, that it's doing the right thing and ignoring Host in this instance, so it's not all bad.)</p>\n<h3>Versions and Environment</h3>\n<p>Wasmtime version or commit: 36.0.2</p>\n<p>Operating system: Fedora 42</p>\n<p>Architecture: x86_64</p>\n<h3>Extra Info</h3>\n<p><a href=\"https://www.rfc-editor.org/rfc/rfc9112.html#name-reconstructing-the-target-u\">RFC 9112, section 3.3, 'Reconstructing the Target URI`</a>:</p>\n<blockquote>\n<p>The target URI is the <a href=\"https://www.rfc-editor.org/rfc/rfc9112.html#request.target\">request-target</a> when the request-target is in <a href=\"https://www.rfc-editor.org/rfc/rfc9112.html#absolute-form\">absolute-form</a>. In that case, a server will parse the URI into its generic components for further evaluation.</p>\n</blockquote>\n<p>The current behaviour is entirely explained by <a href=\"https://github.com/bytecodealliance/wasmtime/blame/0744262f79e235b172331f5ba1a2c43b5aedcbfb/src/commands/serve.rs#L742\">line 742 in <code>serve.rs</code></a>, which is hard-coding the scheme to <code>http</code>.</p>\n<p>I see that there's already been some back and forth on this in #8923 and #8878, but the present behaviour is simply wrong according to the spec.</p>\n<p>wasmtime should probably defer to the scheme provided by hyper (which I've verified is correct in this case) on the basis that hyper sees the actual request line and can follow the guidance in RFC 9112 section 3.3 depending on whether it's in absolute-form or origin-form. Keeping around a scheme and authority _and_ a <code>request::Parts</code> struct that has its own scheme and authority in <code>HostIncomingRequest</code> seems weird and likely to be a bug magnet.</p>\n<p>In practice, most requests in the wild will be origin-form, but I'm getting annoyingly snagged on this because I'm trying to do some local testing of some code that's unhappy if the request URLs aren't as it expects them to be, and I'd like to avoid having to spin up any infrastructure (e.g., DNS, certs, reverse proxies...) for that purpose. This sort of use-case (local testing of <code>wasi-http</code> components in a non-prod environment) seems to be squarely in the domain of <code>wasmtime serve</code>, so it would be useful if it was easy to 'fake' input URLs by using absolute-form requests.</p>\n</blockquote>",
        "id": 536839740,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756491043
    },
    {
        "content": "<p><a href=\"https://github.com/sepointon\">sepointon</a> added the bug label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11571\">Issue #11571</a>.</p>",
        "id": 536839741,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756491043
    },
    {
        "content": "<p>sepointon <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11571#issuecomment-3239368298\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11571\">issue #11571</a>:</p>\n<blockquote>\n<p>I had a look at making a PR, but I think that there are some decisions to be made first in wasi-http about what exactly is expected of implementations wrt request control data and faithfully reflecting incoming requests vs being convenient (<a href=\"https://github.com/WebAssembly/wasi-http/issues/181\">WebAssembly/wasi-http#181</a>).</p>\n</blockquote>",
        "id": 536923537,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756569822
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11571#issuecomment-3245720733\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11571\">issue #11571</a>:</p>\n<blockquote>\n<p>Thanks for the report! A PR would indeed be quite welcome, and no worries if it requires some spec clarifications first. Thanks for opening the upstream issue!</p>\n</blockquote>",
        "id": 537305666,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756825217
    },
    {
        "content": "<p>pchickey assigned pchickey to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11571\">issue #11571</a>.</p>",
        "id": 537334979,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756834394
    }
]