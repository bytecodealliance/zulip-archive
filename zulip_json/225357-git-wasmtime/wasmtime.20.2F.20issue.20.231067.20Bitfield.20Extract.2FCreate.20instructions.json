[
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1067\">issue #1067</a>:</p>\n<blockquote>\n<p>This would add two new instructions to cranelift, <code>bextr</code> and <code>bmak</code>. They provide a easy to optimize, and easy to generate mechanism for bitfield manipulation.</p>\n<h2>bextr</h2>\n<div class=\"codehilite\"><pre><span></span><code>a = bextr target, size, offset\n</code></pre></div>\n\n<p>bextr will extract a _n_ bit large field at the provided offset, and return it in <code>a</code>, shifted so that the LSB of the field is also the LSB of <code>a</code>.<br>\n<code>a</code>'s type is inferred from <code>target</code></p>\n<h3>Visual example</h3>\n<div class=\"codehilite\"><pre><span></span><code>offset = 4\nsize = 4\ntypeof target = i8\n\nxxxx **** \n\\__/----V\n0000 xxxx\n</code></pre></div>\n\n<h2>bmak</h2>\n<div class=\"codehilite\"><pre><span></span><code>a = bmak target, size, offset\n</code></pre></div>\n\n<p>bmak will fill a _n_ bit large field at the provided offset with 1s, the rest with 0. The generated field will then be applied to <code>target</code> using a bitwise AND, and the result will be returned in <code>a</code>.<br>\n<code>a</code>'s type is inferred from <code>target</code><br>\nbmak is designed so that you can simply use a bitwise or to combine the fields.</p>\n<h3>Visual Example</h3>\n<div class=\"codehilite\"><pre><span></span><code>offset = 2\nsize = 4\ntypeof target = i8\n\nxx0101xx\n  \\__/\n  /  \\\n00010100\n</code></pre></div>\n\n</blockquote>",
        "id": 281216878,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651696952
    },
    {
        "content": "<p>cfallin labeled <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1067\">issue #1067</a>:</p>\n<blockquote>\n<p>This would add two new instructions to cranelift, <code>bextr</code> and <code>bmak</code>. They provide a easy to optimize, and easy to generate mechanism for bitfield manipulation.</p>\n<h2>bextr</h2>\n<div class=\"codehilite\"><pre><span></span><code>a = bextr target, size, offset\n</code></pre></div>\n\n<p>bextr will extract a _n_ bit large field at the provided offset, and return it in <code>a</code>, shifted so that the LSB of the field is also the LSB of <code>a</code>.<br>\n<code>a</code>'s type is inferred from <code>target</code></p>\n<h3>Visual example</h3>\n<div class=\"codehilite\"><pre><span></span><code>offset = 4\nsize = 4\ntypeof target = i8\n\nxxxx **** \n\\__/----V\n0000 xxxx\n</code></pre></div>\n\n<h2>bmak</h2>\n<div class=\"codehilite\"><pre><span></span><code>a = bmak target, size, offset\n</code></pre></div>\n\n<p>bmak will fill a _n_ bit large field at the provided offset with 1s, the rest with 0. The generated field will then be applied to <code>target</code> using a bitwise AND, and the result will be returned in <code>a</code>.<br>\n<code>a</code>'s type is inferred from <code>target</code><br>\nbmak is designed so that you can simply use a bitwise or to combine the fields.</p>\n<h3>Visual Example</h3>\n<div class=\"codehilite\"><pre><span></span><code>offset = 2\nsize = 4\ntypeof target = i8\n\nxx0101xx\n  \\__/\n  /  \\\n00010100\n</code></pre></div>\n\n</blockquote>",
        "id": 281216883,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1651696959
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1067#issuecomment-3559365642\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1067\">issue #1067</a>:</p>\n<blockquote>\n<p>We discussed this during old-issue triage today and agreed that it is probably better to have users implement this behavior with shifts/masks and then pattern-match that during isel if a particular target ISA has a nice instruction for it. This fits better with the general trend of making CLIF a simple core IR, especially as not every ISA has such instructions -- this would have to be re-expanded in backends otherwise, and only after the point that that expansion could be optimized. I'll close this issue but thank you for the discussion!</p>\n</blockquote>",
        "id": 558496813,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763661844
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1067\">issue #1067</a>:</p>\n<blockquote>\n<p>This would add two new instructions to cranelift, <code>bextr</code> and <code>bmak</code>. They provide a easy to optimize, and easy to generate mechanism for bitfield manipulation.</p>\n<h2>bextr</h2>\n<div class=\"codehilite\"><pre><span></span><code>a = bextr target, size, offset\n</code></pre></div>\n\n<p>bextr will extract a _n_ bit large field at the provided offset, and return it in <code>a</code>, shifted so that the LSB of the field is also the LSB of <code>a</code>.<br>\n<code>a</code>'s type is inferred from <code>target</code></p>\n<h3>Visual example</h3>\n<div class=\"codehilite\"><pre><span></span><code>offset = 4\nsize = 4\ntypeof target = i8\n\nxxxx **** \n\\__/----V\n0000 xxxx\n</code></pre></div>\n\n<h2>bmak</h2>\n<div class=\"codehilite\"><pre><span></span><code>a = bmak target, size, offset\n</code></pre></div>\n\n<p>bmak will fill a _n_ bit large field at the provided offset with 1s, the rest with 0. The generated field will then be applied to <code>target</code> using a bitwise AND, and the result will be returned in <code>a</code>.<br>\n<code>a</code>'s type is inferred from <code>target</code><br>\nbmak is designed so that you can simply use a bitwise or to combine the fields.</p>\n<h3>Visual Example</h3>\n<div class=\"codehilite\"><pre><span></span><code>offset = 2\nsize = 4\ntypeof target = i8\n\nxx0101xx\n  \\__/\n  /  \\\n00010100\n</code></pre></div>\n\n</blockquote>",
        "id": 558496815,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763661844
    },
    {
        "content": "<p>moonheart08 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1067#issuecomment-3559695980\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/1067\">issue #1067</a>:</p>\n<blockquote>\n<blockquote>\n<p>We discussed this during old-issue triage today and agreed that it is probably better to have users implement this behavior with shifts/masks and then pattern-match that during isel if a particular target ISA has a nice instruction for it. This fits better with the general trend of making CLIF a simple core IR, especially as not every ISA has such instructions -- this would have to be re-expanded in backends otherwise, and only after the point that that expansion could be optimized. I'll close this issue but thank you for the discussion!</p>\n</blockquote>\n<p>7 years later with a stronger understanding of compilers and architectures, and I agree this is probably the right approach. Yet another issue I didn't remember creating resolved today!</p>\n</blockquote>",
        "id": 558512309,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763666884
    }
]