[
    {
        "content": "<p>Ezyyz opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">issue #11989</a>:</p>\n<blockquote>\n<p>Hello,</p>\n<p>During the development of our application, we’ve introduced WebAssembly (WASM) as a plugin system. Our software is a security terminal, and we’re now encountering macOS memory permission-related issues.</p>\n<p>We refer to Apple’s official documentation:  <br>\n<a href=\"https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon#Enable-the-JIT-entitlements-for-the-Hardened-Runtime\">https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon#Enable-the-JIT-entitlements-for-the-Hardened-Runtime</a></p>\n<p>In short, we need to allocate executable JIT memory using:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"n\">mmap</span><span class=\"p\">(</span><span class=\"nb\">NULL</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">wasm_plugin</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">PROT_READ</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">PROT_WRITE</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">PROT_EXEC</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">MAP_PRIVATE</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">MAP_ANON</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">MAP_JIT</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">-1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>and then write into it using the macOS-specific API <code>pthread_jit_write_with_callback_np</code>. Both <code>MAP_JIT</code> and <code>pthread_jit_write_with_callback_np</code> are macOS-specific APIs.</p>\n<p>For example, we implemented a function like this:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">jit_code</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">jit_region</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">dst</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kt\">size_t</span><span class=\"w\"> </span><span class=\"n\">instructions_length</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"nf\">jit_writing_callback</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">context</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">jit_code</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">jit_code</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">context</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"n\">code</span><span class=\"o\">-&gt;</span><span class=\"n\">dst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"o\">-&gt;</span><span class=\"n\">jit_region</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"o\">-&gt;</span><span class=\"n\">instructions_length</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"nf\">mmap_from_vector</span><span class=\"p\">(</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">uint8_t</span><span class=\"o\">&gt;&amp;</span><span class=\"w\"> </span><span class=\"n\">plugin_content</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">jit_mem</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">mmap</span><span class=\"p\">(</span><span class=\"nb\">NULL</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">plugin_content</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">(),</span>\n<span class=\"w\">                         </span><span class=\"n\">PROT_READ</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">PROT_WRITE</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">PROT_EXEC</span><span class=\"p\">,</span>\n<span class=\"w\">                         </span><span class=\"n\">MAP_PRIVATE</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">MAP_ANON</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">MAP_JIT</span><span class=\"p\">,</span>\n<span class=\"w\">                         </span><span class=\"mi\">-1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">jit_mem</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">MAP_FAILED</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// \"jit_mem mmap failed\"</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">MAP_FAILED</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">jit_code</span><span class=\"w\"> </span><span class=\"n\">jtcode</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"n\">jtcode</span><span class=\"p\">.</span><span class=\"n\">jit_region</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">plugin_content</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"n\">jtcode</span><span class=\"p\">.</span><span class=\"n\">dst</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">jit_mem</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"n\">jtcode</span><span class=\"p\">.</span><span class=\"n\">instructions_length</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">plugin_content</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">pthread_jit_write_with_callback_np</span><span class=\"p\">(</span><span class=\"n\">jit_writing_callback</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">jtcode</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">munmap</span><span class=\"p\">(</span><span class=\"n\">jit_mem</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">plugin_content</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">());</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">MAP_FAILED</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">jit_mem</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>The allocated <code>jit_mem</code> is thus marked as executable JIT memory.</p>\n<p>Currently, Wasmtime does not provide native C/C++ APIs, so our approach is to build a dynamic library in Rust using Wasmtime and export C-compatible functions for WASM loading, destruction, and function invocation, which our application then calls.</p>\n<p>However, after allocating memory using the above method and invoking the exported WASM functions through these C interfaces, the program crashes with:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Exception</span><span class=\"w\"> </span><span class=\"n\">Type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">EXC_BAD_ACCESS</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">SIGKILL</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"n\">Signature</span><span class=\"w\"> </span><span class=\"n\">Invalid</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>This indicates that the memory permissions are still invalid at runtime.</p>\n<p>We quickly realized the root cause: when we call <code>Component::new</code> and pass in the WASM binary, Wasmtime internally allocates <strong>new memory regions</strong> during instance creation—meaning the memory we pre-allocated at the upper layer is <strong>not actually used</strong> for code execution.</p>\n<p>After reviewing Wasmtime's source code, we found system-level <code>mmap</code> wrappers in:  <br>\n<code>crates/wasmtime/src/runtime/vm/sys/unix/mmap.rs</code></p>\n<p>Our questions are:</p>\n<ol>\n<li>When Wasmtime allocates <code>CodeMemory</code> on macOS, does it use the <code>mmap</code> implementation in this file?</li>\n<li>Is there any way to extend this implementation to support macOS’s special memory allocation requirements (i.e., using <code>MAP_JIT</code> and writing via <code>pthread_jit_write_with_callback_np</code>)?</li>\n<li>If I modify this code directly, will it affect memory allocations other than CodeMemory? Because, as expected, only executable code needs to be allocated in this special way.</li>\n</ol>\n<p>Thank you!</p>\n</blockquote>",
        "id": 554038228,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762420698
    },
    {
        "content": "<p>Ezyyz edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">issue #11989</a>:</p>\n<blockquote>\n<p>Hello,</p>\n<p>During the development of our application, we’ve introduced WebAssembly (WASM) as a plugin system. Our software is a security terminal, and we’re now encountering macOS memory permission-related issues.</p>\n<p>We refer to Apple’s official documentation:  <br>\n<a href=\"https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon#Enable-the-JIT-entitlements-for-the-Hardened-Runtime\">https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon#Enable-the-JIT-entitlements-for-the-Hardened-Runtime</a></p>\n<p>In short, we need to allocate executable JIT memory using:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"n\">mmap</span><span class=\"p\">(</span><span class=\"nb\">NULL</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">wasm_plugin</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">PROT_READ</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">PROT_WRITE</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">PROT_EXEC</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">MAP_PRIVATE</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">MAP_ANON</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">MAP_JIT</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">-1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>and then write into it using the macOS-specific API <code>pthread_jit_write_with_callback_np</code>. Both <code>MAP_JIT</code> and <code>pthread_jit_write_with_callback_np</code> are macOS-specific APIs.</p>\n<p>For example, we implemented a function like this:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">jit_code</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">jit_region</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">dst</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kt\">size_t</span><span class=\"w\"> </span><span class=\"n\">instructions_length</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"nf\">jit_writing_callback</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">context</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">jit_code</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">jit_code</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">context</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"n\">code</span><span class=\"o\">-&gt;</span><span class=\"n\">dst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"o\">-&gt;</span><span class=\"n\">jit_region</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"o\">-&gt;</span><span class=\"n\">instructions_length</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"nf\">mmap_from_vector</span><span class=\"p\">(</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">uint8_t</span><span class=\"o\">&gt;&amp;</span><span class=\"w\"> </span><span class=\"n\">plugin_content</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">jit_mem</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">mmap</span><span class=\"p\">(</span><span class=\"nb\">NULL</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">plugin_content</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">(),</span>\n<span class=\"w\">                         </span><span class=\"n\">PROT_READ</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">PROT_WRITE</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">PROT_EXEC</span><span class=\"p\">,</span>\n<span class=\"w\">                         </span><span class=\"n\">MAP_PRIVATE</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">MAP_ANON</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">MAP_JIT</span><span class=\"p\">,</span>\n<span class=\"w\">                         </span><span class=\"mi\">-1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">jit_mem</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">MAP_FAILED</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// \"jit_mem mmap failed\"</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">MAP_FAILED</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n\n<span class=\"w\">    </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">jit_code</span><span class=\"w\"> </span><span class=\"n\">jtcode</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"n\">jtcode</span><span class=\"p\">.</span><span class=\"n\">jit_region</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">plugin_content</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"n\">jtcode</span><span class=\"p\">.</span><span class=\"n\">dst</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">jit_mem</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"n\">jtcode</span><span class=\"p\">.</span><span class=\"n\">instructions_length</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">plugin_content</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">pthread_jit_write_with_callback_np</span><span class=\"p\">(</span><span class=\"n\">jit_writing_callback</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">jtcode</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">munmap</span><span class=\"p\">(</span><span class=\"n\">jit_mem</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">plugin_content</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">());</span>\n<span class=\"w\">        </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">MAP_FAILED</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">jit_mem</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>The allocated <code>jit_mem</code> is thus marked as executable JIT memory.</p>\n<p>At the time we began development, Wasmtime does not provide native C/C++ APIs, so our approach is to build a dynamic library in Rust using Wasmtime and export C-compatible functions for WASM loading, destruction, and function invocation, which our application then calls.</p>\n<p>However, after allocating memory using the above method and invoking the exported WASM functions through these C interfaces, the program crashes with:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Exception</span><span class=\"w\"> </span><span class=\"n\">Type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">EXC_BAD_ACCESS</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">SIGKILL</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">Code</span><span class=\"w\"> </span><span class=\"n\">Signature</span><span class=\"w\"> </span><span class=\"n\">Invalid</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>This indicates that the memory permissions are still invalid at runtime.</p>\n<p>We quickly realized the root cause: when we call <code>Component::new</code> and pass in the WASM binary, Wasmtime internally allocates <strong>new memory regions</strong> during instance creation—meaning the memory we pre-allocated at the upper layer is <strong>not actually used</strong> for code execution.</p>\n<p>After reviewing Wasmtime's source code, we found system-level <code>mmap</code> wrappers in:  <br>\n<code>crates/wasmtime/src/runtime/vm/sys/unix/mmap.rs</code></p>\n<p>Our questions are:</p>\n<ol>\n<li>When Wasmtime allocates <code>CodeMemory</code> on macOS, does it use the <code>mmap</code> implementation in this file?</li>\n<li>Is there any way to extend this implementation to support macOS’s special memory allocation requirements (i.e., using <code>MAP_JIT</code> and writing via <code>pthread_jit_write_with_callback_np</code>)?</li>\n<li>If I modify this code directly, will it affect memory allocations other than CodeMemory? Because, as expected, only executable code needs to be allocated in this special way.</li>\n</ol>\n<p>Thank you!</p>\n</blockquote>",
        "id": 554038706,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762420848
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989#issuecomment-3496307802\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">issue #11989</a>:</p>\n<blockquote>\n<blockquote>\n<p>If I modify this code directly, will it affect memory allocations other than CodeMemory?</p>\n</blockquote>\n<p><code>CodeMemory</code> is used to mmap the entire compiled blob. This includes both the executable code segment and read-only segments like linear memory initialization data and side tables used by the Wasmtime runtime. Currently when the mmap region is created it isn't yet known which parts will be mapped as executable. Instead <code>CodeMemory</code> reads the metadata containing this information directly from the mmaped region before it calls mprotect in the <code>publish</code> method.</p>\n</blockquote>",
        "id": 554047682,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762423491
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989#issuecomment-3497966030\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">issue #11989</a>:</p>\n<blockquote>\n<p>Do you have a way that this can be reproduced locally? None of the current maintainers have, for example, shipped iOS applications or published macOS apps so we don't have prior experience with entitlements/MAP_JIT/etc. If you have a way to reproduce though many of us have macs ourselves so we can poke around and try to see what's going on.</p>\n</blockquote>",
        "id": 554126663,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762444256
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989#issuecomment-3498071017\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">issue #11989</a>:</p>\n<blockquote>\n<p>Based on <a href=\"https://wiki.freepascal.org/Hardened_runtime_for_macOS\">https://wiki.freepascal.org/Hardened_runtime_for_macOS</a>, I think creating an <code>entitlements.xml</code> file with the following contents:</p>\n<div class=\"codehilite\" data-code-language=\"XML\"><pre><span></span><code><span class=\"cp\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;</span>\n<span class=\"cp\">&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;</span>\n<span class=\"nt\">&lt;plist</span><span class=\"w\"> </span><span class=\"na\">version=</span><span class=\"s\">\"1.0\"</span><span class=\"nt\">&gt;</span>\n<span class=\"nt\">&lt;dict&gt;</span>\n<span class=\"w\">    </span><span class=\"nt\">&lt;key&gt;</span>com.apple.security.cs.allow-jit<span class=\"nt\">&lt;/key&gt;</span>\n<span class=\"w\">    </span><span class=\"nt\">&lt;true/&gt;</span>\n<span class=\"nt\">&lt;/dict&gt;</span>\n<span class=\"nt\">&lt;/plist&gt;</span>\n</code></pre></div>\n<p>and then signing the executable with <code>codesign --force --options runtime --timestamp --entitlements entitlements.plist --sign - /path/to/wasmtime</code> would work. Where <code>--sign -</code> indicates an ad-hoc signature so you don't need a code signing ceritificate.</p>\n</blockquote>",
        "id": 554130575,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762445144
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989#issuecomment-3498210569\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">issue #11989</a>:</p>\n<blockquote>\n<p>Oh nice! Ok so with that I can see wasmtime dying quickly without <code>MAP_JIT</code>. I can't attach a debugger and see exactly why since that seems to need some other entitlement which I don't know how to find. With this patch though:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/crates/wasmtime/src/runtime/vm/sys/unix/mmap.rs b/crates/wasmtime/src/runtime/vm/sys/unix/mmap.rs</span>\n<span class=\"gh\">index 3463c3b1b6..75530e59bc 100644</span>\n<span class=\"gd\">--- a/crates/wasmtime/src/runtime/vm/sys/unix/mmap.rs</span>\n<span class=\"gi\">+++ b/crates/wasmtime/src/runtime/vm/sys/unix/mmap.rs</span>\n<span class=\"gu\">@@ -35,6 +35,15 @@ cfg_if::cfg_if! {</span>\n<span class=\"w\"> </span>    }\n<span class=\"w\"> </span>}\n\n<span class=\"gi\">+cfg_if::cfg_if! {</span>\n<span class=\"gi\">+    if #[cfg(target_vendor = \"apple\")] {</span>\n<span class=\"gi\">+        const MAP_JIT: rustix::mm::MapFlags =</span>\n<span class=\"gi\">+            rustix::mm::MapFlags::from_bits_retain(libc::MAP_JIT as u32);</span>\n<span class=\"gi\">+    } else {</span>\n<span class=\"gi\">+        const MAP_JIT: rustix::mm::MapFlags = rustix::mm::MapFlags::empty();</span>\n<span class=\"gi\">+    }</span>\n<span class=\"gi\">+}</span>\n<span class=\"gi\">+</span>\n<span class=\"w\"> </span>impl Mmap {\n<span class=\"w\"> </span>    pub fn new_empty() -&gt; Mmap {\n<span class=\"w\"> </span>        Mmap {\n<span class=\"gu\">@@ -48,7 +57,7 @@ impl Mmap {</span>\n<span class=\"w\"> </span>                ptr::null_mut(),\n<span class=\"w\"> </span>                size.byte_count(),\n<span class=\"w\"> </span>                rustix::mm::ProtFlags::READ | rustix::mm::ProtFlags::WRITE,\n<span class=\"gd\">-                rustix::mm::MapFlags::PRIVATE | MMAP_NORESERVE_FLAG,</span>\n<span class=\"gi\">+                rustix::mm::MapFlags::PRIVATE | MMAP_NORESERVE_FLAG | MAP_JIT,</span>\n<span class=\"w\"> </span>            )?\n<span class=\"w\"> </span>        };\n<span class=\"w\"> </span>        let memory = std::ptr::slice_from_raw_parts_mut(ptr.cast(), size.byte_count());\n<span class=\"gu\">@@ -73,7 +82,7 @@ impl Mmap {</span>\n<span class=\"w\"> </span>                //\n<span class=\"w\"> </span>                // Virtual memory that cannot be accessed should not have a backing store reserved\n<span class=\"w\"> </span>                // for it. Hence, passing in NORESERVE is correct here.\n<span class=\"gd\">-                rustix::mm::MapFlags::PRIVATE | MMAP_NORESERVE_FLAG,</span>\n<span class=\"gi\">+                rustix::mm::MapFlags::PRIVATE | MMAP_NORESERVE_FLAG | MAP_JIT,</span>\n<span class=\"w\"> </span>            )?\n<span class=\"w\"> </span>        };\n\n<span class=\"gu\">@@ -94,7 +103,7 @@ impl Mmap {</span>\n<span class=\"w\"> </span>                ptr::null_mut(),\n<span class=\"w\"> </span>                len,\n<span class=\"w\"> </span>                rustix::mm::ProtFlags::READ | rustix::mm::ProtFlags::WRITE,\n<span class=\"gd\">-                rustix::mm::MapFlags::PRIVATE,</span>\n<span class=\"gi\">+                rustix::mm::MapFlags::PRIVATE | MAP_JIT,</span>\n<span class=\"w\"> </span>                &amp;file,\n<span class=\"w\"> </span>                0,\n<span class=\"w\"> </span>            )\n</code></pre></div>\n<p>the crash goes away. @Ezyyz would you be able to test out that patch and see if it works for you?</p>\n</blockquote>",
        "id": 554136404,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762446558
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989#issuecomment-3499446556\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">issue #11989</a>:</p>\n<blockquote>\n<p>Ideally you would only apply MAP_JIT to the memory range that will actually end up being executable. Having to specify MAP_JIT in the first place is a protection against exploits just remapping memory they control as executable using mprotect afaik.</p>\n</blockquote>",
        "id": 554192299,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762464284
    },
    {
        "content": "<p>Ezyyz <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989#issuecomment-3500690831\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">issue #11989</a>:</p>\n<blockquote>\n<p>I've applied this patch, and it is taking effect. However, from my perspective, it might be incorrect and could introduce issues:</p>\n<p>First, the modification targets the lowest-level mmap implementation. If non-code memory allocations (e.g., data segments, heaps, etc.) also go through this path, they would incorrectly be allocated with MAP_JIT and executable permissions, which is both unnecessary and a security risk.</p>\n<p>Second, this approach does not follow Apple’s recommended practice. According to Apple’s documentation, memory allocated with the MAP_JIT flag should not be directly writable. Instead, after mapping such memory as PROT_READ | PROT_EXEC, one should use the official API pthread_jit_write_with_callback_np() to safely write code into it in a controlled manner.</p>\n<p>Therefore, the proper solution on macOS should be to handle code memory allocation specially:</p>\n<p>Only use the MAP_JIT flag when allocating executable code memory (not for general-purpose allocations).<br>\nUse Apple’s recommended pthread_jit_write_with_callback_np() (or pthread_jit_write_protect_np()) to write machine code into that region.<br>\nFor the correct implementation guidance, please refer to Apple’s official documentation:<br>\n<a href=\"https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon#Enable-the-JIT-entitlements-for-the-Hardened-Runtime\">https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon#Enable-the-JIT-entitlements-for-the-Hardened-Runtime</a></p>\n<p>Additionally, note that the required entitlements differ based on usage:</p>\n<p>com.apple.security.cs.allow-jit enables basic JIT support.<br>\ncom.apple.security.cs.jit-write-allowlist (if used) may require different handling.</p>\n<p>I found the relevant API in Rust documentation here:<br>\n<a href=\"https://docs.rs/libvips-rs/latest/x86_64-apple-darwin/libvips_rs/bindings/fn.pthread_jit_write_with_callback_np.html\">https://docs.rs/libvips-rs/latest/x86_64-apple-darwin/libvips_rs/bindings/fn.pthread_jit_write_with_callback_np.html</a><br>\n<a href=\"https://docs.rs/libvips-rs/latest/x86_64-apple-darwin/libvips_rs/bindings/fn.pthread_jit_write_protect_np.html\">https://docs.rs/libvips-rs/latest/x86_64-apple-darwin/libvips_rs/bindings/fn.pthread_jit_write_protect_np.html</a></p>\n<p>The choice of entitlement—and thus the exact API usage—depends on the application’s specific security model and deployment scenario.</p>\n<p>Thanks for your supporting!</p>\n</blockquote>",
        "id": 554237740,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762490806
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989#issuecomment-3505625389\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">issue #11989</a>:</p>\n<blockquote>\n<p>Well, so sort of. </p>\n<blockquote>\n<p>Ideally you would only apply MAP_JIT to the memory range that will actually end up being executable</p>\n</blockquote>\n<p>I don't believe we're equipped to do this unfortunately. We create one mmap with the result of compilation and it's got the entire module image in it. We're not able to create separate mappings at this time. The downside of this seems relatively minor to me though in that while the area has <code>MAP_JIT</code> only the executable section has <code>PROT_EXEC</code>.</p>\n<blockquote>\n<p>First, the modification targets the lowest-level mmap implementation. If non-code memory allocations (e.g., data segments, heaps, etc.) also go through this path, they would incorrectly be allocated with MAP_JIT and executable permissions, which is both unnecessary and a security risk.</p>\n</blockquote>\n<p>True, yes. I meant this as a quick patch to see if something works. I don't want to rearchitect the codebase for a platform when we don't even known if it'll work (e.g. we can't test)</p>\n<blockquote>\n<p>Second, this approach does not follow Apple’s recommended practice.</p>\n</blockquote>\n<p>Apple's recommended practice is for a different style of JIT than Wasmtime. In Wasmtime once code is made executable we never make it non-executable ever again. There's no dynamic modification of code. My read of <code>pthread_jit_write_with_callback_np</code> is that it's not necessary for use in Wasmtime.</p>\n<hr>\n<p>As an aside @Ezyyz it looks like you're using an LLM and/or chat gpt and/or claude to generate responses here. If not, that's a mistake on my part, but if you are I'd appreciate it if you didn't as the answers are pretty verbose and can be misleading around the exact specifics of what should be done here. I don't really trust an LLM to know how best to handle this part of Apple's platforms.</p>\n</blockquote>",
        "id": 554442905,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762568695
    },
    {
        "content": "<p>Ezyyz <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989#issuecomment-3509159334\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">issue #11989</a>:</p>\n<blockquote>\n<p>Yes, i use LLM as translator. I didn't noticed that  it could mislead others.I just wanted to express more accurately.It took me a lot of time, whether searching Apple's security mechanisms or reading the Wasmtime code.</p>\n<p>I think you're right. In my test cases, i used MAP_JIT and pthread_jit_write_with_callback_np and it worked well and it alse worked well when i don't use pthread_jit_write_with_callback_np to copy.<br>\nI'll feedback, if not using pthread_jit_write_with_callback_np causes other issues(eg. Failed to copy/exec with some entitlements on).</p>\n</blockquote>",
        "id": 554610487,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762741256
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989#issuecomment-3512664448\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">issue #11989</a>:</p>\n<blockquote>\n<p>Sounds good yeah, and this patch is also one I'm happy to land in Wasmtime itself (or if you'd like to send a PR that would also be most welcome). We can have follow-up issues about how to make the hardening more precise but I'd ideally like to unblock you first and ensuer that something runs.</p>\n</blockquote>",
        "id": 554741107,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762791666
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasmtime:platform-support label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">Issue #11989</a>.</p>",
        "id": 561998469,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764894222
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989#issuecomment-3614857480\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989\">issue #11989</a>:</p>\n<blockquote>\n<p>I spent some time investigating this today and here's my understanding of the situation as a non-expert in this field:</p>\n<ul>\n<li>Some reference documentation is at <a href=\"https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon\">https://developer.apple.com/documentation/apple-silicon/porting-just-in-time-compilers-to-apple-silicon</a>. Notable confusing things to me are<ul>\n<li>This claims \"When memory protection is enabled, a thread cannot write to a memory region and execute instructions in that region at the same time\" and that memory protection is on-by-default for aarch64. This does not detail how this is enforced. For example I don't know if <code>mmap</code> fails, <code>mprotect</code> fails, or if a fault just happens at some point.</li>\n<li>This claims Wasmtime \"can only create one memory region with the MAP_JIT flag set\" but testing locally seems to show otherwise. I ran the CLI with <code>--preload</code> which creates a region for the main module and the loaded module, and that seemed to work.</li>\n<li>This makes mention of <code>pthread_jit_write_protect_np</code> which apparently disappears with the <code>com.apple.security.cs.jit-write-allowlist</code> entitlement. It says we should call <code>pthread_jit_write_with_callback_np</code>. The <code>pthread_jit_write_with_callback_np</code> seems to temporarily, on a per-thread basis, make some code only-writable and not-executable.</li>\n<li>This says we should execute <code>sys_icache_invalidate</code> \"before you execute the machine instructions on a recently updated memory page\". Wasmtime does not do this right now.</li>\n</ul>\n</li>\n<li>bjorn3's <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989#issuecomment-3498071017\">suggestion above</a> is how this can be tested locally. </li>\n<li>My <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11989#issuecomment-3498210569\">patch above</a> gets Wasmtime working but is a bit coarse:<ul>\n<li>Ideally we'd re-mmap, with <code>MAP_FIXED</code>, only the text region with <code>MAP_JIT</code> and we'd leave off <code>MAP_JIT</code> from other pages. This would require refactoring since the <code>.text</code> section is discovered after a <code>MmapVec</code> is created.</li>\n</ul>\n</li>\n<li>Seems like we may want to call <code>sys_icache_invalidate</code> in the jit-icache-coherence crate.</li>\n<li>I don't think we need to call <code>pthread_jit_write_protect_np</code> (maybe?)</li>\n<li>It seems like we probably don't need to call <code>pthread_jit_write_with_callback_np</code>. Maybe there's some shenanigans though  where it would be applicable. I'm really not sure.</li>\n<li>Personally if we add this I'd want to ensure it's tested in CI. We'd just need a way to codesign all our executables. Maybe a custom \"linker\" which does the real linker thing and then signs the output as well? Maybe a custom \"test runner\" that signs everything?</li>\n</ul>\n<p>Overall I'm on the cusp of feeling able to implement this but not quite. I still don't really understand what <code>MAP_JIT</code> is insofar as how we should manage it, initialize it, ensure caches are flushed/coherent, etc. I don't understand why the documentation says we can only have one <code>MAP_JIT</code> region, which would be a big problem, but I seem to be able to create two locally. I don't understand if we need to use <code>pthread_jit_*</code> APIs.</p>\n<p>I suspect we'll need to refactor creation of executable memory in Wasmtime to appropriately adhere to these hardening rules. I don't think that would be too too hard to do, but I think it should be done by someone who knows more about what they're doing than I. </p>\n</blockquote>",
        "id": 561999647,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764894890
    }
]