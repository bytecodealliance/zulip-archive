[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a> from <code>cfallin:wasm-breakpoints</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>This is a PR that puts together a bunch of earlier pieces (patchable calls in #12061 and #12101, private copies of code in #12051, and all the prior debug event and instrumentation infrastructure) to implement breakpoints in the guest debugger.</p>\n<p>These are implemented in the way we have planned in #11964: each sequence point (location prior to a Wasm opcode) is now a patchable call instruction, patched out (replaced with NOPs) by default. When patched in, the breakpoint callsite calls a trampoline with the <code>patchable</code> ABI which then invokes the <code>breakpoint</code> hostcall. That hostcall emits the debug event and nothing else.</p>\n<p>A few of the interesting bits in this PR include:</p>\n<ul>\n<li>Implementations of \"unpublish\" (switch permissions back to read/write from read/execute) for mmap'd code memory on all our platforms.</li>\n<li>Infrastructure in the frame-tables (debug info) metadata producer and parser to record \"breakpoint patches\".</li>\n<li>A tweak to the NOP metadata packaged with the <code>MachBuffer</code> to allow multiple NOP sizes. This lets us use one 5-byte NOP on x86-64, for example (did you know x86-64 had these?!) rather than five 1-byte NOPs.</li>\n</ul>\n<p>This PR also implements single-stepping with a global-per-<code>Store</code> flag, because at this point why not; it's a small additional bit of logic to do <em>all</em> patches in all modules registered in the <code>Store</code> when that flag is enabled.</p>\n<p>A few realizations for future work:</p>\n<ul>\n<li>The need for an introspection API available to a debugger to see the modules within a component is starting to become clear; either that, or the \"module and PC\" location identifier for a breakpoint switches to a \"module or component\" sum type. Right now, the tests for this feature use only core modules. Extending to components should not actually be hard at all, we just need to build the API for it.</li>\n<li>The interaction between inlining and <code>patchable_call</code> is interesting: what happens if we inline a <code>patchable_call</code> at a <code>try_call</code> callsite? Right now, we do <em>not</em> update the <code>patchable_call</code> to a <code>try_call</code>, because there is no <code>patchable_try_call</code>; this is fine in the Wasmtime embedding in practice because we never (today!) throw exceptions from a breakpoint handler. This does suggest to me that maybe we should make patchability a property of any callsite, and allow try-calls to be patchable too (with the same restriction about no return values as the only restriction); but happy to discuss that one further.</li>\n</ul>\n<p>&lt;!--<br>\nPlease make sure you include the following information:</p>\n<ul>\n<li>\n<p>If this work has been discussed elsewhere, please include a link to that<br>\n  conversation. If it was discussed in an issue, just mention \"issue #...\".</p>\n</li>\n<li>\n<p>Explain why this change is needed. If the details are in an issue already,<br>\n  this can be brief.</p>\n</li>\n</ul>\n<p>Our development process is documented in the Wasmtime book:<br>\n<a href=\"https://docs.wasmtime.dev/contributing-development-process.html\">https://docs.wasmtime.dev/contributing-development-process.html</a></p>\n<p>Please ensure all communication follows the code of conduct:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md\">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>\n--&gt;</p>\n</blockquote>",
        "id": 562271803,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765063873
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/abrown\">abrown</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562271804,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765063873
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers\">wasmtime-compiler-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562271805,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765063873
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/dicej\">dicej</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562271806,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765063874
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562271807,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765063874
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-default-reviewers\">wasmtime-default-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562271808,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765063874
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/fitzgen\">fitzgen</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562271818,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765063893
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562271819,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765063893
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562271891,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765064034
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562274733,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765068162
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#issuecomment-3621476375\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>:</p>\n<blockquote>\n<p>The s390x failure looks like an oversight on my part in the patchable-ABI implementation on that ISA -- the clobber-save code implicitly assumes that clobber set fits in that ABI's special clobber-save region in each frame but that's no longer true when everything is clobbered. I'll rework it in a separate PR then rebase this.</p>\n</blockquote>",
        "id": 562277764,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765072116
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2599477242\">PR review comment</a>:</p>\n<blockquote>\n<p>Well, either all that, or the clause about other threads should be removed from the <code>unsafe</code> docs since that should not be applicable given the rules of <code>&amp;mut</code></p>\n</blockquote>",
        "id": 562523701,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765215559
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2599258424\">PR review comment</a>:</p>\n<blockquote>\n<p>s/FnMut/FnOnce/</p>\n</blockquote>",
        "id": 562523702,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765215559
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2599453394\">PR review comment</a>:</p>\n<blockquote>\n<p>I think that the documentation here is out-of-date (this doesn't change permissions), and additionally I think we can probably make this a safe function. The safety requirement of <code>self.mmap.as_mut_slice()</code> is satisfied by checking <code>self.published</code> and other internal mapping checks to ensure that it's read/write.</p>\n<p>I'd also recommend changing this to return <code>-&gt; &amp;mut [u8]</code> and perhaps renaming it to <code>text_mut()</code> to make it easier to call and more clear which part it's providing mutable access to.</p>\n</blockquote>",
        "id": 562523703,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765215559
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2599264830\">PR review comment</a>:</p>\n<blockquote>\n<p>How come this points to the end vs the start?</p>\n</blockquote>",
        "id": 562523704,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765215559
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2599471513\">PR review comment</a>:</p>\n<blockquote>\n<p>Personally I'd say that this <code>Safety</code> section and <code>unsafe</code> is unnecessary since, if <code>&amp;mut</code> exists, it's already guaranteed that this has exclusive access over the memory.</p>\n<p>Put another way, the unsafety here, other threads executing code, already shows unsafety unrelated to calling this function insofar as it should not be possible to acquire <code>&amp;mut CodeMemory</code> while other threads are executing in the code.</p>\n</blockquote>",
        "id": 562523705,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765215559
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2599270443\">PR review comment</a>:</p>\n<blockquote>\n<p>Instead of adding a new kind here, I would have expected the ABI of the <code>breakpoint</code> builtin to be different from the rest. There's no use for a non-patchable version of the <code>breakpoint</code> builtin for example, right?</p>\n</blockquote>",
        "id": 562523706,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765215559
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2599444837\">PR review comment</a>:</p>\n<blockquote>\n<p>I think this'll want to return an error with <code>bail!</code> for when virtual memory isn't supported</p>\n</blockquote>",
        "id": 562523707,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765215559
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2599488244\">PR review comment</a>:</p>\n<blockquote>\n<p>I think something around this is going to need some special care, specifically when <code>unpublish</code> returns an error. There are situations that this implementation doesn't currently handle such as:</p>\n<ul>\n<li>If <code>unpublish</code> fails then it's documented as leaving things in an indeterminate state which means the entire store needs to be locked down and completely unusable (or something like that), but no such enforcement happens here.</li>\n<li>If <code>unpublish</code> succeeds, there's no guarantee that the future <code>publish</code> in <code>Drop</code> will succeed. I don't think that a futuer <code>publish</code> failing should result in a panic-during-<code>Drop</code> since that's easy to get into a double-panic situation that aborts the process.</li>\n</ul>\n<p>Overall I don't know how to handle this though. If <code>unpublish</code> fails and things are indeterminate, we can't handle that because returning from wasm requires executing some wasm. If <code>publish</code> fails then things definitely aren't executable, so we can't return to wasm to jump back to the other end of wasm. I hadn't really thought about this until reading this just now, but do you have ideas on how to handle the failures here?</p>\n</blockquote>",
        "id": 562523708,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765215559
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3552902501\">PR review</a>.</p>",
        "id": 562523709,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765215559
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2599524771\">PR review comment</a>:</p>\n<blockquote>\n<p>I suppose the closest thing that I can think of for handling this is to document abort-on-error semantics both here during <code>unpublish</code> and in <code>Drop</code> where the re-publish happens. It's on us to ensure that nothing outside of like \"kernel exceeded limit of VMAs\" errors happen and in such a situation there's not much we can do other than abort sort of...</p>\n</blockquote>",
        "id": 562524138,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765215692
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3553279452\">PR review</a>.</p>",
        "id": 562524139,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765215692
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562534179,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765218290
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2599742207\">PR review comment</a>:</p>\n<blockquote>\n<p>This is the \"avoid storing the same number twice\" trick that we use in various places in Cranelift too -- when the ranges are consecutive we just store one endpoint; and we store the end rather than the start because one can always get the end of the previous, or zero for first entry, but the end of the whole pool may have been padded. (I'll add to the comment to note that start is implicit as last end.)</p>\n</blockquote>",
        "id": 562537152,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765219454
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3553573372\">PR review</a>.</p>",
        "id": 562537153,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765219454
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3554944514\">PR review</a>.</p>",
        "id": 562587981,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765246075
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2600797737\">PR review comment</a>:</p>\n<blockquote>\n<p>Hmm, yeah, I am just realizing that even an ordinary panic isn't sufficient here: that will unwind to the top of the hostcall stack frames, but then we'll catch-unwind and return an error through Wasm, but oops the trampoline isn't executable anymore, so we segfault.</p>\n<p>We could <em>almost</em> make this work if we insisted that our trampolines (where the error check and raise that will longjmp back over the activation) were executed in engine code, not store code. Then an error would make Wasm non-executable but leave trampolines executable. We currently use engine-code pointers at some points (as you probably remember from the private-code PR) but for the Wasm-to-host trampolines for builtins, we'll use store-code variants because we emit direct calls from Wasm functions to those trampolines, so that's not a solution (or at least not without making all breakpoint patchable calls indirects and burning another register).</p>\n<p>I agree that there's not much we can do if (in the Linux case) the kernel fails to allocate a new <code>struct vma</code>, and also that that's the only error case (ENOMEM generally) that I see in the Linux manpage for <code>mprotect</code> that isn't a bad-parameter sort of error avoided by construction. I could almost make an argument that the <em>re</em>-publish case should only be merging VMAs or keeping the same number, not splitting them (the whole mmap is initially one; initially publishing text splits into three (R, R+X, R); flipping the middle to R+W won't cause a merge nor a split); of course we can't rely on that for edge-case arguments about kernel OOM'ing and syscall errors but it should put us slightly more at ease...</p>\n<p>Is there an idiomatic way to panic-and-really-abort-the-process even in a panic=unwind build?</p>\n</blockquote>",
        "id": 562587982,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765246075
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2600797737\">PR review comment</a>.</p>",
        "id": 562588119,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765246190
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3554964479\">PR review</a>.</p>",
        "id": 562588544,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765246372
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2600811528\">PR review comment</a>:</p>\n<blockquote>\n<p>Alternately, an idea occurs: this all happens on a fiber in practice, since guest-debugging relies on that. Could we suspend out of the fiber and \"poison\" it somehow? Then we eliminate the re-execution of now-non-executable code by dropping those stackframes on the floor, never returning into them again.</p>\n</blockquote>",
        "id": 562588545,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765246372
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3555930034\">PR review</a>.</p>",
        "id": 562615123,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765266030
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2601458734\">PR review comment</a>:</p>\n<blockquote>\n<p>That's true currently, yeah; the reason I built it this way is that ABI is already a notion baked into the <code>FuncKeyKind</code> (explicitly during codegen for each such trampoline, and exposed via <code>Abi</code> too) and it seemed less error-prone to render that detail explicitly than to try to special-case one builtin (which would possibly require plumbing the builtin index into more places and conditionalizing a bunch of stuff). The lazy generation of trampolines on demand during compilation also means we don't ever actually generate a <code>breakpoint</code> trampoline with kind <code>WasmToBuiltin</code>. Maybe I'm missing somewhere this leads to an efficiency concern though?</p>\n</blockquote>",
        "id": 562615125,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765266031
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2601467243\">PR review comment</a>:</p>\n<blockquote>\n<p>The custom-publish case should otherwise work if we don't <code>bail</code> here, and is ordinarily used in non-virtual-memory builds; is there a reason we want to rule that out? This function body is basically derived by starting with <code>publish</code> and then switching the permissions (and cprop'ing out the \"if needs executable\" because we want to make R/W regardless, e.g. for pulley)</p>\n</blockquote>",
        "id": 562615505,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765266226
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3555939867\">PR review</a>.</p>",
        "id": 562615506,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765266226
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3555964305\">PR review</a>.</p>",
        "id": 562616656,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765266711
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2601488228\">PR review comment</a>:</p>\n<blockquote>\n<p>Yeah, I wasn't totally sure what to do here: it's not clear (to me) that executing code in the code memory is meant to be morally equivalent to an immutable borrow from that code. I guess it has to be since that's the only safe API we provide that can read the machine code (<code>.text()</code>) and executing instructions implies reading them. In that sense, though, the Wasm code is technically violating the borrowing invariants because it is fetching the instructions (immutable borrow) and also has a separate mut borrow to the whole <code>Store</code>.</p>\n<p>Seen another way: should it be possible to cause a segfault by executing non-executable-bit regions when using only safe APIs on this struct within a hostcall? If this method isn't <code>unsafe</code>, then it is: we get a mut <code>Store</code> as a parameter to a hostcall, we unpublish, we return. Wasm code passed in a mut borrow so that was our right; but ending that borrow does not really end its effect.</p>\n<p>(By the way that's what I was trying to capture with the <code>edit</code> function that takes the closure, though a refactor pulled the actual unpublish method out because I wanted to make the edits batched -- I think that's the right call but we need to figure out the above re: safe semantics)</p>\n</blockquote>",
        "id": 562616657,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765266711
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3555971238\">PR review</a>.</p>",
        "id": 562616886,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765266819
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2601493283\">PR review comment</a>:</p>\n<blockquote>\n<p>(I don't see the word \"thread\" anywhere in the docs on this method but let me know which part you want clarified and I'm happy to do so!)</p>\n</blockquote>",
        "id": 562616887,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765266819
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562617612,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765267156
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2601508444\">PR review comment</a>:</p>\n<blockquote>\n<p>Updated, thanks! Done in c90e749f9b.</p>\n</blockquote>",
        "id": 562617639,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765267168
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3555988682\">PR review</a>.</p>",
        "id": 562617640,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765267168
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3555989779\">PR review</a>.</p>",
        "id": 562617687,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765267190
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2601509457\">PR review comment</a>:</p>\n<blockquote>\n<p>Added comment in c90e749f9b; thanks!</p>\n</blockquote>",
        "id": 562617688,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765267190
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3555990209\">PR review</a>.</p>",
        "id": 562617714,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765267198
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2601509893\">PR review comment</a>:</p>\n<blockquote>\n<p>Updated in c90e749f9b, thanks!</p>\n</blockquote>",
        "id": 562617715,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765267198
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562629127,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765271021
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562629356,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765271096
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3558161065\">PR review</a>.</p>",
        "id": 562725409,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765295962
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2603217164\">PR review comment</a>:</p>\n<blockquote>\n<p>I may be misunderstanding, but it looks like the custom-unpublished returns early above meaning it won't reach here. Returning an error if <code>!mmap.supports_virtual_memory()</code> is the same as <code>publish</code> above where if the host has virtual memory but the mapping doesn't support it then this operation fails. (technically this should be an assert of some kind since it would have failed in <code>publish</code>, but that's ok)</p>\n</blockquote>",
        "id": 562725410,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765295962
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2603266922\">PR review comment</a>:</p>\n<blockquote>\n<p>Yeah modeling this all in Rust's borrowing I've never quite wrapped my head around and it feels a bit like a leaky abstraction. One way to interpret this is that wasm gave the host a <code>&amp;mut Thing</code> borrow and the host did <code>*thing = Thing::default()</code>. Another way to interpret it though is that wasm is holding pointers into <code>Thing</code> (e.g. return addresses on the stack) so it's not valid for wasm to hand out <code>&amp;mut Thing</code> to the host.</p>\n<p>On the other hand though a controlled deterministic crash is not something I would consider <code>unsafe</code>. For example aborting the process is a safe operation and here the possible fault of forgetting to call <code>publish</code> is a deterministic \"you don't have permissions to execute code there\" failure.</p>\n<p>So overall I feel like this still doesn't meet the criteria of being <code>unsafe</code>. I'm not aware of UB if this function is called in how it interacts with the rest of the system at least.</p>\n<p>As for <code>edit</code> -- it makes sense to have that style of API but I don't think that this is the right layer to implement it. Rather the <code>BreakpointEdit</code> abstraction you added feels more appropriate. Additionally when designing <code>unsafe</code> primitives I've historically felt that the abstraction needs to be as easy-to-use as possible without increasing the risk of UB. For example <code>text_mut</code> doesn't increase the risk of UB it just makes it easier to use. Effectively writing non-idiomatic code is in a sense more risky than using standard borrowing/etc idioms with clearly defined <code>unsafe</code> contracts and such.</p>\n<p>As for \"thread\", sorry about that I skimmed the docs and just interpreted actively-in-use as threads in the system. What I mean is that <code>&amp;mut CodeMemory</code> provides a static guarantee that it's not actively-in-use and thus that part of the unsafety contract can go away as Rust's type system provides such a guarantee.</p>\n</blockquote>",
        "id": 562725412,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765295962
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2603300136\">PR review comment</a>:</p>\n<blockquote>\n<p>For aborting that'd be <a href=\"https://doc.rust-lang.org/stable/std/process/fn.abort.html\"><code>std::process::abort</code></a>, and I agree that it's sort of our only recourse here.</p>\n<p>Personally I've always felt that man pages are not a reliable source of information when it comes to \"what are the exhaustive set of error conditions that could apply to this function\" and instead I frequently have seen errors not documented in man pages. Given that I don't think we can reason our way around this and conclude that it shouldn't ever actually panic on Linux so we're ok. Instead I think we should expect such errors to be rare (if ever) and still ensure something reasonable happens as a result (e.g. aborting)</p>\n<p>Another option for aborting would be to funnel things through an <code>extern \"C\"</code> function pointer which is defined as \"cannot unwind\" and will catch unwinds and abort the process. That's arguably better since we want to handle panics-while-editing in addition to actual mprotect errors. Or maybe have some sort of flag on <code>BreakpointEdit</code> which indicates a \"yes this is a normal drop\" vs an unwinding drop.</p>\n<p>I do think it would be somewhat possible to basically leak the entire fiber but that's definitely resource leakage. </p>\n<hr>\n<p>Do you know how other engines cope with this? I would expect other JITs to more-or-less run into the same problem here modulo they might not have to return back to code to execute a shim to jump to the start. Otherwise though this seems like something almost all JITs would eventually run into.</p>\n</blockquote>",
        "id": 562725413,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765295962
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2603227470\">PR review comment</a>:</p>\n<blockquote>\n<p>Personally I feel like functions are easier to understand when they can't have variable ABIs and instead just have a single ABI for any particular definition, so I'd lean towards removing this new kind and updating the ABI definition of the breakpoint builtin.</p>\n<p>There might be perf-ish concerns related to Nick's recent refactorings where sets are either dense-or-not and how things are encoded in metadata, but I'm not too concerned about that. I'm mostly worried about accidentally using a non-patchable-abi at some point since everything would more-or-less \"just work\" until runtime if that happened.</p>\n</blockquote>",
        "id": 562725414,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765295962
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3559393888\">PR review</a>.</p>",
        "id": 562784291,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765309825
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2604109221\">PR review comment</a>:</p>\n<blockquote>\n<p>I guess I'm still a little skeptical: there are baked-in notions in various places that the \"Wasm ABI\" means standard <code>tail</code>, and finding any places where we have to add a special case to break that seems worse and more error-prone than saying that there is a new kind of trampoline. I guess I don't see this as a \"variable ABI\" so much as \"we can generate as needed a trampoline of the desired ABI1-to-ABI2 variant\", with current cases Wasm-to-host and Patchable-to-host. That seems cleaner to me? Curious what @fitzgen thinks as well...</p>\n</blockquote>",
        "id": 562784292,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765309826
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 562897251,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765356011
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#issuecomment-3635984492\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>:</p>\n<blockquote>\n<p>Fixed s390x in #12148; that commit is also on top here to see the fix in CI but I'll rebase out once that merges first.</p>\n</blockquote>",
        "id": 562897737,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765356143
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3561388237\">PR review</a>.</p>",
        "id": 562899030,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765356471
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2605733165\">PR review comment</a>:</p>\n<blockquote>\n<p>It looks like SpiderMonkey also landed on the \"just abort the process because there's no better option\" option -- see <a href=\"https://searchfox.org/firefox-main/rev/7496c8515212669451d7e775a00c2be07da38ca5/js/src/jit/AutoWritableJitCode.h#26-56\">AutoWritableJitCodeFallible</a>. Notably the \"fallible\" bit is to make it <em>writable</em>; see the comment there about how it cannot fail to make it executable again in the destructor, and that giant blinking <code>MOZ_CRASH</code> invocation if <code>makeExecutableAndFlushICache</code> fails.</p>\n</blockquote>",
        "id": 562899034,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765356471
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2607272534\">PR review comment</a>:</p>\n<blockquote>\n<p>Ok that seems convincing that we should probably do similar yeah. I'm curious though, what led you to document in <code>unpublish</code> that if it returns an error that things are left in an indeterminate state? I would naively expect that to be able to document/implement \"if this fails then nothing changes, that's a guarantee\" which would mean that starting a breakpoint-edit session is fallible, and it's just dropping the session that's infallible/aborts</p>\n</blockquote>",
        "id": 562992226,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765382678
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3563320835\">PR review</a>.</p>",
        "id": 562992227,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765382678
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 563085526,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765413510
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3568644634\">PR review</a>.</p>",
        "id": 563251850,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765475757
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2611542250\">PR review comment</a>:</p>\n<blockquote>\n<p>We already have a bunch of specific <code>FooToBarTrampoline</code> func keys for trampolines that convert from the <code>Foo</code> ABI/caller to the <code>Bar</code> ABI/callee -- why would we diverge from that precedent/convention here?</p>\n<p>@alexcrichton are you suggesting that we should reuse <code>WasmToBuiltin</code> for this case? That would make sense to me if these trampolines were from the Wasm ABI and calling out to a builtin, but unless I am misunderstanding that is not the case: they are from the patchable ABI to a builtin. We don't already have a <code>FuncKey</code> kind for that pair, so I think it does merit a new kind.</p>\n<blockquote>\n<p>There might be perf-ish concerns related to Nick's recent refactorings where sets are either dense-or-not and how things are encoded in metadata, but I'm not too concerned about that.</p>\n</blockquote>\n<p>I also doubt that this would be an issue in this case.</p>\n</blockquote>",
        "id": 563251853,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765475757
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3568895529\">PR review</a>.</p>",
        "id": 563263256,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765479689
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2611736667\">PR review comment</a>:</p>\n<blockquote>\n<p>Well, overall this is a pretty minor point, so I don't want to over-rotate on this. At the same time though I see <code>FuncKey</code> as a more \"logically these are the buckets of functions we have\". We don't really have all that many <code>FooToBarTrampoline</code> variants actually:</p>\n<ul>\n<li><code>ArrayToWasmTrampoline</code> - this has evolved into the purpose of an entry trampoline and would probably be more aptly named as such. </li>\n<li><code>WasmToArrayTrampoline</code> - this is probably better named \"exit trampoline\" or something like that</li>\n<li><code>WasmToBuiltinTrampoline</code> - this is effectively a different flavor of exit trampoline where it's exiting via a statically known libcall as opposed to some host function of a particular type signature</li>\n</ul>\n<p>Others, however, have little to do with ABI naming-wise: <code>DefinedWasmFunction</code>, <code>PulleyHostCall</code>, <code>ComponentTrampoline</code>, <code>ResourceDropTrampoline</code>, <code>UnsafeIntrinsic</code>.</p>\n<p>I suppose a better way to phrase my concern here is that the naming here hasn't stood up well to the changes over time that have happened, specifically switching from two host ABIs (native + array) to just the one host ABI (array).</p>\n<p>To me, with the lens of \"these are logical buckets\", then there's no need for this new kind because the bucket is \"it's an exit trampoline for a builtin\" which we already have. ABI is heavily implied in all of these variants (and more explicitly specified in some), but the ABI also goes far beyond the literal choice of something like <code>system_v</code> or <code>patchable</code>. For example <code>WasmToArrayTrampoline</code> ABI-wise assumes that it gets a <code>VMArrayCallHostFuncContext</code> which has its own ABI. </p>\n<p>Basically it doesn't feel right to me to focus so heavily on the literal Cranelift ABI used here in these keys. I think it makes more sense to focus on logical buckets, which I feel that this new builtin fits very well into.</p>\n</blockquote>",
        "id": 563263262,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765479690
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3568932145\">PR review</a>.</p>",
        "id": 563265040,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765480381
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2611767583\">PR review comment</a>:</p>\n<blockquote>\n<p>I understand where you're coming from in the sense that there is more to this enum than just Cranelift ABI; but on the other hand, from the perspective of \"I want to use the type system to ensure that I write correct software\", it doesn't feel right to me to add a single exception to one of the details (\"<code>WasmToBuiltin</code> means all of these settings, except for this one special case, so be sure to check the <code>builtin</code> index\"). Basically: the upside to your approach is that we have one less enum entry; the downside is an unknown audit of the whole Wasm-to-Cranelift compiler to ensure that we aren't implicitly assuming things about <code>WasmToBuiltin</code>, and an ongoing complexity cost in this one special exception. We leverage the type system in lots of other places to represent reality and ensure that we cover all cases and get things right; why avoid that here?</p>\n</blockquote>",
        "id": 563265041,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765480381
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3569028275\">PR review</a>:</p>\n<blockquote>\n<p>r=me with outstanding threads resolved</p>\n</blockquote>",
        "id": 563271115,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765482530
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2611846355\">PR review comment</a>:</p>\n<blockquote>\n<p>Not 100% necessary in this PR but: we might want to newtype this, just because we are often also talking about native PCs and text offsets in various places, and we don't want to mix them all up. (We should probably newtype those things too, IMO).</p>\n</blockquote>",
        "id": 563271120,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765482531
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 563330699,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765520348
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3570472965\">PR review</a>.</p>",
        "id": 563330701,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765520350
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2613065889\">PR review comment</a>:</p>\n<blockquote>\n<p>OK, yup, all of that makes sense -- removed the <code>unsafe</code> qualifier here. Thanks!</p>\n</blockquote>",
        "id": 563330702,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765520350
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3570473813\">PR review</a>.</p>",
        "id": 563330718,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765520364
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2613066375\">PR review comment</a>:</p>\n<blockquote>\n<p>Ah, right, I was misreading the logic in <code>publish</code> above for this case -- added the equivalent <code>bail!</code> here too.</p>\n</blockquote>",
        "id": 563330719,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765520365
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 563331896,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765521060
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3570505120\">PR review</a>.</p>",
        "id": 563332022,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765521139
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2613091629\">PR review comment</a>:</p>\n<blockquote>\n<p>OK, updated to <code>std::process::abort</code> on failure to re-publish in the drop impl (see 809b8e54f9).</p>\n<p>I've also updated the docs on <code>unpublish</code> to state that if it fails, permissions are left as executable. I believe this is the case for the actual virtual memory syscall on all supported platforms -- e.g. if <code>mprotect</code> fails it will leave the original permissions.</p>\n<blockquote>\n<p>I'm curious though, what led you to document in unpublish that if it returns an error that things are left in an indeterminate state?</p>\n</blockquote>\n<p>I suppose I hadn't thought too much about what <code>mprotect</code> failure actually meant.</p>\n</blockquote>",
        "id": 563332024,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765521140
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3570506443\">PR review</a>.</p>",
        "id": 563332098,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765521179
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2613092959\">PR review comment</a>:</p>\n<blockquote>\n<p>Agreed -- I'll take this on in followup work as I build out more APIs for this.</p>\n</blockquote>",
        "id": 563332099,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765521179
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#issuecomment-3645122981\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>:</p>\n<blockquote>\n<p>OK, I'm going to go ahead and merge based on Nick's approval here -- thanks Alex and Nick for all the comments!</p>\n</blockquote>",
        "id": 563332160,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765521219
    },
    {
        "content": "<p>cfallin has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 563332168,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765521225
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 563385419,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765526068
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#issuecomment-3645392152\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>:</p>\n<blockquote>\n<p>I had to add some icache coherence handling for aarch64 to make macOS/aarch64 happy in CI (curiously did not reproduce locally on my M1 laptop; but there could be several reasons why cache incoherency would show up differently on different uarchs or nondeterministically in general). @fitzgen mind giving fecbc22 a look and re-r+'ing if OK?</p>\n</blockquote>",
        "id": 563406526,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765526993
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#issuecomment-3645393709\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>:</p>\n<blockquote>\n<p>(That commit should properly fix #3310 once it merges as well.)</p>\n</blockquote>",
        "id": 563407172,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765527024
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2615306252\">PR review comment</a>:</p>\n<blockquote>\n<p>Better to use <a href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html#method.next_multiple_of\">https://doc.rust-lang.org/nightly/std/primitive.usize.html#method.next_multiple_of</a> than to open-code this stuff so that readers have to double-check their hacker's delight knowledge.</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">next_multiple_of</span><span class=\"p\">(</span><span class=\"n\">CACHE_LINE_SIZE</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"p\">.</span><span class=\"n\">next_multiple_of</span><span class=\"p\">(</span><span class=\"n\">CACHE_LINE_SIZE</span><span class=\"p\">);</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 563545495,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765566987
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3573259375\">PR review</a>:</p>\n<blockquote>\n<p>New commit LGTM with one nitpick below</p>\n</blockquote>",
        "id": 563545496,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765566987
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2615313606\">PR review comment</a>:</p>\n<blockquote>\n<p>(FWIW, I verified that LLVM can recreate the hacker's delight style solution for calls to these methods with constant powers-of-two multiples.)</p>\n</blockquote>",
        "id": 563545623,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765567043
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3573271430\">PR review</a>.</p>",
        "id": 563545624,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765567043
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3573344307\">PR review</a>.</p>",
        "id": 563548713,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765568295
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2615369421\">PR review comment</a>:</p>\n<blockquote>\n<p>Ah, yeah, this is an old idiom I just have stuck in my brain. To illustrate the subtlety (and why I just regurgigate the idiom), though, the snippet in your comment is slightly wrong: it needs to be <code>start - CACHE_LINE_SIZE + 1).next_multiple_of(CACHE_LINE_SIZE)</code> to round down properly (consider otherwise e.g. an address halfway through a cache-line).</p>\n<p>I'll update to use the methods but it sure would be nice for there to be a <code>previous_multiple_of</code> or <code>round_down</code> or something like that too!</p>\n</blockquote>",
        "id": 563548715,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765568295
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2615369421\">PR review comment</a>.</p>",
        "id": 563548746,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765568309
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 563548879,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765568367
    },
    {
        "content": "<p>cfallin has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 563548947,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765568391
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3573406471\">PR review</a>.</p>",
        "id": 563551820,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765569610
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2615419806\">PR review comment</a>:</p>\n<blockquote>\n<p>Ah yes of course, good eye.</p>\n<p>I also often wish that <code>prev_multiple_of</code> existed...</p>\n</blockquote>",
        "id": 563551821,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765569610
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#pullrequestreview-3573415301\">PR review</a>.</p>",
        "id": 563552398,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765569829
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133#discussion_r2615427573\">PR review comment</a>:</p>\n<blockquote>\n<p>There is some discussion of it in <a href=\"https://github.com/rust-lang/rust/issues/88581\">https://github.com/rust-lang/rust/issues/88581</a> fwiw, but it also looks like a bit of a mess...</p>\n</blockquote>",
        "id": 563552401,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765569829
    },
    {
        "content": "<p>cfallin merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12133\">PR #12133</a>.</p>",
        "id": 563555602,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1765571152
    }
]