[
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>.</p>",
        "id": 528761179,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752538873
    },
    {
        "content": "<p><strong>cfallin</strong> has marked <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a> as ready for review.</p>",
        "id": 528761202,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752538882
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>.</p>",
        "id": 528761205,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752538884
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers\">wasmtime-compiler-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>.</p>",
        "id": 528761206,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752538884
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>.</p>",
        "id": 528761207,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752538884
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-fuzz-reviewers\">wasmtime-fuzz-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>.</p>",
        "id": 528761209,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752538884
    },
    {
        "content": "<p><strong>cfallin</strong> requested <a href=\"https://github.com/fitzgen\">fitzgen</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>.</p>",
        "id": 528761227,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752538892
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#issuecomment-3071406384\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>:</p>\n<blockquote>\n<p>I think this is ready for a proper review now (and I've addressed comments from Alex and bjorn3 already -- thanks!).</p>\n</blockquote>",
        "id": 528761272,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752538913
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#pullrequestreview-3018238126\">PR review</a>:</p>\n<blockquote>\n<p>LGTM!</p>\n</blockquote>",
        "id": 528767099,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752544133
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#discussion_r2206098128\">PR review comment</a>:</p>\n<blockquote>\n<p>Should this return a <code>StoreInstanceId</code> (i.e. a <code>(StoreId, InstanceId)</code> pair) instead of a plain <code>InstanceId</code> as the first tuple member here? That would make it fully \"tamper-proof\".</p>\n<p>I am not sure where this method is used yet tho...</p>\n</blockquote>",
        "id": 528767100,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752544133
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#discussion_r2206108413\">PR review comment</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>    /// * `Ok(Ok(_))`: The allocation was successful.\n</code></pre></div>\n<p>I guess the copy-paste source probably needs updates too...</p>\n</blockquote>",
        "id": 528767101,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752544134
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#discussion_r2206104962\">PR review comment</a>:</p>\n<blockquote>\n<div class=\"codehilite\" data-code-language=\"suggestion\"><pre><span></span><code>    /// Allocate an uninitialized exception object with the given type\n</code></pre></div>\n<p>\"exceptino\" would make a good pokemon name</p>\n</blockquote>",
        "id": 528767102,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752544134
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#issuecomment-3071811661\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"fuzzing\", \"wasmtime:c-api\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: fuzzing</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 528775427,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752552182
    },
    {
        "content": "<p>jeffparsons submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#pullrequestreview-3018788604\">PR review</a>.</p>",
        "id": 528784899,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752559402
    },
    {
        "content": "<p>jeffparsons created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#discussion_r2206474769\">PR review comment</a>:</p>\n<blockquote>\n<p>Isn't that the evolution of <a href=\"https://en.wikipedia.org/wiki/MissingNo.\">_MissingNo._</a>?</p>\n</blockquote>",
        "id": 528784900,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752559402
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#issuecomment-3072808532\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>:</p>\n<blockquote>\n<blockquote>\n<p>Perhaps with the exception of a setjmp/longjmp use-case in wasi-libc?</p>\n</blockquote>\n<p>I think this is a very load-bearing \"perhaps\", fwiw: I can very very easily see people wanting to have smallest-possible Wasmtime builds and not use GC. And I can equally easily see wasi-libc switch to using sjlj based on EH.</p>\n<p>None of this might be enough to put in the work to support exceptions without GC, of course. But if it's more a lack of signal for a need for it: I would bet good money on us getting that signal before too long </p>\n</blockquote>",
        "id": 528812931,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752570400
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#issuecomment-3073405775\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>:</p>\n<blockquote>\n<p>wasi-libc does have a <a href=\"https://github.com/WebAssembly/wasi-libc/pull/483\">setjmp/longjmp implementation using EH</a>, and does not support setjmp/longjmp otherwise.</p>\n</blockquote>",
        "id": 528848431,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752582450
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#issuecomment-3074281939\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>:</p>\n<blockquote>\n<p>Yes, that's fair, and I did discuss this with Nick early on re: overheads of requiring GC. It seems that the <a href=\"https://github.com/bytecodealliance/wasmtime/blob/64bc3bd982d256bdd608736533e704959bb537b4/crates/wasmtime/src/runtime/store.rs#L1483-L1488\">lazy GC heap allocation</a> means that we should be able to have GC enabled without paying a large penalty for it when not used. That, put against the huge duplication of code to also have a \"GC-less exceptions\" implementation (which would necessarily be almost fully separate, and would also require separate codegen paths), convinced me to go this route.</p>\n<p>I'll note that the exceptions proposal's structuring unfortunately pushes us in this direction too: it does not hold back <code>catch_ref</code> clauses and <code>throw_ref</code> to a \"when GC enabled\" superset, but rather these are always available. It wouldn't be too bad to do an \"unboxed exceptions\" implementation that directly copies payload values and supports only <code>catch</code> clauses and <code>throw</code>, and indeed I started designing down that route in the hope that I could make setjmp/longjmp a happy fastpath, but it's just too much duplication to be maintainable, and also once you need to support the full proposal and box into exception objects, it adds dynamic checks to support the full matrix of <code>{boxed, unboxed} ^ 2</code>.</p>\n</blockquote>",
        "id": 528895327,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752595726
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#issuecomment-3074310071\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>:</p>\n<blockquote>\n<p>Personally while I agree with @cfallin's conclusions about this direction being the way to go for now I also believe that this issue won't be put to rest and this is something we're going to have to deal with. One example is that allocating a GC heap is akin to a second linear memory meaning that the per-Store overhead will jump from one linear memory to two linear memories for \"lean\" languages such as Rust/C/C++, just to support exceptions. (assuming guests eventually get to the point of using exceptions by default). That's then additionally coupled with the fact that it's unlikely embedders will want to interact deeply with exceptions (e.g. make their own, read fields, etc) and nor will Rust/C/C++ use the GC-like behavior of exceptions (e.g. a <code>catch_ref</code> is probably immediately always followed by a <code>throw_ref</code> later in the control flow).</p>\n<p>I think these are all problems we're going to have to tackle at some point in the future. \"Just turn on GC\" as-is today I don't think is going to cut it in the long-term, but I also don't think that should apply stop-energy here either. This implementation is also going to be required in the fullness of time to support GC languages and the exceptions they throw/use. In essence I think that this implementation is basically inevitable and the only hypothetical missing piece is a leaner implementation of \"only the exceptions bits needed for linear memory languages\". That's hypothetical in that it's not certain we need it and it's also not certain what exact subset, if any, is needed.</p>\n</blockquote>",
        "id": 528897059,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752596243
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#discussion_r2208010426\">PR review comment</a>:</p>\n<blockquote>\n<p>I thought about that, but this is stored within an object within the store, and when we reconstitute a <code>&amp;Tag</code> we use the store it came from, so I think we should be fine in this case (vs. adding 4 bytes to every exception object).</p>\n</blockquote>",
        "id": 528901853,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752597798
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#pullrequestreview-3021235713\">PR review</a>.</p>",
        "id": 528901854,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752597798
    },
    {
        "content": "<p>cfallin updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>.</p>",
        "id": 528902112,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752597894
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#discussion_r2208013291\">PR review comment</a>:</p>\n<blockquote>\n<p>Fixed!</p>\n</blockquote>",
        "id": 528902125,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752597899
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#pullrequestreview-3021239972\">PR review</a>.</p>",
        "id": 528902128,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752597899
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#pullrequestreview-3021240156\">PR review</a>.</p>",
        "id": 528902150,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752597904
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#discussion_r2208013444\">PR review comment</a>:</p>\n<blockquote>\n<p>Fixed!</p>\n<p>And fwiw, I believe exceptinos are the subatomic particles that convey exception throws at the speed of light...</p>\n</blockquote>",
        "id": 528902152,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752597904
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>:</p>\n<blockquote>\n<p>This PR implements <em>exception objects</em>: the data model required to support Wasm exceptions, integrated with Wasm GC.</p>\n<p>It builds out support for defining exception types (based on function signatures), and a host API to allocate and examine exception objects. It does <em>not</em> yet tie this into any exception-throwing or -catching instructions (<code>throw</code>, <code>throw_ref</code>, <code>try_table</code>); that will come next.</p>\n<p>The design is a little fiddly because the type system has a nominal aspect to it: tags are <em>per-instance</em> entities and exceptions are associated with tags. The stack-switching work already added support for tags analogously to other instance entities (memories, tables, etc.). But, notably, because they are a runtime concept, they are not types per-se. Their signatures are, though, and <code>TagType</code> is a thin wrapper around <code>FuncType</code> as a result. The Wasm proposal does not define any concrete type definitions for exception objects in the lattice, only providing top (<code>exnref</code> / <code>(ref null exn)</code>) and bottom (<code>nullexnref</code> / <code>(ref null noexn)</code>) types. In order to align with the way the rest of the GC system works, I've opted to define our own notion of structural types at the host API and type-interning layer built around the signatures; so all Wasm exception objects with the same func-type / signature are the same \"type\" as far as GC is concerned. The objects of that type are then associated with particular tag instances via runtime fields. In essence we are refining the Wasm types further to allow our implementation to precompute things (i.e., layouts); this is fine because this refinement is not exposed to Wasm.</p>\n</blockquote>",
        "id": 528902281,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752597950
    },
    {
        "content": "<p>cfallin has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>.</p>",
        "id": 528902445,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752598004
    },
    {
        "content": "<p>cfallin merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>.</p>",
        "id": 528911316,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752601194
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#issuecomment-3074653770\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>:</p>\n<blockquote>\n<p>I think we will want to keep the implementation of exceptions in terms of GC objects, with possible unboxing optimizations that are really orthogonal to the core discussion here, but we will want to add config knobs dedicated for GC heaps. Right now, GC heaps are always the same configuration as linear memories. For LIME-style deployments, however, they will want to configure the GC heap to be much smaller than 64KiB (effectively using custom-page-sizes for GC heap memories), after which</p>\n<blockquote>\n<p>allocating a GC heap is akin to a second linear memory</p>\n</blockquote>\n<p>is effectively resolved.</p>\n<p>We really don't want to have to maintain two implementations of exceptions: one for LIME Wasm and one for GC Wasm. By allowing one to configure the GC heap so that it is tiny, we are effectively allowing the GC-based implementation to be tuned down into the equivalent side-table that we would implement for the LIME Wasm version.</p>\n</blockquote>",
        "id": 528912260,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752601575
    },
    {
        "content": "<p>tschneidereit <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#issuecomment-3077917554\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>:</p>\n<blockquote>\n<blockquote>\n<p>is effectively resolved.</p>\n</blockquote>\n<p>Does this allow us to set the allocation to 0, or something really very small? Because if it still requires at least one host page size of memory, I'm not sure it really is effectively resolved for all use cases.</p>\n<p>Besides memory usage, I'm also concerned about the code size increase we incur by forcing the inclusion of full GC support for exception handling. Do we have a way to quantify / at least very roughly estimate how much larger a size-optimized binary becomes because of that?</p>\n</blockquote>",
        "id": 529025794,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752661249
    },
    {
        "content": "<p>sunfishcode <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#issuecomment-3078409608\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>:</p>\n<blockquote>\n<blockquote>\n<p>It wouldn't be too bad to do an \"unboxed exceptions\" implementation that directly copies payload values and supports only <code>catch</code> clauses and <code>throw</code></p>\n</blockquote>\n<p>In the Lime series, we do have the ability to <a href=\"https://github.com/WebAssembly/tool-conventions/blob/main/Lime.md#feature-subsets\">subset features</a>, for exactly this reason, so perhaps we should to that for EH too.</p>\n<p>It seems likely that other engines will want a subset too. And the <a href=\"https://github.com/WebAssembly/tool-conventions/blob/main/SetjmpLongjmp.md\">setjmp/longjmp</a> used by LLVM and wasi-libc already uses just <code>catch</code> and <code>throw</code>.</p>\n</blockquote>",
        "id": 529050838,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752669732
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#issuecomment-3079572949\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>:</p>\n<blockquote>\n<p>Meta note: I am going to file a follow up issue for this discussion. Once I do so, let's move all this discussion there.</p>\n</blockquote>",
        "id": 529106815,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752687102
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230#issuecomment-3079720789\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11230\">PR #11230</a>:</p>\n<blockquote>\n<blockquote>\n<p>Meta note: I am going to file a follow up issue for this discussion. Once I do so, let's move all this discussion there.</p>\n</blockquote>\n<p>Filed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11256\">https://github.com/bytecodealliance/wasmtime/issues/11256</a></p>\n</blockquote>",
        "id": 529112025,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1752689310
    }
]