[
    {
        "content": "<p>geraintluff opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Can the <code>wasi.h</code> API be made generic, so that it only references <code>wasm.h</code>, and not any Wasmtime internals?</p>\n<p>It's really close already, and I've detailed the exact changes below make it usable for this situation.</p>\n<h4>Benefit</h4>\n<p>Making the WASI API more generic would let users swap the implementation out, supporting straightforward WASI with other engines.</p>\n<p>For example, I'm writing a library which uses a WASM engine through the official C API.  I'm testing it by linking to Wasmtime, but nothing in my code is Wasmtime-specific, so users <em>could</em> use alternatives (such as Bytecode Alliance's WAMR, which has a smaller binary footprint).</p>\n<p>Wasmtime's implementation of the <code>wasi.h</code> API could still be tightly coupled to its <code>wasm.h</code> implementation, (i.e. knowing that <code>wasm_store_t *</code> was a particular Wasmtime class).</p>\n<p>I'm writing a C++ implementation of such a WASI module, but it would be awesome to have Wasmtime's one spun out and usable independently, for security and performance reasons.</p>\n<h4>Implementation</h4>\n<p>I've added the following changes to Wasmtime's <code>wasi.h</code>:</p>\n<ul>\n<li>remove <code>#include &lt;wasmtime/conf.h&gt;</code> and <code>#ifdef WASMTIME_FEATURE_WASI</code></li>\n<li>remove the <code>WASMTIME_</code> prefixes from the <code>wasi_dir_perms_flags</code>/<code>wasi_file_perms_flags</code> enums.</li>\n<li>add a single function to resolve a WASI import:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cm\">/**</span>\n<span class=\"cm\"> * \\brief returns a WASI import, or NULL if not supported by the config.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The caller is expected to deallocate the returned import.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The import is valid only for the lifetime of the supplied config and store.</span>\n<span class=\"cm\"> */</span>\n<span class=\"n\">WASI_API_EXTERN</span><span class=\"w\"> </span><span class=\"n\">wasm_extern_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">wasi_config_resolve</span><span class=\"p\">(</span><span class=\"n\">wasi_config_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">config</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_store_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">store</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_importtype_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">type</span><span class=\"p\">);</span>\n</code></pre></div>\n<h4>Alternatives</h4>\n<p>Since I can't use an engine-agnostic WASI API, I'm _currently_ writing/using my own C++ library, which provides WASI for <em>any</em> WASM engine.</p>\n<p>This would still be useful for other engines which don't (yet) provide their own <code>wasi.h</code>, but being able to use Wasmtime's (fast and secure) WASI implementation without being locked to Wasmtime specifically would be much preferable!</p>\n</blockquote>",
        "id": 503009158,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741003384
    },
    {
        "content": "<p>geraintluff edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Can the <code>wasi.h</code> API be made generic, so that it only references <code>wasm.h</code>, and not any Wasmtime internals?</p>\n<p>It's really close already, and I've detailed the exact changes below make it usable for this situation.</p>\n<h4>Benefit</h4>\n<p>Making the WASI API more generic would let users swap the implementation out, supporting straightforward WASI with other engines.</p>\n<p>For example, I'm writing a library which uses a WASM engine through the official C API.  I'm testing it by linking to Wasmtime, but nothing in my code is Wasmtime-specific, so users <em>could</em> link the library to alternatives (such as Bytecode Alliance's WAMR, which has a smaller binary footprint).</p>\n<p>I can't (currently) use WASI the same way, so (to be engine-agnostic) I've ended up writing my own C++ WASI implementation.  It would be awesome to use Wasmtime's one (for security and performance) when using the Wasmtime engine, by just linking appropriately.  Wasmtime's implementation of the <code>wasi.h</code> API could still be tightly coupled to its <code>wasm.h</code> implementation, (i.e. knowing that <code>wasm_store_t *</code> was a particular Wasmtime class).</p>\n<h4>Implementation</h4>\n<p>I've added the following changes to Wasmtime's <code>wasi.h</code>:</p>\n<ul>\n<li>remove <code>#include &lt;wasmtime/conf.h&gt;</code> and <code>#ifdef WASMTIME_FEATURE_WASI</code></li>\n<li>remove the <code>WASMTIME_</code> prefixes from the <code>wasi_dir_perms_flags</code>/<code>wasi_file_perms_flags</code> enums.</li>\n<li>add a single function to resolve a WASI import:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cm\">/**</span>\n<span class=\"cm\"> * \\brief returns a WASI import, or NULL if not supported by the config.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The caller is expected to deallocate the returned import.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The import is valid only for the lifetime of the supplied config and store.</span>\n<span class=\"cm\"> */</span>\n<span class=\"n\">WASI_API_EXTERN</span><span class=\"w\"> </span><span class=\"n\">wasm_extern_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">wasi_config_resolve</span><span class=\"p\">(</span><span class=\"n\">wasi_config_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">config</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_store_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">store</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_importtype_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">type</span><span class=\"p\">);</span>\n</code></pre></div>\n<h4>Alternatives</h4>\n<p>Since I can't use an engine-agnostic WASI API, I'm _currently_ writing/using my own C++ library, which provides WASI for <em>any</em> WASM engine.</p>\n<p>This would still be useful for other engines which don't (yet) provide their own <code>wasi.h</code>, but being able to use Wasmtime's (fast and secure) WASI implementation without being locked to Wasmtime specifically would be much preferable!</p>\n</blockquote>",
        "id": 503016188,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741005603
    },
    {
        "content": "<p>geraintluff edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Can the <code>wasi.h</code> API be made generic, so that it only references <code>wasm.h</code>, and not any Wasmtime internals?</p>\n<p>It's really close already, and I've detailed the exact changes below make it usable for this situation.</p>\n<h4>Benefit</h4>\n<p>Making the WASI API more generic would let users swap the implementation out, supporting straightforward WASI with other engines.</p>\n<p>For example, I'm writing a library which uses a WASM engine through the official C API.  I'm testing it by linking to Wasmtime, but nothing in my code is Wasmtime-specific, so users <em>could</em> link the library to alternatives (such as Bytecode Alliance's WAMR, which has a smaller binary footprint).</p>\n<p>I can't (currently) use WASI the same way, so (to be engine-agnostic) I've ended up writing my own C++ WASI implementation, which uses the engine entirely through the WASM C API.  It would be awesome to use Wasmtime's one (for security and performance) when using the Wasmtime engine, by just linking appropriately.  Wasmtime's implementation of the <code>wasi.h</code> API could still be tightly coupled to its <code>wasm.h</code> implementation, (i.e. knowing that <code>wasm_store_t *</code> was a particular Wasmtime class).</p>\n<h4>Implementation</h4>\n<p>I've added the following changes to Wasmtime's <code>wasi.h</code>:</p>\n<ul>\n<li>remove <code>#include &lt;wasmtime/conf.h&gt;</code> and <code>#ifdef WASMTIME_FEATURE_WASI</code></li>\n<li>remove the <code>WASMTIME_</code> prefixes from the <code>wasi_dir_perms_flags</code>/<code>wasi_file_perms_flags</code> enums.</li>\n<li>add a single function to resolve a WASI import:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cm\">/**</span>\n<span class=\"cm\"> * \\brief returns a WASI import, or NULL if not supported by the config.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The caller is expected to deallocate the returned import.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The import is valid only for the lifetime of the supplied config and store.</span>\n<span class=\"cm\"> */</span>\n<span class=\"n\">WASI_API_EXTERN</span><span class=\"w\"> </span><span class=\"n\">wasm_extern_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">wasi_config_resolve</span><span class=\"p\">(</span><span class=\"n\">wasi_config_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">config</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_store_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">store</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_importtype_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">type</span><span class=\"p\">);</span>\n</code></pre></div>\n<h4>Alternatives</h4>\n<p>Since I can't use an engine-agnostic WASI API, I'm _currently_ writing/using my own C++ library, which provides WASI for <em>any</em> WASM engine.</p>\n<p>This would still be useful for other engines which don't (yet) provide their own <code>wasi.h</code>, but being able to use Wasmtime's (fast and secure) WASI implementation without being locked to Wasmtime specifically would be much preferable!</p>\n</blockquote>",
        "id": 503016376,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741005656
    },
    {
        "content": "<p>geraintluff edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Can the <code>wasi.h</code> API be made generic, so that it only references <code>wasm.h</code>, and not any Wasmtime internals?</p>\n<p>It's really close already, and I've detailed the exact changes below make it usable for this situation.</p>\n<h4>Benefit</h4>\n<p>Making the WASI API more generic would let users swap the implementation out, supporting straightforward WASI with other engines.</p>\n<p>For example, I'm writing a library which uses a WASM engine through the official C API.  I'm testing it by linking to Wasmtime, but nothing in my code is Wasmtime-specific, so users <em>could</em> link the library to alternatives (such as Bytecode Alliance's WAMR, which has a smaller binary footprint).</p>\n<p>I can't (currently) use WASI the same way.  It would be awesome to use Wasmtime's one (for security and performance) when using the Wasmtime engine, or a more generic fallback one, just by linking differently.  Wasmtime's implementation of the <code>wasi.h</code> API could still be tightly coupled to its <code>wasm.h</code> implementation, (i.e. knowing that <code>wasm_store_t *</code> was a particular Wasmtime class).</p>\n<h4>Implementation</h4>\n<p>I've added the following changes to Wasmtime's <code>wasi.h</code>:</p>\n<ul>\n<li>remove <code>#include &lt;wasmtime/conf.h&gt;</code> and <code>#ifdef WASMTIME_FEATURE_WASI</code></li>\n<li>remove the <code>WASMTIME_</code> prefixes from the <code>wasi_dir_perms_flags</code>/<code>wasi_file_perms_flags</code> enums.</li>\n<li>add a single function to resolve a WASI import:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cm\">/**</span>\n<span class=\"cm\"> * \\brief returns a WASI import, or NULL if not supported by the config.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The caller is expected to deallocate the returned import.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The import is valid only for the lifetime of the supplied config and store.</span>\n<span class=\"cm\"> */</span>\n<span class=\"n\">WASI_API_EXTERN</span><span class=\"w\"> </span><span class=\"n\">wasm_extern_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">wasi_config_resolve</span><span class=\"p\">(</span><span class=\"n\">wasi_config_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">config</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_store_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">store</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_importtype_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">type</span><span class=\"p\">);</span>\n</code></pre></div>\n<h4>Alternatives</h4>\n<p>To be engine-agnostic, I'm _currently_ writing/using my own C++ library which provides the above API, entirely through the WASM C API so it works with any WASM engine.</p>\n<p>Unfortunately, this means I can't use Wasmtime's (fast and secure) WASI implementation unless I put some gnarly Wasmtime-specific <code>#ifdef</code>s in the code.</p>\n</blockquote>",
        "id": 503021141,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741007043
    },
    {
        "content": "<p>geraintluff edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Can the <code>wasi.h</code> API be made generic, so that it only references <code>wasm.h</code>, and not any Wasmtime internals?</p>\n<p>It's really close already, and I've detailed the exact changes below which would make it usable for this.</p>\n<h4>Benefit</h4>\n<p>Making the WASI API more generic would let users swap the implementation out, supporting straightforward WASI with other engines.</p>\n<p>For example, I'm writing a library which uses a WASM engine through the official C API.  I'm testing it by linking to Wasmtime, but nothing in my code is Wasmtime-specific, so users <em>could</em> link the library to alternatives (such as Bytecode Alliance's WAMR, which has a smaller binary footprint).</p>\n<p>I can't (currently) use WASI the same way.  It would be awesome to use Wasmtime's one (for security and performance) when using the Wasmtime engine, or a more generic fallback one, just by linking differently.  Wasmtime's implementation of the <code>wasi.h</code> API could still be tightly coupled to its <code>wasm.h</code> implementation, (i.e. knowing that <code>wasm_store_t *</code> was a particular Wasmtime class).</p>\n<h4>Implementation</h4>\n<p>I've added the following changes to Wasmtime's <code>wasi.h</code>:</p>\n<ul>\n<li>remove <code>#include &lt;wasmtime/conf.h&gt;</code> and <code>#ifdef WASMTIME_FEATURE_WASI</code></li>\n<li>remove the <code>WASMTIME_</code> prefixes from the <code>wasi_dir_perms_flags</code>/<code>wasi_file_perms_flags</code> enums.</li>\n<li>add a single function to resolve a WASI import:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cm\">/**</span>\n<span class=\"cm\"> * \\brief returns a WASI import, or NULL if not supported by the config.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The caller is expected to deallocate the returned import.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The import is valid only for the lifetime of the supplied config and store.</span>\n<span class=\"cm\"> */</span>\n<span class=\"n\">WASI_API_EXTERN</span><span class=\"w\"> </span><span class=\"n\">wasm_extern_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">wasi_config_resolve</span><span class=\"p\">(</span><span class=\"n\">wasi_config_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">config</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_store_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">store</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_importtype_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">type</span><span class=\"p\">);</span>\n</code></pre></div>\n<h4>Alternatives</h4>\n<p>To be engine-agnostic, I'm _currently_ writing/using my own C++ library which provides the above API, entirely through the WASM C API so it works with any WASM engine.</p>\n<p>Unfortunately, this means I can't use Wasmtime's (fast and secure) WASI implementation unless I put some gnarly Wasmtime-specific <code>#ifdef</code>s in the code.</p>\n</blockquote>",
        "id": 503022220,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741007374
    },
    {
        "content": "<p>geraintluff edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Can the <code>wasi.h</code> API be made generic, so that it only references <code>wasm.h</code>, and not any Wasmtime internals?</p>\n<p>It's really close already, and I've detailed the exact changes below which would make it usable for this.</p>\n<h4>Benefit</h4>\n<p>Making the WASI API more generic would let users swap the implementation out, supporting straightforward WASI with other engines.</p>\n<p>For example, I'm writing a library which uses a WASM engine through the official C API.  I'm testing it by linking to Wasmtime, but nothing in my code is Wasmtime-specific, so users <em>could</em> link the library to alternatives (such as Bytecode Alliance's WAMR, which has a smaller binary footprint) with no code changes.</p>\n<p>I can't (currently) use WASI the same way.  It would be awesome to use Wasmtime's one (for security and performance) when using the Wasmtime engine, or a more generic fallback one, just by linking differently.  Wasmtime's implementation of the <code>wasi.h</code> API could still be tightly coupled to its <code>wasm.h</code> implementation, (i.e. knowing that <code>wasm_store_t *</code> was a particular Wasmtime class).</p>\n<h4>Implementation</h4>\n<p>I've added the following changes to Wasmtime's <code>wasi.h</code>:</p>\n<ul>\n<li>remove <code>#include &lt;wasmtime/conf.h&gt;</code> and <code>#ifdef WASMTIME_FEATURE_WASI</code></li>\n<li>remove the <code>WASMTIME_</code> prefixes from the <code>wasi_dir_perms_flags</code>/<code>wasi_file_perms_flags</code> enums.</li>\n<li>add a single function to resolve a WASI import:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cm\">/**</span>\n<span class=\"cm\"> * \\brief returns a WASI import, or NULL if not supported by the config.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The caller is expected to deallocate the returned import.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The import is valid only for the lifetime of the supplied config and store.</span>\n<span class=\"cm\"> */</span>\n<span class=\"n\">WASI_API_EXTERN</span><span class=\"w\"> </span><span class=\"n\">wasm_extern_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">wasi_config_resolve</span><span class=\"p\">(</span><span class=\"n\">wasi_config_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">config</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_store_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">store</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_importtype_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">type</span><span class=\"p\">);</span>\n</code></pre></div>\n<h4>Alternatives</h4>\n<p>To be engine-agnostic, I'm _currently_ writing/using my own C++ library which provides the above API, entirely through the WASM C API so it works with any WASM engine.</p>\n<p>Unfortunately, this means I can't use Wasmtime's (fast and secure) WASI implementation unless I put some gnarly Wasmtime-specific <code>#ifdef</code>s in the code.</p>\n</blockquote>",
        "id": 503022327,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741007403
    },
    {
        "content": "<p>geraintluff edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Can the <code>wasi.h</code> API be made generic, so that it only references <code>wasm.h</code>, and not any Wasmtime internals?</p>\n<p>It's really close already, and I've detailed the exact changes below which would make it usable for this.</p>\n<h4>Benefit</h4>\n<p>Making the WASI API more generic would let users swap the implementation out, supporting straightforward WASI with other engines.</p>\n<p>For example, I'm writing a library which uses a WASM engine through the official C API.  I'm testing it by linking to Wasmtime, but nothing in my code is Wasmtime-specific, so users <em>could</em> link the library to alternatives (such as Bytecode Alliance's WAMR, which has a smaller binary footprint) with no code changes.</p>\n<p>I can't (currently) use WASI the same way.  It would be awesome to use Wasmtime's one (for security and performance) when using the Wasmtime engine, or a more generic fallback one, just by linking differently.  Wasmtime's implementation of the <code>wasi.h</code> API could still be tightly coupled to its <code>wasm.h</code> implementation, (i.e. knowing that <code>wasm_store_t *</code> was a particular Wasmtime class).</p>\n<h4>Implementation</h4>\n<p>I've added the following changes to Wasmtime's <code>wasi.h</code>:</p>\n<ul>\n<li>remove <code>#include &lt;wasmtime/conf.h&gt;</code> and <code>#ifdef WASMTIME_FEATURE_WASI</code></li>\n<li>remove the <code>WASMTIME_</code> prefixes from the <code>wasi_dir_perms_flags</code>/<code>wasi_file_perms_flags</code> enums.</li>\n<li>add a single function to resolve a WASI import:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cm\">/**</span>\n<span class=\"cm\"> * \\brief returns a WASI import, or NULL if not supported by the config.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The caller is expected to deallocate the returned import.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The import is valid only for the lifetime of the supplied config and store.</span>\n<span class=\"cm\"> */</span>\n<span class=\"n\">WASI_API_EXTERN</span><span class=\"w\"> </span><span class=\"n\">wasm_extern_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">wasi_config_resolve</span><span class=\"p\">(</span><span class=\"n\">wasi_config_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">config</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_store_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">store</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">wasm_importtype_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">type</span><span class=\"p\">);</span>\n</code></pre></div>\n<h4>Alternatives</h4>\n<p>To be engine-agnostic, I'm _currently_ writing/using my own C++ library which provides the above API, entirely through the WASM C API so it works with any WASM engine.</p>\n<p>Unfortunately, this means I can't use Wasmtime's (fast and secure) WASI implementation unless I put some gnarly Wasmtime-specific <code>#ifdef</code>s in the code.</p>\n</blockquote>",
        "id": 503024085,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741007903
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320#issuecomment-2694868429\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<p>Personally I would not recommend using the <code>wasm.h</code> C API. It is less safe and less performant than Wasmtime's custom C API. For this reason I've additionally wanted to historically move in the direction of making <code>wasi.h</code> more like <code>wasmtime/wasi.h</code> and making it Wasmtime-specific. It was originally envisioned as the start of a standard but that hasn't really panned out so we've had various pressures historically pushing in the direction of integrating it more tightly and changing it over time.</p>\n<blockquote>\n<p>which has a smaller binary footprint</p>\n</blockquote>\n<p>This should not be the case in theory, if you find a drastic difference we have <a href=\"https://docs.wasmtime.dev/examples-minimal.html\">documentation on producing minimal builds</a> and if a large different still remains we'd appreciate a bug report!</p>\n</blockquote>",
        "id": 503064055,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741017882
    },
    {
        "content": "<p>geraintluff <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320#issuecomment-2695083458\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<p>So you reckon the WASM C API is a bad idea, and would prefer each library to be tied to a particular WASM engine?</p>\n<p>For what it's worth, if the WASM C API hadn't made it so easy to switch, I would still be using Wasmer.  It's what I started with, and it lets you use the <a href=\"https://wasmer.io/posts/wasmer-3_3-and-javascriptcore\">JavaScriptCore WebAssembly engine</a> (so you don't even need to ship a compiler/JIT for MacOS).</p>\n</blockquote>",
        "id": 503083839,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741022845
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320#issuecomment-2695462687\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<p>I'm pointing out that this issue is unlikely to happen in my opinion since we've generally gone in the opposite direction of <code>wasm.h</code>.  That does not mean it shouldn't be done nor that it won't be done, just that from my own personal perspective it's probably not worth doing. I don't mean to stifle development of <code>wasm.h</code> or a hypothetical \"official\" <code>wasi.h</code> either. </p>\n<p>The topic of the quality fo the <code>wasm.h</code> API is probably a bit orthogonal to this issue. I brought it up to motivate why I have the rationale I do, but if you'd like to dig into that it's probably best to do so on Zulip for example or in a dedicated location.</p>\n</blockquote>",
        "id": 503117191,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741033617
    },
    {
        "content": "<p>geraintluff <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320#issuecomment-2697013961\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<p>What (in your opinion) are the chances of _removing_ the <code>wasi.h</code> exports then, and using Wasmtime-only names instead of something that looks like it should be generic?</p>\n<p>At the moment, I've had to do some awkward linking tricks to stop the Wasmtime exports from clashing with my own implementation.  I like the <code>wasi.h</code> API (with the above changes) and would like to provide something with that API.</p>\n</blockquote>",
        "id": 503232307,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741084550
    },
    {
        "content": "<p>geraintluff edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320#issuecomment-2697013961\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<p>What (in your opinion) are the chances of _removing_ the <code>wasi.h</code> exports then, and using Wasmtime-only names instead of something that looks like it should be generic?</p>\n<p>At the moment, I've had to do some awkward linking tricks to stop the Wasmtime exports from clashing with my own implementation.  I like the <code>wasi.h</code> API (with the above changes) and would like to provide something with that interface, particularly if Wasmtime isn't interested in it.</p>\n</blockquote>",
        "id": 503232535,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741084624
    },
    {
        "content": "<p>geraintluff edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320#issuecomment-2697013961\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<p>What (in your opinion) are the chances of _removing_ the <code>wasi.h</code> exports then, and using Wasmtime-only names instead of something that looks like it should be generic?</p>\n<p>At the moment, I've had to do some awkward linking tricks to stop the Wasmtime exports from clashing with my own implementation.  I like the <code>wasi.h</code> API (with the above changes) and would like to provide something with that interface, particularly if Wasmtime isn't interested in filling the same gap.</p>\n</blockquote>",
        "id": 503232563,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741084633
    },
    {
        "content": "<p>geraintluff edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320#issuecomment-2697013961\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<p>What (in your opinion) are the chances of _removing_ the <code>wasi.h</code> exports then, and using Wasmtime-only names instead of something that looks like it should be generic?</p>\n<p>At the moment, I've had to do some awkward linking tricks to stop the Wasmtime exports from clashing with my own implementation.  I like the <code>wasi.h</code> API (with the above changes) and would like to provide something with that interface - something independent and engine-agnostic, plus a wrapper around Wasmtime-coupled one if possible.</p>\n</blockquote>",
        "id": 503233851,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741085084
    },
    {
        "content": "<p>geraintluff closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Can the <code>wasi.h</code> API be made generic, so that it only references <code>wasm.h</code>, and not any Wasmtime internals?</p>\n<p>It's really close already, and I've detailed the exact changes below which would make it usable for this.</p>\n<h4>Benefit</h4>\n<p>Making the WASI API more generic would let users swap the implementation out, supporting straightforward WASI with other engines.</p>\n<p>For example, I'm writing a library which uses a WASM engine through the official C API.  I'm testing it by linking to Wasmtime, but nothing in my code is Wasmtime-specific, so users <em>could</em> link the library to alternatives (such as Bytecode Alliance's WAMR, which has a smaller binary footprint) with no code changes.</p>\n<p>I can't (currently) use WASI the same way.  It would be awesome to use Wasmtime's one (for security and performance) when using the Wasmtime engine, or a more generic fallback one, just by linking differently.  Wasmtime's implementation of the <code>wasi.h</code> API could still be tightly coupled to its <code>wasm.h</code> implementation, (i.e. knowing that <code>wasm_store_t *</code> was a particular Wasmtime class).</p>\n<h4>Implementation</h4>\n<p>I've added the following changes to Wasmtime's <code>wasi.h</code>:</p>\n<ul>\n<li>remove <code>#include &lt;wasmtime/conf.h&gt;</code> and <code>#ifdef WASMTIME_FEATURE_WASI</code></li>\n<li>remove the <code>WASMTIME_</code> prefixes from the <code>wasi_dir_perms_flags</code>/<code>wasi_file_perms_flags</code> enums.</li>\n<li>add a single function to resolve a WASI import:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"cm\">/**</span>\n<span class=\"cm\"> * \\brief returns a WASI import, or NULL if not supported by the config.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The caller is expected to deallocate the returned import.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * The import is valid only for the lifetime of the supplied config and store.</span>\n<span class=\"cm\"> */</span>\n<span class=\"n\">WASI_API_EXTERN</span><span class=\"w\"> </span><span class=\"n\">wasm_extern_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">wasi_config_resolve</span><span class=\"p\">(</span><span class=\"n\">wasi_config_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">config</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"n\">wasm_store_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">store</span><span class=\"p\">,</span>\n<span class=\"w\">                                                    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">wasm_importtype_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">type</span><span class=\"p\">);</span>\n</code></pre></div>\n<h4>Alternatives</h4>\n<p>To be engine-agnostic, I'm _currently_ writing/using my own C++ library which provides the above API, entirely through the WASM C API so it works with any WASM engine.</p>\n<p>Unfortunately, this means I can't use Wasmtime's (fast and secure) WASI implementation unless I put some gnarly Wasmtime-specific <code>#ifdef</code>s in the code.</p>\n</blockquote>",
        "id": 503522295,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741182979
    },
    {
        "content": "<p>geraintluff <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320#issuecomment-2701019911\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10320\">issue #10320</a>:</p>\n<blockquote>\n<p>OK, so Wasmtime's <code>wasm.h</code> interface actually aborts on a key operation I needed (calling a function by index in a function table), so I can't use it, WASI or not.</p>\n<p>Closing as no longer relevant.</p>\n</blockquote>",
        "id": 503522299,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1741182980
    }
]