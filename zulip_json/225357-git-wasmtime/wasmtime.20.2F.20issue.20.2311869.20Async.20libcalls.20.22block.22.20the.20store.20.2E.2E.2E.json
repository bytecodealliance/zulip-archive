[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11869\">issue #11869</a>:</p>\n<blockquote>\n<p>At this time the implementation of async libcalls in Wasmtime all use the <code>block_on</code> helper internally in the implementation. This has the property, though, that the store is \"locked\" while the libcall is waiting on the result meaning that in a component-model-async world it's not possible to make progress on anything else in the store while this is happening. This notably affects <code>Store::run_concurrent</code> as well where any select-ed async computation won't make progress because the wasm is locking up everything.</p>\n<p>To fix this it will require async libcalls to be refactored/reimplemented to not close over the store for the duration of their execution. Instead something like <code>Accessor</code> will be required where mutable access to a store can be temporarily granted but otherwise it's not held across <code>await</code> points. In implementing this it'll fix <code>run_concurrent</code> to correctly and actually run various computations in the provided closure concurrently. This will also enable other concurrent tasks within the store to make progress while a libcall is blocked.</p>\n</blockquote>",
        "id": 545132224,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760564730
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasm-proposal:component-model-async label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11869\">Issue #11869</a>.</p>",
        "id": 545132227,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760564730
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11869#issuecomment-3832992306\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11869\">issue #11869</a>:</p>\n<blockquote>\n<p>I talked with Luke and Joel about this a bit ago and wanted to write down some notes. Async libcalls right now are:</p>\n<ul>\n<li>Things that trigger an async limiter<ul>\n<li>table growth (all kinds)</li>\n<li>memory growth</li>\n</ul>\n</li>\n<li>Things that may trigger GC (async nature of GC, async limiter, etc)<ul>\n<li>table initialization</li>\n<li>growing the gc heap</li>\n<li>gc allocation</li>\n<li>array new/init data/elem</li>\n</ul>\n</li>\n<li>Fuel running out</li>\n<li>Epochs changing</li>\n</ul>\n<p>All of these libcalls fall into the category of \"the wasm is stuck between two plain/normal wasm instructions\". It would be a violation of runtime semantics if Wasmtime were to allow something else to interleave between instructions. For example during an epoch yield it's not valid for Wasmtime to run some other wasm within the store as that could have visible side effects.</p>\n<p>Put another way Wasmtime will need to enforce a \"lock\" where when these async situations are hit it prevents all wasm from continuing to execute. My rough idea for this is that the store, with concurrency enabled, will grow an async-recursive-mutex-of-sorts (probably not literally). This lock will be \"bounced on\" whenever wasm is entered via the host call or exited via a hostcall returning. The lock is then held across the async operation of an epoch/fuel/async limiters/gc/etc from above. The rough idea is that this is a <code>Option&lt;Vec&lt;Waker&gt;&gt;</code> in the store. If that's <code>None</code>, the lock isn't held. If it's <code>Some</code>, then the lock is held. When the lock is \"dropped\" then all the wakers are woken (if any).</p>\n<p>This'll likely require refactoring some various points within Wasmtime to instrument more entries/exits with <code>async</code> in Rust. Ideally the lock acquisition/bounce/etc are all native <code>async</code> functions. This'll probably require some finesse.</p>\n<p>The main learning from this is we can't simply start using <code>run_concurrent</code> (ish) within these libcalls. If we were to do that then we would accidentally allow the situation we don't want, which is executing wasm instructions between other instructions that don't allow interleaving. This means that to fully avoid blocking the store we'll have to add infrastructure, as opposed to just removing a limitation.</p>\n</blockquote>",
        "id": 571349914,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770010184
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11869#issuecomment-3902685168\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11869\">issue #11869</a>:</p>\n<blockquote>\n<p>Another thought that occurs to me borne out of thoughts/discussion from <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12587\">https://github.com/bytecodealliance/wasmtime/pull/12587</a> -- preventing wasm execution during an async libcall is not enough, we have to prevent mutation of the entire store. This includes things like executing wasm, but it extends to host-initiated modifications of tables/globals as well. That's a needle I don't know how to thread...</p>\n</blockquote>",
        "id": 573930457,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771108268
    }
]