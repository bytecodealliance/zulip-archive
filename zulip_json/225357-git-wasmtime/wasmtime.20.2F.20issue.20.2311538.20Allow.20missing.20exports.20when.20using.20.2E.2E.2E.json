[
    {
        "content": "<p>no30bit opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538\">issue #11538</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Extend <code>wasmtime::component::bindgen!</code> or <code>wasmtime::component::Linker</code> to allow input components to miss some of the exports from WIT interfaces.</p>\n<h4>Benefit</h4>\n<p>On my project I have a user-implemented wasm component that I compile and call functions from at runtime.<br>\nWith <code>component::Linker</code> I haven't found a way to add \"default\" <strong>exports</strong>. For imports this can be achieved with <code>allow_shadowing</code> and <code>func_wrap</code>.</p>\n<p>So I have to force my users to define every single export with default values event when they don't need it. This implies their code breaks every time I add another possible export, since they would have it missing.</p>\n<p>Benefit in my case is backward compatibility when adding new exports in WIT and not having to define unnecessary defaults by guests. </p>\n<h4>Implementation</h4>\n<p>Currently <code>bindgen!</code> generates code that looks like this for each WIT export:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">WorldName</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Guest</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>I would like to have something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// panics if `foo` export isn't present in component</span>\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Guest</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// `None` if `foo` export isn't present in component</span>\n<span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">get_foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"n\">Guest</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>To maintain backward compatibility, this feature could be configured in <code>bindgen!</code> parameters (i.e. making exports not link-time verified). </p>\n<h4>Alternatives</h4>\n<ul>\n<li>\n<p>If there's a way to link a default-component to be partially shadowed by real implementations, I'd like an example similar to the existing one for linking modules (<a href=\"https://docs.wasmtime.dev/examples-c-linking.html\">this</a>). </p>\n</li>\n<li>\n<p>Add <code>component::Linker::define_missing_exports_as_default_values</code> similar to <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Linker.html#method.define_unknown_imports_as_default_values\">define_unknown_imports_as_default_values</a></p>\n</li>\n</ul>\n</blockquote>",
        "id": 536193542,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756200058
    },
    {
        "content": "<p>no30bit <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538#issuecomment-3223342079\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538\">issue #11538</a>:</p>\n<blockquote>\n<p>cc @stevenj</p>\n</blockquote>",
        "id": 536193797,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756200154
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538#issuecomment-3224385015\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538\">issue #11538</a>:</p>\n<blockquote>\n<p>One way to model this today would be to define a world-per-export that your users have. You would then generate bindings once-per-world (probably using <code>with</code> to point all imports to the same set of imports for all bindings). That way you'd do detection on the host for \"which world should be used\".</p>\n<p>Alternatively you could also skip <code>bindgen!</code> entirely for exports and just have a world with imports and then manually poke at a component after instantiating it.</p>\n</blockquote>",
        "id": 536248630,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756218092
    },
    {
        "content": "<p>stevenj <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538#issuecomment-3224418971\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538\">issue #11538</a>:</p>\n<blockquote>\n<p>@alexcrichton In our use case, we are using the component model as a kind of plugin, where we can deliver <code>events</code> to a wasm component.  Each different <code>event</code> is handled by a different export.  The module can implement any number of <code>event</code> handlers, depending on what work it does.  We also need to validate in our imports that an <code>export</code> exists.  For example,  wasm can call <code>subscribe_to_cron(&lt;params&gt;)</code>   that will generate a <code>cron</code> event which gets delivered to a <code>cron_event</code> export in the same component.  The <code>subscribe_to_cron</code> call needs to fail if the calling component does not have a <code>cron_event</code> export.</p>\n<p>This is fully composable.</p>\n<p>Currently we are exploring patching out the <code>.wat</code> file of the loaded wasm component with stubbed exports that it doesn't implement, just to satisfy the linker and bindings.</p>\n</blockquote>",
        "id": 536250463,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756218586
    },
    {
        "content": "<p>stevenj edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538#issuecomment-3224418971\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538\">issue #11538</a>:</p>\n<blockquote>\n<p>@alexcrichton In our use case, we are using the component model as a kind of plugin, where we can deliver <code>events</code> to a wasm component.  Each different <code>event</code> is handled by a different export.  The module can implement any number of <code>event</code> handlers, depending on what work it does.  We also need to validate in our imports that an <code>export</code> exists.  For example,  wasm can call <code>subscribe_to_cron(&lt;params&gt;)</code>   that will generate a <code>cron</code> event which gets delivered to a <code>cron_event</code> export in the same component.  The <code>subscribe_to_cron</code> call needs to fail if the calling component does not have a <code>cron_event</code> export.</p>\n<p>This is fully composable.</p>\n<p>Currently we are exploring patching out the <code>.wat</code> file of the loaded wasm component with stubbed exports that it doesn't implement, just to satisfy the linker and bindings.</p>\n<p>Another complication is it needs to be forward compatible, as we will add events over time, and we can't break existing components just because there are new events they won't subscribe to anyway.</p>\n</blockquote>",
        "id": 536250794,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756218670
    },
    {
        "content": "<p>stevenj edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538#issuecomment-3224418971\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538\">issue #11538</a>:</p>\n<blockquote>\n<p>@alexcrichton In our use case, we are using the component model as a kind of plugin, where we can deliver <code>events</code> to a wasm component.  Each different <code>event</code> is handled by a different export.  The module can implement any number of <code>event</code> handlers, depending on what work it does.  We also need to validate in our imports that an <code>export</code> exists.  For example,  wasm can call <code>subscribe_to_cron(&lt;params&gt;)</code>   that will generate a <code>cron</code> event which gets delivered to a <code>cron_event</code> export in the same component.  The <code>subscribe_to_cron</code> call needs to fail if the calling component does not have a <code>cron_event</code> export.</p>\n<p>This is fully composable.</p>\n<p>Currently we are exploring patching out the <code>.wat</code> file of the loaded wasm component with stubbed exports that it doesn't implement, just to satisfy the linker and bindings.</p>\n<p>Another complication is it needs to be forward compatible, as we will add events over time, and we can't break existing components just because there are new events they won't subscribe to anyway.</p>\n<p>We will also look at the possibility to manually poke the component after instantiating, as it may give us more flexibility.</p>\n</blockquote>",
        "id": 536250994,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756218712
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538#issuecomment-3224989314\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538\">issue #11538</a>:</p>\n<blockquote>\n<p>That makes sense yeah, and would it work to have a <code>world</code>-per-event? That way when you compile a component you could then also test it for all <code>world</code>s to see which it conforms to. That way per-store state could have a reference to \"this instance supports these events through these bindings\". That way in <code>subscribe-to-cron</code>, for example, you could reject the call if the component doesn't suport the cron world export event.</p>\n<p>This strategy should also be forwards-compatible because on your end you'd be adding more worlds and not updating any preexisting worlds. The upside here is you get to keep using auto-generated bindings and no need to try to get types to align or anything.</p>\n</blockquote>",
        "id": 536278646,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756227209
    },
    {
        "content": "<p>stevenj <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538#issuecomment-3226702295\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11538\">issue #11538</a>:</p>\n<blockquote>\n<p>@alexcrichton I am not sure if a <code>world-per-event</code> would work for us.  The Component can choose to implement any number of the available events.   We do have a <code>world-per-component-module</code> because each component modules world is a strict subset of the engines total <code>world</code>.   </p>\n<p>So there would be an large number of possible permutation worlds.  </p>\n<p>Also, Components in our model should not <code>import</code> anything they don't actually use, and should not export events they don't handle.  As we will be using this information as part of a permissions system.  ie, if the component does not have permission to use <code>cron events</code> it will be refused to load if it imports cron functions or exports a cron event.  @no30bit is working on a solution based on your earlier advice <code>skip bindgen! entirely for exports and just have a world with imports and then manually poke at a component after instantiating it.</code>.  If we get a working solution we will follow up with how we went about it.</p>\n</blockquote>",
        "id": 536345526,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756269128
    }
]