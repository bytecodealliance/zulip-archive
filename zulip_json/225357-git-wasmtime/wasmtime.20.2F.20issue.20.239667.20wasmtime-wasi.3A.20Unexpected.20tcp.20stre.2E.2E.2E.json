[
    {
        "content": "<p>Heap-Hop edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667\">issue #9667</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/67674881db5fbdbba8594feb52655aaa351a5f77/crates/wasi/src/tcp.rs#L719-L723\">https://github.com/bytecodealliance/wasmtime/blob/67674881db5fbdbba8594feb52655aaa351a5f77/crates/wasi/src/tcp.rs#L719-L723</a></p>\n<p>Returning <code>0</code> for <code>std::io::ErrorKind::WouldBlock</code> causes downstream to interpret it as a closed stream, see: <br>\n<a href=\"https://github.com/yoshuawuyts/wstd/issues/25#issuecomment-2493294087\">https://github.com/yoshuawuyts/wstd/issues/25#issuecomment-2493294087</a>.<br>\n<a href=\"https://github.com/yoshuawuyts/wstd/blob/5ce367add5e7bcb569b6487453cb9ba94468dc99/src/io/copy.rs#L12\">https://github.com/yoshuawuyts/wstd/blob/5ce367add5e7bcb569b6487453cb9ba94468dc99/src/io/copy.rs#L12</a></p>\n<p>This is also found in:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/67674881db5fbdbba8594feb52655aaa351a5f77/crates/test-programs/src/bin/preview2_tcp_streams.rs#L17-L22\">https://github.com/bytecodealliance/wasmtime/blob/67674881db5fbdbba8594feb52655aaa351a5f77/crates/test-programs/src/bin/preview2_tcp_streams.rs#L17-L22</a></p>\n<p><del>Given that the <code>wit</code> files already include many <code>would-block</code> errors, would it make sense to extend <code>stream-error</code> to include a <code>would-block</code>?</del><br>\n</p>\n</blockquote>",
        "id": 484870254,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1732784719
    },
    {
        "content": "<p>Heap-Hop <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2506253514\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667\">issue #9667</a>:</p>\n<blockquote>\n<p>@pchickey <a href=\"https://github.com/bytecodealliance/wasmtime/actions/runs/12070585313/job/33660435175?pr=9691#step:18:419\">https://github.com/bytecodealliance/wasmtime/actions/runs/12070585313/job/33660435175?pr=9691#step:18:419</a></p>\n</blockquote>",
        "id": 484933596,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1732804184
    },
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2506498842\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667\">issue #9667</a>:</p>\n<blockquote>\n<p>Thanks! Its a holiday weekend here so I’ll get to this next week.</p>\n</blockquote>",
        "id": 484957857,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1732812344
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2607929136\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667\">issue #9667</a>:</p>\n<blockquote>\n<p>I apologize it's taken me quite some time to take a look at this. Now that I've read over this and <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9691\">https://github.com/bytecodealliance/wasmtime/pull/9691</a> I personally don't think there's a bug in the wasmtime-wasi implementation here. I don't think WASI can reasonably provide super strict guarantees about exactly when things become ready and exactly the states before/after reads. Attempting to do this might not even be feasible in the face of an implementation across multiple platforms.</p>\n<p>For example the test in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9691\">https://github.com/bytecodealliance/wasmtime/pull/9691</a> looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">test_programs</span><span class=\"p\">::</span><span class=\"n\">wasi</span><span class=\"p\">::</span><span class=\"n\">clocks</span><span class=\"p\">::</span><span class=\"n\">monotonic_clock</span><span class=\"p\">::</span><span class=\"n\">subscribe_duration</span><span class=\"p\">;</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">timeout_100ms</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">100_000_000</span><span class=\"p\">;</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Send some data to the server</span>\n<span class=\"w\">        </span><span class=\"n\">client</span><span class=\"p\">.</span><span class=\"n\">output</span><span class=\"p\">.</span><span class=\"n\">blocking_write_and_flush</span><span class=\"p\">(</span><span class=\"s\">b\"Hi!\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">        </span><span class=\"n\">server</span><span class=\"p\">.</span><span class=\"n\">input</span><span class=\"p\">.</span><span class=\"n\">subscribe</span><span class=\"p\">().</span><span class=\"n\">block</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">server</span><span class=\"p\">.</span><span class=\"n\">input</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"mi\">512</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">b\"Hi!\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"Expected to receive data\"</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Don't send any data</span>\n\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">server</span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">input</span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">subscribe</span><span class=\"p\">()</span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">block_until</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">subscribe_duration</span><span class=\"p\">(</span><span class=\"n\">timeout_100ms</span><span class=\"p\">));</span>\n<span class=\"w\">        </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">.</span><span class=\"n\">is_err</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"s\">\"Expected to time out cause no data was sent\"</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>I don't believe that this can be made to work reliably. Here after the initial \"Hi!\" message is ready it's not actually known whether the stream is readable or not. Determining this would involve actually consulting the kernel with some sort of syscall or something like that. It's a pretty important perf optimization that in async servers you don't do anything with the kernel until absolutely necessary.</p>\n<p>For example here the kernel was consulted during the first <code>server.input.subscribe().block()</code>. At this point the stream is considered readable. The issued <code>read</code> then again consults the kernel and reads out <code>\"Hi!\"</code>.  At this point though the stream is notably considered still readable by Tokio and Wasmtime. It's not known whether this was a \"short read\" or whether more data is coming soon. This is why the next <code>subscribe()</code> immediately says \"yes this is readable\". Doing otherwise would require unnecessarily consulting the kernel.</p>\n<p>Working robustly with async is certainly an art but personally I don't think that there's a bug here that needs fixing. I would personally think we can close <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9691\">https://github.com/bytecodealliance/wasmtime/pull/9691</a> and this issue as \"working as intended\".</p>\n</blockquote>",
        "id": 495345822,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737569353
    },
    {
        "content": "<p>pchickey <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2608134946\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667\">issue #9667</a>:</p>\n<blockquote>\n<p>I apologize I never got back to this after saying I would. I started a new job and have a whole host of new problems to work on, so I dropped some of the old ones.</p>\n<p>Thanks Alex for digging into this and helping me understand why the existing behavior is there. My conclusion is that my specification of \"a ready pollable implies <a href=\"http://input-stream.read\">input-stream.read</a> will succeed\" is too strong of a guarantee to implement efficiently on top of POSIX. In discussion with Alex, he suggested that only the behavior of read shows whether input was ready or not, and the pollable's readiness is a best-effort indicator that provides an optimization over busy-looping on read. I expect that we can easily accommodate the weakening of that guarantee in existing code (at least in wstd), and any existing binaries can't possibly be relying on that guarantee since its never been upheld by implementations. We will have to take that discussion out to the spec repo in order to nail it all down.</p>\n</blockquote>",
        "id": 495362531,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737575537
    },
    {
        "content": "<p>badeend <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2608203882\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667\">issue #9667</a>:</p>\n<blockquote>\n<blockquote>\n<p>I would personally think we can close (...) this issue as \"working as intended\".</p>\n</blockquote>\n<p>For non-blocking APIs: agree. There's not much wasmtime can do (efficiently).</p>\n<p>Maybe this could also justify the removal of <a href=\"https://github.com/bytecodealliance/wasmtime/blob/ca9557646aac2d625a6d1d040e6caf065d0340f6/crates/wasi/src/filesystem.rs#L372-L373\">starting an arbitrary-sized read in the FileInputStream implementation</a> that was put in place to fulfill this guarantee?</p>\n<hr>\n<p>For blocking APIs: there a few places where wasmtime blindly trusts that <code>ready().await</code> actually implies readiness. For example:</p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/blob/ca9557646aac2d625a6d1d040e6caf065d0340f6/crates/wasi-io/src/streams.rs#L24-L29\">https://github.com/bytecodealliance/wasmtime/blob/ca9557646aac2d625a6d1d040e6caf065d0340f6/crates/wasi-io/src/streams.rs#L24-L29</a></p>\n<p>In these cases wasmtime _is_ in a position to \"fix\" spurious wakeups by wrapping it in a loop.</p>\n</blockquote>",
        "id": 495368355,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737577844
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2608226315\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667\">issue #9667</a>:</p>\n<blockquote>\n<p>Yeah I would agree that <code>blocking_read</code> should have a loop to handle situations like this</p>\n</blockquote>",
        "id": 495370266,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737578675
    },
    {
        "content": "<p>Heap-Hop <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2609090727\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667\">issue #9667</a>:</p>\n<blockquote>\n<blockquote>\n<p>This is why the next subscribe() immediately says \"yes this is readable\". Doing otherwise would require unnecessarily consulting the kernel.</p>\n</blockquote>\n<p>@alexcrichton Thank you so much for the clear explanation, it resolved my confusion about why <code>readable()</code> in Tokio is not explicit.</p>\n<p>It would be great if the <code>blocking_</code> functions returned the expected results.</p>\n<p>I would be happy to submit a PR to modify the <code>blocking_</code> functions if no one else is currently working on it.</p>\n</blockquote>",
        "id": 495442979,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737618989
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2610426979\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667\">issue #9667</a>:</p>\n<blockquote>\n<p>That'd be most welcome, thank you!</p>\n</blockquote>",
        "id": 495546747,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737651640
    },
    {
        "content": "<p>Heap-Hop <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667#issuecomment-2613830631\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9667\">issue #9667</a>:</p>\n<blockquote>\n<p>#10113 <br>\nSorry, I haven't found an easy way to write a test that might block the process, as there isn’t a <code>_until</code> function for <code>blocking_</code>.<br>\nIs there an existing test case for this? The only approach I can think of is externally controlling the timeout for Wasmtime.</p>\n</blockquote>",
        "id": 495847449,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737791547
    }
]