[
    {
        "content": "<p>dicej opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11833\">issue #11833</a>:</p>\n<blockquote>\n<p>The component model async ABI supports cancelling subtasks, and this is implemented in Wasmtime for guests via the <code>subtask.cancel</code> intrinsic.  However, there's not yet any host-level API for cancelling tasks created using <code>call_concurrent</code>.</p>\n<p>Note that subtask cancellation is both cooperative and asynchronous such that the guest may require arbitrary time and/or I/O to handle a cancellation request; in extreme cases, it may be busy looping and not even receive the request, or it might receive it and ignore it.  Therefore, the host needs some way to know when the task has actually exited after sending it a cancellation request.  In addition, since a task may continue running after it has returned a result, the host may need to cancel it either before it returns or after.</p>\n<p>Currently, <code>call_concurrent</code> already returns a <code>TaskExit</code> object which may be used to wait (asynchronously) for the task to exit.  However, the caller must wait until the <code>call_concurrent</code> <code>Future</code> resolves before it can get access to it.</p>\n<p>Here's a rough sketch of an API that might work:</p>\n<ul>\n<li><code>[Typed]Func::call_concurrent</code> returns a custom <code>Future</code> implementation with an <code>async fn cancel(self, accessor: impl AsAccessor) -&gt; Result&lt;Option&lt;R&gt;, TaskExit&gt;</code> function, where <code>R</code> is the return type and <code>Option&lt;R&gt;</code> represents the possibility that the task calls <code>task.return</code> instead of <code>task.cancel</code> after receiving the cancel request.</li>\n<li><code>TaskExit</code> gets a new <code>async fn cancel(self, accessor: impl AsAccessor) -&gt; Result&lt;()&gt;</code> function which allows the caller to cancel a task (or wait just wait for it to exit it we've already sent it a cancel request) after it has returned a value.</li>\n</ul>\n<p>Note that the host can always simply drop the instance if the guest refuses to cooperate promptly with a cancel request.</p>\n</blockquote>",
        "id": 544226483,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760120836
    },
    {
        "content": "<p><a href=\"https://github.com/dicej\">dicej</a> added the wasm-proposal:component-model-async label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11833\">Issue #11833</a>.</p>",
        "id": 544226484,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760120836
    },
    {
        "content": "<p>dicej edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11833\">issue #11833</a>:</p>\n<blockquote>\n<p>The component model async ABI supports cancelling subtasks, and this is implemented in Wasmtime for guests via the <code>subtask.cancel</code> intrinsic.  However, there's not yet any host-level API for cancelling tasks created using <code>call_concurrent</code>.</p>\n<p>Note that subtask cancellation is both cooperative and asynchronous such that the guest may require arbitrary time and/or I/O to handle a cancellation request; in extreme cases, it may be busy looping and not even receive the request, or it might receive it and ignore it.  Therefore, the host needs some way to know when the task has actually exited after sending it a cancellation request.  In addition, since a task may continue running after it has returned a result, the host may need to cancel it either before it returns or after.</p>\n<p>Currently, <code>call_concurrent</code> already returns a <code>TaskExit</code> object which may be used to wait (asynchronously) for the task to exit.  However, the caller must wait until the <code>call_concurrent</code> <code>Future</code> resolves before it can get access to it.</p>\n<p>Here's a rough sketch of an API that might work:</p>\n<ul>\n<li><code>[Typed]Func::call_concurrent</code> returns a custom <code>Future</code> implementation with an <code>async fn cancel(self, accessor: impl AsAccessor) -&gt; Result&lt;Option&lt;R&gt;, TaskExit&gt;</code> function, where <code>R</code> is the return type and <code>Option&lt;R&gt;</code> represents the possibility that the task calls <code>task.return</code> instead of <code>task.cancel</code> after receiving the cancel request.</li>\n<li><code>TaskExit</code> gets a new <code>async fn cancel(self, accessor: impl AsAccessor) -&gt; Result&lt;()&gt;</code> function which allows the caller to cancel a task (or wait just wait for it to exit if we've already sent it a cancel request) after it has returned a value.</li>\n</ul>\n<p>Note that the host can always simply drop the instance if the guest refuses to cooperate promptly with a cancel request.</p>\n</blockquote>",
        "id": 544226583,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760120899
    },
    {
        "content": "<p>dicej <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11833#issuecomment-3392272245\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11833\">issue #11833</a>:</p>\n<blockquote>\n<p>Note that, once we have this, we can and should use it when timing out instances in <code>wasmtime serve</code> to allow them a bit of extra time to shut down gracefully.</p>\n</blockquote>",
        "id": 544245023,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760129289
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11833#issuecomment-3392364753\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11833\">issue #11833</a>:</p>\n<blockquote>\n<p>For the bikeshed, I'm getting a bit worried about the contortions necessary to get access to these events and such. For example there's two <code>cancel</code> functions here and technically it's impossible to call the original <code>cancel</code> function if it's on the future itself, or at least it's difficult to because you want to simultaneously wait on the future (which naively takes ownership of the future) and then also retain the ability to cancel.</p>\n<p>How about something like this instead:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Func</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">call</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">AsAccessor</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">AsyncTask</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// ...</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">AsyncTask</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">task_done</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">AsAccesor</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">cancel</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">AsAccesor</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>The properties being:</p>\n<ul>\n<li>The task metadata is available immediately, not just after the function returns</li>\n<li>The task can be cancelled at any time through the task handle</li>\n<li>Cancellation is modeled as when the <code>call</code> future resolves. I'm thinking we make a custom error to represent cancellation and embedders downcast to test it.</li>\n</ul>\n</blockquote>",
        "id": 544251022,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760132035
    }
]