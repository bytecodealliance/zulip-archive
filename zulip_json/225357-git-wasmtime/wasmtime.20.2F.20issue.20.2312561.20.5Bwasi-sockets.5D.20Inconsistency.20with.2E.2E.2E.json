[
    {
        "content": "<p>saulecabrera opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561\">issue #12561</a>:</p>\n<blockquote>\n<p>In the following snippet:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">listen</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">    </span><span class=\"n\">futures</span><span class=\"p\">::</span><span class=\"n\">join</span><span class=\"o\">!</span><span class=\"p\">(</span>\n<span class=\"w\">        </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">next</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">accept</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">            </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">get_address_family</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_address_family</span><span class=\"p\">());</span>\n<span class=\"w\">            </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">get_keep_alive_enabled</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_keep_alive_enabled</span><span class=\"p\">());</span>\n<span class=\"w\">            </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span>\n<span class=\"w\">                </span><span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">get_keep_alive_idle_time</span><span class=\"p\">(),</span>\n<span class=\"w\">                </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_keep_alive_idle_time</span><span class=\"p\">()</span>\n<span class=\"w\">            </span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span>\n<span class=\"w\">                </span><span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">get_keep_alive_interval</span><span class=\"p\">(),</span>\n<span class=\"w\">                </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_keep_alive_interval</span><span class=\"p\">()</span>\n<span class=\"w\">            </span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">get_keep_alive_count</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_keep_alive_count</span><span class=\"p\">());</span>\n<span class=\"w\">            </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">get_hop_limit</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_hop_limit</span><span class=\"p\">());</span>\n\n<span class=\"w\">            </span><span class=\"c1\">// The following asserts fail.</span>\n<span class=\"w\">            </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span>\n<span class=\"w\">                </span><span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">get_receive_buffer_size</span><span class=\"p\">(),</span>\n<span class=\"w\">                </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_receive_buffer_size</span><span class=\"p\">()</span>\n<span class=\"w\">            </span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">next</span><span class=\"p\">.</span><span class=\"n\">get_send_buffer_size</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_send_buffer_size</span><span class=\"p\">());</span>\n<span class=\"w\">        </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">client</span><span class=\"p\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">local_addr</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">);</span>\n</code></pre></div>\n<p>The values for <code>get_receive_buffer_size()</code> and <code>get_send_buffer_size()</code> are different between the listener and the handler socket. </p>\n<p>According to the spec:</p>\n<p>The following properties are inherited from the listener socket:</p>\n<ul>\n<li><code>address-family</code></li>\n<li><code>keep-alive-enabled</code></li>\n<li><code>keep-alive-idle-time</code></li>\n<li><code>keep-alive-interval</code></li>\n<li><code>keep-alive-count</code></li>\n<li><code>hop-limit</code></li>\n<li><code>receive-buffer-size</code></li>\n<li><code>send-buffer-size</code></li>\n</ul>\n<p>Platform specific information:</p>\n<ul>\n<li><a href=\"https://github.com/WebAssembly/wasi-testsuite/actions/runs/21880672593/job/63162311357?pr=208#step:10:106\">On ubuntu</a>, only the comparison between <code>get_send_buffer_size</code> is failing. </li>\n<li><a href=\"https://github.com/WebAssembly/wasi-testsuite/actions/runs/21880672593/job/63162311407?pr=208#step:10:127\">On macOS</a>, both comparisons are failing (<code>get_receive_buffer_size</code> / <code>get_send_buffer_size</code>)</li>\n<li>On Windows the test behaves as expected. </li>\n</ul>\n</blockquote>",
        "id": 573142132,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770754878
    },
    {
        "content": "<p><a href=\"https://github.com/saulecabrera\">saulecabrera</a> added the bug label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561\">Issue #12561</a>.</p>",
        "id": 573142134,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770754878
    },
    {
        "content": "<p><a href=\"https://github.com/saulecabrera\">saulecabrera</a> added the wasi label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561\">Issue #12561</a>.</p>",
        "id": 573142136,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770754879
    },
    {
        "content": "<p>saulecabrera <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561#issuecomment-3880609418\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561\">issue #12561</a>:</p>\n<blockquote>\n<p>The inconsistency only seems to be happening when the values are not explicitly set by calling the respective setters i.e., if explicitly set, it works as expected, according to this test <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/test-programs/src/bin/p3_sockets_tcp_sockopts.rs#L113\">https://github.com/bytecodealliance/wasmtime/blob/main/crates/test-programs/src/bin/p3_sockets_tcp_sockopts.rs#L113</a></p>\n</blockquote>",
        "id": 573146043,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770756197
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561#issuecomment-3881084942\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561\">issue #12561</a>:</p>\n<blockquote>\n<p>cc @badeend </p>\n</blockquote>",
        "id": 573162603,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770762608
    },
    {
        "content": "<p>badeend <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561#issuecomment-3886752006\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561\">issue #12561</a>:</p>\n<blockquote>\n<p>Heh, nice find ;) </p>\n<p>Let me find out why this is happening</p>\n</blockquote>",
        "id": 573375526,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770839878
    },
    {
        "content": "<p>badeend <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561#issuecomment-3904444558\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561\">issue #12561</a>:</p>\n<blockquote>\n<p>I looked at the <code>SO_RCVBUF</code> &amp; <code>SO_SNDBUF</code> implementations of Linux &amp; MacOS.</p>\n<p>By default, both platforms use a dynamic buffer capacity feature, which is disabled when the user explicitly sets <code>SO_RCVBUF</code> or <code>SO_SNDBUF</code>. On Linux the relevant search terms are <a href=\"https://github.com/torvalds/linux/blob/ca4ee40bf13dbd3a4be3b40a00c33a1153d487e5/include/uapi/linux/socket.h#L29-L30\"><code>SOCK_SNDBUF_LOCK</code> &amp; <code>SOCK_RCVBUF_LOCK</code></a>. On MacOS this is controlled by <a href=\"https://github.com/apple-oss-distributions/xnu/blob/f6217f891ac0bb64f3d375211650a4c1ff8ca1ea/bsd/sys/socketvar.h#L207\"><code>SB_AUTOSIZE</code></a>.</p>\n<p>That explains the behavior observed in this issue.</p>\n<p>Also relevant:</p>\n<ul>\n<li>On MacOS, the socket options reflect the _current_ capacity of the buffer. If not explicitly set, <code>getsockopt</code> may return different values over the lifetime of the connection as the buffer fills &amp; drains.</li>\n<li>On Linux, the socket options reflect the _maximum_ buffer capacity. If not explicitly set, Linux <a href=\"https://github.com/torvalds/linux/blob/ca4ee40bf13dbd3a4be3b40a00c33a1153d487e5/net/ipv4/tcp_input.c#L600-L635\">computes</a> a maximum based on connection statistics. This currently occurs only once when the connection is established. This causes the one-time jump in the value returned by getsockopt, which afterwards remains stable.</li>\n</ul>\n<p>Importantly, this behavior is not specific to listener sockets or inheritance. The same effect occurs on client sockets. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">recv_before</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_receive_buffer_size</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">send_before</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_send_buffer_size</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">recv_after</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_receive_buffer_size</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">send_after</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_send_buffer_size</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Recv {recv_before} -&gt; {recv_after}\"</span><span class=\"p\">);</span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Send {send_before} -&gt; {send_after}\"</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>Prints:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Recv</span><span class=\"w\"> </span><span class=\"mi\">65536</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"mi\">65536</span>\n<span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"mi\">8192</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"mi\">43520</span>\n</code></pre></div>\n<hr>\n<p>With this in mind, the underlying issue seems less about inheritance and more about the fact that <code>getsockopt(SO_RCVBUF or SO_SNDBUF)</code> returns meaningless values until either:</p>\n<ul>\n<li>the option has been explicitly set, or</li>\n<li>a connection has been established.</li>\n</ul>\n<p>It's unclear to me how WASI should handle this situation. Automatically calling <code>setsockopt</code> on every accepted socket just to satisfy a single test seems undesirable, as it would add runtime overhead and disable the kernel's dynamic buffer sizing.</p>\n<ul>\n<li>One option is to leave the behavior as-is and simply document these platform-specific quirks.</li>\n<li>Another possibility is to have <code>get_send/receive_buffer_size</code> return an error or 0 until the buffer size has been explicitly set or the socket has been connected. From my current understanding, there is rarely a meaningful use case for reading these values beforehand anyways. But I can't predict how many existing applications might break because of that.</li>\n</ul>\n<p>In summary, I understand the problem now but I don't know the best way forward yet.</p>\n</blockquote>",
        "id": 573976448,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771161945
    },
    {
        "content": "<p>badeend edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561#issuecomment-3904444558\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12561\">issue #12561</a>:</p>\n<blockquote>\n<p>I looked at the <code>SO_RCVBUF</code> &amp; <code>SO_SNDBUF</code> implementations of Linux &amp; MacOS.</p>\n<p>By default, both platforms use a dynamic buffer capacity feature, which is disabled when the user explicitly sets <code>SO_RCVBUF</code> or <code>SO_SNDBUF</code>. On Linux the relevant search terms are <a href=\"https://github.com/torvalds/linux/blob/ca4ee40bf13dbd3a4be3b40a00c33a1153d487e5/include/uapi/linux/socket.h#L29-L30\"><code>SOCK_SNDBUF_LOCK</code> &amp; <code>SOCK_RCVBUF_LOCK</code></a>. On MacOS this is controlled by <a href=\"https://github.com/apple-oss-distributions/xnu/blob/f6217f891ac0bb64f3d375211650a4c1ff8ca1ea/bsd/sys/socketvar.h#L207\"><code>SB_AUTOSIZE</code></a>.</p>\n<p>That explains the behavior observed in this issue.</p>\n<p>Also relevant:</p>\n<ul>\n<li>On MacOS, the socket options reflect the _current_ capacity of the buffer. If not explicitly set, <code>getsockopt</code> may return different values over the lifetime of the connection as the buffer fills &amp; drains.</li>\n<li>On Linux, the socket options reflect the _maximum_ buffer capacity. If not explicitly set, Linux <a href=\"https://github.com/torvalds/linux/blob/ca4ee40bf13dbd3a4be3b40a00c33a1153d487e5/net/ipv4/tcp_input.c#L600-L635\">computes</a> a maximum based on connection statistics. This currently occurs only once when the connection is established. This causes the one-time jump in the value returned by getsockopt, which afterwards remains stable.</li>\n</ul>\n<p>Importantly, this behavior is not specific to listener sockets or inheritance. The same effect occurs on client sockets. Example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">recv_before</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_receive_buffer_size</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">send_before</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_send_buffer_size</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">recv_after</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_receive_buffer_size</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">send_after</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">sock</span><span class=\"p\">.</span><span class=\"n\">get_send_buffer_size</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Recv {recv_before} -&gt; {recv_after}\"</span><span class=\"p\">);</span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Send {send_before} -&gt; {send_after}\"</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>Prints:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Recv</span><span class=\"w\"> </span><span class=\"mi\">65536</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"mi\">65536</span>\n<span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"mi\">8192</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"mi\">43520</span>\n</code></pre></div>\n<hr>\n<p>With this in mind, the underlying issue seems less about inheritance and more about the fact that <code>getsockopt(SO_RCVBUF or SO_SNDBUF)</code> returns meaningless values until either:</p>\n<ul>\n<li>the option has been explicitly set, or</li>\n<li>a connection has been established.</li>\n</ul>\n<p>It's unclear to me how WASI should handle this situation. Automatically calling <code>setsockopt</code> on every accepted socket just to satisfy a single test seems undesirable, as it would add runtime overhead and disable the kernel's dynamic buffer sizing.</p>\n<ul>\n<li>One option is to leave the behavior as-is and simply document these platform-specific quirks.</li>\n<li>Another possibility is to have <code>get_send/receive_buffer_size</code> return an error until the buffer size has been explicitly set or the socket has been connected. From my current understanding, there is rarely a meaningful use case for reading these values beforehand anyways. But I can't predict how many existing applications might break because of that.<ul>\n<li><strong>Edit:</strong> instead of returning an error, maybe returning 0 may not be so bad. Which can be interpreted as: the socket starts out with an empty buffer.</li>\n</ul>\n</li>\n</ul>\n<p>In summary, I understand the problem now but I don't know the best way forward yet.</p>\n</blockquote>",
        "id": 573979704,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771165019
    }
]