[
    {
        "content": "<p><strong>dicej</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11756\">PR #11756</a>.</p>",
        "id": 542096854,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1759166229
    },
    {
        "content": "<p>dicej opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11756\">PR #11756</a> from <code>dicej:no-trap-on-idle-by-default</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>Previously, <code>Instance::run_concurrent</code> returned <code>Trap::AsyncDeadlock</code> when all guest tasks and background host tasks had completed, and yet the future parameter it was passed still hadn't resolved.  The theory was that this indicated a mistake on the host embedder's part, but it turns out there are scenarios where this is actually what the embedder wanted.</p>\n<p>For example, consider a host embedder that implements a pool of worker tasks, each of which runs a loop inside async closure passed to <code>Instance::run_concurrent</code>.  In this case, each worker accepts jobs (which involve calling guest functions) from a multiple-producer, multiple-consumer job queue, adding them to a <code>futures::stream::FuturesUnordered</code> so they can be run concurrently.  When all the jobs accepted by a given worker have finished, there may be a lull during which no new jobs are yet available.  In that case, the worker _could_ break out of the loop, resolve the future, allow <code>Instance::run_concurrent</code> to finish, and wait until the next job arrives before calling <code>Instance::run_concurrent</code> again, but that's more awkward (i.e. nested loops, complicated control flow) than just a single loop inside <code>Instance::run_concurrent</code> that goes idle now and then.</p>\n<p>In short, the closure passed to <code>Instance::run_concurrent</code> might experience delays between when a set of guest tasks have completed and when the next set are ready to start, and that's not necessarily a bug.</p>\n<p>Internally, I've added a new <code>run_concurrent_trap_on_idle</code>, which provides the original, trapping behavior, and I'm using it to implement <code>[Typed]Func::call_async</code>, in which case it _is_ an error if the event loop goes idle without the future resolving.  If this turns out to be useful as part of the public API, we can change the <code>pub(super)</code> to <code>pub</code>.</p>\n<p>Note that this is a refinement of <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11720\">https://github.com/bytecodealliance/wasmtime/pull/11720</a></p>\n<p>&lt;!--<br>\nPlease make sure you include the following information:</p>\n<ul>\n<li>\n<p>If this work has been discussed elsewhere, please include a link to that<br>\n  conversation. If it was discussed in an issue, just mention \"issue #...\".</p>\n</li>\n<li>\n<p>Explain why this change is needed. If the details are in an issue already,<br>\n  this can be brief.</p>\n</li>\n</ul>\n<p>Our development process is documented in the Wasmtime book:<br>\n<a href=\"https://docs.wasmtime.dev/contributing-development-process.html\">https://docs.wasmtime.dev/contributing-development-process.html</a></p>\n<p>Please ensure all communication follows the code of conduct:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md\">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>\n--&gt;</p>\n</blockquote>",
        "id": 542096856,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1759166230
    },
    {
        "content": "<p><strong>dicej</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11756\">PR #11756</a>.</p>",
        "id": 542096860,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1759166230
    }
]