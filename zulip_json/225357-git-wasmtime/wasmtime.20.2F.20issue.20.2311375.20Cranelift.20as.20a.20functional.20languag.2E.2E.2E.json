[
    {
        "content": "<p>Germ210 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11375\">issue #11375</a>:</p>\n<blockquote>\n<p>Currently, I am designing a language that requires tail call optimization and possibly calling C functions/being called from C functions. How does Cranelift handle cross ABI compatibility?</p>\n<p>On top of that, Cranelift does not support 32 bit architectures, are there any plan for that? If not, what should I use for generating code for those architectures instead?</p>\n</blockquote>",
        "id": 532666995,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754293710
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11375\">issue #11375</a>:</p>\n<blockquote>\n<p>Currently, I am designing a language that requires tail call optimization and possibly calling C functions/being called from C functions. How does Cranelift handle cross ABI compatibility?</p>\n<p>On top of that, Cranelift does not support 32 bit architectures, are there any plan for that? If not, what should I use for generating code for those architectures instead?</p>\n</blockquote>",
        "id": 534022951,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755018404
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11375#issuecomment-3180244797\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11375\">issue #11375</a>:</p>\n<blockquote>\n<blockquote>\n<p>How does Cranelift handle cross ABI compatibility?</p>\n</blockquote>\n<p>We have a notion of calling convention in signatures; Cranelift supports a function that is compiled using one calling convention calling a function with another convention(and this is well-tested and used in practice in Wasmtime). So you should be able to define your external C functions using <code>sys_v</code> (on Unix/Linux/macOS) or <code>fastcall</code> (on Windows) conventions and the calls should work fine. I'd encourage you to peruse our <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/isa/enum.CallConv.html\">documentation</a> for more.</p>\n<blockquote>\n<p>On top of that, Cranelift does not support 32 bit architectures, are there any plan for that?</p>\n</blockquote>\n<p>You can find all of our tracking issues for supporting new ISAs using the <code>cranelift:new-target</code> issue label: <a href=\"https://github.com/bytecodealliance/wasmtime/issues?q=state%3Aopen%20label%3A%22cranelift%3Anew-target%22\">link</a>. For example, arm32 in #1173 and x86-32 in #1980 are both 32-bit platforms.</p>\n<p>The main issue is developer time: we don't have enough full-time contributors to Cranelift to develop and maintain backends for all of these ISAs. As I've described in comments in most of those listed issues, we estimate the effort to build a new backend at around 3 months of work / 20k lines of code. And we expect new backends to ideally have a fulltime maintainer available (i.e., not a one-time develop-and-dump prospect).</p>\n<blockquote>\n<p>If not, what should I use for generating code for those architectures instead?</p>\n</blockquote>\n<p>While this question is outside the scope of the Cranelift issue tracker, for \"some other compiler\" I'd recommend LLVM by default.</p>\n</blockquote>",
        "id": 534022955,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755018405
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11375#issuecomment-3180244797\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11375\">issue #11375</a>:</p>\n<blockquote>\n<blockquote>\n<p>How does Cranelift handle cross ABI compatibility?</p>\n</blockquote>\n<p>We have a notion of calling convention in signatures; Cranelift supports a function that is compiled using one calling convention calling a function with another convention (and this is well-tested and used in practice in Wasmtime). So you should be able to define your external C functions using <code>sys_v</code> (on Unix/Linux/macOS) or <code>fastcall</code> (on Windows) conventions and the calls should work fine. I'd encourage you to peruse our <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/isa/enum.CallConv.html\">documentation</a> for more.</p>\n<blockquote>\n<p>On top of that, Cranelift does not support 32 bit architectures, are there any plan for that?</p>\n</blockquote>\n<p>You can find all of our tracking issues for supporting new ISAs using the <code>cranelift:new-target</code> issue label: <a href=\"https://github.com/bytecodealliance/wasmtime/issues?q=state%3Aopen%20label%3A%22cranelift%3Anew-target%22\">link</a>. For example, arm32 in #1173 and x86-32 in #1980 are both 32-bit platforms.</p>\n<p>The main issue is developer time: we don't have enough full-time contributors to Cranelift to develop and maintain backends for all of these ISAs. As I've described in comments in most of those listed issues, we estimate the effort to build a new backend at around 3 months of work / 20k lines of code. And we expect new backends to ideally have a fulltime maintainer available (i.e., not a one-time develop-and-dump prospect).</p>\n<blockquote>\n<p>If not, what should I use for generating code for those architectures instead?</p>\n</blockquote>\n<p>While this question is outside the scope of the Cranelift issue tracker, for \"some other compiler\" I'd recommend LLVM by default.</p>\n</blockquote>",
        "id": 534022989,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755018419
    },
    {
        "content": "<p>cfallin edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11375#issuecomment-3180244797\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11375\">issue #11375</a>:</p>\n<blockquote>\n<blockquote>\n<p>How does Cranelift handle cross ABI compatibility?</p>\n</blockquote>\n<p>We have a notion of calling convention in signatures; Cranelift supports a function that is compiled using one calling convention calling a function with another convention (and this is well-tested and used in practice in Wasmtime). So you should be able to define your external C functions using <code>system_v</code> (on Unix/Linux/macOS) or <code>fastcall</code> (on Windows) conventions and the calls should work fine. I'd encourage you to peruse our <a href=\"https://docs.rs/cranelift-codegen/latest/cranelift_codegen/isa/enum.CallConv.html\">documentation</a> for more.</p>\n<blockquote>\n<p>On top of that, Cranelift does not support 32 bit architectures, are there any plan for that?</p>\n</blockquote>\n<p>You can find all of our tracking issues for supporting new ISAs using the <code>cranelift:new-target</code> issue label: <a href=\"https://github.com/bytecodealliance/wasmtime/issues?q=state%3Aopen%20label%3A%22cranelift%3Anew-target%22\">link</a>. For example, arm32 in #1173 and x86-32 in #1980 are both 32-bit platforms.</p>\n<p>The main issue is developer time: we don't have enough full-time contributors to Cranelift to develop and maintain backends for all of these ISAs. As I've described in comments in most of those listed issues, we estimate the effort to build a new backend at around 3 months of work / 20k lines of code. And we expect new backends to ideally have a fulltime maintainer available (i.e., not a one-time develop-and-dump prospect).</p>\n<blockquote>\n<p>If not, what should I use for generating code for those architectures instead?</p>\n</blockquote>\n<p>While this question is outside the scope of the Cranelift issue tracker, for \"some other compiler\" I'd recommend LLVM by default.</p>\n</blockquote>",
        "id": 534023038,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755018435
    }
]