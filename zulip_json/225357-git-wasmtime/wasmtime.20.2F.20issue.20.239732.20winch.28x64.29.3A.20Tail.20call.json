[
    {
        "content": "<p>saulecabrera edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9732\">issue #9732</a>:</p>\n<blockquote>\n<p>The Wasm Tail Call proposal is considered Tier 1 according to <a href=\"https://docs.wasmtime.dev/stability-tiers.html#tier-1\">Wasmtime's Tiers of support</a>. </p>\n<p>Winch currently doesn't support this proposal.</p>\n<ul>\n<li>[ ] <code>return_call</code></li>\n<li>[ ] <code>return_call_indirect</code></li>\n</ul>\n</blockquote>",
        "id": 492124453,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1736176712
    },
    {
        "content": "<p>saulecabrera assigned saulecabrera to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9732\">issue #9732</a>.</p>",
        "id": 494257698,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737073469
    },
    {
        "content": "<p>MarinPostma <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9732#issuecomment-2598531711\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9732\">issue #9732</a>:</p>\n<blockquote>\n<p>@saulecabrera you can assign me to that <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n</blockquote>",
        "id": 494376783,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737125342
    },
    {
        "content": "<p>saulecabrera edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9732\">issue #9732</a>:</p>\n<blockquote>\n<p>The Wasm Tail Call proposal is considered Tier 1 according to <a href=\"https://docs.wasmtime.dev/stability-tiers.html#tier-1\">Wasmtime's Tiers of support</a>. </p>\n<p>Winch currently doesn't support this proposal.</p>\n<ul>\n<li>[ ] <code>return_call</code> @MarinPostma</li>\n<li>[ ] <code>return_call_indirect</code> @MarinPostma </li>\n</ul>\n</blockquote>",
        "id": 494377032,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737125420
    },
    {
        "content": "<p>MarinPostma <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9732#issuecomment-2600949527\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9732\">issue #9732</a>:</p>\n<blockquote>\n<p>@saulecabrera </p>\n<p>Did you have a sketch of a plan on how to implement that already?</p>\n<p>I did some homework this weekend, trying to find a path toward tail calls. I think we could do something like described in this post about <a href=\"https://v8.dev/blog/wasm-tail-call\">v8 baseline compiler</a>, or as initially implemented <a href=\"https://github.com/bytecodealliance/wasmtime/pull/6635\">in cranelift</a>, basically:</p>\n<ul>\n<li>set up the frame as if we were about to perform a normal call</li>\n<li><code>memcpy</code> the frame down to override the caller frame</li>\n<li>jump to the callee entry-point</li>\n</ul>\n<p>However this is over simplistic. There are many things getting in our way. Here's my understanding of the situation, thus far:</p>\n<p>1) The callee and the caller may not require the same amount of stack space for their arguments. In the Winch calling convention, it is the caller that <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/winch/codegen/src/codegen/call.rs#L103-L112\">cleans up the stack space for the arguments</a>. This is an issue for tail calls, because the caller doesn't know ahead of time how much stack space will need to be cleaned up when the callee returns. cranelift <code>TailCall</code> convention solves that by requiring that the callee <a href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/tail-calls.md#new-wasm-calling-conventions-in-cranelift\">cleans-up it's stack space</a>. I suppose there are alternatives to let the caller know dynamically the amount of stack space to pop on cleanup, but in any case, it seems to me that we need a calling convention that supports that.<br>\n2) The <code>ret_area</code> is inherited from the caller, rather and allocated in the caller stack. This is easy to do: we can get it from the caller's initial control frame. (see <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/winch/codegen/src/visitor.rs#L1899\">there</a>). This works, because the callee must have the same return as the caller.<br>\n3) We need to emit a jump to the callee, rather than a call, because we must not push a return address, since the state is already set up during the return_call preparation. Winch relies of cranelift to emit relocs for the callee address. The story around converting a function ref to a <code>MachLabel</code> that can be used for a jump is not entirely clear to me yet. Alternatively, we could pop the FP back into it's register and let <code>call</code> push it back (this is what v8 baseline does).<br>\n4) Cranelift has <a href=\"https://github.com/bytecodealliance/wasmtime/blob/2eb65138e9e0f331776d7d3747a47117f706d406/cranelift/codegen/src/isa/x64/inst/emit.rs?plain=1#L1670\"><code>Inst::CallReturn*</code></a> macro-instruction, but it's not clear to me if we can use it, since it emits code specific to cranelift <code>Tail</code> calling convention.</p>\n<p>I am glancing over a lot of things here, obviously. My principal concern is with <code>1)</code> right now; I don't see a way forward without addressing it.</p>\n</blockquote>",
        "id": 494659761,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1737307161
    },
    {
        "content": "<p>saulecabrera <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9732#issuecomment-2647898974\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9732\">issue #9732</a>:</p>\n<blockquote>\n<p>Some preliminary context:</p>\n<ul>\n<li>Winch has a single, internal calling convention, which is mostly used between Wasm-to-Wasm calls. </li>\n<li>Non Wasm-to-Wasm calls (e.g., calls to host-defined functions), go through</li>\n<li>\n<p>trampolines, which are currently emitted<br>\n  through Cranelift. These trampolines convert between different calling conventions. </p>\n</li>\n<li>\n<p>Winch supports other calling conventions (e.g., SysV) used function calls<br>\n  which don't go through trampolines (calls to built-in function like<br>\n<code>f32.abs</code>)</p>\n</li>\n</ul>\n<p>-- </p>\n<p>Regarding the implementation of tail-calls:</p>\n<p>I don't have a one-size-fits-all answer unfortunately, but we did discuss some<br>\nideas in the past, unfortunately they are not officially documented anywhere; in<br>\nthe next couple of sentences I'll try to do a summary, taking into account your<br>\npoints above:</p>\n<blockquote>\n<p>I suppose there are alternatives to let the caller know dynamically the amount<br>\nof stack space to pop on cleanup, but in any case, it seems to me that we need<br>\na calling convention that supports that.</p>\n</blockquote>\n<p>Indeed, there have been attempts <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1572400\">in other production ready Wasm\ncompilers</a> to avoid having<br>\nthe callee clean up the stack space used for arguments. Given that (i) for tail<br>\ncalls it's assumed that we're using the current frame to resolve calls and (ii)<br>\neven though that we don't know the exact space needed for arguments, there are<br>\nsome expectations around the stack pointer position before/after the call, which<br>\ncould be helpful to derive the correct stack pointer position in the presence of<br>\ntail calls and stack arguments. I was hoping to explore this idea, through<br>\na prototype. The main benefit that I see here is minimizing ABI changes. </p>\n<p>The alternative, as you note, is to have the callee clean up any stack space<br>\nallocated for stack arguments. Even though, this seems like the obvious<br>\napproach, I would not be comfortable introducing this change without a proper<br>\nexploration of the other alternatives; a change like this  represents<br>\na fundamental shift in the following fronts:</p>\n<ul>\n<li>ABI</li>\n<li>Frame handling</li>\n<li>Multi-value</li>\n</ul>\n<p>In either case, I don't think we need to introduce a different calling<br>\nconvention, my expectation is that modifying Winch's default calling convention<br>\nshould suffice.</p>\n<blockquote>\n<p>The ret_area is inherited from the caller, rather and allocated in the caller<br>\nstack. This is easy to do: we can get it from the caller's initial control<br>\nframe. (see there). This works, because the callee must have the same return<br>\nas the caller.</p>\n</blockquote>\n<p>In principle nothing fundamental should change for multiple return values in<br>\nthe presence of tail calls. Note that if the callee cleans the space for stack<br>\narguments, some updates will be needed to handle the stack return area.</p>\n<blockquote>\n<p>We need to emit a jump to the callee, rather than a call, because we must not<br>\npush a return address, since the state is already set up during the<br>\nreturn_call preparation. Winch relies of cranelift to emit relocs for the<br>\ncallee address. The story around converting a function ref to a MachLabel that<br>\ncan be used for a jump is not entirely clear to me yet. Alternatively, we<br>\ncould pop the FP back into it's register and let call push it back (this is<br>\nwhat v8 baseline does).</p>\n</blockquote>\n<p>There are many assumptions in this statement, however, if I'm understanding this<br>\nstatement correctly, I think that relocations and FP/return address handling are<br>\ntwo, largely orthogonal issues that we need to think about regardless.</p>\n<p>--</p>\n<p>In general, I agree that resolving how to handle stack arguments is a<br>\npre-requisite for supporting tail-calls. My expectation is to take an informed<br>\ndecision based on prototyping, given that there are many trade-offs to consider,<br>\nnot only around the complexity of the potential ABI changes, but also the<br>\nimpact of any new changes on:</p>\n<ul>\n<li>Compilation performance</li>\n<li>Runtime performance</li>\n<li>Other non-x86-64 backends</li>\n</ul>\n<p>After spending some time thinking a bit more about tail calls, and in<br>\nparticular, with the last point above (non-x86-64 backends), I'd also recommend<br>\nwaiting until we can fully run spec tests for aarch64. As I've been working on<br>\ntrying to get them all passing I've found myself fixing some ABI-related bugs [1]<br>\nto ensure that our generated code meets all the aarc64 ABI requirements.<br>\nI suspect that if we introduce any new compiler-wide ABI changes, before the<br>\naarch64 backend is fully complete, there's a risk of conflicts down the road,<br>\nmore concreely around the stack pointer handling and relocations side of things.</p>\n<p>[1]: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10146\">https://github.com/bytecodealliance/wasmtime/pull/10146</a></p>\n</blockquote>",
        "id": 498752773,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739191912
    },
    {
        "content": "<p>saulecabrera edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9732\">issue #9732</a>:</p>\n<blockquote>\n<p>The Wasm Tail Call proposal is considered Tier 1 according to <a href=\"https://docs.wasmtime.dev/stability-tiers.html#tier-1\">Wasmtime's Tiers of support</a>. </p>\n<p>Winch currently doesn't support this proposal.</p>\n<ul>\n<li>[ ] <code>return_call</code></li>\n<li>[ ] <code>return_call_indirect</code></li>\n</ul>\n</blockquote>",
        "id": 499228716,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1739365911
    }
]