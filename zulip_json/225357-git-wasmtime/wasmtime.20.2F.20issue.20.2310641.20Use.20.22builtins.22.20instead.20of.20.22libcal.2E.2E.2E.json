[
    {
        "content": "<p>Destructor17 opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10641\">issue #10641</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Currently Cranelift emits \"libcalls\" for float-to-int conversion on baseline x86_64.<br>\nIt is a problem because libcalls require relocation, but relacations are not possible for externally owned code memory.<br>\nThe idea is to let people to prohibit compiler from emitting libcalls even on baseline x86_64 by using \"builtins\".</p>\n<h4>Benefit</h4>\n<p>This feature would allow to freely use <code>wasmtime::CustomCodeMemory</code> without fear of \"Unable to apply relocations to readonly MmapVec\" error.<br>\nIt is especially useful for scenarios described in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7777\">https://github.com/bytecodealliance/wasmtime/issues/7777</a></p>\n<h4>Implementation</h4>\n<p>First approach is to completely replace \"libcalls\" with \"builtins\".<br>\nAFAIK builtins do the same libcalls do, but require no relocations, passes vmcontext and may trap, so I bet they are a bit slower then libcalls.</p>\n<p>Builtins are already used for some atomic operations, memory growth, GC and many other things, while libcalls are used only in rare cases for f32/f64 rounding and X86Pshufb (whatever it is).</p>\n<p>Note that this approach may brake non-Wasmtime usecases of Cranelift, so maybe alternative approach makes more sense.</p>\n<h4>Alternatives</h4>\n<p>Alternatively we can add new entry in <code>wasmtime::Config</code> to allow programmers to choose weather builtins or libcalls variants will be used when needed.<br>\nThis approach is more complicated, but will not add any overhead if replacement is not needed.</p>\n</blockquote>",
        "id": 513680468,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745347383
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10641#issuecomment-2822276963\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10641\">issue #10641</a>:</p>\n<blockquote>\n<p>If the CPU you're running code on has various SSE3+ proposals you can also use <code>Config::cranelift_flag_enable</code> to enable those and avoid the use of libcalls. If it doesn't though and you need the libcalls then this change is part of <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9093\">https://github.com/bytecodealliance/wasmtime/pull/9093</a> where libcalls are avoided entirely in Wasmtime, as you suggest (and also removes the relocation handling path entirely as a result)</p>\n</blockquote>",
        "id": 513688049,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745350036
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10641\">issue #10641</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Currently Cranelift emits \"libcalls\" for float-to-int conversion on baseline x86_64.<br>\nIt is a problem because libcalls require relocation, but relacations are not possible for externally owned code memory.<br>\nThe idea is to let people to prohibit compiler from emitting libcalls even on baseline x86_64 by using \"builtins\".</p>\n<h4>Benefit</h4>\n<p>This feature would allow to freely use <code>wasmtime::CustomCodeMemory</code> without fear of \"Unable to apply relocations to readonly MmapVec\" error.<br>\nIt is especially useful for scenarios described in <a href=\"https://github.com/bytecodealliance/wasmtime/issues/7777\">https://github.com/bytecodealliance/wasmtime/issues/7777</a></p>\n<h4>Implementation</h4>\n<p>First approach is to completely replace \"libcalls\" with \"builtins\".<br>\nAFAIK builtins do the same libcalls do, but require no relocations, passes vmcontext and may trap, so I bet they are a bit slower then libcalls.</p>\n<p>Builtins are already used for some atomic operations, memory growth, GC and many other things, while libcalls are used only in rare cases for f32/f64 rounding and X86Pshufb (whatever it is).</p>\n<p>Note that this approach may brake non-Wasmtime usecases of Cranelift, so maybe alternative approach makes more sense.</p>\n<h4>Alternatives</h4>\n<p>Alternatively we can add new entry in <code>wasmtime::Config</code> to allow programmers to choose weather builtins or libcalls variants will be used when needed.<br>\nThis approach is more complicated, but will not add any overhead if replacement is not needed.</p>\n</blockquote>",
        "id": 514185123,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745516205
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10641#issuecomment-2828368306\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10641\">issue #10641</a>:</p>\n<blockquote>\n<p>Done in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10657\">https://github.com/bytecodealliance/wasmtime/pull/10657</a> (thanks @sunfishcode!)</p>\n</blockquote>",
        "id": 514185124,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745516205
    }
]