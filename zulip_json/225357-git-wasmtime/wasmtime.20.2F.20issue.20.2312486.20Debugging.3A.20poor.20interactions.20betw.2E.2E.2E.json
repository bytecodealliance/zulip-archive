[
    {
        "content": "<p>cfallin opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>In our \"bottom-half\" API that provides access to a debuggee <code>Store</code>'s execution state via the native Wasmtime API, we have the <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Store.html#method.debug_frames\"><code>Store::debug_frames</code></a> method that returns a <code>DebugFrameCursor&lt;'a, T&gt;</code>. This cursor follows established iterator idioms in Rust: it borrows the <code>Store</code> for the duration of its existence, thus freezing its state (disallowing execution) and making stack frames safe to traverse and hold pointers into.</p>\n<p>However, as we reflect this API into a form that can be used by a \"top half\" that is built in Wasm (per our <a href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/wasmtime-debugging.md\">current RFC consensus</a>, with current informal discussions to tweak bits of how this works but not fundamentally abandon the notion of using a Wasm component), we need to follow the ownership semantics of WIT.</p>\n<p>In particular, this means that if we reify both the debuggee (the <code>Store</code> being debugged) and a handle to a particular frame as <em>resources</em>, we need to be able to put types in the <a href=\"https://docs.rs/wasmtime/latest/wasmtime/component/struct.ResourceTable.html\"><code>ResourceTable</code></a> that are standalone. A resource can have a parent-child relationship with another, but cannot \"borrow\" (and freeze) another via a lifetime parameter. In fact this would not even be representable in a Rust host-side implementation: lifetime parameters must bottom out at some actual stack frame; they cannot refer to some value with dynamic lifetime extent.</p>\n<p>The above is all well-and-good and unsurprising: WIT simplifies the available semantic range of borrowing/ownership considerably. We'll instead need to enforce the restrictions dynamically: something like, if a <code>frame</code> resource exists, then use of any API on the <code>debuggee</code> will trap.</p>\n<p>Unfortunately, implementing even this is difficult, because of the above-mentioned limitation: a borrow <em>needs to correspond to some frame</em>; without a single hostcall instance that corresponds to the whole stack traversal, the only other option is to correspond to the lifetime of the entire resource table.</p>\n<p>The net effect of this is that if we want to have a \"dynamic checks\" variant of the API exposed at any level, we need to fundamentally rethink the stack iterator idea. We instead need a notion of \"frame handles\" that refer to frozen stack frames, just as we have instance handles, table handles, and the like today; the handles are <code>Copy</code> or <code>Clone</code>-able things that are morally indexes into the <code>Store</code>. Unlike instances, however, we need more complex invalidation rules: we need a way to make a frame handle invalid (and dynamically fail if used) once execution resumes. We could do this by, internally, keeping a \"frame handle table\" and a generation number on each slot. This fits better with the semantic abstraction level of an API with an arbitrary number of handles (i.e., WIT resources).</p>\n<p>The alternative to all of this is to force an eager capture of the entire stack, all local values, and all operand-stack values on every pause; then provide an API over these <code>Vec</code>s held in resources rather than by actually lazily querying the paused machine stack.</p>\n<p>The other major question that arises is: would this be better if we wrote the top-half of the debugger in a native Rust implementation instead, using the existing Wasmtime APIs? Yes and no: yes, in the sense that we have tests today showing how to use the API effectively to walk the stack with a stack iterator. No, in the sense that we likely want to have a single top-level event loop, and always hold the debuggee <code>Store</code>; to use the iterator effectively we'd need to have a state machine where we take the iterator and poll the inbound requests/commands from the debugger connection, moving the iterator or exiting to the outer loop (ending the inner borrow) when leaving \"stack traversal mode\". It's much cleaner to be \"modeless\" and allow handles to frames to coexist with all other handles.</p>\n<p>So basically I believe we need to do this refactor regardless, and I don't see a way around it unless we do a very inefficient copy on every pause.</p>\n<p>cc @alexcrichton and @fitzgen for thoughts?</p>\n</blockquote>",
        "id": 571333726,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1769997775
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>In our \"bottom-half\" API that provides access to a debuggee <code>Store</code>'s execution state via the native Wasmtime API, we have the <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Store.html#method.debug_frames\"><code>Store::debug_frames</code></a> method that returns a <code>DebugFrameCursor&lt;'a, T&gt;</code>. This cursor follows established iterator idioms in Rust: it borrows the <code>Store</code> for the duration of its existence, thus freezing its state (disallowing execution) and making stack frames safe to traverse and hold pointers into.</p>\n<p>However, as we reflect this API into a form that can be used by a \"top half\" that is built in Wasm (per our <a href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/wasmtime-debugging.md\">current RFC consensus</a>, with current informal discussions to tweak bits of how this works but not fundamentally abandon the notion of using a Wasm component), we need to follow the ownership semantics of WIT.</p>\n<p>In particular, this means that if we reify both the debuggee (the <code>Store</code> being debugged) and a handle to a particular frame as <em>resources</em>, we need to be able to put types in the <a href=\"https://docs.rs/wasmtime/latest/wasmtime/component/struct.ResourceTable.html\"><code>ResourceTable</code></a> that are standalone. A resource can have a parent-child relationship with another, but cannot \"borrow\" (and freeze) another via a lifetime parameter. In fact this would not even be representable in a Rust host-side implementation: lifetime parameters must bottom out at some actual stack frame; they cannot refer to some value with dynamic lifetime extent.</p>\n<p>The above is all well-and-good and unsurprising: WIT simplifies the available semantic range of borrowing/ownership considerably. We'll instead need to enforce the restrictions dynamically: something like, if a <code>frame</code> resource exists, then use of any API on the <code>debuggee</code> will trap.</p>\n<p>Unfortunately, implementing even this is difficult, because of the above-mentioned limitation: a borrow <em>needs to correspond to some host frame</em>, not a data structure; without a single hostcall instance that corresponds to the whole stack traversal, (EDIT) we cannot create a resource that is stored in a data structure that holds this borrow. (Said more simply: this implies a captured lifetime on whatever dynamic table the API is backed by; that lifetime itself also refers to the table; that's a self-reference and can't work, at least without unsafe code and very weird and easy-to-get-wrong semantics.)</p>\n<p>The net effect of this is that if we want to have a \"dynamic checks\" variant of the API exposed at any level, we need to fundamentally rethink the stack iterator idea. We instead need a notion of \"frame handles\" that refer to frozen stack frames, just as we have instance handles, table handles, and the like today; the handles are <code>Copy</code> or <code>Clone</code>-able things that are morally indexes into the <code>Store</code>. Unlike instances, however, we need more complex invalidation rules: we need a way to make a frame handle invalid (and dynamically fail if used) once execution resumes. We could do this by, internally, keeping a \"frame handle table\" and a generation number on each slot. This fits better with the semantic abstraction level of an API with an arbitrary number of handles (i.e., WIT resources).</p>\n<p>The alternative to all of this is to force an eager capture of the entire stack, all local values, and all operand-stack values on every pause; then provide an API over these <code>Vec</code>s held in resources rather than by actually lazily querying the paused machine stack.</p>\n<p>The other major question that arises is: would this be better if we wrote the top-half of the debugger in a native Rust implementation instead, using the existing Wasmtime APIs? Yes and no: yes, in the sense that we have tests today showing how to use the API effectively to walk the stack with a stack iterator. No, in the sense that we likely want to have a single top-level event loop, and always hold the debuggee <code>Store</code>; to use the iterator effectively we'd need to have a state machine where we take the iterator and poll the inbound requests/commands from the debugger connection, moving the iterator or exiting to the outer loop (ending the inner borrow) when leaving \"stack traversal mode\". It's much cleaner to be \"modeless\" and allow handles to frames to coexist with all other handles.</p>\n<p>So basically I believe we need to do this refactor regardless, and I don't see a way around it unless we do a very inefficient copy on every pause.</p>\n<p>cc @alexcrichton and @fitzgen for thoughts?</p>\n</blockquote>",
        "id": 571334043,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1769998054
    },
    {
        "content": "<p>cfallin edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>In our \"bottom-half\" API that provides access to a debuggee <code>Store</code>'s execution state via the native Wasmtime API, we have the <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Store.html#method.debug_frames\"><code>Store::debug_frames</code></a> method that returns a <code>DebugFrameCursor&lt;'a, T&gt;</code>. This cursor follows established iterator idioms in Rust: it borrows the <code>Store</code> for the duration of its existence, thus freezing its state (disallowing execution) and making stack frames safe to traverse and hold pointers into.</p>\n<p>However, as we reflect this API into a form that can be used by a \"top half\" that is built in Wasm (per our <a href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/wasmtime-debugging.md\">current RFC consensus</a>, with current informal discussions to tweak bits of how this works but not fundamentally abandon the notion of using a Wasm component), we need to follow the ownership semantics of WIT.</p>\n<p>In particular, this means that if we reify both the debuggee (the <code>Store</code> being debugged) and a handle to a particular frame as <em>resources</em>, we need to be able to put types in the <a href=\"https://docs.rs/wasmtime/latest/wasmtime/component/struct.ResourceTable.html\"><code>ResourceTable</code></a> that are standalone. A resource can have a parent-child relationship with another, but cannot \"borrow\" (and freeze) another via a lifetime parameter. In fact this would not even be representable in a Rust host-side implementation: lifetime parameters must bottom out at some actual stack frame; they cannot refer to some value with dynamic lifetime extent.</p>\n<p>The above is all well-and-good and unsurprising: WIT simplifies the available semantic range of borrowing/ownership considerably. We'll instead need to enforce the restrictions dynamically: something like, if a <code>frame</code> resource exists, then use of any API on the <code>debuggee</code> will trap.</p>\n<p>Unfortunately, implementing even this is difficult, because of the above-mentioned limitation: a borrow <em>needs to correspond to some host frame</em>, not a data structure; without a single hostcall instance that corresponds to the whole stack traversal, (EDIT) we cannot create a resource that is stored in a data structure that holds this borrow. (Said more simply: this implies a captured lifetime on whatever dynamic table the API is backed by; that lifetime itself also refers to the table; that's a self-reference and can't work.)</p>\n<p>The net effect of this is that if we want to have a \"dynamic checks\" variant of the API exposed at any level, we need to fundamentally rethink the stack iterator idea. We instead need a notion of \"frame handles\" that refer to frozen stack frames, just as we have instance handles, table handles, and the like today; the handles are <code>Copy</code> or <code>Clone</code>-able things that are morally indexes into the <code>Store</code>. Unlike instances, however, we need more complex invalidation rules: we need a way to make a frame handle invalid (and dynamically fail if used) once execution resumes. We could do this by, internally, keeping a \"frame handle table\" and a generation number on each slot. This fits better with the semantic abstraction level of an API with an arbitrary number of handles (i.e., WIT resources).</p>\n<p>The alternative to all of this is to force an eager capture of the entire stack, all local values, and all operand-stack values on every pause; then provide an API over these <code>Vec</code>s held in resources rather than by actually lazily querying the paused machine stack.</p>\n<p>The other major question that arises is: would this be better if we wrote the top-half of the debugger in a native Rust implementation instead, using the existing Wasmtime APIs? Yes and no: yes, in the sense that we have tests today showing how to use the API effectively to walk the stack with a stack iterator. No, in the sense that we likely want to have a single top-level event loop, and always hold the debuggee <code>Store</code>; to use the iterator effectively we'd need to have a state machine where we take the iterator and poll the inbound requests/commands from the debugger connection, moving the iterator or exiting to the outer loop (ending the inner borrow) when leaving \"stack traversal mode\". It's much cleaner to be \"modeless\" and allow handles to frames to coexist with all other handles.</p>\n<p>So basically I believe we need to do this refactor regardless, and I don't see a way around it unless we do a very inefficient copy on every pause.</p>\n<p>cc @alexcrichton and @fitzgen for thoughts?</p>\n</blockquote>",
        "id": 571334079,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1769998083
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3832586128\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>Extra wrinkle: frame-handle invalidation needs to happen not only on resuming execution but on dropping a future representing Wasm execution as well. I suspect what we'll want is something like a \"current execution generation\" counter on a <code>Store</code> that is incremented on every return from hostcall and in a drop guard in the fiber glue around async Wasm invocations. Then every <code>Frame</code> carries (i) unsafe raw <code>usize</code> pointing to the frame in the actual stack, (ii) store ID, (iii) execution generation in that store.</p>\n</blockquote>",
        "id": 571335438,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1769999226
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3836463375\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>In general, the more heavily we lean on Rust's type system, the more of these impedance mismatches like this we will encounter (and similar for e.g. exposing things in C APIs). For APIs that we expect to be used primarily from other languages or via WIT, we should probably design the APIs with this in mind, going forward.</p>\n<blockquote>\n<p>I suspect what we'll want is something like a \"current execution generation\" counter on a <code>Store</code> that is incremented on every return from hostcall and in a drop guard in the fiber glue around async Wasm invocations.</p>\n</blockquote>\n<p>Is this not equivalent to the Wasm's exit PC and (FP or SP)? When paired with the store id, this seems like it should be a way to validate whether a debugging stack frame iterator is still valid or not without any additional overhead on top of what we already track today.</p>\n</blockquote>",
        "id": 571481003,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770051207
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3836609553\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>I definitely agree with @fitzgen about how if we leverage Rust's uniqueness then it falls down in other integrations. That being said I'm not sure if there's really a good alternative for a frame iterator here, as ideally we wouldn't add more infrastructure around wasm entry/exit to invalidate handles/etc.</p>\n<p>An idea to maybe thread this needle: in the WIT for guests a frame iterator could be modeled where the construction of the frame iterator takes the debuggee store by-<code>own</code>. This models how nothing can be done while a debugger is iterating frames, and then when iteration is finished there'd be a way to get back the store. To model this on the host what we sort of want is typed coroutines where a coroutine closes over the store. Resuming the coroutine is done for the various API calls that a frame iterator can do, and the yields correspond to those results. We don't have coroutines in Rust, however, so the next closest way to model this on the host would be an async task with a channel going in/out.</p>\n<p>The WIT for example might look like:</p>\n<div class=\"codehilite\" data-code-language=\"wit\"><pre><span></span><code>resource stack {\n    constructor(store: store);\n    up: func() -&gt; bool;\n    down: func() -&gt; bool;\n    finish: static func(stack: stack) -&gt; store;\n\n    instance: func() -&gt; instance;\n    func-index: func() -&gt; u32;\n    get-local: func(idx: u32) -&gt; result&lt;wasm-value, ...&gt;;\n    set-local: func(idx: u32, val: wasm-value) -&gt; result&lt;_, ...&gt;;\n    // ...\n}\n</code></pre></div>\n<p>The implementation would look something like:</p>\n<ul>\n<li>On calling <code>constructor</code> an async task is created which owns the store and starts the frame iteration.</li>\n<li>A <code>stack</code> resource internally owns a channel to this task</li>\n<li>Each method on <code>stack</code> sends a message over this channel</li>\n<li>Each message also has a oneshot going back saying \"here's the result of the thing you just asked for\"</li>\n<li>The async task would be a <code>for</code> loop over all the messages in the channel plus synchronously handling each message. This would <code>break</code> when <code>finish</code> is called or the channel is closed (e.g. <code>stack</code> is dropped)</li>\n</ul>\n<p>That would enable all the borrowing we have in today's API (which accurately models to Rust how this works), would avoid any quadratic behavior, and in theory could map ok to a C-like API too</p>\n</blockquote>",
        "id": 571487378,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770052908
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3836742872\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<blockquote>\n<p>Is this not equivalent to the Wasm's exit PC and (FP or SP)? When paired with the store id, this seems like it should be a way to validate whether a debugging stack frame iterator is still valid or not without any additional overhead on top of what we already track today.</p>\n</blockquote>\n<p>Not exactly, because one could exit from the same PC/FP/SP in multiple successive calls (in fact it's even likely if one has e.g. a loop in the same function making the same call). If nothing above that frame has changed, then handles to higher frames may still be valid by chance, but e.g. the same function could have been called via some other path with the same frame sizes.</p>\n<p>To be concrete e.g. we have <code>e</code>, <code>f</code>, <code>g</code>, <code>h</code> all with minimal frame sizes (e.g. 16 bytes for the saved FP/ret addr pair only). We have <code>e</code> -&gt; <code>f</code> -&gt; <code>h</code> -&gt; hostcall; create some frame handles, resume. Then <code>h</code> returns, <code>f</code> returns, <code>e</code> calls <code>e</code> -&gt; <code>g</code> -&gt; <code>h</code> -&gt; hostcall. Same FP and SP in the stack; same PC; but a handle to the middle of <code>f</code>'s frame should be invalidated.</p>\n</blockquote>",
        "id": 571492859,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770054571
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3836767432\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>To Alex's sketch: I like the idea of passing ownership of the store (in my prototype, <code>debuggee</code>, so I'll call it that) to model what is actually possible at the WIT API level. That said, I think the implementation sketched above has complexity significantly higher than I would have hoped for. Question: is the cost of one u64 increment on hostcall return too much to bear?</p>\n</blockquote>",
        "id": 571493635,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770054816
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3837110777\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>The other tricky bit about the API that truly takes ownership of the store (<code>debuggee</code>) is that it needs to essentially duplicate all of the API surface of the rest of the reflection API, too: (i) working with Wasm values as read from stack frames may require use of the store (e.g. for GC refs), and (ii) the debugger is free to query other state while reading out the stack.</p>\n<p>I guess that's the fundamental thing: a protocol like gdbstub or DAP has a notion of either \"read stack frame <code>i</code> local <code>j</code>\" (gdbstub witih Wasm extensions) or \"give me a handle to stack frame <code>i</code>\" then \"with stack handle <code>f</code> read local <code>j</code>\" (DAP). I believe we'll thus want to implement this by essentially caching for each level a stack frame handle, as requested. This lets the client interleave walking up the stack with querying other state. That cache is then invalidated whenever we resume execution. Basically, I think the iterator paradigm is fundamentally too restrictive for what the protocols require, and emulating what the protocols require will require quadratic behavior if we are stuck with an iterator interface.</p>\n</blockquote>",
        "id": 571506504,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770059404
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3837304780\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>Needing to do store-related things while you otherwise wouldn't have ownership to the debuggee definitely sinks the idea of passing ownership -- it's definitely not worth it to duplicate API surface area.</p>\n<p>I think I don't fully understand what the proposal is here for a non-iterator-like-interface then? My hope was that we wouldn't need more <code>unsafe</code> code to deal with stack frames, but moving away from something iterator-like seems like it will require some form of <code>unsafe</code> somewhere. There's sort of a few layers here -- what the debugging protocol wants, how the debugger is implemented, what Wasmtime's WIT provides, how Wasmtime implements the WIT, and the base-level API Wasmtime provides. Could you detail a bit more what you're thinking about w.r.t. specifically the base-level API Wasmtime provides? </p>\n<p>I'm not worried about a u64 increment/decrement specifically, what I'm worried about is further expanding the <code>unsafe</code> scope here. The iterator approach, at least to me, is pretty trivially safe. Anything beyond that will require further special care/consideration which isn't a dealbreaker, but I'd be surprised if it boiled down to just a single increment/decrement/check and that's it.</p>\n</blockquote>",
        "id": 571516575,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770063195
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3837322798\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>Yes, the proposal is more or less what's written up above: </p>\n<blockquote>\n<p>We instead need a notion of \"frame handles\" that refer to frozen stack frames, just as we have instance handles, table handles, and the like today; the handles are Copy or Clone-able things that are morally indexes into the Store</p>\n</blockquote>\n<p>These handles capture:</p>\n<blockquote>\n<p>Then every Frame carries (i) unsafe raw usize pointing to the frame in the actual stack, (ii) store ID, (iii) execution generation in that store.</p>\n</blockquote>\n<p>The raw address is unsafe, but the unsafety is bounded by the check that the frame is still valid -- given by the combination of store ID matching a passed-in store, and the generation matching the current generation on that passed-in store, and generation being updated whenever we give control of the stack back to Wasm code (by returning) or drop it (by dropping a fiber).</p>\n<p>Then we have a <code>debug_frame(&amp;self) -&gt; Option&lt;Frame&gt;</code> on <code>Store</code> that gives the innermost frame (if any); any frame has a <code>fn parent(&amp;self) -&gt; Option&lt;Frame&gt;</code>; and any <code>Frame</code> has accessors for locals and operand stack and instance and all the rest, as the iterator does today, that takes <code>&amp;mut Store</code> explicitly. <code>Frame</code> itself would be at least <code>Clone</code> (maybe even <code>Copy</code>?) as e.g. <code>Instance</code> is today.</p>\n</blockquote>",
        "id": 571517516,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770063602
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3837339118\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>(Slight complication with reentrancy and also continuations: we may actually want <code>debug_frame_exits(&amp;self) -&gt; impl Iterator&lt;Item = Frame&gt;</code> or something like that to give all Wasm exit frames, so we don't have to explicitly unroll the iterator that traverses all of those as part of the stack iter currently. Then the <code>parent()</code> impl is just following one link in the chain of one activation, up to a saved entry FP)</p>\n</blockquote>",
        "id": 571518548,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770063980
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3837556844\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>Ah ok thanks makes sense. I agree that the idea of a copy-able <code>Frame</code> is appealing as it helps disentangle the lifetimes here and basically the same dynamic check that the rest of the API has. I'd be surprised if this only needed a single raw usize to identify the frame itself, for example it probably also needs the original entry fp to know when to stop walking, but that's fine to iron out details over time.</p>\n<p>How are you imagining that the generation number is going to work? The simplest implementation would invalidate all historical frames as soon as wasm starts running, but it also sounds like you might be thinking that lower down activations on the stack may stay valid.</p>\n<blockquote>\n<p>the unsafety is bounded by the check that the frame is still valid</p>\n</blockquote>\n<p>This is partly what I'm worried about, but I think might just be something we have to stomach. The store ID is simple enough to check but we already maintain a surprisingly large amount of state around wasm calls and this would be \"yet one more piece of state to check\". For example <a href=\"https://github.com/bytecodealliance/wasmtime/blob/f248b5c06d041681a0c9d629d5c4146fe8bac860/crates/wasmtime/src/runtime/func.rs#L1431-L1450\">this is all the state we currently maintain</a> which is <a href=\"https://github.com/bytecodealliance/wasmtime/blob/f248b5c06d041681a0c9d629d5c4146fe8bac860/crates/wasmtime/src/runtime/fiber.rs#L539-L581\">different from fiber state</a> which neither handles returning to wasm from the host. I realize that this'll \"just\" be a matter of putting some increments in the right places but the consequence for forgetting an increment is a use-after-free CVE where in most other places it's a denial-of-service CVE with a crash of some kind. Basically I'd love to try really hard to lean on existing state rather than adding yet-more-state. I don't know how that can be done, and I realize how in isolation the easiest thing to do is to add-one-more-piece-of-state, but this is at least where my original concern was coming from.</p>\n</blockquote>",
        "id": 571532465,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770069244
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3837683497\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>FWIW, in SpiderMonkey, we had a fairly fancy cache for captured <code>SavedFrame</code> objects: <a href=\"https://searchfox.org/firefox-main/rev/33fd6bd39c625067a29f153adce6a4646e45750f/js/src/vm/Activation.h#46\">https://searchfox.org/firefox-main/rev/33fd6bd39c625067a29f153adce6a4646e45750f/js/src/vm/Activation.h#46</a></p>\n<p>This wasn't used directly for the <code>Debug.Frame</code> debugging API, IIRC, but we could do something similar.</p>\n</blockquote>",
        "id": 571540472,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770072581
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3837691044\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'd be surprised if this only needed a single raw usize to identify the frame itself, for example it probably also needs the original entry fp to know when to stop walking, but that's fine to iron out details over time.</p>\n</blockquote>\n<p>Right, yeah, you're right of course -- we need two <code>usize</code>s for current FP and entry FP.</p>\n<blockquote>\n<p>Basically I'd love to try really hard to lean on existing state rather than adding yet-more-state. I don't know how that can be done, and I realize how in isolation the easiest thing to do is to add-one-more-piece-of-state, but this is at least where my original concern was coming from.</p>\n</blockquote>\n<p>I was thinking we'd keep the version per <code>Store</code> (or I guess <code>VMStoreContext</code> to make it reachable from trampoline-land), not <code>EntryStoreContext</code>, as this is scoped for lifetime of store not one activation. You're right that we need to capture all cases where we might return control to execution that could unwind a stack. I was hoping that we'd have a narrow waist where we could do that around the same place that we deal with <code>HostResult</code>s in <code>traphandlers.rs</code>; and then a drop guard in one place in the fiber entry point that owns the fiber stack. If we think this is workable I'll put together a draft PR and of couse welcome your comments where I've forgotten it :-)</p>\n</blockquote>",
        "id": 571540751,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770072755
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3837695047\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>To be explicit, too, bumping the version number on every return into Wasm means that, e.g., if we are suspended at some breakpoint and then we manually invoke another Wasm function from the debugger at that point, that invalidates our cache. But the \"cache\" framing is intentional here as we can always rebuild the cache by counting up the frames from our current point again. So one <code>u64</code> and not, e.g., versions per level or something like that.</p>\n</blockquote>",
        "id": 571540925,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770072845
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486#issuecomment-3842227776\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>The best narrow waist here might actually be the trampolines themselves given how tightly we control entry/exit into wasm. With a <code>VMStoreContext</code>-reachable location the increment could be folded into the entry trampolines and then any return from a host/libcall would handle the increment-back-into-wasm. That'd also handle the case where we're raising a trap, longjmp'ing, etc.</p>\n<p>The only other case I can think of is related to signal handlers, so there could also be an increment on the \"returned with exception\" path of entry trampolines too</p>\n</blockquote>",
        "id": 571703085,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770134940
    },
    {
        "content": "<p>cfallin closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12486\">issue #12486</a>:</p>\n<blockquote>\n<p>In our \"bottom-half\" API that provides access to a debuggee <code>Store</code>'s execution state via the native Wasmtime API, we have the <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Store.html#method.debug_frames\"><code>Store::debug_frames</code></a> method that returns a <code>DebugFrameCursor&lt;'a, T&gt;</code>. This cursor follows established iterator idioms in Rust: it borrows the <code>Store</code> for the duration of its existence, thus freezing its state (disallowing execution) and making stack frames safe to traverse and hold pointers into.</p>\n<p>However, as we reflect this API into a form that can be used by a \"top half\" that is built in Wasm (per our <a href=\"https://github.com/bytecodealliance/rfcs/blob/main/accepted/wasmtime-debugging.md\">current RFC consensus</a>, with current informal discussions to tweak bits of how this works but not fundamentally abandon the notion of using a Wasm component), we need to follow the ownership semantics of WIT.</p>\n<p>In particular, this means that if we reify both the debuggee (the <code>Store</code> being debugged) and a handle to a particular frame as <em>resources</em>, we need to be able to put types in the <a href=\"https://docs.rs/wasmtime/latest/wasmtime/component/struct.ResourceTable.html\"><code>ResourceTable</code></a> that are standalone. A resource can have a parent-child relationship with another, but cannot \"borrow\" (and freeze) another via a lifetime parameter. In fact this would not even be representable in a Rust host-side implementation: lifetime parameters must bottom out at some actual stack frame; they cannot refer to some value with dynamic lifetime extent.</p>\n<p>The above is all well-and-good and unsurprising: WIT simplifies the available semantic range of borrowing/ownership considerably. We'll instead need to enforce the restrictions dynamically: something like, if a <code>frame</code> resource exists, then use of any API on the <code>debuggee</code> will trap.</p>\n<p>Unfortunately, implementing even this is difficult, because of the above-mentioned limitation: a borrow <em>needs to correspond to some host frame</em>, not a data structure; without a single hostcall instance that corresponds to the whole stack traversal, (EDIT) we cannot create a resource that is stored in a data structure that holds this borrow. (Said more simply: this implies a captured lifetime on whatever dynamic table the API is backed by; that lifetime itself also refers to the table; that's a self-reference and can't work.)</p>\n<p>The net effect of this is that if we want to have a \"dynamic checks\" variant of the API exposed at any level, we need to fundamentally rethink the stack iterator idea. We instead need a notion of \"frame handles\" that refer to frozen stack frames, just as we have instance handles, table handles, and the like today; the handles are <code>Copy</code> or <code>Clone</code>-able things that are morally indexes into the <code>Store</code>. Unlike instances, however, we need more complex invalidation rules: we need a way to make a frame handle invalid (and dynamically fail if used) once execution resumes. We could do this by, internally, keeping a \"frame handle table\" and a generation number on each slot. This fits better with the semantic abstraction level of an API with an arbitrary number of handles (i.e., WIT resources).</p>\n<p>The alternative to all of this is to force an eager capture of the entire stack, all local values, and all operand-stack values on every pause; then provide an API over these <code>Vec</code>s held in resources rather than by actually lazily querying the paused machine stack.</p>\n<p>The other major question that arises is: would this be better if we wrote the top-half of the debugger in a native Rust implementation instead, using the existing Wasmtime APIs? Yes and no: yes, in the sense that we have tests today showing how to use the API effectively to walk the stack with a stack iterator. No, in the sense that we likely want to have a single top-level event loop, and always hold the debuggee <code>Store</code>; to use the iterator effectively we'd need to have a state machine where we take the iterator and poll the inbound requests/commands from the debugger connection, moving the iterator or exiting to the outer loop (ending the inner borrow) when leaving \"stack traversal mode\". It's much cleaner to be \"modeless\" and allow handles to frames to coexist with all other handles.</p>\n<p>So basically I believe we need to do this refactor regardless, and I don't see a way around it unless we do a very inefficient copy on every pause.</p>\n<p>cc @alexcrichton and @fitzgen for thoughts?</p>\n</blockquote>",
        "id": 573410919,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770854820
    }
]