[
    {
        "content": "<p>lethalbit opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862\">issue #11862</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>As the title says, the ability to optionally append a prefix (or suffix, doesn't matter which really) to the output <code>JitDump</code> or <code>PerfMap</code> files when profiling is enabled.</p>\n<h4>Benefit</h4>\n<p>The main benefit would be to allow for wasmtime to live in a process that has another different JIT engine inside of it that also emits a perf map or jitdump files.</p>\n<p>While this is a niche use case, i've run into needing it myself on a few occasions, primarily when doing Python &lt;-&gt; Rust &lt;-&gt; WASM interop, as Python also emits perf map (or jitdump) files. </p>\n<p>Granted this would need post-processing, but that would need to happen regardless as <code>perf</code> on linux makes the (likely sane) assumption that only one JIT runtime will be in any given process.</p>\n<h4>Implementation</h4>\n<p>Implementation wise, it wouldn't be too complex, the <code>jitdump</code> and <code>perfmap</code> profiling agents could take an <code>Option&lt;T&gt;</code> for the file prefix/suffix, and then just update the file name with that. The <code>ProfilingStrategy</code> enum would either need an API breaking change to add said <code>Option&lt;T&gt;</code> to the <code>PerfMap</code>/<code>JitDump</code> elements or have 2 new \"prefixed\" variants added that take just the <code>T</code>.</p>\n<p>In the case of the <code>PerfMapAgent</code>, we would also likely want to prefix <code>wasm::</code> to the sanitized name entries to properly namespace it, i've not looked too much into the <code>JitDumpAgent</code> but it would likely need a similar change. </p>\n<h4>Alternatives</h4>\n<p>The primary alternative would be to not use this, and have each hosted JIT use a different method, one perf map and the other JIT dump, however, the <code>perf</code> tools will only really use the input from one or the other because as mentioned previously <code>perf</code> assumes only one JIT per process.</p>\n<p>This also applies to doing the JIT dump processing and then trying to apply a perf map file to it after.</p>\n<h4>Example</h4>\n<p>Here is a screenshot for a locally patched version of wasmtime I had to use in order to get the wanted behaviour, showing a use case for this specific feature, in this case it is Python and wasmtime both emitting a perf map file, which I then post-process to namespace the WASM map and then merge them into a single perf map file prior to using <code>perf report</code></p>\n<p>&lt;img width=\"1650\" height=\"1085\" alt=\"Image\" src=\"<a href=\"https://github.com/user-attachments/assets/3653cf41-13da-4ca5-a9f0-ca5aa35fb433\">https://github.com/user-attachments/assets/3653cf41-13da-4ca5-a9f0-ca5aa35fb433</a>\" /&gt;</p>\n</blockquote>",
        "id": 544956060,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760531505
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406489276\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862\">issue #11862</a>:</p>\n<blockquote>\n<p>For perfmap would it work if both Wasmtime and Python open the perfmap file in append mode and try to atomically write a full entry at a time? That way you wouldn't need any post processing I think. That wouldn't work for jitdump though.</p>\n</blockquote>",
        "id": 544970812,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760535375
    },
    {
        "content": "<p>lethalbit <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406512246\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862\">issue #11862</a>:</p>\n<blockquote>\n<p>In Pythons case it makes the very much sane assumption that it is the only thing writing to the perf map file.</p>\n<p>Plus there might be contention when flushing the file contents regardless, so I don't think that's a very viable option. </p>\n</blockquote>",
        "id": 544972053,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760535710
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406554837\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862\">issue #11862</a>:</p>\n<blockquote>\n<blockquote>\n<p>Plus there might be contention when flushing the file contents regardless</p>\n</blockquote>\n<p>If you only buffer full entries that wouldn't matter. At worst you did get a non-deterministic order, not corrupt entries.</p>\n<blockquote>\n<p>In Pythons case it makes the very much sane assumption that it is the only thing writing to the perf map file.</p>\n</blockquote>\n<p>I guess nobody thought about having multiple jits in the same process when they designed this interface, so now everyone has to add workarounds. I presume the same kind of issues would occur if you try to use Python and C# or a javascript engine in the same process.</p>\n</blockquote>",
        "id": 544974463,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760536303
    },
    {
        "content": "<p>lethalbit <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406605908\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862\">issue #11862</a>:</p>\n<blockquote>\n<p>Yeah, I mean, to be fair, having multiple <em>different</em> JITs in the same process is a bit of an esoteric situation, so it's not too surprising that it was overlooked.</p>\n<p>On top of that the <code>perf</code> tools have some long outstanding issues in the first place, in the case of the JIT dump files, when post-processing that into the <code>.so</code> files <code>perf</code> will try to d a symbol lookup for each object if you have <code>DEBUGINFOD_URLS</code> set, which will fail because of course the upstream debug info server won't have any symbols for them.</p>\n<p>In general the perf tooling around JIT debug is pretty rough, and while I would love for there to be a better way, I think having prefixed/suffixed dumps/maps would be the current \"best\" solution for it, even if not optimal. </p>\n</blockquote>",
        "id": 544977224,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760536982
    },
    {
        "content": "<p>lethalbit edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406605908\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862\">issue #11862</a>:</p>\n<blockquote>\n<p>Yeah, I mean, to be fair, having multiple <em>different</em> JITs in the same process is a bit of an esoteric situation, so it's not too surprising that it was overlooked.</p>\n<p>On top of that the <code>perf</code> tools have some long outstanding issues in the first place, in the case of the JIT dump files, when post-processing that into the <code>.so</code> files <code>perf</code> will try to do a symbol lookup for each object if you have <code>DEBUGINFOD_URLS</code> set, which will fail because of course the upstream debug info server won't have any symbols for them.</p>\n<p>In general the perf tooling around JIT debug is pretty rough, and while I would love for there to be a better way, I think having prefixed/suffixed dumps/maps would be the current \"best\" solution for it, even if not optimal. </p>\n</blockquote>",
        "id": 544984838,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760538665
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406908936\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862\">issue #11862</a>:</p>\n<blockquote>\n<p>For perfmap support unforunately this isn't something we can fix I believe. Perf itself <a href=\"https://github.com/torvalds/linux/blob/9b332cece987ee1790b2ed4c989e28162fa47860/tools/perf/Documentation/jit-interface.txt#L4\">hardcodes the filename</a>. Similarly for jitdump <a href=\"https://github.com/torvalds/linux/blob/9b332cece987ee1790b2ed4c989e28162fa47860/tools/perf/util/jitdump.c#L749-L753\">the filename to be recognized is hardcoded</a>. Given that all we can really do I think is what @bjorn3 is suggestion, which is to open files in <code>O_APPEND</code> mode and write out entire entries at once.</p>\n</blockquote>",
        "id": 544993226,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760540590
    },
    {
        "content": "<p>lethalbit <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3406955368\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862\">issue #11862</a>:</p>\n<blockquote>\n<p>Hence why I was suggesting a prefixed or postfixed variant so that it could be post-processed as needed.</p>\n<p>But looking at the current implementation in Python that looks like they also open in append mode:</p>\n<p><a href=\"https://github.com/python/cpython/blob/728d239e57b650c392517b7ae569b0eb05af826e/Python/sysmodule.c#L2674-L2703\">https://github.com/python/cpython/blob/728d239e57b650c392517b7ae569b0eb05af826e/Python/sysmodule.c#L2674-L2703</a></p>\n<p>So maybe that would be the best way, assuming the \"namespacing\" of the wasm entries is done,</p>\n<p>While I would still personally like to be able to split it out, if this is the better solution then that works.<br>\n</p>\n</blockquote>",
        "id": 544995499,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760541187
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3407184768\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862\">issue #11862</a>:</p>\n<blockquote>\n<p>Is your goal to separate out the profiles so wasm stacks are excluded, for example when you're profiling Python? or vice-versa? Or is the goal to be able to profile everything together? In some ways our hands are tied here as we don't really want to maintain/recommend nonstandard tooling for post-processing files (it's already confusing enough as is sort of...) so if it works for you to have everything in one file I think then that it's basically on us to work with preexisting files and ensure that we append entire records at once and fail if a partial write is ever done.</p>\n</blockquote>",
        "id": 545005874,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760543940
    },
    {
        "content": "<p>lethalbit <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862#issuecomment-3407239222\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862\">issue #11862</a>:</p>\n<blockquote>\n<p>Ideally It would have been nice to be able to have them seperate if I wanted to look at wasm-only or Python-only, but honestly, as long as the wasm entries are properly prefixed (with <code>wasm::</code> or something, as Python does <code>py::</code>) then they can be split out after if needed and it's not a huge deal.</p>\n</blockquote>",
        "id": 545007897,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760544495
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11862\">issue #11862</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>As the title says, the ability to optionally append a prefix (or suffix, doesn't matter which really) to the output <code>JitDump</code> or <code>PerfMap</code> files when profiling is enabled.</p>\n<h4>Benefit</h4>\n<p>The main benefit would be to allow for wasmtime to live in a process that has another different JIT engine inside of it that also emits a perf map or jitdump files.</p>\n<p>While this is a niche use case, i've run into needing it myself on a few occasions, primarily when doing Python &lt;-&gt; Rust &lt;-&gt; WASM interop, as Python also emits perf map (or jitdump) files. </p>\n<p>Granted this would need post-processing, but that would need to happen regardless as <code>perf</code> on linux makes the (likely sane) assumption that only one JIT runtime will be in any given process.</p>\n<h4>Implementation</h4>\n<p>Implementation wise, it wouldn't be too complex, the <code>jitdump</code> and <code>perfmap</code> profiling agents could take an <code>Option&lt;T&gt;</code> for the file prefix/suffix, and then just update the file name with that. The <code>ProfilingStrategy</code> enum would either need an API breaking change to add said <code>Option&lt;T&gt;</code> to the <code>PerfMap</code>/<code>JitDump</code> elements or have 2 new \"prefixed\" variants added that take just the <code>T</code>.</p>\n<p>In the case of the <code>PerfMapAgent</code>, we would also likely want to prefix <code>wasm::</code> to the sanitized name entries to properly namespace it, i've not looked too much into the <code>JitDumpAgent</code> but it would likely need a similar change. </p>\n<h4>Alternatives</h4>\n<p>The primary alternative would be to not use this, and have each hosted JIT use a different method, one perf map and the other JIT dump, however, the <code>perf</code> tools will only really use the input from one or the other because as mentioned previously <code>perf</code> assumes only one JIT per process.</p>\n<p>This also applies to doing the JIT dump processing and then trying to apply a perf map file to it after.</p>\n<h4>Example</h4>\n<p>Here is a screenshot for a locally patched version of wasmtime I had to use in order to get the wanted behaviour, showing a use case for this specific feature, in this case it is Python and wasmtime both emitting a perf map file, which I then post-process to namespace the WASM map and then merge them into a single perf map file prior to using <code>perf report</code></p>\n<p>&lt;img width=\"1650\" height=\"1085\" alt=\"Image\" src=\"<a href=\"https://github.com/user-attachments/assets/3653cf41-13da-4ca5-a9f0-ca5aa35fb433\">https://github.com/user-attachments/assets/3653cf41-13da-4ca5-a9f0-ca5aa35fb433</a>\" /&gt;</p>\n</blockquote>",
        "id": 545136284,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1760566845
    }
]