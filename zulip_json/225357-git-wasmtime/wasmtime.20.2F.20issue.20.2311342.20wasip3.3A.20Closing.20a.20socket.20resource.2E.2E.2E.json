[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342\">issue #11342</a>:</p>\n<blockquote>\n<p>Currently there is liberal use of <code>Arc&lt;...&gt;</code> in the WASIp3 <code>wasi:sockets</code> implementation which is used for sharing sockets between tasks which are used to implement streams. One example is that a stream of clients can be extracted from a TCP listener, meaning that the underlying socket is now shared between the original TCP listener resource and the stream that is reading clients. The consequence of this implementation is that when the resource is closed it does not mean that the actual socket is itself closed. For example the OS-level port remains reserved until the task for accepted clients also exits. While the tasks will \"promptly exit\" there is currently no reliable mechanism to await this happening.</p>\n<p>This leads to tests for REUSEADDR, for example, having a loop around re-binding a port and asserting it's successful. This test is being added in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11291\">https://github.com/bytecodealliance/wasmtime/pull/11291</a>.</p>\n</blockquote>",
        "id": 531717196,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753832332
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasi:impl label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342\">Issue #11342</a>.</p>",
        "id": 531717197,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753832332
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasm-proposal:component-model-async label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342\">Issue #11342</a>.</p>",
        "id": 531717198,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1753832332
    },
    {
        "content": "<p>rvolosatovs <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342#issuecomment-3174860894\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342\">issue #11342</a>:</p>\n<blockquote>\n<p>One thing that is currently missing in the implementation is the receive/listen task cancellation on socket drop, i.e. <code>receive</code> and <code>listen</code> should store the <code>AbortHandle</code> in the socket state and abort these tasks once the socket is dropped.</p>\n<p>I spent some time on it just now, but I don't really see a nice way to integrate this with the <code>start_receive</code> etc. abstractions without making <code>TcpState</code> field public again, @alexcrichton could you handle this?</p>\n<p>I don't know if that would necessarily fix this issue, but it's something we should do anyway. For reference, here's the documentation of <code>wasi:http</code> for a similar construct: <a href=\"https://github.com/WebAssembly/wasi-http/blob/ad500ba30bdfd57e04bdabdcd0480111681bf017/wit-0.3.0-draft/types.wit#L420-L423\">https://github.com/WebAssembly/wasi-http/blob/ad500ba30bdfd57e04bdabdcd0480111681bf017/wit-0.3.0-draft/types.wit#L420-L423</a></p>\n</blockquote>",
        "id": 533794936,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754919023
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342#issuecomment-3174860894\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342\">issue #11342</a>:</p>\n<blockquote>\n<p>One thing that is currently missing in the implementation is the receive/listen task cancellation on socket drop, i.e. <code>receive</code> and <code>listen</code> should store the <code>AbortHandle</code> in the socket state and abort these tasks once the socket is dropped.</p>\n<p>I spent some time on it just now, but I don't really see a nice way to integrate this with the <code>start_receive</code> etc. abstractions without making <code>TcpState</code> field public again, @alexcrichton could you handle this?</p>\n<p>I've implemented this for filesystem though: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11406/commits/40415b52f79a33c376a2a875ffecb1d0a01c7903\">https://github.com/bytecodealliance/wasmtime/pull/11406/commits/40415b52f79a33c376a2a875ffecb1d0a01c7903</a></p>\n<p>I don't know if that would necessarily fix this issue, but it's something we should do anyway. For reference, here's the documentation of <code>wasi:http</code> for a similar construct: <a href=\"https://github.com/WebAssembly/wasi-http/blob/ad500ba30bdfd57e04bdabdcd0480111681bf017/wit-0.3.0-draft/types.wit#L420-L423\">https://github.com/WebAssembly/wasi-http/blob/ad500ba30bdfd57e04bdabdcd0480111681bf017/wit-0.3.0-draft/types.wit#L420-L423</a></p>\n</blockquote>",
        "id": 533795121,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754919078
    },
    {
        "content": "<p>rvolosatovs edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342#issuecomment-3174860894\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342\">issue #11342</a>:</p>\n<blockquote>\n<p>One thing that is currently missing in the implementation is the receive/listen task cancellation on socket drop, i.e. <code>receive</code> and <code>listen</code> should store the <code>AbortHandle</code> in the socket state and abort these tasks once the socket is dropped.</p>\n<p>I spent some time on it just now, but I don't really see a nice way to integrate this with the <code>start_receive</code> etc. abstractions without making <code>TcpState</code> field public again, @alexcrichton could you handle this?</p>\n<p>I've implemented this for filesystem though: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11406/commits/40415b52f79a33c376a2a875ffecb1d0a01c7903\">https://github.com/bytecodealliance/wasmtime/pull/11406/commits/40415b52f79a33c376a2a875ffecb1d0a01c7903</a></p>\n<p>I don't know if that would necessarily fix this issue, but it's something we should do anyway. For reference, here's the documentation of <code>wasi:http</code> for a similar construct: <a href=\"https://github.com/WebAssembly/wasi-http/blob/ad500ba30bdfd57e04bdabdcd0480111681bf017/wit-0.3.0-draft/types.wit#L420-L423\">https://github.com/WebAssembly/wasi-http/blob/ad500ba30bdfd57e04bdabdcd0480111681bf017/wit-0.3.0-draft/types.wit#L420-L423</a></p>\n<p>For reference, here's the in-progress diff, if it helps:</p>\n<p><div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gh\">diff --git a/crates/wasi/src/p3/sockets/host/types/tcp.rs b/crates/wasi/src/p3/sockets/host/types/tcp.rs</span>\n<span class=\"gh\">index 66314d5372..a2bf1ff0c1 100644</span>\n<span class=\"gd\">--- a/crates/wasi/src/p3/sockets/host/types/tcp.rs</span>\n<span class=\"gi\">+++ b/crates/wasi/src/p3/sockets/host/types/tcp.rs</span>\n<span class=\"gu\">@@ -266,11 +266,12 @@ impl HostTcpSocketWithStore for WasiSockets {</span>\n<span class=\"w\"> </span>                    let (result_tx, result_rx) = instance\n<span class=\"w\"> </span>                        .future(&amp;mut view, || unreachable!())\n<span class=\"w\"> </span>                        .context(\"failed to create future\")?;\n<span class=\"gd\">-                    view.spawn(ReceiveTask {</span>\n<span class=\"gi\">+                    let task = view.spawn(ReceiveTask {</span>\n<span class=\"w\"> </span>                        stream,\n<span class=\"w\"> </span>                        data_tx,\n<span class=\"w\"> </span>                        result_tx,\n<span class=\"w\"> </span>                    });\n<span class=\"gi\">+                    socket.set_p3_receive_task(task);</span>\n<span class=\"w\"> </span>                    Ok((data_rx, result_rx))\n<span class=\"w\"> </span>                }\n<span class=\"w\"> </span>                None =&gt; {\n<span class=\"gh\">diff --git a/crates/wasi/src/sockets/tcp.rs b/crates/wasi/src/sockets/tcp.rs</span>\n<span class=\"gh\">index 09dd2ba8de..ff907b356e 100644</span>\n<span class=\"gd\">--- a/crates/wasi/src/sockets/tcp.rs</span>\n<span class=\"gi\">+++ b/crates/wasi/src/sockets/tcp.rs</span>\n<span class=\"gu\">@@ -94,7 +94,10 @@ enum TcpState {</span>\n<span class=\"w\"> </span>    ///\n<span class=\"w\"> </span>    /// A socket will not transition out of this state.\n<span class=\"w\"> </span>    #[cfg(feature = \"p3\")]\n<span class=\"gd\">-    Receiving(Arc&lt;tokio::net::TcpStream&gt;),</span>\n<span class=\"gi\">+    Receiving(</span>\n<span class=\"gi\">+        Arc&lt;tokio::net::TcpStream&gt;,</span>\n<span class=\"gi\">+        Option&lt;wasmtime::component::AbortHandle&gt;,</span>\n<span class=\"gi\">+    ),</span>\n\n<span class=\"w\"> </span>    /// This is a WASIp2-bound socket which stores some extra state for\n<span class=\"w\"> </span>    /// read/write streams to handle TCP shutdown.\n<span class=\"gu\">@@ -239,7 +242,7 @@ impl TcpSocket {</span>\n<span class=\"w\"> </span>            | TcpState::ListenStarted(socket) =&gt; Ok(socket.as_socketlike_view()),\n<span class=\"w\"> </span>            TcpState::Connected(stream) =&gt; Ok(stream.as_socketlike_view()),\n<span class=\"w\"> </span>            #[cfg(feature = \"p3\")]\n<span class=\"gd\">-            TcpState::Receiving(stream) =&gt; Ok(stream.as_socketlike_view()),</span>\n<span class=\"gi\">+            TcpState::Receiving(stream, _) =&gt; Ok(stream.as_socketlike_view()),</span>\n<span class=\"w\"> </span>            TcpState::Listening { listener, .. } =&gt; Ok(listener.as_socketlike_view()),\n<span class=\"w\"> </span>            TcpState::P2Streaming(state) =&gt; Ok(state.stream.as_socketlike_view()),\n<span class=\"w\"> </span>            TcpState::Connecting(..) | TcpState::ConnectReady(_) | TcpState::Closed =&gt; {\n<span class=\"gu\">@@ -459,7 +462,7 @@ impl TcpSocket {</span>\n<span class=\"w\"> </span>    pub(crate) fn start_receive(&amp;mut self) -&gt; Option&lt;&amp;Arc&lt;tokio::net::TcpStream&gt;&gt; {\n<span class=\"w\"> </span>        match mem::replace(&amp;mut self.tcp_state, TcpState::Closed) {\n<span class=\"w\"> </span>            TcpState::Connected(stream) =&gt; {\n<span class=\"gd\">-                self.tcp_state = TcpState::Receiving(stream);</span>\n<span class=\"gi\">+                self.tcp_state = TcpState::Receiving(stream, None);</span>\n<span class=\"w\"> </span>                Some(self.tcp_stream_arc().unwrap())\n<span class=\"w\"> </span>            }\n<span class=\"w\"> </span>            prev =&gt; {\n<span class=\"gu\">@@ -469,12 +472,26 @@ impl TcpSocket {</span>\n<span class=\"w\"> </span>        }\n<span class=\"w\"> </span>    }\n\n<span class=\"gi\">+    #[cfg(feature = \"p3\")]</span>\n<span class=\"gi\">+    pub(crate) fn set_p3_receive_task(</span>\n<span class=\"gi\">+        &amp;mut self,</span>\n<span class=\"gi\">+        task: wasmtime::component::AbortHandle,</span>\n<span class=\"gi\">+    ) -&gt; Result&lt;(), ErrorCode&gt; {</span>\n<span class=\"gi\">+        match &amp;mut self.tcp_state {</span>\n<span class=\"gi\">+            TcpState::Receiving(_, slot @ None) =&gt; {</span>\n<span class=\"gi\">+                *slot = Some(task);</span>\n<span class=\"gi\">+                Ok(())</span>\n<span class=\"gi\">+            }</span>\n<span class=\"gi\">+            _ =&gt; Err(ErrorCode::InvalidState),</span>\n<span class=\"gi\">+        }</span>\n<span class=\"gi\">+    }</span>\n<span class=\"gi\">+</span>\n<span class=\"w\"> </span>    pub(crate) fn local_address(&amp;self) -&gt; Result&lt;SocketAddr, ErrorCode&gt; {\n<span class=\"w\"> </span>        match &amp;self.tcp_state {\n<span class=\"w\"> </span>            TcpState::Bound(socket) =&gt; Ok(socket.local_addr()?),\n<span class=\"w\"> </span>            TcpState::Connected(stream) =&gt; Ok(stream.local_addr()?),\n<span class=\"w\"> </span>            #[cfg(feature = \"p3\")]\n<span class=\"gd\">-            TcpState::Receiving(stream) =&gt; Ok(stream.local_addr()?),</span>\n<span class=\"gi\">+            TcpState::Receiving(stream, _) =&gt; Ok(stream.local_addr()?),</span>\n<span class=\"w\"> </span>            TcpState::P2Streaming(state) =&gt; Ok(state.stream.local_addr()?),\n<span class=\"w\"> </span>            TcpState::Listening { listener, .. } =&gt; Ok(listener.local_addr()?),\n<span class=\"w\"> </span>            #[cfg(feature = \"p3\")]\n<span class=\"gu\">@@ -645,7 +662,7 @@ impl TcpSocket {</span>\n<span class=\"w\"> </span>        match &amp;self.tcp_state {\n<span class=\"w\"> </span>            TcpState::Connected(socket) =&gt; Ok(socket),\n<span class=\"w\"> </span>            #[cfg(feature = \"p3\")]\n<span class=\"gd\">-            TcpState::Receiving(socket) =&gt; Ok(socket),</span>\n<span class=\"gi\">+            TcpState::Receiving(socket, _) =&gt; Ok(socket),</span>\n<span class=\"w\"> </span>            TcpState::P2Streaming(state) =&gt; Ok(&amp;state.stream),\n<span class=\"w\"> </span>            #[cfg(feature = \"p3\")]\n<span class=\"w\"> </span>            TcpState::Error(err) =&gt; Err(err.into()),\n<span class=\"gu\">@@ -695,7 +712,7 @@ impl TcpSocket {</span>\n<span class=\"w\"> </span>            | TcpState::P2Streaming(_) =&gt; {}\n\n<span class=\"w\"> </span>            #[cfg(feature = \"p3\")]\n<span class=\"gd\">-            TcpState::Receiving(_) | TcpState::Error(_) =&gt; {}</span>\n<span class=\"gi\">+            TcpState::Receiving(_, _) | TcpState::Error(_) =&gt; {}</span>\n\n<span class=\"w\"> </span>            TcpState::Connecting(Some(future)) =&gt; {\n<span class=\"w\"> </span>                self.tcp_state = TcpState::ConnectReady(future.as_mut().await);\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 533795446,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754919193
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342#issuecomment-3176362182\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342\">issue #11342</a>:</p>\n<blockquote>\n<p>Related issue after our discussion today as well: <a href=\"https://github.com/WebAssembly/component-model/issues/552\">https://github.com/WebAssembly/component-model/issues/552</a></p>\n</blockquote>",
        "id": 533848677,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1754938159
    },
    {
        "content": "<p>alexcrichton assigned dicej to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342\">issue #11342</a>.</p>",
        "id": 534277103,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1755107580
    },
    {
        "content": "<p>alexcrichton closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342\">issue #11342</a>:</p>\n<blockquote>\n<p>Currently there is liberal use of <code>Arc&lt;...&gt;</code> in the WASIp3 <code>wasi:sockets</code> implementation which is used for sharing sockets between tasks which are used to implement streams. One example is that a stream of clients can be extracted from a TCP listener, meaning that the underlying socket is now shared between the original TCP listener resource and the stream that is reading clients. The consequence of this implementation is that when the resource is closed it does not mean that the actual socket is itself closed. For example the OS-level port remains reserved until the task for accepted clients also exits. While the tasks will \"promptly exit\" there is currently no reliable mechanism to await this happening.</p>\n<p>This leads to tests for REUSEADDR, for example, having a loop around re-binding a port and asserting it's successful. This test is being added in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11291\">https://github.com/bytecodealliance/wasmtime/pull/11291</a>.</p>\n</blockquote>",
        "id": 537769213,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757027851
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342#issuecomment-3256269061\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/11342\">issue #11342</a>:</p>\n<blockquote>\n<p>Fixed in <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11515\">https://github.com/bytecodealliance/wasmtime/pull/11515</a></p>\n</blockquote>",
        "id": 537769218,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757027852
    }
]