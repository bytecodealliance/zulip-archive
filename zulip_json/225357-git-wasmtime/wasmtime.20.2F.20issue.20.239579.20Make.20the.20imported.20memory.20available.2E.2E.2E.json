[
    {
        "content": "<p>Lohann opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>Thanks for filing a feature request! Please fill out the TODOs below.</p>\n<h4>Feature</h4>\n<p>Hello, I need to access the imported memory inside a functions, then I realized the Caller only show exports, not imports, so I had a lot of trouble to get Wasmtime store working with <a href=\"https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html\">MaybeUnit</a>, this simple solution segfaults:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">uninit</span><span class=\"p\">();</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">mem</span><span class=\"p\">::</span><span class=\"n\">transmute</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"p\">};</span>\n\n<span class=\"c1\">// segfaults below</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Instance</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">imports</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>Then I realized the issue is that there's no way for me transmute only the State, I need to transmute the Store which is not recommended, once rust <a href=\"https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html#layout-1\">doesn't guarantee the same memory layout</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>Actually I haven't find any way to use MaybeUnit that doesn't look hacky, and I want to avoid the usage of Option and unwraps in the code, once it bloats the binary with panic data.</p>\n<h4>Alternatives</h4>\n<ol>\n<li>Make the imported memory easily available inside Functions, ex: expose it in the Caller.</li>\n<li>Use <code>#[repr(C)]</code> on <code>Store</code>, so we can safely transmute it.<br>\n</li>\n</ol>\n</blockquote>",
        "id": 481064544,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730967048
    },
    {
        "content": "<p>Lohann edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>Thanks for filing a feature request! Please fill out the TODOs below.</p>\n<h4>Feature</h4>\n<p>Hello, I need to access the imported memory inside a functions, then I realized the Caller only show exports, not imports, so I had a lot of trouble to get Wasmtime store working with <a href=\"https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html\">MaybeUnit</a>, this simple solution segfaults:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">uninit</span><span class=\"p\">();</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">mem</span><span class=\"p\">::</span><span class=\"n\">transmute</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"p\">};</span>\n\n<span class=\"c1\">// ...</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">imports</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">()];</span>\n\n<span class=\"c1\">// segfaults below</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Instance</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">imports</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>Then I realized the issue is that there's no way for me transmute only the State, I need to transmute the Store which is not recommended, once rust <a href=\"https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html#layout-1\">doesn't guarantee the same memory layout</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>Actually I haven't find any way to use MaybeUnit that doesn't look hacky, and I want to avoid the usage of Option and unwraps in the code, once it bloats the binary with panic data.</p>\n<h4>Alternatives</h4>\n<ol>\n<li>Make the imported memory easily available inside Functions, ex: expose it in the Caller.</li>\n<li>Use <code>#[repr(C)]</code> on <code>Store</code>, so we can safely transmute it.<br>\n</li>\n</ol>\n</blockquote>",
        "id": 481064808,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730967149
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-2462576544\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>Where possible I'd recommend avoiding <code>unsafe</code>. If things are segfaulting it's probably due to that, so for example you could store <code>Option&lt;Memory&gt;</code> instead of using <code>MaybeUninit</code> and then there's no need for <code>transmute</code> and this probably won't segfault.</p>\n<p>Otherwise though is there a problem with storing the memory in <code>State</code>?</p>\n</blockquote>",
        "id": 481148931,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1730994472
    },
    {
        "content": "<p>Lohann <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-2466987241\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<blockquote>\n<p>Otherwise though is there a problem with storing the memory in State?</p>\n</blockquote>\n<p>There's no problem, is just there's no examples of that, and is not ergonomic as using exported memory, rust encourages the use of <a href=\"https://cliffle.com/blog/rust-typestate/\">Typestate Pattern</a>, where the state of an object guarantees it is valid. In this case I want to guarantee the memory ALWAYS exists, that's why I don't want to use Option.<br>\nOne example is the <a href=\"https://doc.rust-lang.org/std/num/type.NonZeroU32.html\">NonZeroU32</a> by knowing the number is never zero, the rust compiler can do some neat optimizations:</p>\n<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6778305b1980ec60413183a0a1127a4d\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6778305b1980ec60413183a0a1127a4d</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">);</span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">);</span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">NonZeroU32</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>In my case I want to guarantee the memory always exists, I don't want to handle the <code>Option::None</code> everywhere, neither use <code>unwrap()</code> everywhere, that's ok if there's no other option, but I think this is something that should be supported somehow by wasmtime, once the Store owns the memory, makes sense I be able to store it together with the store.</p>\n</blockquote>",
        "id": 481607315,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1731281592
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-2466987241\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<blockquote>\n<p>Otherwise though is there a problem with storing the memory in State?</p>\n</blockquote>\n<p>There's no problem, but rust encourages the use of <a href=\"https://cliffle.com/blog/rust-typestate/\">Typestate Pattern</a>, where the state of an object guarantees it is valid. In this case I want to guarantee the memory ALWAYS exists, that's why I don't want to use Option.<br>\nOne example is the <a href=\"https://doc.rust-lang.org/std/num/type.NonZeroU32.html\">NonZeroU32</a> by knowing the number is never zero, the rust compiler can do some neat optimizations:</p>\n<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6778305b1980ec60413183a0a1127a4d\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=6778305b1980ec60413183a0a1127a4d</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">);</span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">);</span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">NonZeroU32</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>In my case I want to guarantee the memory always exists, I don't want to handle the <code>Option::None</code> everywhere, neither use <code>unwrap()</code> everywhere, that's ok if there's no other option, but I think this is something that should be supported somehow by wasmtime, once the Store owns the memory, makes sense I be able to store it together with the store.</p>\n</blockquote>",
        "id": 481607891,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1731282077
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-2469585743\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>One thing you could perhaps do is to create a dummy <code>Memory</code> with a throwaway <code>Store</code> which is placed within future <code>Store</code>s as they're created. That would then be overwritten to the \"real\" memory once the store is created. That way you can store just <code>Memory</code> without having to deal with <code>Option</code> and you won't have to deal with any unsafety either.</p>\n</blockquote>",
        "id": 481863294,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1731386227
    },
    {
        "content": "<p>Lohann <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to handle imported memory inside imported functions.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that is IMPORTED to the WASM instance.</span>\n<span class=\"w\">    </span><span class=\"sd\">/// this MUST be here, otherwise you can't read it inside</span>\n<span class=\"w\">    </span><span class=\"sd\">/// imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory that owned by the `store` itself.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State` to be created, but memory also needs `Store` to be created</span>\n<span class=\"w\">        </span><span class=\"c1\">// and the `State` needs memory, so this is a ciclc dependency issue, to solve this by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// create the `State` using a dummy memory with `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized right below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory` that replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553540606,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762240465
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to handle imported memory inside imported functions.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that is IMPORTED to the WASM instance.</span>\n<span class=\"w\">    </span><span class=\"sd\">/// this MUST be here, otherwise you can't read it inside</span>\n<span class=\"w\">    </span><span class=\"sd\">/// imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory that owned by the `store` itself.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State` to be created, but memory also needs `Store` to be created</span>\n<span class=\"w\">        </span><span class=\"c1\">// and the `State` needs memory, so this is a ciclc dependency issue, to solve this by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// create the `State` using a dummy memory with `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory` that replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553540779,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762240565
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to handle imported memory inside imported functions.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that is IMPORTED to the WASM instance.</span>\n<span class=\"w\">    </span><span class=\"sd\">/// this MUST be here, otherwise you can't read it inside</span>\n<span class=\"w\">    </span><span class=\"sd\">/// imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory that owned by the `store` itself.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State` to be created, but memory also needs `Store` to be created</span>\n<span class=\"w\">        </span><span class=\"c1\">// and the `State` needs memory, so this is a ciclc dependency issue, solved this by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory` that replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553540894,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762240618
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to handle imported memory inside imported functions.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that will be IMPORTED to the WASM instance, it must be</span>\n<span class=\"w\">    </span><span class=\"sd\">/// created before instantiate the WASM, and must be stored here</span>\n<span class=\"w\">    </span><span class=\"sd\">/// otherwise you can't read this memory inside imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory that owned by the `store` itself.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State` to be created, but memory also needs `Store` to be created</span>\n<span class=\"w\">        </span><span class=\"c1\">// and the `State` needs memory, so this is a ciclc dependency issue, solved this by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory` that replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553541880,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762241106
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to handle imported memory inside imported functions.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that will be IMPORTED to the WASM instance, it must be</span>\n<span class=\"w\">    </span><span class=\"sd\">/// created before instantiate the WASM, and must be stored here</span>\n<span class=\"w\">    </span><span class=\"sd\">/// otherwise you can't read this memory inside imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory that owned by the `store` itself.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>\n<span class=\"w\">        </span><span class=\"c1\">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory`, then replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// Get the address of state's dummy memory.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"c1\">// replaces the  dummy memory by a valid memory</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553542368,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762241346
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to handle imported memory inside imported functions.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that will be IMPORTED to the WASM instance, it must be</span>\n<span class=\"w\">    </span><span class=\"sd\">/// created before instantiate the WASM, and must be stored here</span>\n<span class=\"w\">    </span><span class=\"sd\">/// otherwise you can't read this memory inside imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory that owned by the `store` itself.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>\n<span class=\"w\">        </span><span class=\"c1\">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// Get the address of state's dummy memory.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"c1\">// replaces the  dummy memory by a valid memory</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553542411,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762241367
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access imported memory without <code>Option</code> and unsafe code.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that will be IMPORTED to the WASM instance, it must be</span>\n<span class=\"w\">    </span><span class=\"sd\">/// created before instantiate the WASM, and must be stored here</span>\n<span class=\"w\">    </span><span class=\"sd\">/// otherwise you can't read this memory inside imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory that owned by the `store` itself.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>\n<span class=\"w\">        </span><span class=\"c1\">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// Get the address of state's dummy memory.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"c1\">// replaces the  dummy memory by a valid memory</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553542665,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762241488
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access imported memory without <code>Option</code> or unsafe code.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that will be IMPORTED to the WASM instance, it must be</span>\n<span class=\"w\">    </span><span class=\"sd\">/// created before instantiate the WASM, and must be stored here</span>\n<span class=\"w\">    </span><span class=\"sd\">/// otherwise you can't read this memory inside imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory that owned by the `store` itself.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>\n<span class=\"w\">        </span><span class=\"c1\">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// Get the address of state's dummy memory.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"c1\">// replaces the  dummy memory by a valid memory</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553542722,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762241515
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access <strong>imported memory</strong> like <strong>exported memory</strong>, without <code>Option</code> or unsafe code.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that will be IMPORTED to the WASM instance, it must be</span>\n<span class=\"w\">    </span><span class=\"sd\">/// created before instantiate the WASM, and must be stored here</span>\n<span class=\"w\">    </span><span class=\"sd\">/// otherwise you can't read this memory inside imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory that owned by the `store` itself.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>\n<span class=\"w\">        </span><span class=\"c1\">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// Get the address of state's dummy memory.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"c1\">// replaces the  dummy memory by a valid memory</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553542793,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762241537
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access <strong>imported memory</strong> like <strong>exported memory</strong>, without <code>Option</code> or unsafe code.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that will be IMPORTED to the WASM instance, then it must be</span>\n<span class=\"w\">    </span><span class=\"sd\">/// created before instantiate the WASM, and must be stored here otherwise</span>\n<span class=\"w\">    </span><span class=\"sd\">/// you can't access the memory inside WasmTime imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory that owned by the `store` itself.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>\n<span class=\"w\">        </span><span class=\"c1\">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// Get the address of state's dummy memory.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"c1\">// replaces the  dummy memory by a valid memory</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553542917,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762241598
    },
    {
        "content": "<p>Lohann edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<h4>Feature</h4>\n<p>Hello, I need to access the imported memory inside a functions, then I realized the <a href=\"https://docs.rs/wasmtime/38.0.3/wasmtime/struct.Caller.html\">Caller</a> only show exports, not imports, so I had a lot of trouble to get Wasmtime store working with <a href=\"https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html\">MaybeUnit</a>, this simple solution segfaults:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">uninit</span><span class=\"p\">();</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">mem</span><span class=\"p\">::</span><span class=\"n\">transmute</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"p\">};</span>\n\n<span class=\"c1\">// ...</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">imports</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">memory</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">()];</span>\n\n<span class=\"c1\">// segfaults below</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Instance</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">imports</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>Then I realized the issue is that there's no way for me transmute only the State, I need to transmute the Store which is not recommended, once rust <a href=\"https://doc.rust-lang.org/beta/std/mem/union.MaybeUninit.html#layout-1\">doesn't guarantee the same memory layout</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">size_of</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;&gt;&gt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>Actually I haven't find any way to use MaybeUnit that doesn't look hacky, and I want to avoid the usage of Option and unwraps in the code, once it bloats the binary with panic data.</p>\n<h4>Alternatives</h4>\n<ol>\n<li>Make the imported memory easily available inside Functions, ex: expose it in the Caller.</li>\n<li>Use <code>#[repr(C)]</code> on <code>Store</code>, so we can safely transmute it.<br>\n</li>\n</ol>\n</blockquote>",
        "id": 553543328,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762241782
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access <strong>imported memory</strong> without <code>Option</code> or <code>unsafe</code> code.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that will be IMPORTED to the WASM instance, then it must be</span>\n<span class=\"w\">    </span><span class=\"sd\">/// created before instantiate the WASM, and must be stored here otherwise</span>\n<span class=\"w\">    </span><span class=\"sd\">/// you can't access the memory inside WasmTime imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory that owned by the `store` itself.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>\n<span class=\"w\">        </span><span class=\"c1\">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// Get the address of state's dummy memory.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"c1\">// replaces the  dummy memory by a valid memory</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553543430,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762241834
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access <strong>imported memory</strong> without <code>Option</code> or <code>unsafe</code> code.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that will be IMPORTED to the WASM instance, then it must be</span>\n<span class=\"w\">    </span><span class=\"sd\">/// created before instantiate the WASM, and must be stored here otherwise</span>\n<span class=\"w\">    </span><span class=\"sd\">/// you can't access the memory inside WasmTime imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory owned by the `store`.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>\n<span class=\"w\">        </span><span class=\"c1\">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// Get the address of state's dummy memory.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"c1\">// replaces the  dummy memory by a valid memory</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553543568,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762241905
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3484207448\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p><strong>Update:</strong> I managed to store the imported memory in the <code>State</code> without <code>Option&lt;Memory&gt;</code> by using <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\">MaybeUninit</a>, the code is sound but requires two unsafe blocks.</p>\n<p>For me it worthy the price, better than having to handle <code>Option&lt;Memory&gt;</code> in every imported function. But I still would love to have a more ergonomic way to access <strong>imported memory</strong> without <code>Option</code> or <code>unsafe</code> code.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Memory that will be IMPORTED to the WASM instance, then it must be</span>\n<span class=\"w\">    </span><span class=\"sd\">/// created before instantiate the WASM, must be stored here otherwise</span>\n<span class=\"w\">    </span><span class=\"sd\">/// you can't access the memory inside WasmTime imported functions.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Initializes a Store with a memory owned by the `store`.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">Engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">MemoryType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">anyhow</span><span class=\"p\">::</span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// The `Store` needs `State`, the `State` needs `Memory`, but  `Memory` can only be</span>\n<span class=\"w\">        </span><span class=\"c1\">// created after `Store`, so we have a ciclc dependency issue. Solved this bellow by first</span>\n<span class=\"w\">        </span><span class=\"c1\">// initialize the `State` with a dummy memory using `MaybeUninit::zeroed().assume_init()`.</span>\n<span class=\"w\">        </span><span class=\"c1\">// References:</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://github.com/bytecodealliance/wasmtime/issues/4922#issuecomment-1251086171</span>\n<span class=\"w\">        </span><span class=\"c1\">// - https://doc.rust-lang.org/std/mem/union.MaybeUninit.html</span>\n<span class=\"w\">        </span><span class=\"cp\">#[allow(clippy::uninit_assumed_init)]</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: This `memory` will be correctly initialized after the `Store` below.</span>\n<span class=\"w\">            </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"n\">Memory</span><span class=\"o\">&gt;</span><span class=\"p\">::</span><span class=\"n\">zeroed</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">        </span><span class=\"p\">};</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Now use the `State` to create the `Store`.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">);</span>\n\n<span class=\"w\">        </span><span class=\"c1\">// Use the `Store` to create a valid `Memory` then replaces the dummy memory.</span>\n<span class=\"w\">        </span><span class=\"c1\">// Ref: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#initializing-a-struct-field-by-field</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"c1\">// Get the address of state's dummy memory.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span><span class=\"p\">::</span><span class=\"n\">ptr</span><span class=\"p\">::</span><span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">data_mut</span><span class=\"p\">().</span><span class=\"n\">memory</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"c1\">// replaces the  dummy memory by a valid memory</span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Before you ask, no, I can't simply export the memory like everyone else, because the wasm code is a <a href=\"https://github.com/use-ink/ink/tree/v5.1.1\">ink</a> smart-contract, and the memory is always imported.</p>\n</blockquote>",
        "id": 553543638,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762241937
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton\">alexcrichton</a> added the wasmtime:api label to <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">Issue #9579</a>.</p>",
        "id": 553634335,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1762267683
    },
    {
        "content": "<p>ZylosLumen <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567089352\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>Just ran into this issue and wanted to avoid <code>unsafe Option::unwrap_unchecked()</code> everywhere but it will have to do for now.<br>\nReally curious as importing the memory (or any other store-bound type) and also needing to access it from the host does not seem like a rare use case so having a low cost api would be really nice</p>\n</blockquote>",
        "id": 558846623,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763849614
    },
    {
        "content": "<p>Lohann <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it doesn't have lifetime and implements <code>Copy</code>), so one possible solutions is create the store and memory atomically, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<p>Then need to figure what type the <code>store_ref</code> will be.. it can't be <code>Store&lt;State&gt;</code>.</p>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558849439,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763853426
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it doesn't have lifetime and implements <code>Copy</code>), so one possible solutions is create the store and memory atomically, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<p>Then need to figure what type the <code>store_ref</code> will be.. it can't be <code>Store&lt;State&gt;</code>.</p>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558849571,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763853597
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it doesn't have lifetime and implements <code>Copy</code>), so one possible solutions is create the store and memory atomically, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<p>Then need to figure what type the <code>store_ref</code> will be.. it can't be <code>Store&lt;State&gt;</code>.</p>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">init_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: the memory was imported above</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558849703,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763853776
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so one possible solutions is create the store and memory atomically, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<p>Then need to figure what type the <code>store_ref</code> will be.. it can't be <code>Store&lt;State&gt;</code>.</p>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">init_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: the memory was imported above</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558849735,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763853795
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<p>Then need to figure what type the <code>store_ref</code> will be.. it can't be <code>Store&lt;State&gt;</code>.</p>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">init_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: the memory was imported above</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558849782,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763853855
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<p>Maybe <code>store_ref</code> can be another type that creates the memory instead being a reference to a dummy store.</p>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">init_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: the memory was imported above</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558849828,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763853940
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<p>Or maybe <code>store_ref</code> can be another type able to create the memory without expose the store:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">lazy_init</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">LazyLinker</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">lazy_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"p\">})</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">init_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: the memory was imported above</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558850196,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763854440
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<p>Or maybe instead <code>Store&lt;()&gt;</code>, we provide some way to create the memory without expose the store:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">lazy_init</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">LazyLinker</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">lazy_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"p\">})</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">init_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: the memory was imported above</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558850306,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763854542
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, or create the Store last, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<p>Or maybe instead <code>Store&lt;()&gt;</code>, we provide some way to create the memory without expose the store:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">lazy_init</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">LazyLinker</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">lazy_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"p\">})</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">init_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: the memory was imported above</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558850404,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763854664
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, or create the Store last, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">MaybeUnit</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// obs: in method requires `State` to implement Unpin, this prevents State from reference Store.</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<p>Or maybe instead <code>Store&lt;()&gt;</code>, we provide some way to create the memory without expose the store:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">lazy_init</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">LazyLinker</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"p\">})</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">init_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: the memory was imported above</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558851523,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763856193
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, or create the Store last, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">MaybeUnit</span><span class=\"o\">&lt;</span><span class=\"n\">State</span><span class=\"o\">&gt;&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// obs: in method requires `State` to implement Unpin, this prevents State from reference Store.</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">init_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: the memory was imported above</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558852022,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763856760
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, or create the Store last, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">Opaque</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// obs: in method requires `State` to implement Unpin, this prevents State from reference Store.</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">init_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: the memory was imported above</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558852098,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763856847
    },
    {
        "content": "<p>Lohann edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3567136088\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>@alexcrichton <br>\nI noticed <a href=\"https://docs.rs/wasmtime/latest/wasmtime/struct.Memory.html\">Memory</a> is simple a identifier,  it doesn't have the actual buffer, (that's why it implements <code>Copy</code>), so a possible solution is create both the state and memory atomically, or create the Store last, ex:</p>\n<h2>Proposal 1 - <code>Store::new_with</code></h2>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"p\">::</span><span class=\"n\">new_with</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">store_ref</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Store</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;|</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\">  </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"c1\">// obs: in method requires `State` to implement Unpin, this prevents State from reference Store.</span>\n<span class=\"w\">    </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">store_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">});</span>\n</code></pre></div>\n<h2>Proposal 2 - <code>StoreBuilder</code></h2>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">Memory</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MemoryType</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">):</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">StoreBuilder</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_memory</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memory_type</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">with_func</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"add\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">init_state</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">linker</span><span class=\"o\">|</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: the memory was imported above</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s\">\"env\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"memory\"</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"n\">State</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">memory</span><span class=\"w\"> </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">})</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">build</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">linker</span><span class=\"p\">.</span><span class=\"n\">instantiate</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">module</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 558852119,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1763856880
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579#issuecomment-3571696118\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/9579\">issue #9579</a>:</p>\n<blockquote>\n<p>Personally I would recommend having a <code>memory()</code> function as opposed a <code>memory.unwrap()</code> field access for ergonomics. I'll also note that <code>unsafe { MaybeUninit::&lt;Memory&gt;::zeroed().assume_init() }</code> is immediate undefined behavior. <code>Memory</code> has a <code>NonZeroU64</code> inside of it which this is explicitly setting to zero. Whether or not that actually causes a problem is entirely up to LLVM which is highly likely to change over time. </p>\n<p>I would recommend measuring the overhead of doing <code>.unwrap()</code> before doing anything <code>unsafe</code> w.r.t. this issue. It is an incredibly high bar to clear, in my opinion, to save a few instructions while adding <code>unsafe</code> code.</p>\n<p>In terms of \"solving\" this issue, personally I feel at this time that it's pretty unlikely. The APIs you're sketching out @Lohann for example are not possible to implement in a sound fashion. Once a <code>Store&lt;T&gt;</code> is presented, for example, then instances can be created which can execute wasm which can execute imports which expect functions to be there. The validity of this pattern requires the inability to invoke imported functions (or access <code>T</code> in general) before the <code>T</code> is fully filled in. That's, in general, a dynamic property of the embedding in question rather than one we can bake into the type system of Wasmtime.</p>\n</blockquote>",
        "id": 559095279,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1764001984
    }
]