[
    {
        "content": "<p>khagankhan opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577\">PR #12577</a> from <code>khagankhan:struct-subtypes</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<h1>Add support for struct subtyping</h1>\n<p>This PR adds support for one struct type being a subtype of another.</p>\n<h2>Changes</h2>\n<ul>\n<li><code>SubType</code> now has:<ul>\n<li><code>supertype: Option&lt;TypeId&gt;</code></li>\n<li><code>is_final: bool</code></li>\n</ul>\n</li>\n<li>Mutators may:<ul>\n<li>Randomly assign an existing struct as supertype</li>\n<li>Mark a type as <code>final</code> with 1/4 probability</li>\n</ul>\n</li>\n</ul>\n<h2>Cycle Handling</h2>\n<ul>\n<li><code>Types::merge_rec_groups_via_scc(...)</code>:<ul>\n<li>Finds cycles across rec-groups and merges them.</li>\n</ul>\n</li>\n<li><code>Types::break_type_cycles_in_rec_groups(...)</code>:<ul>\n<li>Breaks cycles within a rec-group by clearing <code>supertype</code>.</li>\n</ul>\n</li>\n</ul>\n<h2>Ordering</h2>\n<ul>\n<li>Rec-groups are topologically sorted using Kahn topo-sort.</li>\n<li>Types are sorted via DFS (<code>Enter</code>/<code>Exit</code> enum) so supertypes come before subtypes.</li>\n</ul>\n<h2>Fixups</h2>\n<p>Handled in <code>Types::fixup</code>:</p>\n<ul>\n<li>If a subtype references a <code>final</code> supertype its supertype becomes <code>None</code></li>\n<li>If a supertype is removed, its subtypes has no supertype anyome (becomes <code>None</code>)</li>\n</ul>\n<h2>Mutator Update</h2>\n<ul>\n<li><code>duplicate_rec_group</code> now actually  duplicates.</li>\n</ul>\n<p>New tests added.</p>\n<p>cc @fitzgen @eeide</p>\n</blockquote>",
        "id": 573432529,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770870259
    },
    {
        "content": "<p><strong>khagankhan</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-fuzz-reviewers\">wasmtime-fuzz-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577\">PR #12577</a>.</p>",
        "id": 573432530,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770870259
    },
    {
        "content": "<p><strong>khagankhan</strong> requested <a href=\"https://github.com/fitzgen\">fitzgen</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577\">PR #12577</a>.</p>",
        "id": 573432531,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770870259
    },
    {
        "content": "<p>khagankhan updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577\">PR #12577</a>.</p>",
        "id": 573434672,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770871691
    },
    {
        "content": "<p>github-actions[bot] added the label <code>fuzzing</code> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577\">PR #12577</a>.</p>",
        "id": 573441104,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770876243
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577#issuecomment-3889037723\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577\">PR #12577</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"fuzzing\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: fuzzing</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 573447474,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770879865
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577#discussion_r2801131110\">PR review comment</a>:</p>\n<blockquote>\n<p>The DFS should handle this special case in a general way already, right? I think we can remove this.</p>\n</blockquote>",
        "id": 573627361,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770934422
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577#discussion_r2801297284\">PR review comment</a>:</p>\n<blockquote>\n<p>Ah okay, great. Yeah we should make this DFS code generic and reuse in our various places where we need to do a DFS.</p>\n</blockquote>",
        "id": 573627362,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770934422
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577#discussion_r2801243915\">PR review comment</a>:</p>\n<blockquote>\n<p>Allocating these things within this double-nested loop is going to thrash the allocator and be quite slow. I think this DFS could be refactored to be more sympathatic to the machine and look something like this:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// A map from `TypeId` to the DFS index when we started traversing that type.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">dfs_pre_index</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">BTreeMap</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">();</span>\n\n<span class=\"c1\">// A map from `TypeId` to the DFS index when we finished traversing that type.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">dfs_post_index</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">BTreeMap</span><span class=\"p\">::</span><span class=\"n\">new</span><span class=\"p\">();</span>\n\n<span class=\"k\">enum</span><span class=\"w\"> </span><span class=\"nc\">DfsEvent</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">Enter</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Exit</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">DfsEvent</span><span class=\"p\">::</span><span class=\"o\">*</span><span class=\"p\">;</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">all_type_ids</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"c1\">// new method that returns `impl Iterator&lt;Item = TypeId&gt;`</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">ty</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Enter</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">))</span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">collect</span><span class=\"p\">::</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">();</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"k\">while</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">((</span><span class=\"n\">event</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"p\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">event</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">Enter</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">dfs_pre_index</span><span class=\"p\">.</span><span class=\"n\">entry</span><span class=\"p\">(</span><span class=\"n\">ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">Entry</span><span class=\"p\">::</span><span class=\"n\">Occupied</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{},</span>\n<span class=\"w\">            </span><span class=\"n\">Entry</span><span class=\"p\">::</span><span class=\"n\">Vacant</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                </span><span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">);</span>\n<span class=\"w\">                </span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"w\">                </span><span class=\"n\">stack</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">((</span><span class=\"n\">Exit</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">));</span>\n\n<span class=\"w\">                </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">sup_ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">type_defs</span><span class=\"p\">[</span><span class=\"n\">ty</span><span class=\"p\">].</span><span class=\"n\">supertype</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">dfs_pre_index</span><span class=\"p\">.</span><span class=\"n\">contains_key</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">sup_ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">dfs_post_index</span><span class=\"p\">.</span><span class=\"n\">contains_key</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">sup_ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                        </span><span class=\"c1\">// Cyclic subtyping! Break the cycle.</span>\n<span class=\"w\">                        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">type_defs</span><span class=\"p\">[</span><span class=\"n\">ty</span><span class=\"p\">].</span><span class=\"n\">supertype</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">;</span>\n<span class=\"w\">                    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                        </span><span class=\"n\">stack</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">((</span><span class=\"n\">Event</span><span class=\"p\">::</span><span class=\"n\">Enter</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">sup_ty</span><span class=\"p\">));</span>\n<span class=\"w\">                    </span><span class=\"p\">}</span>\n<span class=\"w\">                </span><span class=\"p\">}</span>\n<span class=\"w\">            </span><span class=\"p\">}</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">        </span><span class=\"n\">Exit</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">old</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dfs_post_index</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">ty</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"fm\">debug_assert!</span><span class=\"p\">(</span><span class=\"n\">old</span><span class=\"p\">.</span><span class=\"n\">is_none</span><span class=\"p\">());</span>\n<span class=\"w\">            </span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><br>\n</p>\n</blockquote>",
        "id": 573627363,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770934422
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577#discussion_r2801256209\">PR review comment</a>:</p>\n<blockquote>\n<p>It occurs to me that we don't actually even need SCCs yet, since subtyping doesn't care about rec group boundaries so long as the supertype is defined before the subtype. So I think we can delay all this stuff until we actually have struct fields (or array elements). This is nice because it means that support for subtyping will be able to land before we make the existing SCC algorithm reusable and all that.</p>\n</blockquote>",
        "id": 573627364,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770934423
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577#discussion_r2801304578\">PR review comment</a>:</p>\n<blockquote>\n<p>I already talked about how we can remove the SCC stuff in this PR, but for the future: this method should sort in place, rather than allocating and returning a new vector.</p>\n</blockquote>",
        "id": 573627365,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770934423
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577#discussion_r2801111984\">PR review comment</a>:</p>\n<blockquote>\n<p>I think we will want to move our existing SCC implementation somewhere that it can be reused so that we don't have forks of the same code in the same tree.</p>\n<p>I can do this and let you know when to rebase.</p>\n</blockquote>",
        "id": 573627366,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770934423
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577#discussion_r2801157167\">PR review comment</a>:</p>\n<blockquote>\n<p>I don't think we should need to think about rec groups at all while breaking supertype cycles. The only constraint on a type's supertype is that the supertype is already defined at the point of the type's definition.</p>\n<p>After breaking cycles, it should be sufficient to reorder types within a rec group as necessary, as a follow up fixup pass.</p>\n<p>I bring this up because we don't want to, for example, artificially disallow a type subtyping another type defined earlier in its rec group. (We should have a test that defines a rec group of two types, where the first is the supertype of the second, and then calls <code>fixup</code> and make sure that the subtyping is preserved.)</p>\n</blockquote>",
        "id": 573627367,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770934423
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577#pullrequestreview-3793731662\">PR review</a>:</p>\n<blockquote>\n<p>Thanks! Feedback inline below.</p>\n</blockquote>",
        "id": 573627369,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770934423
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577#discussion_r2801291316\">PR review comment</a>:</p>\n<blockquote>\n<p>And we should probably make generic and reuse the DFS code from my last comment to do this topo sorting as well (although rec groups form a DAG, not a tree, but I think the code should work just fine for this case, perhaps with some minimal tweaks, as well).</p>\n</blockquote>",
        "id": 573627371,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770934423
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577#issuecomment-3899502469\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12577\">PR #12577</a>:</p>\n<blockquote>\n<p>@khagankhan I just put a PR to make Wasmtime's existing SCC computation and DFS traversal stuff reusable, and I think this PR can be rebased on top of it: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12590\">https://github.com/bytecodealliance/wasmtime/pull/12590</a></p>\n</blockquote>",
        "id": 573828894,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771017200
    }
]