[
    {
        "content": "<p>espoal opened <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12598\">issue #12598</a>:</p>\n<blockquote>\n<p>I will start to admit that I'm a noob in the compiler topics, so I'm probably misunderstanding something fundamental.</p>\n<p><strong>Goal:</strong> I would like to implement a custom target using cranelift, which is a virtual machine very similar to WASM. Let's say for now that the source is Rust code.</p>\n<p><strong>My understanding:</strong> I think that to achieve this I would need to implement a custom backend / codegen module, while reusing the existing Rust frontend. I believe that the Rust-to-WASM pipeline is implemented this way, but <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2566\">this issue</a> seems to contradict what I know.</p>\n<p><strong>Questions:</strong> </p>\n<ul>\n<li>Is my understanding right? If not, how is the Rust-to-WASM pipeline implemented?</li>\n<li>Are there better/simpler approaches?</li>\n<li>Where could I find some resources on implementing a custom target/backend? Or is this very novel territory that is not yet covered by tutorials?</li>\n</ul>\n</blockquote>",
        "id": 573975222,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771160872
    },
    {
        "content": "<p>espoal edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12598\">issue #12598</a>:</p>\n<blockquote>\n<p>I will start to admit that I'm a noob in the compiler topic, so I'm probably misunderstanding something fundamental.</p>\n<p><strong>Goal:</strong> I would like to implement a custom target using cranelift, which is a virtual machine very similar to WASM. Let's say for now that the source is Rust code.</p>\n<p><strong>My understanding:</strong> I think that to achieve this I would need to implement a custom backend / codegen module, while reusing the existing Rust frontend. I believe that the Rust-to-WASM pipeline is implemented this way, but <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2566\">this issue</a> seems to contradict what I know.</p>\n<p><strong>Questions:</strong> </p>\n<ul>\n<li>Is my understanding right? If not, how is the Rust-to-WASM pipeline implemented?</li>\n<li>Are there better/simpler approaches?</li>\n<li>Where could I find some resources on implementing a custom target/backend? Or is this very novel territory that is not yet covered by tutorials?</li>\n</ul>\n</blockquote>",
        "id": 573975239,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771160884
    },
    {
        "content": "<p>espoal edited <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12598\">issue #12598</a>:</p>\n<blockquote>\n<p>I will start to admit that I'm a noob in the compiler topic, so I'm probably misunderstanding something fundamental.</p>\n<p><strong>Goal:</strong> I would like to implement a custom target using cranelift, which is a virtual machine very similar to WASM. Let's say for now that the source is Rust code.</p>\n<p><strong>My understanding:</strong> I think that to achieve this I would need to implement a custom backend / codegen module, while reusing the existing Rust frontend. I believe that the Rust-to-WASM pipeline is implemented this way, but <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2566\">this issue</a> seems to contradict what I know.</p>\n<p><strong>Questions:</strong> </p>\n<ul>\n<li>Is my understanding right? If not, how is the Rust-to-WASM pipeline implemented?</li>\n<li>Are there better/simpler approaches?</li>\n<li>Where could I find some resources on implementing a custom target/backend? Or is this very novel territory that is not yet covered by tutorials?</li>\n</ul>\n<p>Thank you!</p>\n</blockquote>",
        "id": 573975254,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771160901
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12598#issuecomment-3904434891\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12598\">issue #12598</a>:</p>\n<blockquote>\n<p>Rustc uses LLVM for compiling to wasm. No Cranelift or Wasmtime is involved with that at all. Only compiling the wasm to machine code uses Cranelift as compiler when using Wasmtime as wasm runtime. There is also rustc_codegen_cranelift for directly compiling rust code with Cranelift, but that doesn't allow producing wasm, rather it directly produces machine code. Only wasm -&gt; cranelift ir is supported through Wasmtime, not cranelift ir -&gt; wasm. Wasm is different enough from machine code that you can't reuse Cranelift backend framework at all. Cranelift expects to compile to a register machine (like almost all real hardware), while wasm is a stack machine.</p>\n</blockquote>",
        "id": 573975963,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771161534
    },
    {
        "content": "<p>espoal <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12598#issuecomment-3904475832\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12598\">issue #12598</a>:</p>\n<blockquote>\n<p>Thanks @bjorn3 for the explanation. So from what I understood:</p>\n<ul>\n<li>Rust get compiled to WASM bytecode using the LLVM backend</li>\n<li>The WASM file is then distributed </li>\n<li>To execute it, wasmtime uses cranelift to lower it to actual machine code</li>\n<li>Lowering can be done either JIT, or AOT</li>\n</ul>\n<p>Makes sense now. </p>\n</blockquote>",
        "id": 573977205,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771162612
    },
    {
        "content": "<p>espoal edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12598#issuecomment-3904475832\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12598\">issue #12598</a>:</p>\n<blockquote>\n<p>Thanks @bjorn3 for the explanation. So from what I understood:</p>\n<ul>\n<li>Rust get compiled to WASM bytecode using the LLVM backend</li>\n<li>The WASM file is then distributed </li>\n<li>To execute it, wasmtime uses cranelift to lower it to actual machine code</li>\n<li>Lowering can be done either JIT, or AOT</li>\n</ul>\n<p>Makes sense now. If that's correct please answer with a thumb up, and I will consider this issue closed.</p>\n</blockquote>",
        "id": 573977232,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771162636
    },
    {
        "content": "<p>espoal edited a <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12598#issuecomment-3904475832\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12598\">issue #12598</a>:</p>\n<blockquote>\n<p>Thanks @bjorn3 for the explanation. So from what I understood:</p>\n<ul>\n<li>Rust get compiled to WASM bytecode using the LLVM backend</li>\n<li>The WASM file is then distributed </li>\n<li>To execute it, wasmtime uses cranelift to lower it to actual machine code</li>\n<li>Lowering can be done either JIT, or AOT</li>\n</ul>\n<p>Makes sense now. If that's correct please react with a thumb up, and I will consider this issue closed.</p>\n</blockquote>",
        "id": 573977526,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771162834
    },
    {
        "content": "<p>espoal closed <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12598\">issue #12598</a>:</p>\n<blockquote>\n<p>I will start to admit that I'm a noob in the compiler topic, so I'm probably misunderstanding something fundamental.</p>\n<p><strong>Goal:</strong> I would like to implement a custom target using cranelift, which is a virtual machine very similar to WASM. Let's say for now that the source is Rust code.</p>\n<p><strong>My understanding:</strong> I think that to achieve this I would need to implement a custom backend / codegen module, while reusing the existing Rust frontend. I believe that the Rust-to-WASM pipeline is implemented this way, but <a href=\"https://github.com/bytecodealliance/wasmtime/issues/2566\">this issue</a> seems to contradict what I know.</p>\n<p><strong>Questions:</strong> </p>\n<ul>\n<li>Is my understanding right? If not, how is the Rust-to-WASM pipeline implemented?</li>\n<li>Are there better/simpler approaches?</li>\n<li>Where could I find some resources on implementing a custom target/backend? Or is this very novel territory that is not yet covered by tutorials?</li>\n</ul>\n<p>Thank you!</p>\n</blockquote>",
        "id": 573977942,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1771163174
    }
]