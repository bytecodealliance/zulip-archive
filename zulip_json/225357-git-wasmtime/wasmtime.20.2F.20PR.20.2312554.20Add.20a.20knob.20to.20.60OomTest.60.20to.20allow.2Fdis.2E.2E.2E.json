[
    {
        "content": "<p><strong>fitzgen</strong> requested <a href=\"https://github.com/alexcrichton\">alexcrichton</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554</a>.</p>",
        "id": 572907795,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770679706
    },
    {
        "content": "<p><strong>fitzgen</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-fuzz-reviewers\">wasmtime-fuzz-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554</a>.</p>",
        "id": 572907796,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770679706
    },
    {
        "content": "<p>fitzgen opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554</a> from <code>fitzgen:oom-test-knob-alloc-after-oom</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>&lt;!--<br>\nPlease make sure you include the following information:</p>\n<ul>\n<li>\n<p>If this work has been discussed elsewhere, please include a link to that<br>\n  conversation. If it was discussed in an issue, just mention \"issue #...\".</p>\n</li>\n<li>\n<p>Explain why this change is needed. If the details are in an issue already,<br>\n  this can be brief.</p>\n</li>\n</ul>\n<p>Our development process is documented in the Wasmtime book:<br>\n<a href=\"https://docs.wasmtime.dev/contributing-development-process.html\">https://docs.wasmtime.dev/contributing-development-process.html</a></p>\n<p>Please ensure all communication follows the code of conduct:<br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md\">https://github.com/bytecodealliance/wasmtime/blob/main/CODE_OF_CONDUCT.md</a><br>\n--&gt;</p>\n</blockquote>",
        "id": 572907797,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770679706
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554#pullrequestreview-3776029891\">PR review</a>:</p>\n<blockquote>\n<p>I know we discussed this <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12070#discussion_r2551147037\">briefly before</a>, but looking back I'm still not sure what the best thing to do here is. It's easy to reason about the previous behavior, but with this current behavior technically what we need to do is to basically re-run \"OOM at the finger\" behavior after the original OOM.</p>\n<p>For example we in theory need to explore the tree-like behavior where, after an OOM, every future allocation can either OOM or succeed. This PR takes the everything-always-fails route which might not explore as much code as something-failed-then-succeeded-then-failed-again or something like that.</p>\n<p>My initial gut was that allocations should succeed after the first OOm. My second gut was that we should go with your original hunch of strictly enforcing no allocations after OOM. My third gut then got confused the more I thought about this...</p>\n<p>What do you think about this? We could probably hook something up to fuzzing eventually do pseudo-randomly make allocations fail, but that wouldn't work well in the current infrastructure since it's already exhaustively exploring most state spaces. I'm not sure it's worth it to exhaustively explore this state space necessarily either.</p>\n<p>Out of curiosity what was the context this came up in? I'm curious to calibrate my thinking about this problem in general</p>\n</blockquote>",
        "id": 572912121,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770681773
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554#discussion_r2785109906\">PR review comment</a>:</p>\n<blockquote>\n<p>I think this is preexisting as well, but I believe that this, existing tests using <code>alloc</code>, and below, are all leaking memory.</p>\n</blockquote>",
        "id": 572912124,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770681773
    },
    {
        "content": "<p>github-actions[bot] added the label <code>fuzzing</code> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554</a>.</p>",
        "id": 572942035,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770698174
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554#issuecomment-3875271607\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554</a>:</p>\n<blockquote>\n<h4>Subscribe to Label Action</h4>\n<p>cc @fitzgen</p>\n<p>&lt;details&gt;<br>\nThis issue or pull request has been labeled: \"fuzzing\"</p>\n<p>Thus the following users have been cc'd because of the following labels:</p>\n<ul>\n<li>fitzgen: fuzzing</li>\n</ul>\n<p>To subscribe or unsubscribe from this label, edit the &lt;code&gt;.github/subscribe-to-label.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/subscribe-to-label-action\">Learn more.</a><br>\n&lt;/details&gt;</p>\n</blockquote>",
        "id": 572942150,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770698232
    },
    {
        "content": "<p>fitzgen submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554#pullrequestreview-3780229495\">PR review</a>.</p>",
        "id": 573092016,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770741543
    },
    {
        "content": "<p>fitzgen created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554#discussion_r2789061497\">PR review comment</a>:</p>\n<blockquote>\n<p>D'oh :facepalm: </p>\n</blockquote>",
        "id": 573092018,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770741543
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554#issuecomment-3879382495\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554</a>:</p>\n<blockquote>\n<blockquote>\n<p>I know we discussed this <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12070#discussion_r2551147037\">briefly before</a>, but looking back I'm still not sure what the best thing to do here is. It's easy to reason about the previous behavior, but with this current behavior technically what we need to do is to basically re-run \"OOM at the finger\" behavior after the original OOM.</p>\n<p>For example we in theory need to explore the tree-like behavior where, after an OOM, every future allocation can either OOM or succeed. This PR takes the everything-always-fails route which might not explore as much code as something-failed-then-succeeded-then-failed-again or something like that.</p>\n<p>My initial gut was that allocations should succeed after the first OOm. My second gut was that we should go with your original hunch of strictly enforcing no allocations after OOM. My third gut then got confused the more I thought about this...</p>\n</blockquote>\n<p>We can add another knob to control whether allocations succeed or fail after the first OOM, if we ever need to tweak the behavior.</p>\n<blockquote>\n<p>What do you think about this? We could probably hook something up to fuzzing eventually do pseudo-randomly make allocations fail, but that wouldn't work well in the current infrastructure since it's already exhaustively exploring most state spaces. I'm not sure it's worth it to exhaustively explore this state space necessarily either.</p>\n</blockquote>\n<p>Yeah, there is no way we can exhaustively explore the space as we start testing more and more complicated code paths.</p>\n<p>We will want to start having the fuzzer drive OOM tests.</p>\n<blockquote>\n<p>Out of curiosity what was the context this came up in? I'm curious to calibrate my thinking about this problem in general</p>\n</blockquote>\n<p>It is a pretty simple scenario where I'm not too concerned with actually exploring/exercising the post-OOM allocation behavior, so hopefully this will alleviate some of your concerns here (which are all valid, but also not a bridge we have to cross yet really, IMO):</p>\n<ul>\n<li>When implementing custom serialization/deserialization for our OOM-handling collections, when we encounter OOM during deserialization, we return a an error via the <a href=\"https://docs.rs/serde/1.0.228/serde/de/trait.Error.html#tymethod.custom\"><code>serde::de::Error::custom(oom)</code></a> static trait method</li>\n<li>Each serde format library (<code>serde_json</code>, <code>postcard</code>, etc...) will typically have its own concrete error type that implements that <code>serde::de::Error</code> trait. In the specific case I am hitting now, this means deserialization returns a <a href=\"https://docs.rs/postcard/latest/postcard/enum.Error.html\"><code>postcard::Error</code></a>, and specifically the <code>SerdeDeCustom</code> variant of that error. That error does <em>not</em> keep around the original OOM error.</li>\n<li>Therefore, our call into <code>postcard::deserialize</code> will return an error <em>that we no longer know is an OOM</em> and <code>wasmtime::Error::from(postcard::Error)</code> will attempt to box the postcard error into its internal thin-pointer <code>dyn Error</code> trait object, which will trigger the alloc-after-OOM detector in our OOM test harness.</li>\n</ul>\n<p>So this knob is being used just to say \"yes, we attempt to make an allocation after OOM in this specific case, but it is ultimately nothing to worry about and the situation is out of our hands.\"</p>\n<hr>\n<p>Aside: yes, it is too bad that we lose the original OOM error and its size-of-failed-alloc info here, but I don't think it is <em>too</em> bad. If, in the future, we really want to avoid losing it, we could perhaps make our own deserialization trait that provides a side-channel for OOM errors and somehow also adapts to <code>serde::de::Deserialize</code>. Would need to think a bit more to flesh this out. Also don't think we need it urgently at this time, more important is just getting stuff working in the face of OOM at all.</p>\n</blockquote>",
        "id": 573097786,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770742776
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554#pullrequestreview-3780450342\">PR review</a>:</p>\n<blockquote>\n<p>Ok yeah thanks for explaining, and definitely makes sense. I'd agree there's not much we can do about <code>postcard</code> discarding the custom error we pass in, nor anything we can do about recovering the precise error afterwards. That's pretty minor and I'm not too worried about it though, so I think it's reasonable to land this as-is (perhaps modulo the memory leaks)</p>\n<p>I also think there's no need to fully flesh out the fuzzing just yet, the fuzzing parts are going to be more interesting when there's a more full-featured thing to run which hits OOM occasionally, and that'll happen later.</p>\n<hr>\n<p>Also I was curious why ASAN in CI didn't catch the memory leak, because it should. Turns out we exclude <code>wasmtime-fuzzing</code> from <code>./ci/run-tests.py</code> specifically and that's because <code>--all-features</code> would require OCaml which we don't want to deal with.  The dedicated job to running these tests doesn't run with ASAN</p>\n</blockquote>",
        "id": 573103907,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770744109
    },
    {
        "content": "<p>fitzgen updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554</a>.</p>",
        "id": 573135183,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770752831
    },
    {
        "content": "<p>fitzgen has enabled auto merge for <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554</a>.</p>",
        "id": 573135216,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770752838
    },
    {
        "content": "<p>fitzgen added <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554 Add a knob to <code>OomTest</code> to allow/disallow allocation after OOM injection</a> to the merge queue.</p>",
        "id": 573138185,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770753650
    },
    {
        "content": "<p>github-merge-queue[bot] removed <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554 Add a knob to <code>OomTest</code> to allow/disallow allocation after OOM injection</a> from the merge queue.</p>",
        "id": 573145054,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770755843
    },
    {
        "content": "<p>fitzgen added <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554 Add a knob to <code>OomTest</code> to allow/disallow allocation after OOM injection</a> to the merge queue.</p>",
        "id": 573145504,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770755993
    },
    {
        "content": "<p>fitzgen <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554#issuecomment-3880591636\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554</a>:</p>\n<blockquote>\n<p>Re-enqueuing, network ghosts.</p>\n</blockquote>",
        "id": 573145540,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770756004
    },
    {
        "content": "<p>fitzgen merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554</a>.</p>",
        "id": 573152310,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770758456
    },
    {
        "content": "<p>fitzgen removed <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12554\">PR #12554 Add a knob to <code>OomTest</code> to allow/disallow allocation after OOM injection</a> from the merge queue.</p>",
        "id": 573152314,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1770758456
    }
]