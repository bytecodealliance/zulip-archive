[
    {
        "content": "<p>alexcrichton opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a> from <code>alexcrichton:trampoline-try-call</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>Since Wasmtime's inception it's used the <code>setjmp</code> and <code>longjmp</code><br>\nfunctions in C to implement handling of traps. While this solution was<br>\neasy to implement, relatively portable, and performant enough, there are<br>\na number of downsides that have evolved over time to make this an<br>\nunattractive approach in the long run:</p>\n<ul>\n<li>\n<p>Using <code>setjmp</code> fundamentally requires using C because Rust does not<br>\n  understand a function that returns twice. It's fundamentally unsound<br>\n  to invoke <code>setjmp</code> in Rust meaning that Wasmtime has forever needed a<br>\n  C compiler configured and set up to build. This notably means that<br>\n<code>cargo check</code> cannot check other targets easily.</p>\n</li>\n<li>\n<p>Using <code>longjmp</code> means that Rust function frames are unwound on the<br>\n  stack without running destructors. This is a dangerous operation of<br>\n  which we get no protection from the compiler about. Both frames<br>\n  entering wasm and frames exiting wasm are all skipped. Absolutely<br>\n  minimizing this has been beneficial for portability to platforms such<br>\n  as Pulley.</p>\n</li>\n<li>\n<p>Currently the no_std implementation of Wasmtime requires embedders to<br>\n  provide <code>wasmtime_{setjmp,longjmp}</code> which is a thorn in the side of<br>\n  what is otherwise a mostly entirely independent implementation of<br>\n  Wasmtime.</p>\n</li>\n<li>\n<p>There is a performance floor to using <code>setjmp</code> and <code>longjmp</code>. Calling<br>\n<code>setjmp</code> requires using C but Wasmtime is otherwise written in Rust<br>\n  meaning that there's a Rust-&gt;C-&gt;Rust-&gt;Wasm boundary which<br>\n  fundamentally can't be inlined without cross-language LTO which is<br>\n  difficult to configure.</p>\n</li>\n<li>\n<p>With the implementation of the WebAssembly exceptions proposal<br>\n  Wasmtime now has two means of unwinding the stack. Ideally Wasmtime<br>\n  would only have one, and the more general one is the method of<br>\n  exceptions.</p>\n</li>\n<li>\n<p>Jumping out of a signal handler on Unix is tricky business. While<br>\n  we've made it work it's generally most robust of the signal handler<br>\n  simply returns which it now does.</p>\n</li>\n</ul>\n<p>With all of that in mind the purpose of this commit is to replace the<br>\nsetjmp/longjmp mechanism of handling traps with the recently implemented<br>\nsupport for exceptions in Cranelift. That is intended to resolve all of<br>\nthe above points in one swoop.</p>\n<p>One point in particular though that's nice about setjmp/longjmp is that<br>\nunwinding the stack on a trap is an O(1) operation. For situations such<br>\nas stack overflow that's a particularly nice property to have as we can<br>\nguarantee embedders that traps are a constant time (albeit somewhat<br>\nexpensive with signals) operation. Exceptions naively require unwinding<br>\nthe entire stack, and although frame pointers mean we're just traversing<br>\na linked list I wanted to preserve the O(1) property here nonetheless.<br>\nTo achieve this a solution is implemented where the array-to-wasm<br>\n(host-to-wasm) trampolines setup state in <code>VMStoreContext</code> so looking up<br>\nthe current trap handler frame is an O(1) operation. Namely the sp/fp/pc<br>\nvalues for a <code>Handler</code> are stored inline.</p>\n<p>Implementing this feature required supporting<br>\nrelocations-to-offsets-in-functions which was not previously supported<br>\nby Wasmtime. This required Cranelift refactorings such as <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11570\">https://github.com/bytecodealliance/wasmtime/pull/11570</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11585\">https://github.com/bytecodealliance/wasmtime/pull/11585</a>,<br>\nand <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11576\">https://github.com/bytecodealliance/wasmtime/pull/11576</a>. This then additionally required some more refactoring in<br>\nthis commit which was difficult to split out as it otherwise wouldn't be<br>\ntested.</p>\n<p>Apart from the relocation-related business much of this change is about<br>\nupdating the platform signal handlers to use exceptions instead of<br>\nlongjmp to return. For example on Unix this means updating the<br>\n<code>ucontext_t</code> with register values that the handler specifies. Windows<br>\ninvolves updating similar contexts, and macOS mach ports ended up not<br>\nneeding too many changes.</p>\n<p>In terms of overall performance the relevant benchmark from this<br>\nrepository, compared to before this commit, is:</p>\n<div class=\"codehilite\"><pre><span></span><code>sync/no-hook/core - host-to-wasm - typed - nop\n            time:   [10.552 ns 10.561 ns 10.571 ns]\n            change: [−7.5238% −7.4011% −7.2786%] (p = 0.00 &lt; 0.05)\n            Performance has improved.\n</code></pre></div>\n\n<p>Closes <a href=\"https://github.com/bytecodealliance/wasmtime/issues/3927\">https://github.com/bytecodealliance/wasmtime/issues/3927</a><br>\ncc <a href=\"https://github.com/bytecodealliance/wasmtime/issues/10923\">https://github.com/bytecodealliance/wasmtime/issues/10923</a></p>\n</blockquote>",
        "id": 537351289,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756841284
    },
    {
        "content": "<p><strong>alexcrichton</strong> requested <a href=\"https://github.com/abrown\">abrown</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537351290,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756841285
    },
    {
        "content": "<p><strong>alexcrichton</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-compiler-reviewers\">wasmtime-compiler-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537351291,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756841285
    },
    {
        "content": "<p><strong>alexcrichton</strong> requested <a href=\"https://github.com/dicej\">dicej</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537351293,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756841286
    },
    {
        "content": "<p><strong>alexcrichton</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537351294,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756841286
    },
    {
        "content": "<p><strong>alexcrichton</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-default-reviewers\">wasmtime-default-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537351300,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756841287
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3246537250\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<p>Procedurally this is stacked on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11585\">https://github.com/bytecodealliance/wasmtime/pull/11585</a>, <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11577\">https://github.com/bytecodealliance/wasmtime/pull/11577</a>, and <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11576\">https://github.com/bytecodealliance/wasmtime/pull/11576</a> at this time. I expect this to have a bit of a gauntlet on CI, however, so I wanted to get working on that sooner rather than later.</p>\n</blockquote>",
        "id": 537351420,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756841339
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537354902,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756842882
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537372117,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756851417
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537375545,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756853782
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537376267,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756854285
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537490544,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756910093
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537491114,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756910286
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537509910,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756915565
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537526971,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756921528
    },
    {
        "content": "<p>alexcrichton edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3246537250\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<p>Procedurally this is stacked on <del>https://github.com/bytecodealliance/wasmtime/pull/11585</del>, <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11577\">https://github.com/bytecodealliance/wasmtime/pull/11577</a>, and <del>https://github.com/bytecodealliance/wasmtime/pull/11576</del> at this time. I expect this to have a bit of a gauntlet on CI, however, so I wanted to get working on that sooner rather than later.</p>\n</blockquote>",
        "id": 537526991,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756921538
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537553535,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756933166
    },
    {
        "content": "<p>alexcrichton edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3246537250\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<p>Procedurally this is stacked on <del>https://github.com/bytecodealliance/wasmtime/pull/11585</del>, <del>https://github.com/bytecodealliance/wasmtime/pull/11577</del>, and <del>https://github.com/bytecodealliance/wasmtime/pull/11576</del> at this time. I expect this to have a bit of a gauntlet on CI, however, so I wanted to get working on that sooner rather than later.</p>\n</blockquote>",
        "id": 537553571,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756933185
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#pullrequestreview-3182478503\">PR review</a>.</p>",
        "id": 537554868,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756933781
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#discussion_r2320203576\">PR review comment</a>:</p>\n<blockquote>\n<p>For review this is particularly noteworthy, I had to enable this because when we compile for Winch now the entry trampolines (system ABI) are calling a Winch-defined function (winch ABI). The <code>try_call</code> being done requires that the callee ABI (here: Winch) needs to support exceptions. </p>\n<p>I don't fully understand the implications of this flag, but I updated the aarch64/x64 backends to explicitly say that exceptions + winch clobbers all registers (like tail + winch). I'm not sure if there's more that needs be done, however.</p>\n</blockquote>",
        "id": 537554869,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756933781
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#discussion_r2320222722\">PR review comment</a>:</p>\n<blockquote>\n<p>This is an example of trampolines getting significantly larger than before. It might worthwhile to invest some effort in making a new set of trampolines where we have something like all static entrypoints have their normal trampoline signature they have today, but internally they dispatch to a signature-specific trampoline which takes the function-to-call as a function pointer. That way we'd effectively deduplicate trampolines at least per-signature as we used to do.</p>\n</blockquote>",
        "id": 537554870,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756933781
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#discussion_r2320216179\">PR review comment</a>:</p>\n<blockquote>\n<p>For review this is me from 3 years ago causing pain for myself. Years ago we switched from the <code>winapi</code> crate to the <code>windows-sys</code> crate. During that transition I found that the <code>windows-sys</code> crate, at the time, did not have <code>EXCEPTION_CONTINUE_{SEARCH,EXECUTION}</code> defined. It did, however, have <code>ExceptionContinue{Search,Execution}</code>. Being the naive little flower I am I assumed that this was some sort of mistake in the bindings and the values were all the same. Turns out this has always been wrong but it hasn't mattered since we practically never used <code>ExceptionContinueExecution</code> (only used for embedding-handled signals, which folks do sometimes on Linux but basically never on Windows).</p>\n<p>Turns out that <code>ExceptionContinue{Search,Execution}</code> have different values than <code>EXCEPTION_CONTINUE_{SEARCH,EXECUTION}</code> and they're both interpreted as \"continue search\". It's basically a bit of a miracle this never broke before now. In this PR though we're actually using <code>EXCEPTION_CONTINUE_EXECUTION</code> which required this change.</p>\n</blockquote>",
        "id": 537554871,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756933781
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#discussion_r2320218969\">PR review comment</a>:</p>\n<blockquote>\n<p>This is another consequence of this PR, the single-pass register allocator effectively no longer works with Wasmtime because it has issues with exceptions and Wasmtime unconditionally uses <code>try_call</code> for trampolines. This manifested in tests as crashes so I've disabled the usage in various tests.</p>\n</blockquote>",
        "id": 537554872,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756933781
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#discussion_r2320224348\">PR review comment</a>:</p>\n<blockquote>\n<p>This test is to double-check that we don't accidentally ever run exception handlers on traps now that we're almost implementing traps with exceptions.</p>\n</blockquote>",
        "id": 537554873,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756933781
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537555079,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756933878
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537556519,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756934580
    },
    {
        "content": "<p>github-actions[bot] <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3251144061\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<h4>Label Messager: wasmtime:config</h4>\n<p>It looks like you are changing Wasmtime's configuration options. Make sure to<br>\ncomplete this check list:</p>\n<ul>\n<li>\n<p>[ ] If you added a new <code>Config</code> method, you wrote extensive documentation for<br>\n      it.</p>\n<p>&lt;details&gt;</p>\n<p>Our documentation should be of the following form:</p>\n<p>```text<br>\nShort, simple summary sentence.</p>\n<p>More details. These details can be multiple paragraphs. There should be<br>\ninformation about not just the method, but its parameters and results as<br>\nwell.</p>\n<p>Is this method fallible? If so, when can it return an error?</p>\n<p>Can this method panic? If so, when does it panic?</p>\n<h1>Example</h1>\n<p>Optional example here.<br>\n```</p>\n<p>&lt;/details&gt;</p>\n</li>\n<li>\n<p>[ ] If you added a new <code>Config</code> method, or modified an existing one, you<br>\n  ensured that this configuration is exercised by the fuzz targets.</p>\n<p>&lt;details&gt;</p>\n<p>For example, if you expose a new strategy for allocating the next instance<br>\nslot inside the pooling allocator, you should ensure that at least one of our<br>\nfuzz targets exercises that new strategy.</p>\n<p>Often, all that is required of you is to ensure that there is a knob for this<br>\nconfiguration option in [<code>wasmtime_fuzzing::Config</code>][fuzzing-config] (or one<br>\nof its nested <code>struct</code>s).</p>\n<p>Rarely, this may require authoring a new fuzz target to specifically test this<br>\nconfiguration. See [our docs on fuzzing][fuzzing-docs] for more details.</p>\n<p>&lt;/details&gt;</p>\n</li>\n<li>\n<p>[ ] If you are enabling a configuration option by default, make sure that it<br>\n  has been fuzzed for at least two weeks before turning it on by default.</p>\n</li>\n</ul>\n<p>[fuzzing-config]: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194\">https://github.com/bytecodealliance/wasmtime/blob/ca0e8d0a1d8cefc0496dba2f77a670571d8fdcab/crates/fuzzing/src/generators.rs#L182-L194</a><br>\n[fuzzing-docs]: <a href=\"https://docs.wasmtime.dev/contributing-fuzzing.html\">https://docs.wasmtime.dev/contributing-fuzzing.html</a></p>\n<hr>\n<p>&lt;details&gt;</p>\n<p>To modify this label's message, edit the &lt;code&gt;.github/label-messager/wasmtime-config.md&lt;/code&gt; file.</p>\n<p>To add new label messages or remove existing label messages, edit the<br>\n&lt;code&gt;.github/label-messager.json&lt;/code&gt; configuration file.</p>\n<p><a href=\"https://github.com/bytecodealliance/label-messager-action\">Learn more.</a></p>\n<p>&lt;/details&gt;</p>\n</blockquote>",
        "id": 537568604,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756943092
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537579519,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756952981
    },
    {
        "content": "<p><strong>alexcrichton</strong> has marked <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a> as ready for review.</p>",
        "id": 537579920,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756953267
    },
    {
        "content": "<p><strong>alexcrichton</strong> requested <a href=\"https://github.com/fitzgen\">fitzgen</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537579997,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756953342
    },
    {
        "content": "<p><strong>alexcrichton</strong> requested <a href=\"https://github.com/cfallin\">cfallin</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537579998,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1756953342
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#pullrequestreview-3187106660\">PR review</a>:</p>\n<blockquote>\n<p>This is fantastic -- thanks for pushing toward the \"unwinds only within Cranelift frames\" goal!</p>\n<p>Overall this all looks fine, with a few exceptions (no pun intended) around the handling of trap-handler addresses/relocations and the relocation hacks here. It's <em>workable</em> (and I left some comments on the MachBuffer changes below if we end up going this way) but I suspect there might be a simpler approach...</p>\n<p>First: I think the handler address is always within the current function (there's an assert saying so), right? Then it seems like we shouldn't need to wait until we're using the text-section builder and working across functions to resolve the reference, channeling through the relocations mechanism; rather, it seems like we should be able to take the address of an exception handler target directly, and lower to an instruction/pair of instructions with the right <code>LabelUse</code>s, never creating <code>Reloc</code>s.</p>\n<p>What I'm thinking is that an <code>exception_handler_address</code> CLIF operator, taking a block entity, could directly give us what we need. It's a property of the <code>try_call</code> lowering that we <a href=\"https://github.com/bytecodealliance/wasmtime/blob/e3561d515f1c217c80c634a12c17d6797ce1332a/cranelift/codegen/src/machinst/abi.rs#L2515\">directly pass through the label</a> and <a href=\"https://github.com/bytecodealliance/wasmtime/blob/e3561d515f1c217c80c634a12c17d6797ce1332a/cranelift/codegen/src/machinst/buffer.rs#L1817\">use that label to get an offset</a>, so there is no \"magic glue\" between the <code>try_call</code> and the block -- in the lowering we can just get the block address directly by using the appropriate <code>LabelUse</code>(s).</p>\n<p>That would remove the slightly brittle \"take the one and only exception handler in this trampoline\" logic, the special relocation and special <code>FuncKey</code>, the magic late-resolved labels and offset/addend stuff, and make things generally much cleaner I think.</p>\n<p>What do you think?</p>\n</blockquote>",
        "id": 537753806,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757019658
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#discussion_r2323491567\">PR review comment</a>:</p>\n<blockquote>\n<p>The code in <code>buffer.rs</code> is a little idiosyncratic in that it has an embedded informal correctness proof, but at the risk of being a slightly annoying reviewer, I think it's worth extending the correctness arguments here to really make sure we get it right...</p>\n<p>I was starting to write out a sketch of an argument that we can say \"invariants don't matter when called from <code>finish()</code> but that can invoke forced veneer creation that then calls into much of the rest of the mechanisms here so I'm not super-confident actually. I think it's fine because <code>optimize_branches</code> is the step that makes the invariants load-bearing, and the text-section builder doesn't invoke that after <code>finish</code> like the VCode pipeline does <a href=\"https://github.com/bytecodealliance/wasmtime/blob/e3561d515f1c217c80c634a12c17d6797ce1332a/cranelift/codegen/src/machinst/vcode.rs#L1083-L1085\">here</a>, but that's a fairly distributed and brittle argument. I think the fact that in practice the labels you bind late are not at the very end of the buffer may also be load-bearing here.</p>\n<p>I think what I'd rather see here is that <code>bind_label</code> becomes <code>bind_label_at_offset</code> with its whole body intact (and add a surface <code>bind_label</code> that delegates), and we do the labels-at-tail updates and optimize-branches step only if <code>offset == self.cur_offset()</code>. What do you think?</p>\n</blockquote>",
        "id": 537753808,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757019658
    },
    {
        "content": "<p>cfallin created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#discussion_r2323449577\">PR review comment</a>:</p>\n<blockquote>\n<p>This is only used in the verifier, so I think this is fine practically. Semantically, we more or less have defined exception throws in the Winch ABI by virtue of adding the clobber and payload definitions -- so we now \"support\" it, even though the Winch-the-compiler doesn't yet have lowerings for any of the opcodes.</p>\n</blockquote>",
        "id": 537753809,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757019658
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3256320933\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<blockquote>\n<p>What I'm thinking is that an <code>exception_handler_address</code> CLIF operator</p>\n</blockquote>\n<p>I definitely agree this would be nicer, but can you sketch out more fully what you're thinking? For example this would need to come before a <code>try_call</code> and I'm not aware of anything else in CLIF where you'd want to refer to a label as a value (e.g. like <code>label_addr block0</code> or something). I've been under the impression that adding something a bit more first-class in Cranelift would be a pretty big lift and not necessarily worth it for this case where a \"special reloc\" worked well enough (you're right though that there's no need to defer until the end of the <code>MachBuffer</code> building, I think it could be done sooner)</p>\n</blockquote>",
        "id": 537769723,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757028256
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#pullrequestreview-3187537091\">PR review</a>.</p>",
        "id": 537770070,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757028558
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#discussion_r2323744128\">PR review comment</a>:</p>\n<blockquote>\n<p>To make sure I understand, you're saying revert this PR's changes, add an <code>offset</code> parameter to <code>bind_label</code> and only apply the optimizations if it's <code>cur_offset</code>, and then add a new method <code>bind_label_at_current_offset</code> as a helper for setting the <code>offset</code> parameter to <code>self.cur_offset</code> (or similarly bikeshedded)?</p>\n<p>That all sounds reasonable to me yeah, I'd also be fine asserting that the labels are all empty since I think during text section creation we never hit those paths. If you're confident that running the optimizations is safe to only do conditionally though I'm happy to change to that too</p>\n</blockquote>",
        "id": 537770071,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757028559
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3256372699\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<p>Right, it would more or less be that -- an operator that takes a <code>Block</code> as an argument; and we define its semantics to be: return the address of the handler that would be placed in exception-table metadata if this block were an exception handler. I suppose it also needs an ABI for that exception transfer, and we check the signature as we do for <code>try_call</code>. So something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">v1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">exception_handler_address</span><span class=\"w\"> </span><span class=\"n\">winch</span><span class=\"w\"> </span><span class=\"n\">block1</span>\n</code></pre></div>\n<p>could appear anywhere in the function, and would lower to the ADRP/ADR, or LEA, or whatever is appropriate on the target.</p>\n<p>I'm happy to whip this up tomorrow or late tonight if you like (about to disappear for the day right now)...</p>\n</blockquote>",
        "id": 537770447,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757028848
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 537771142,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757029282
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3256937607\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<p>Is it reasonable to expect Cranelift to always provide the guarantee that an exceptional entrypoint can be purely based on a block name alone? I would have expected that what we really want here is an identification of an edge, or a <code>try_call</code> plus <code>block</code> pair, as opposed to just the <code>block</code>. Otherwise if we're comfortable going just with blocks, how come <code>exception_handler_address</code> would be needed vs a bare <code>v1 = block_addr block2</code>?</p>\n<p>I suppose put another way, if you wouldn't mind sketching this out I'd appreciate that. I'm having a bit of a block imagining what this would look like in CLIF but I fear I'm shackled by my current understanding of CLIF. This isn't that urgent though so don't feel the need to drop everything to sketch this out.</p>\n</blockquote>",
        "id": 537786693,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757042040
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3257123586\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<blockquote>\n<p>Is it reasonable to expect Cranelift to always provide the guarantee that an exceptional entrypoint can be purely based on a block name alone? I would have expected that what we really want here is an identification of an edge, or a <code>try_call</code> plus <code>block</code> pair, as opposed to just the <code>block</code>. Otherwise if we're comfortable going just with blocks, how come <code>exception_handler_address</code> would be needed vs a bare <code>v1 = block_addr block2</code>?</p>\n<p>I suppose put another way, if you wouldn't mind sketching this out I'd appreciate that. I'm having a bit of a block imagining what this would look like in CLIF but I fear I'm shackled by my current understanding of CLIF. This isn't that urgent though so don't feel the need to drop everything to sketch this out.</p>\n</blockquote>\n<p>So I dove down the surprisingly deep rabbithole <a href=\"https://github.com/bytecodealliance/wasmtime/commit/15825ab953f458034a3b2e81f6b36f1f0d96ab81\">here</a>, at least for x64 (other backends left as an exercise for the reader...).</p>\n<p>You're right that one actually needs to identify the edge, not the handler block; I ended up spec'ing the instruction to take a raw block entity reference to the <em>callsite</em> block (the one that ends with <code>try_call</code>) and an immediate indicating which out-edge. Then given that, the idea is it gives exactly the PC that the exception table gives for that handler edge.</p>\n<p>Now that I wrote it out I'm not sure if I like it any better than the relocation-with-fake-external-<code>FuncKey</code> hack that you have here, though. It is more direct at least. I'll flesh it out for the other four backends and put up a PR if you'd like. Or if not, the one thing I would say about this PR is that, for avoidance of potential for subtle correctness bugs or unexpected coupling later, I'd prefer that we resolve the reloc eagerly after function compilation rather than add the deferred-label-resolution mechanism to the <code>MachBuffer</code> -- that's the part that sketches me out the most honestly. Thoughts?</p>\n</blockquote>",
        "id": 537796503,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757050339
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3258538261\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<blockquote>\n<p>I'd prefer that we resolve the reloc eagerly after function compilation</p>\n</blockquote>\n<p>For this I'd defintely be ok switching to this behavior, but I'm not sure how to implement this. From Cranelift's perspective it just sees a <code>symbol_addr</code> with some opaque symbol and it's later embedder-specific knowlege \"oh yeah that symbol is in the function here\". Given that the function is completely finished by the time it's learned what the label is bound to, so no matter what the <code>MachBuffer</code> would need to support \"bind this label at this offset which isn't necessarily the current offset\".</p>\n<p>Were you thinking something else though? Or did you have an idea of how this would get plumbed to the <code>MachBuffer</code> during construction?</p>\n</blockquote>",
        "id": 537882344,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757082111
    },
    {
        "content": "<p>bjorn3 <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3258565946\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<blockquote>\n<p>v1 = exception_handler_address winch block1</p>\n</blockquote>\n<p>You could emulate this in the frontend as <code>v1 = symbol_value gv1</code> where <code>gv1</code> gets a relocation applied immediately after compilation based on the exception table Cranelift emits, right?</p>\n</blockquote>",
        "id": 537884024,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757082615
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3258773018\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<p>I believe that's more-or-less what this PR does already though. Supporting that requires a bind-this-label-at-this-offset mechanism in <code>MachBuffer</code> which it seems @cfallin would prefer to avoid</p>\n</blockquote>",
        "id": 537894946,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757085878
    },
    {
        "content": "<p>cfallin <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3258973717\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<p>Hmm, yeah, if we don't adopt the <code>get_exception_handler_address</code> approach from my branch above, I was imagining a more direct approach where we process the relocs directly as they come out of Cranelift -- the key is not using the deferred-label mechanism, because I am not actually sure that it is correct in all cases (it violates the invariants at least on paper, but right at the end of processing, but there are edge cases that could still possibly happen wrt island insertion).</p>\n<p>Basically rather than converting the reloc to a label we would apply the reloc directly into the slice of function body. Given that we know the offset of the start of the function and the offset of the exception handler at that point we should have everything we need I think.</p>\n<p>That said, I think it's probably best I finish other backends on my branch and put up a PR for the first-class operator instead -- it's a more straightforward design (even if a slightly heavy lift to add the new instruction format). Will do that shortly!</p>\n</blockquote>",
        "id": 537907802,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757090068
    },
    {
        "content": "<p>alexcrichton updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 538108625,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757283185
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#issuecomment-3264106178\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>:</p>\n<blockquote>\n<p>Updated now to incorporate the work from <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11629\">https://github.com/bytecodealliance/wasmtime/pull/11629</a></p>\n</blockquote>",
        "id": 538108767,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757283326
    },
    {
        "content": "<p>cfallin submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592#pullrequestreview-3194659634\">PR review</a>:</p>\n<blockquote>\n<p>Looks great -- thanks for the patience!</p>\n</blockquote>",
        "id": 538112864,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757289263
    },
    {
        "content": "<p>alexcrichton merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11592\">PR #11592</a>.</p>",
        "id": 538248516,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1757343425
    }
]