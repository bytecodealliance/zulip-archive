[
    {
        "content": "<p>MangoPeachGrape opened <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a> from <code>MangoPeachGrape:c-api/component-model/instance</code> to <code>bytecodealliance:main</code>:</p>\n<blockquote>\n<p>Next small chunk of #9812.</p>\n<p>I'm not sure about the lifetime requirements of <code>wasmtime_component_linker_instance()</code>, is there any better way to express this?<br>\nSee previous discussion: <a href=\"https://github.com/bytecodealliance/wasmtime/pull/9812#discussion_r1884466077\">https://github.com/bytecodealliance/wasmtime/pull/9812#discussion_r1884466077</a></p>\n</blockquote>",
        "id": 512660825,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744831211
    },
    {
        "content": "<p><strong>MangoPeachGrape</strong> requested <a href=\"https://github.com/pchickey\">pchickey</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>.</p>",
        "id": 512660827,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744831211
    },
    {
        "content": "<p><strong>MangoPeachGrape</strong> requested <a href=\"https://github.com/orgs/bytecodealliance/teams/wasmtime-core-reviewers\">wasmtime-core-reviewers</a> for a review on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>.</p>",
        "id": 512660828,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744831211
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>.</p>",
        "id": 512662691,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744831512
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#pullrequestreview-2773644205\">PR review</a>:</p>\n<blockquote>\n<p>Thanks! Would you be up for additionally writing tests now that we've got that set up? Ideally through a new C++ API but also optionally through the C API.</p>\n</blockquote>",
        "id": 512666354,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744832073
    },
    {
        "content": "<p>MangoPeachGrape <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#issuecomment-2810653162\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>:</p>\n<blockquote>\n<p>Yes! I would like to write tests, but I'm not sure on some things:</p>\n<p>I tested this locally by writing a \"example\" host using these functions, and running it with a guest component which doesn't import anything.<br>\nHow would this be represented as test in the repo?<br>\nWould this kind of E2E test go the <code>c-api/tests</code>?<br>\nHow would the guest component get compiled?</p>\n<p>Also, I'm not sure if I would want to update the C++ API as well in these PRs. Would it make more sense to add tests for the C API now, and if later - when the same functionality gets exposed to C++ API, and a test written for it - made the C test obsolete, remove it?</p>\n</blockquote>",
        "id": 512678092,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744834329
    },
    {
        "content": "<p>MangoPeachGrape edited a <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#issuecomment-2810653162\">comment</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>:</p>\n<blockquote>\n<p>Yes! I would like to write tests, but I'm not sure on some things:</p>\n<p>I tested this locally by writing an \"example\" host using these functions, and running it with a guest component which doesn't import anything.<br>\nHow would this be represented as a test in the repo?<br>\nWould this kind of E2E test go into the <code>c-api/tests</code>?<br>\nHow would the guest component get compiled?</p>\n<p>Also, I'm not sure if I would want to update the C++ API as well in these PRs. Would it make more sense to add tests for the C API now, and if later - when the same functionality gets exposed to C++ API, and a test written for it - made the C test obsolete, remove it?</p>\n</blockquote>",
        "id": 512678301,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744834428
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#issuecomment-2810667504\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>:</p>\n<blockquote>\n<p>My thinking is that most of the tests could use the text format of WebAssembly, meaning the test wasm file would be in-line with the test itself (this is used a lot on the Rust side for testing too). Orchestrating native-language binaries compiled to wasm to be available in the tests is possible but will be a bit of a pain.</p>\n<p>For location, yeah I'm thinking we'd drop things in <code>crates/c-api/tests/*.cc</code>. And yeah if you'd prefer to start by testing the C API I think that's reasonable.</p>\n</blockquote>",
        "id": 512679074,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744834747
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>.</p>",
        "id": 512695129,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744840880
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>.</p>",
        "id": 512695425,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744841018
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>.</p>",
        "id": 512699371,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744842774
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#pullrequestreview-2774080335\">PR review</a>.</p>",
        "id": 512703160,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744844826
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#discussion_r2047905874\">PR review comment</a>:</p>\n<blockquote>\n<p>I may have missed this on other headers, but I think for this to work reliably you'll want to <code>#include &lt;wasmtime/conf.h&gt;</code> in these headers too? (basically fix the case where this header, and just this header, are included)</p>\n</blockquote>",
        "id": 512703161,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744844826
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#discussion_r2047907624\">PR review comment</a>:</p>\n<blockquote>\n<p>Mind deferring this type to later? I think there's going to be some tricky ownership questions we'll want to grapple with for this (e.g. handling the lifetime parameter in the Rust side of things)</p>\n</blockquote>",
        "id": 512703162,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744844826
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#discussion_r2047908436\">PR review comment</a>:</p>\n<blockquote>\n<p>I think we'll want this to be similar to <code>wasmtime_instance_t</code> where it's not an opaque struct but instead it's a known sturct of two integers (although embeddings won't use the integers much). That'll also obviate the need for deletion of this structure too</p>\n</blockquote>",
        "id": 512703163,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744844826
    },
    {
        "content": "<p>MangoPeachGrape submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#pullrequestreview-2774138857\">PR review</a>.</p>",
        "id": 512707127,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744847239
    },
    {
        "content": "<p>MangoPeachGrape created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#discussion_r2047943140\">PR review comment</a>:</p>\n<blockquote>\n<p>Do you mean not adding this and <code>wasmtime_component_linker_instance()</code> in this PR?</p>\n</blockquote>",
        "id": 512707128,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744847239
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>.</p>",
        "id": 512708193,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744847972
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#pullrequestreview-2775990293\">PR review</a>.</p>",
        "id": 512841111,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744900239
    },
    {
        "content": "<p>alexcrichton created <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#discussion_r2049090819\">PR review comment</a>:</p>\n<blockquote>\n<p>Yeah I think it'd be best to defer that to a future PR to discuss possible directions for that API</p>\n</blockquote>",
        "id": 512841113,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744900239
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>.</p>",
        "id": 512930527,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744931081
    },
    {
        "content": "<p>MangoPeachGrape updated <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>.</p>",
        "id": 512931165,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744931484
    },
    {
        "content": "<p>alexcrichton submitted <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#pullrequestreview-2778721704\">PR review</a>.</p>",
        "id": 513042673,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744986707
    },
    {
        "content": "<p>alexcrichton merged <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>.</p>",
        "id": 513046615,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1744988186
    },
    {
        "content": "<p>MangoPeachGrape <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#issuecomment-2816225689\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>:</p>\n<blockquote>\n<p>@alexcrichton What do you want in the next PR?</p>\n</blockquote>",
        "id": 513100440,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745011927
    },
    {
        "content": "<p>alexcrichton <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598#issuecomment-2818696550\">commented</a> on <a href=\"https://github.com/bytecodealliance/wasmtime/pull/10598\">PR #10598</a>:</p>\n<blockquote>\n<p>How about sketching out the <code>Linker</code> API? Basically being able to create recursive instances/etc. Perhaps hooking up the <code>wasmtime_module_t</code> type where you can supply a core module to a component? (in lieu of defining functions which I think is a bit harder to do as a single step)</p>\n<p>My main concern there is that the <code>Linker</code> API in Rust has a lot of borrowed lifetimes which makes it nontrivial to map to other languages. Clear ownership semantics tend to work out best IMO, and it's also the case that performance is not of the utmost concern when creating a <code>Linker</code>. In that sense I think we may want to design this in such a way such that separate pointers in the C API aren't intrinsically linked but instead perhaps define an item-at-a-time where there's no intermediately-owned structures?</p>\n<p>One example could be that the entire \"path\" to an item is passed to the C API, where each element in the path is an exported instance layer. That would then call <code>.instance(..)</code> as necessary in the Rust API and define the requested item at the leaf when the path is iterated over. Or... something like that, just some vague ideas.</p>\n<p>It's not that we can't have inter-related objects in the C API, it's mostly just that I'd prefer to avoid it if possible.</p>\n</blockquote>",
        "id": 513415950,
        "sender_full_name": "Wasmtime GitHub notifications bot",
        "timestamp": 1745247935
    }
]