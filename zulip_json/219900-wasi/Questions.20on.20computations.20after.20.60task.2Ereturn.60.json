[
    {
        "content": "<p>Hi, I'm not quite sure if this is the best place to ask, but I've been thinking about the behavior for computations after <code>task.return</code>. Notably:</p>\n<ol>\n<li>If I understand correctly, <code>subtask.cancel</code> would resolve immediately if a subtask has returned. If that's the case, how would I know if the task is actually cancelled or not? Or maybe <code>subtask.cancel</code> doesn't trully blocks until the end, but only blocks until <code>task.cancel</code>?</li>\n<li>On the other side, <code>task.cancel</code> can't be called after <code>task.return</code>. So does that mean it would block the <code>subtask.cancel</code> a bit longer than expected? (e.g. if the cancellation woken some other coroutines and the event loop is busying with those stuff unable to return)</li>\n<li>Is the computations after <code>task.return</code> always allowed or is it defined per implementation? For example, I find it a bit weird if computation continues when <code>run: async func() -&gt; result</code> has resolved, and it seems that the current wasmtime doesn't allow it (not quite sure how it is implemented now though)</li>\n</ol>",
        "id": 564377361,
        "sender_full_name": "Zihang Ye",
        "timestamp": 1766030613
    },
    {
        "content": "<p>Once a subtask has either returned a value (e.g. by calling <code>task.return</code>) or confirmed cancellation (by calling <code>task.cancel</code>), the supertask which created it will receive either a <code>RETURNED</code> or a <code>RETURN_CANCELLED</code> event, respectively.  After that, the supertask will receive no further events concerning that subtask, even if the subtask continues running.  However, the supertask may still be able to communicate with the subtask by way of any streams or futures passed as parameters or returned as results.</p>",
        "id": 564485299,
        "sender_full_name": "Joel Dice",
        "timestamp": 1766070694
    },
    {
        "content": "<p>There's no way to cancel a subtask for which a <code>RETURNED</code> or <code>RETURN_CANCELLED</code> event has been received, but you could do something equivalent at the WIT level by adding a <code>cancel: future</code> parameter to the function that creates the subtask.  In that case, the supertask would have the write end of the <code>future</code>, while the subtask would have the read end, and when the supertask writes an item to that <code>future</code>, the subtask could interpret that as a request for it to exit.  The function could also return a <code>future</code> if the supertask wanted confirmation that the subtask has finished exiting.</p>",
        "id": 564486655,
        "sender_full_name": "Joel Dice",
        "timestamp": 1766070990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"678748\">Zihang Ye</span> <a href=\"#narrow/channel/219900-wasi/topic/Questions.20on.20computations.20after.20.60task.2Ereturn.60/near/564377361\">said</a>:</p>\n<blockquote>\n<ol>\n<li>If I understand correctly, <code>subtask.cancel</code> would resolve immediately if a subtask has returned. If that's the case, how would I know if the task is actually cancelled or not? Or maybe <code>subtask.cancel</code> doesn't trully blocks until the end, but only blocks until <code>task.cancel</code>?</li>\n</ol>\n</blockquote>\n<p>The way to interpret <code>subtask.cancel</code> is: \"I don't care about the return value any more, so stop whatever you're doing to compute that value\".  If the value has already been returned, it's too late to say that.  There's no built-in mechanism to cancel post-return computation, so you have arrange that sort of thing at the WIT level as I described above.</p>\n<p>Note that even a cancelled task (i.e. a task that has called <code>task.cancel</code>) can continue running, and there's nothing the supertask can do to prevent that.</p>",
        "id": 564487643,
        "sender_full_name": "Joel Dice",
        "timestamp": 1766071229
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"678748\">Zihang Ye</span> <a href=\"#narrow/channel/219900-wasi/topic/Questions.20on.20computations.20after.20.60task.2Ereturn.60/near/564377361\">said</a>:</p>\n<blockquote>\n<ol>\n<li>On the other side, <code>task.cancel</code> can't be called after <code>task.return</code>. So does that mean it would block the <code>subtask.cancel</code> a bit longer than expected? (e.g. if the cancellation woken some other coroutines and the event loop is busying with those stuff unable to return)</li>\n</ol>\n</blockquote>\n<p><code>subtask.cancel</code> can be called synchronously or asynchronously.  If it's called synchronously, it will block until the subtask either calls <code>task.return</code> or <code>task.cancel</code>.  If it's called asynchronously, the supertask can do other things while it is waiting for the subtask to call <code>task.return</code> or <code>task.cancel</code>.</p>",
        "id": 564488385,
        "sender_full_name": "Joel Dice",
        "timestamp": 1766071391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"678748\">Zihang Ye</span> <a href=\"#narrow/channel/219900-wasi/topic/Questions.20on.20computations.20after.20.60task.2Ereturn.60/near/564377361\">said</a>:</p>\n<blockquote>\n<ol>\n<li>Is the computations after <code>task.return</code> always allowed or is it defined per implementation?</li>\n</ol>\n</blockquote>\n<p>Yes, computations after <code>task.return</code> are always allowed (and also after <code>task.cancel</code>), and are invisible to the supertask except indirectly via any streams or futures passed as parameters or results.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"678748\">Zihang Ye</span> <a href=\"#narrow/channel/219900-wasi/topic/Questions.20on.20computations.20after.20.60task.2Ereturn.60/near/564377361\">said</a>:</p>\n<blockquote>\n<ol>\n<li>For example, I find it a bit weird if computation continues when <code>run: async func() -&gt; result</code> has resolved, and it seems that the current wasmtime doesn't allow it (not quite sure how it is implemented now though)</li>\n</ol>\n</blockquote>\n<p>That's a core part of the design, and it's what enables functions like <code>foo: async func() -&gt; stream&lt;u8&gt;</code> to work.  The only way the subtask can write to the stream it returns from that function is by writing to it after returning, since streams are unbuffered.</p>\n<p>Can you elaborate on what you mean by \"it seems that the current wasmtime doesn't allow it\"?  What, specifically, is Wasmtime not allowing?</p>",
        "id": 564489824,
        "sender_full_name": "Joel Dice",
        "timestamp": 1766071705
    },
    {
        "content": "<p>Wow, thanks for your detailed explanation.</p>",
        "id": 564604731,
        "sender_full_name": "Zihang Ye",
        "timestamp": 1766110796
    },
    {
        "content": "<blockquote>\n<p>Can you elaborate on what you mean by \"it seems that the current wasmtime doesn't allow it\"? What, specifically, is Wasmtime not allowing?</p>\n</blockquote>\n<p>I'm working on the codegen for wasip3 for MoonBit, and here's a prototype to let me know what to generate: <a href=\"https://github.com/peter-jerry-ye/async-wasi-cli/blob/80b30e1ca16cbf2115f00401b8c656ec0d45b0fd/gen/interface/wasi/cli/run/stub.mbt\">https://github.com/peter-jerry-ye/async-wasi-cli/blob/80b30e1ca16cbf2115f00401b8c656ec0d45b0fd/gen/interface/wasi/cli/run/stub.mbt</a></p>\n<p>So what it does is that it will spawn two coroutines, the first one prints <code>Hello Wow</code> and then reach the <code>task.return</code>. The second would sleep for some time and prints <code>Hello World</code>. And the result is that only <code>Hello Wow</code> is printed.</p>\n<p>If you would like to try it out, you would need <a href=\"https://www.moonbitlang.com/download\">MoonBit toolchain</a>, and wasm-tools, and just. The command is <code>just run</code>.</p>\n<p>I tried to reproduce this example with Rust but I'm not that familiar with Rust, especially async Rust, so still wip.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/peter-jerry-ye/async-wasi-cli/blob/80b30e1ca16cbf2115f00401b8c656ec0d45b0fd/gen/interface/wasi/cli/run/stub.mbt\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/c0391f71a1fd4c4a5c626180f67138973eb04cfa/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f613133386335656164663435376634366562306132303337626562333564613130393436643965633064646535663462373831376134613163636362323930392f70657465722d6a657272792d79652f6173796e632d776173692d636c69&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/peter-jerry-ye/async-wasi-cli/blob/80b30e1ca16cbf2115f00401b8c656ec0d45b0fd/gen/interface/wasi/cli/run/stub.mbt\" title=\"async-wasi-cli/gen/interface/wasi/cli/run/stub.mbt at 80b30e1ca16cbf2115f00401b8c656ec0d45b0fd · peter-jerry-ye/async-wasi-cli\">async-wasi-cli/gen/interface/wasi/cli/run/stub.mbt at 80b30e1ca16cbf2115f00401b8c656ec0d45b0fd · peter-jerry-ye/async-wasi-cli</a></div><div class=\"message_embed_description\">Contribute to peter-jerry-ye/async-wasi-cli development by creating an account on GitHub.</div></div></div>",
        "id": 564656786,
        "sender_full_name": "Zihang Ye",
        "timestamp": 1766138118
    },
    {
        "content": "<p>Good catch; you're right that <code>wasmtime run</code> is not allowing post-return I/O (including <code>monotonic-clock#wait-for</code>) to complete.  <a href=\"https://github.com/bytecodealliance/wasmtime/pull/12185\">This PR</a> fixes that.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/12185\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/c3964205cb21151c77dbd75a8c5e7964d5acff0d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f313836303063333964356666666134353966643433663162613937303438316661333337386566373238323036333333343261383563646537623539666262652f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3132313835&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/12185\" title=\"generate `wasmtime-wasi` export bindings with `task_exit` option by dicej · Pull Request #12185 · bytecodealliance/wasmtime\">generate `wasmtime-wasi` export bindings with `task_exit` option by dicej · Pull Request #12185 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">Previously, wasmtime run only ran wasi:cli/run@0.3.x tasks until they returned a result, then exited.  That meant any post-return computation done by the task might not have a chance to run.\nThis c...</div></div></div>",
        "id": 564727598,
        "sender_full_name": "Joel Dice",
        "timestamp": 1766159597
    },
    {
        "content": "<p>See also <a href=\"https://github.com/bytecodealliance/wasmtime/issues/12187\">https://github.com/bytecodealliance/wasmtime/issues/12187</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/issues/12187\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/eee424ccf927420f570d8a6d6b95d11348cab745/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f343364653832653039656636376135613861346661363830323266613135353137306631633039366333306638616666343336663464633735333663623661302f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f3132313837&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/issues/12187\" title=\"Run task to completion in `wasmtime run --invoke 'foo()'` · Issue #12187 · bytecodealliance/wasmtime\">Run task to completion in `wasmtime run --invoke 'foo()'` · Issue #12187 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">Currently, wasmtime run's invoke_component function uses Func::call_async to invoke the function. However, that will only run the guest task until it produces a result, then print that result an ex...</div></div></div>",
        "id": 564733705,
        "sender_full_name": "Joel Dice",
        "timestamp": 1766161212
    }
]