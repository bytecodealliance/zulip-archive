[
    {
        "content": "<p>Hey all! First time opening a thread here, also my first time using Zulip... I appreciate any patience with any error I make opening this thread :).</p>\n<p>I've been lurking and working on wasip3 support as a consumer of wasmtime for a project of mine, and I've been exploring adding p3 support to the rust libc (and thus wasi-libc, and wasi-sdk, and so on) and made some progress but there's nothing notable other than just having everything plumbed together to iterate on p3 libc support. I was hoping to do more of the work before ever mentioning it, but I want to make sure to reach out to see if what I'm doing fits into the plans for p3. Right now I've been working on wit-bindgen's c bindings.</p>\n<p>If there's any interest at all in what I've done I'd be glad to push my work and we can take a look, otherwise I'm perfectly content continuing individually. I'd also be glad to rework any previous work to align with upstream goals.</p>",
        "id": 509254910,
        "sender_full_name": "Amber",
        "timestamp": 1743439516
    },
    {
        "content": "<p>My implementation is driven by the ultimate task of \"port tokio (and its internal deps) to wasip3\" (at least as a fork I can use myself). I felt like the tokio port for p2 using libc looked pretty reasonable, so that's the approach thats driving my p3 work.</p>",
        "id": 509257448,
        "sender_full_name": "Amber",
        "timestamp": 1743440335
    },
    {
        "content": "<p>That sounds awesome!  <span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> and I both started sketching <code>wit-bindgen</code> C support for component model async but haven't had a chance to take it beyond a sketch.  Also, <span class=\"user-mention\" data-user-id=\"253992\">@Pat Hickey</span> has been thinking about updating <code>wasi-libc</code>'s support for p2 by removing the dependency on the p1-&gt;p2 adapter, which would be a helpful step towards native p3 support, so you might want to coordinate your wasi-libc efforts with him.</p>\n<p>Posting here is a great way to start a discussion.  In addition, opening a draft PR for the <code>wit-bindgen</code> C work would be a great way to collaborate and avoid redundant effort.</p>",
        "id": 509257573,
        "sender_full_name": "Joel Dice",
        "timestamp": 1743440373
    },
    {
        "content": "<p>I'm interested in taking a look at the existing sketches, I did a really cursory look for where that'd be , found this: <a href=\"https://hackmd.io/@NXXwAQZbQ8CTpJXGoJcJ8w/SyIwhv9i6\">https://hackmd.io/@NXXwAQZbQ8CTpJXGoJcJ8w/SyIwhv9i6</a>, which I suspect is a start but I'm getting the impression there's more to find. Are there any other places I should look for existing conceptualization / implementation on the wit-bindgen c support?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://hackmd.io/@NXXwAQZbQ8CTpJXGoJcJ8w/SyIwhv9i6\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f8833a4340ab1f5f4b067117308223870fca5545/68747470733a2f2f6861636b6d642e696f2f696d616765732f6d656469612f4861636b4d442d6e656f2d6f672e6a7067&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://hackmd.io/@NXXwAQZbQ8CTpJXGoJcJ8w/SyIwhv9i6\" title=\"Component Model Async MVP Implementation Plan - HackMD\">Component Model Async MVP Implementation Plan - HackMD</a></div><div class=\"message_embed_description\">This is a brief outline of a plan to implement conc</div></div></div>",
        "id": 509533155,
        "sender_full_name": "Amber",
        "timestamp": 1743536124
    },
    {
        "content": "<p>Currently there's no async support in <code>wit-bindgen c</code>, and while I was going to start it a month or so ago I still haven't gotten around to doing so. You're welcome though to try to take this on and see where it goes! I'll caution you though in that there is not a stable foundation to build on at this time. For example there are no runtime tests in the wit-bindgen repository for async things nor is it easy to set them up. Additionally we're still figuring out idioms and general infrasturctural questions, for example wasi-libc and wasi-sdk haven't started to add a p3 target yet (much less rustc). Basically there's a lot up in the air, and I mostly want to make sure to set expectations</p>",
        "id": 509538346,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1743537957
    },
    {
        "content": "<p>This is my very rough, incomplete sketch of C bindgen support from a while ago: <a href=\"https://github.com/dicej/wit-bindgen/tree/c-async\">https://github.com/dicej/wit-bindgen/tree/c-async</a></p>\n<p>The basic idea was that, for each async-lowered import (named \"foo\", for example), we'd declare three functions: <code>foo</code>, <code>foo_lift</code>, and <code>foo_free</code>, plus one type: <code>foo_result_t</code>.  <code>foo</code> would return a <code>foo_result_t</code> which is a newtype wrapper around a general-purpose <code>async_result_t</code> type that looks something like:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">typedef</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kt\">uint32_t</span><span class=\"w\"> </span><span class=\"n\">status_code</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kt\">uint32_t</span><span class=\"w\"> </span><span class=\"n\">subtask_handle</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kt\">uint8_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">params</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"kt\">uint8_t</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">results</span><span class=\"p\">;</span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">async_result_t</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>The <code>foo_lift</code> function could be called once the subtask has reached <code>STATUS_RETURNED</code> and take a <code>foo_result_t *</code> parameter, plus outpointer(s) for each lifted result, lifting from the lowered results in <code>async_result_t::results</code> into the outpointer(s).  The caller is then responsible for disposing of the <code>foo_result_t</code> by passing it to <code>foo_result_free</code>.</p>\n<p>Note that I hadn't even started thinking about how exports would work, but Alex recently did some brainstorming about that: <a href=\"https://github.com/WebAssembly/component-model/issues/485#issuecomment-2766981494\">https://github.com/WebAssembly/component-model/issues/485#issuecomment-2766981494</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/dicej/wit-bindgen/tree/c-async\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/af7a8c57cce9d733cdb6a218475d8bd06fe1f403/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f383461633737363031376234363437643161373964333435663466626635343262356133383264613134376635613162373932363738633939393431306162382f646963656a2f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/dicej/wit-bindgen/tree/c-async\" title=\"GitHub - dicej/wit-bindgen at c-async\">GitHub - dicej/wit-bindgen at c-async</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - GitHub - dicej/wit-bindgen at c-async</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/issues/485#issuecomment-2766981494\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/49b8dd6b5fb8905243d3f75a89e91b2f2292ac44/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f373164383230623062643738656236343038666238303531336130643961326533306633663735656535373061663666393235323162653133616665326131332f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f6973737565732f343835&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/issues/485#issuecomment-2766981494\" title=\"Toolchain conventions and `context.get` 路 Issue #485 路 WebAssembly/component-model\">Toolchain conventions and `context.get` 路 Issue #485 路 WebAssembly/component-model</a></div><div class=\"message_embed_description\">Currently in wit-bindgen it uses context.get to store a per-exported-task data structure which manages waitable sets and and child tasks from Rust's perspectives (not component-model tasks, Rust ta...</div></div></div>",
        "id": 509542558,
        "sender_full_name": "Joel Dice",
        "timestamp": 1743539540
    },
    {
        "content": "<p>For what it's worth regarding the challenges of building on the existing foundation, I have a forked <code>rust</code> that I added <code>wasm32-wasip3</code> to and integrated to the point that I can consume the target and build a crate. I also have <code>libc</code>, <code>wasi-sdk</code>, and <code>wasi-libc</code> set up to build a p3 sdk sysroot along with the rest of the existing targets. Obviously there is no actual p3 implementation so there's no impact for that work, but I should be pretty well set up to iterate on some wit-bindgen work for p3. Obviously the part where my work became definitely blocked was when none of the in-progress branches with wit-bindgen changes had full implementations of the new codegen for the p3 ABI. I also am entirely willing to do some work that with requirements that change later on, so I'd love to see where I can take wit-bindgen c support with the planning available right now</p>",
        "id": 509542954,
        "sender_full_name": "Amber",
        "timestamp": 1743539696
    },
    {
        "content": "<p>My understanding is that long term what I've said I have doesn't meet the higher level desires for what an implementation looks like since I figure anything short of a fully unit/integration tested implementation isn't what you're looking for. I like testing so I would be fine if I had to do any of that work. <br>\nUltimately what I feel like my expectation is, is that anything I do related to this task in the rustc and libc realm is something I'm doing without any proper planning or coordination and would treat it as such. The <code>wasi-sdk</code>, <code>wasi-libc</code>, and <code>wit-bindgen</code> work is relevant enough to the current phase of the p3 timeline as I understand it and so I'd continue collaborating until any potential other work I did might fit into the plans.</p>",
        "id": 509546652,
        "sender_full_name": "Amber",
        "timestamp": 1743541131
    },
    {
        "content": "<p>The root of many of these changes will definitely start with C bindings for p3/async things, so that's probably a good place to start. The main thing is that it'll be kind of hard to test and exercise that at this time</p>",
        "id": 509552595,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1743543652
    },
    {
        "content": "<p>I am wondering whether the addition of cooperative threads to wasmtime could make a difference for implementing wasip3 in libc. My understanding is that <code>waitable-set.wait</code> would enable reasonable behavior for a \"blocking\" system call without forcing C to learn async functions.</p>",
        "id": 558320571,
        "sender_full_name": "Christof Petig",
        "timestamp": 1763593483
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"590366\">Christof Petig</span> has marked this topic as unresolved.</p>",
        "id": 558320596,
        "sender_full_name": "Notification Bot",
        "timestamp": 1763593500
    },
    {
        "content": "<p>I think the idea is that any given blocking call in <code>wasi-libc</code> will call an async-lowered import (or <code>stream.read</code>, <code>stream.write</code>, etc.) and then suspend the current thread if a result is not yet available, only resuming that thread once the operation finishes.  Whether <code>waitable-set.wait</code> is used (vs. returning <code>CALLBACK_CODE_WAIT</code> from an async-lifted export) to wait for an event on one of the accumulated waitables would depend on whether a sync-lifted or async-lifted export was called.</p>\n<p>But yes, for the most part it would be plain old synchronous C, except for right at the edges (i.e. at the exports and imports).</p>",
        "id": 558323545,
        "sender_full_name": "Joel Dice",
        "timestamp": 1763595041
    }
]