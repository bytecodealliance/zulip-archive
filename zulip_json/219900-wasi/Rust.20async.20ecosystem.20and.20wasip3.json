[
    {
        "content": "<p>With WASI 0.3 on the horizon, I'm curious about its future support within the Rust async ecosystem, particularly with regard to its compatibility with tokio. I have a potential use case involving streaming results asynchronously from the guest to the host. Once tokio supports the <code>wasip3</code> target, will I be able to use any crate that provides asynchronous functionality and relies on tokio (e.g., tokio-postgres) in the guest? Or will each crate have to add support for <code>wasip3</code> individually?</p>",
        "id": 546275937,
        "sender_full_name": "Nicola Krumschmidt",
        "timestamp": 1761062822
    },
    {
        "content": "<p>There is <a href=\"https://github.com/tokio-rs/tokio/pull/6893\">https://github.com/tokio-rs/tokio/pull/6893</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/tokio-rs/tokio/pull/6893\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/82292d050e10f944cecc19d5ce529e94303f74f1/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f636563383833316432323461623435373632333661326538373165333032663830376531326232633966336238346365363463326564376366303865383931342f746f6b696f2d72732f746f6b696f2f70756c6c2f36383933&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/tokio-rs/tokio/pull/6893\" title=\"add wasm32-wasip2 support by dicej 路 Pull Request #6893 路 tokio-rs/tokio\">add wasm32-wasip2 support by dicej 路 Pull Request #6893 路 tokio-rs/tokio</a></div><div class=\"message_embed_description\">Motivation\n\nThis adds support for the new wasm32-wasip2 target platform, which includes more extensive support for sockets than wasm32-wasip1 (formerly known as wasm32-wasi).\nSolution\n\nThe bulk of ...</div></div></div>",
        "id": 546277223,
        "sender_full_name": "Ludea",
        "timestamp": 1761063216
    },
    {
        "content": "<p>You can use <a href=\"https://github.com/bytecodealliance/wstd\">https://github.com/bytecodealliance/wstd</a> instead</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wstd\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/48656314f330103a5b76ab9a96b37e012de998cf/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f393863343465343230303134636438303262326230646233633136656235613239313137633161383964636164356632313438313831303564663935363062622f62797465636f6465616c6c69616e63652f77737464&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wstd\" title=\"GitHub - bytecodealliance/wstd: A WebAssembly-native Rust stdlib\">GitHub - bytecodealliance/wstd: A WebAssembly-native Rust stdlib</a></div><div class=\"message_embed_description\">A WebAssembly-native Rust stdlib. Contribute to bytecodealliance/wstd development by creating an account on GitHub.</div></div></div>",
        "id": 546278898,
        "sender_full_name": "Ludea",
        "timestamp": 1761063724
    },
    {
        "content": "<blockquote>\n<p>Once tokio supports the <code>wasip3</code> target, will I be able to use any crate that provides asynchronous functionality and relies on tokio (e.g., tokio-postgres) in the guest?</p>\n</blockquote>\n<p>There won't be a universal answer here. Some crates will work immediately, some will work eventually, and some (hopefully very few!) will likely never work.</p>",
        "id": 546278928,
        "sender_full_name": "Lann Martin",
        "timestamp": 1761063731
    },
    {
        "content": "<blockquote>\n<p>Or will each crate have to add support for <code>wasip3</code> individually?</p>\n</blockquote>\n<p>This shouldn't be necessary, though a few common dependencies like <code>hyper</code> may need individual work toward support to enable dependent crates.</p>",
        "id": 546280257,
        "sender_full_name": "Lann Martin",
        "timestamp": 1761064066
    },
    {
        "content": "<p>Thanks! All of that makes sense so far. There is one thing I'm wondering about, though. If I understand correctly, to call an async function that transitively calls a function from tokio, the call must happen in a tokio runtime context. However, if the function is called from an exported guest function, the runtime runs inside the host, so there is no runtime that the guest is aware of.</p>",
        "id": 546291793,
        "sender_full_name": "Nicola Krumschmidt",
        "timestamp": 1761067593
    },
    {
        "content": "<p>you'll never see that sort of connection between guest and host.</p>",
        "id": 546292242,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761067724
    },
    {
        "content": "<p>running tokio inside the guest means that the guest tokio will use wasip3 as its syscall layer. it won't (can't, and shouldn't) know anything about the host environment it is running inside, just that the environment provides wasip3</p>",
        "id": 546292422,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761067774
    },
    {
        "content": "<p>so, the guest tokio (linked to by any libraries using tokio inside the guest) will have to satisfy all of its needs from the external world (connecting, accepting, sending and recieving data on sockets, opening files, timers, etc) via wasip3. if the host happens to use a tokio for implementing wasip3, thats an implementation detail out on the host where the host tokio will be making linux (or mac or etc) syscalls to implement its functionality. but the two will always be in totally separate memory spaces, symbols from one tokio wont ever resolve to the other</p>",
        "id": 546292907,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761067897
    },
    {
        "content": "<p>But if you just call a tokio function from an exported guest function, there would be no tokio runtime running inside the guest, would there? If I called a tokio function outside of the tokio runtime context today, it will panic, but when the same function is called from a guest that is compiled to <code>wasip3</code>, it should still work.</p>",
        "id": 546298670,
        "sender_full_name": "Nicola Krumschmidt",
        "timestamp": 1761069674
    },
    {
        "content": "<p>That's right yeah, the guest would be responsible for setting up and managing the tokio runtime within itself and calls to its exports. This might be via a wasi-specific API in tokio or something like that</p>",
        "id": 546299222,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1761069857
    },
    {
        "content": "<p>Ah, I see. Thanks! So, calling an async function alone won't suffice. Has anyone experimented with what that might look like in terms of implementation in tokio? I'm very interested to see how it will work.</p>",
        "id": 546326541,
        "sender_full_name": "Nicola Krumschmidt",
        "timestamp": 1761080208
    },
    {
        "content": "<p>there have been experiments porting tokio to wasip2, but none yet to wasip3</p>",
        "id": 546331560,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761082471
    },
    {
        "content": "<p>wstd is a much smaller runtime than tokio that works for wasip2 today <a href=\"https://github.com/bytecodealliance/wstd\">https://github.com/bytecodealliance/wstd</a>. it will be ported to wasip3 in the future</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wstd\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/48656314f330103a5b76ab9a96b37e012de998cf/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f393863343465343230303134636438303262326230646233633136656235613239313137633161383964636164356632313438313831303564663935363062622f62797465636f6465616c6c69616e63652f77737464&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wstd\" title=\"GitHub - bytecodealliance/wstd: A WebAssembly-native Rust stdlib\">GitHub - bytecodealliance/wstd: A WebAssembly-native Rust stdlib</a></div><div class=\"message_embed_description\">A WebAssembly-native Rust stdlib. Contribute to bytecodealliance/wstd development by creating an account on GitHub.</div></div></div>",
        "id": 546331747,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761082561
    },
    {
        "content": "<p>its worth considering what, exactly, you need from tokio. If you are just using tokio::net, tokio::time, tokio::task::spwan, that stuff works great with wstd today (though under a different crate name)</p>",
        "id": 546331858,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761082615
    },
    {
        "content": "<p>if you are trying to use e.g. tokio-native-tls that uses the (linux, macos, windows) native tls - that wont work today, that doesnt (yet) exist for wasi. (there is a wasi-tls proposal in progress and will eventaully be possible)</p>",
        "id": 546332094,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761082740
    },
    {
        "content": "<p>if you are using features of tokio's multi-threaded executor (e.g. spawn_blocking) those wont work on wasip3 either, because those require threads, and wasip3 will not have threads at launch (they will come later, and they will initially be cooperative threads, not preemptive). (and its sort of a traditional-os-ism to need blocking syscalls, which along with long-running cpu-bound computations is why spawn_blocking exists, in wasip3 all syscalls can be made async, but thats neither here nor there)</p>",
        "id": 546332471,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1761082938
    }
]