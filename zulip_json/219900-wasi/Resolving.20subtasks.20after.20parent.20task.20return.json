[
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"509936\">@Joel Dice</span>  / <span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span>  I'm a bit stuck and have a question about <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/test-programs/src/bin/async_sleep_post_return_caller.rs\">the <code>async_sleep_post_return_caller</code> test</a> -- I'm a bit stuck because I don't see <em>how</em> we keep polling the spawned subtask (i.e. calling the callback) after the first time. </p>\n<p>Pending event is set when the subtask first starts (<code>on_start()</code> which is set up during <code>canon_lower</code>), but the first time you check it, it's supposed to removed (set to <code>None</code> in the spec docs -- <code>Waitable#get_pending_event()</code> via <code>WaitableSet#get_pending_event()</code> via the <code>Subtask</code> itself)... </p>\n<p>So how could the subtask keep getting <code>wait_until</code>'d in the main loop? I think I'm missing something here. </p>\n<p>It's a bit hard to explain but let me try again:</p>\n<ol>\n<li>The initial callback call returns the code <code>2</code> (i.e. wait) and the waitable rep to watch is <code>1</code>, the new <code>Subtask</code> itself</li>\n<li><code>wait_until</code> spits out <code>{ code: State.Subtask, index: 1, result: 1 }</code>which makes sense because we have to wait for that spawned subtask,  and the task is <code>STARTED</code> (<code>result</code>) -- the pending event fn was cleared for this</li>\n<li>The callback is run a second time,  and returns the unpacked code <code>2</code> (wait) w/ waitable <code>1</code> (the subtask) -- this all makes sense</li>\n<li>We get into the <em>second</em> <code>wait_until()</code>,  and the task will never resolve because we never re-set the pending event:</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code>  <span class=\"c1\"># Task#wait_until -&gt; Task#suspend_until -&gt; Thread#suspend_until</span>\n  <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">wait_until</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">ready_func</span><span class=\"p\">,</span> <span class=\"n\">thread</span><span class=\"p\">,</span> <span class=\"n\">wset</span><span class=\"p\">,</span> <span class=\"n\">cancellable</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">EventTuple</span><span class=\"p\">:</span>\n    <span class=\"k\">assert</span><span class=\"p\">(</span><span class=\"n\">thread</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">threads</span> <span class=\"ow\">and</span> <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"n\">task</span> <span class=\"ow\">is</span> <span class=\"bp\">self</span><span class=\"p\">)</span>\n    <span class=\"n\">wset</span><span class=\"o\">.</span><span class=\"n\">num_waiting</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">ready_and_has_event</span><span class=\"p\">():</span>\n      <span class=\"k\">return</span> <span class=\"n\">ready_func</span><span class=\"p\">()</span> <span class=\"ow\">and</span> <span class=\"n\">wset</span><span class=\"o\">.</span><span class=\"n\">has_pending_event</span><span class=\"p\">()</span> <span class=\"c1\"># &lt;-- second condition will never be the case</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">suspend_until</span><span class=\"p\">(</span><span class=\"n\">ready_and_has_event</span><span class=\"p\">,</span> <span class=\"n\">thread</span><span class=\"p\">,</span> <span class=\"n\">cancellable</span><span class=\"p\">):</span>\n      <span class=\"n\">event</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">EventCode</span><span class=\"o\">.</span><span class=\"n\">TASK_CANCELLED</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n      <span class=\"n\">event</span> <span class=\"o\">=</span> <span class=\"n\">wset</span><span class=\"o\">.</span><span class=\"n\">get_pending_event</span><span class=\"p\">()</span>\n    <span class=\"n\">wset</span><span class=\"o\">.</span><span class=\"n\">num_waiting</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">return</span> <span class=\"n\">event</span>\n</code></pre></div>\n<p>Basically, I can't see/am missing the mechanism by which <code>pending_event</code> would ever  get set again -- obviously <code>on_progress()</code> would be the thing to do this, BUT it wouldn't get called from <code>on_start()</code> established in <code>canon_lower</code> (we've already started), and not <code>on_resolve()</code> either because we're not done yet (the caller in the subtask has not <code>task.return</code>ed)</p>\n<p>Cheating and taking a look <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasmtime/src/runtime/component/concurrent.rs#L2389\">at the Rust impl</a>, it looks like wasmtime basically just do another turn at the loop by creating another subtask under the current task (so 1 + n subtasks for every poll while the spawned tasks have not completed) -- this makes intuitive sense but I cannot find rationale in the spec for this.</p>\n<p>If I'm reading the spec right, <code>Subtask</code>s only get created during the initial <code>canon_lower</code> call (i.e. on the code side this is responding to <code>Trampoline::StartAsyncCall</code> IIUC), so I can't figure out which mechanism is responsible for allowing the new subtask creation.</p>\n<p>Also <span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> in case I'm misreading the spec here</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/test-programs/src/bin/async_sleep_post_return_caller.rs\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/661786a27eab4b737a8c24357e902be6ffaaa245/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f316436626630613837303039633130613237326662343439393937333630656136313839653432666265653762343833326264646662353133656266393937322f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/test-programs/src/bin/async_sleep_post_return_caller.rs\" title=\"wasmtime/crates/test-programs/src/bin/async_sleep_post_return_caller.rs at main · bytecodealliance/wasmtime\">wasmtime/crates/test-programs/src/bin/async_sleep_post_return_caller.rs at main · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasmtime/src/runtime/component/concurrent.rs#L2389\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/661786a27eab4b737a8c24357e902be6ffaaa245/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f316436626630613837303039633130613237326662343439393937333630656136313839653432666265653762343833326264646662353133656266393937322f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasmtime/src/runtime/component/concurrent.rs#L2389\" title=\"wasmtime/crates/wasmtime/src/runtime/component/concurrent.rs at main · bytecodealliance/wasmtime\">wasmtime/crates/wasmtime/src/runtime/component/concurrent.rs at main · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>",
        "id": 558098461,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763516023
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"598440\">Victor Adossi</span> <a href=\"#narrow/channel/219900-wasi/topic/Resolving.20subtasks.20after.20parent.20task.20return/near/558098461\">said</a>:</p>\n<blockquote>\n<p>it looks like wasmtime basically just do another turn at the loop by creating another subtask under the current task (so 1 + n subtasks for every poll while the spawned tasks have not completed)</p>\n</blockquote>\n<p>I'm not sure what you mean by this.  Wasmtime isn't creating new subtasks on each poll or wait.  All it's doing is being <em>lazy</em> about adding it to the caller's handle table.  I.e. if the callee returns a result immediately, then there's no need to add it to the caller's handle table because, as far as the caller is concerned, the subtask is already finished.</p>\n<p>Of course in this case the subtask will still do more stuff after it has returned, but that's invisible to the caller.  And once the caller exits and the subtask still isn't done, the <em>caller's</em> caller (the host, in this case) will inherit the subtask.  The host then allows that subtask and any transitive subtasks to complete by continuing to run the event loop until there's nothing left to do: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/7fb8b55a8d3003a926753f4c3fcd676c813ebf98/crates/misc/component-async-tests/tests/scenario/post_return.rs#L90-L92\">https://github.com/bytecodealliance/wasmtime/blob/7fb8b55a8d3003a926753f4c3fcd676c813ebf98/crates/misc/component-async-tests/tests/scenario/post_return.rs#L90-L92</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/7fb8b55a8d3003a926753f4c3fcd676c813ebf98/crates/misc/component-async-tests/tests/scenario/post_return.rs#L90-L92\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/8f58c19e79723673c6fed419e4ecb0c3cfc2c11b/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f313939303438323662613231666561353630373062626430626661323830346162323932373535616233636462356131383531373535316532323932653735392f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/7fb8b55a8d3003a926753f4c3fcd676c813ebf98/crates/misc/component-async-tests/tests/scenario/post_return.rs#L90-L92\" title=\"wasmtime/crates/misc/component-async-tests/tests/scenario/post_return.rs at 7fb8b55a8d3003a926753f4c3fcd676c813ebf98 · bytecodealliance/wasmtime\">wasmtime/crates/misc/component-async-tests/tests/scenario/post_return.rs at 7fb8b55a8d3003a926753f4c3fcd676c813ebf98 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>",
        "id": 558225851,
        "sender_full_name": "Joel Dice",
        "timestamp": 1763564218
    },
    {
        "content": "<p>I'm not sure how that all matches up to the spec code, but perhaps <span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> can help with that.</p>",
        "id": 558226114,
        "sender_full_name": "Joel Dice",
        "timestamp": 1763564265
    },
    {
        "content": "<p>Ah, so I get that the host gets to run the subtasks until there's nothing left to do, via the <code>tick()</code> function -- my problem is with the check in the threads that looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">#</span><span class=\"w\"> </span><span class=\"n\">Task</span><span class=\"p\">#</span><span class=\"n\">wait_until</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">Task</span><span class=\"p\">#</span><span class=\"n\">suspend_until</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">Thread</span><span class=\"p\">#</span><span class=\"n\">suspend_until</span>\n<span class=\"w\">  </span><span class=\"n\">def</span><span class=\"w\"> </span><span class=\"n\">wait_until</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ready_func</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">thread</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">wset</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cancellable</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">EventTuple</span><span class=\"p\">:</span>\n<span class=\"w\">    </span><span class=\"nc\">assert</span><span class=\"p\">(</span><span class=\"n\">thread</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">threads</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">thread</span><span class=\"p\">.</span><span class=\"n\">task</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"n\">wset</span><span class=\"p\">.</span><span class=\"n\">num_waiting</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"n\">def</span><span class=\"w\"> </span><span class=\"n\">ready_and_has_event</span><span class=\"p\">():</span>\n<span class=\"w\">      </span><span class=\"nc\">return</span><span class=\"w\"> </span><span class=\"n\">ready_func</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">wset</span><span class=\"p\">.</span><span class=\"n\">has_pending_event</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">#</span><span class=\"w\"> </span><span class=\"o\">&lt;--</span><span class=\"w\"> </span><span class=\"n\">second</span><span class=\"w\"> </span><span class=\"n\">condition</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">never</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">case</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">suspend_until</span><span class=\"p\">(</span><span class=\"n\">ready_and_has_event</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">thread</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cancellable</span><span class=\"p\">):</span>\n<span class=\"w\">      </span><span class=\"nc\">event</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">EventCode</span><span class=\"p\">.</span><span class=\"n\">TASK_CANCELLED</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"w\">    </span><span class=\"k\">else</span><span class=\"p\">:</span>\n<span class=\"w\">      </span><span class=\"nc\">event</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">wset</span><span class=\"p\">.</span><span class=\"n\">get_pending_event</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"n\">wset</span><span class=\"p\">.</span><span class=\"n\">num_waiting</span><span class=\"w\"> </span><span class=\"o\">-=</span><span class=\"w\"> </span><span class=\"mi\">1</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">event</span>\n</code></pre></div>\n<p>My main question was how the subtask would get it's pending event set again after that first time.</p>\n<p>The host IS currently trying to drive the subtask to completion but I'm stuck (well, the host is stuck) because it's running <code>wait_until</code> on a subtask that will never be ready according to that <code>ready_and_has_event</code> logic.</p>",
        "id": 558231869,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763565589
    },
    {
        "content": "<p>So <em>it makes sense</em> to me to keep running it, but maybe what you're saying is that once we're out of that loop of checking for event codes we don't enter it again? i.e. we break out of this loop:</p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code>    <span class=\"p\">[</span><span class=\"n\">packed</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">call_and_trap_on_throw</span><span class=\"p\">(</span><span class=\"n\">callee</span><span class=\"p\">,</span> <span class=\"n\">thread</span><span class=\"p\">,</span> <span class=\"n\">flat_args</span><span class=\"p\">)</span>\n    <span class=\"n\">code</span><span class=\"p\">,</span><span class=\"n\">si</span> <span class=\"o\">=</span> <span class=\"n\">unpack_callback_result</span><span class=\"p\">(</span><span class=\"n\">packed</span><span class=\"p\">)</span>\n    <span class=\"k\">while</span> <span class=\"n\">code</span> <span class=\"o\">!=</span> <span class=\"n\">CallbackCode</span><span class=\"o\">.</span><span class=\"n\">EXIT</span><span class=\"p\">:</span>\n      <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"n\">in_event_loop</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n      <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">exclusive</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n      <span class=\"k\">match</span> <span class=\"n\">code</span><span class=\"p\">:</span>\n        <span class=\"k\">case</span> <span class=\"n\">CallbackCode</span><span class=\"o\">.</span><span class=\"n\">YIELD</span><span class=\"p\">:</span>\n          <span class=\"n\">event</span> <span class=\"o\">=</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">yield_until</span><span class=\"p\">(</span><span class=\"k\">lambda</span><span class=\"p\">:</span> <span class=\"ow\">not</span> <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">exclusive</span><span class=\"p\">,</span> <span class=\"n\">thread</span><span class=\"p\">,</span> <span class=\"n\">cancellable</span> <span class=\"o\">=</span> <span class=\"kc\">True</span><span class=\"p\">)</span>\n        <span class=\"k\">case</span> <span class=\"n\">CallbackCode</span><span class=\"o\">.</span><span class=\"n\">WAIT</span><span class=\"p\">:</span>\n          <span class=\"n\">wset</span> <span class=\"o\">=</span> <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">table</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">si</span><span class=\"p\">)</span>\n          <span class=\"n\">trap_if</span><span class=\"p\">(</span><span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">wset</span><span class=\"p\">,</span> <span class=\"n\">WaitableSet</span><span class=\"p\">))</span>\n          <span class=\"n\">event</span> <span class=\"o\">=</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">wait_until</span><span class=\"p\">(</span><span class=\"k\">lambda</span><span class=\"p\">:</span> <span class=\"ow\">not</span> <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">exclusive</span><span class=\"p\">,</span> <span class=\"n\">thread</span><span class=\"p\">,</span> <span class=\"n\">wset</span><span class=\"p\">,</span> <span class=\"n\">cancellable</span> <span class=\"o\">=</span> <span class=\"kc\">True</span><span class=\"p\">)</span>\n        <span class=\"k\">case</span> <span class=\"n\">CallbackCode</span><span class=\"o\">.</span><span class=\"n\">POLL</span><span class=\"p\">:</span>\n          <span class=\"n\">wset</span> <span class=\"o\">=</span> <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">table</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">si</span><span class=\"p\">)</span>\n          <span class=\"n\">trap_if</span><span class=\"p\">(</span><span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">wset</span><span class=\"p\">,</span> <span class=\"n\">WaitableSet</span><span class=\"p\">))</span>\n          <span class=\"n\">event</span> <span class=\"o\">=</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">poll_until</span><span class=\"p\">(</span><span class=\"k\">lambda</span><span class=\"p\">:</span> <span class=\"ow\">not</span> <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">exclusive</span><span class=\"p\">,</span> <span class=\"n\">thread</span><span class=\"p\">,</span> <span class=\"n\">wset</span><span class=\"p\">,</span> <span class=\"n\">cancellable</span> <span class=\"o\">=</span> <span class=\"kc\">True</span><span class=\"p\">)</span>\n      <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"n\">in_event_loop</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n      <span class=\"n\">inst</span><span class=\"o\">.</span><span class=\"n\">exclusive</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n      <span class=\"n\">event_code</span><span class=\"p\">,</span> <span class=\"n\">p1</span><span class=\"p\">,</span> <span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">event</span>\n      <span class=\"p\">[</span><span class=\"n\">packed</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">call_and_trap_on_throw</span><span class=\"p\">(</span><span class=\"n\">opts</span><span class=\"o\">.</span><span class=\"n\">callback</span><span class=\"p\">,</span> <span class=\"n\">thread</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">event_code</span><span class=\"p\">,</span> <span class=\"n\">p1</span><span class=\"p\">,</span> <span class=\"n\">p2</span><span class=\"p\">])</span>\n      <span class=\"n\">code</span><span class=\"p\">,</span><span class=\"n\">si</span> <span class=\"o\">=</span> <span class=\"n\">unpack_callback_result</span><span class=\"p\">(</span><span class=\"n\">packed</span><span class=\"p\">)</span>\n    <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">exit</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span>\n</code></pre></div>\n<p>And just start running the callback in a tight loop? somewhere else?</p>\n<p>Unless I'm reading it wrong (very possible!) progressing that subtask <em>is</em> going through that loop until we can get to <code>CallbackCode.EXIT</code>, and right now I'm stuck at <code>WAIT</code> because of the conditions of <code>wait_until</code> that will only be fulfilled once, essentially.</p>",
        "id": 558233669,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763565991
    },
    {
        "content": "<p>At a high level, the host is looping until all tasks exit.  In the case of this particular test, that will only happen once the host tasks representing calls to <code>local:local/sleep#sleep-millis</code> complete, at which point the caller of each host task will receive a <code>returned</code> event and exit.</p>",
        "id": 558235624,
        "sender_full_name": "Joel Dice",
        "timestamp": 1763566428
    },
    {
        "content": "<p>Again, though, any questions about the details of the Python code will have to be addressed by Luke.  I haven't studied it in detail.</p>",
        "id": 558235823,
        "sender_full_name": "Joel Dice",
        "timestamp": 1763566471
    },
    {
        "content": "<p>So in the Rust code, from what I can see is that it:</p>\n<ul>\n<li>breaks out of the loop of reading and interpreting results</li>\n<li>joins the guest waitable to the old set</li>\n<li>resets to the calling task</li>\n</ul>\n<p>This is fine, but if I'm correct, this means that the subtask that was reparented is now being called in <code>Store::poll_until</code> via <code>do_run_concurrent()</code> -- is that right? </p>\n<p>Assuming what I've said above is right (minus the creating new subtasks part early on!) the thing I was getting at is that there's nowhere in the spec that it notes to break out of that callback result interpretation loop bit and \"just\" run the subtask to completion.</p>",
        "id": 558239449,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763567271
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"598440\">@Victor Adossi</span> spec-wise, the way that subtasks \"keep running\" even after having returned their value to the caller is that that callback loop runs in a new <code>Thread</code> created at the end of <code>canon_lift</code> and the <code>Store</code> has a list of all threads that are waiting to run and it runs them (via <code>Store.tick</code>) until there are no more left (which, it sounds like, is what Wasmtime is doing too)</p>",
        "id": 558241321,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763567682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"598440\">Victor Adossi</span> <a href=\"#narrow/channel/219900-wasi/topic/Resolving.20subtasks.20after.20parent.20task.20return/near/558239449\">said</a>:</p>\n<blockquote>\n<p>This is fine, but if I'm correct, this means that the subtask that was reparented is now being called in <code>Store::poll_until</code> via <code>do_run_concurrent()</code> -- is that right?</p>\n</blockquote>\n<p>Yeah, once the subtask is inherited by the host, it and its subtasks become (or more accurately, <em>remain</em>) part of the general set of work-to-do stored in <code>ConcurrentState</code> and iterated on in <code>poll_until</code></p>",
        "id": 558241389,
        "sender_full_name": "Joel Dice",
        "timestamp": 1763567699
    },
    {
        "content": "<p>The way I could see this making sense in the current spec is if this was <code>Thread#resume</code> <em>but</em> the problem still stands that I don't see how you get out of that loop</p>",
        "id": 558241436,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763567705
    },
    {
        "content": "<p>Yup so <span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> this is what I'm doing, but my problem is how do you get out of that callback execution loop that I posted earlier -- it depends on having a pending event set on the subtask to keep executing it</p>",
        "id": 558241751,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763567781
    },
    {
        "content": "<p>The callback execution loop of a <code>Task</code> doesn't have any knowledge of a caller's <code>Subtask</code> (in fact, in the host-calls-component scenario, there <em>is</em> no caller <code>Subtask</code>)</p>",
        "id": 558242051,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763567836
    },
    {
        "content": "<p>My problem is that the spec makes it seem like the thread's work <em>is</em> that callback execution and result processing loop (until you get an <code>EventCode.EXIT</code>).</p>",
        "id": 558242132,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763567853
    },
    {
        "content": "<p>And yeah we're talking about a guest-&gt; guest call here</p>",
        "id": 558242188,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763567864
    },
    {
        "content": "<p>the host-call to the component exits immediately basically, and a guest-&gt;guest component call lingers in the background being executed</p>",
        "id": 558242306,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763567889
    },
    {
        "content": "<p>Yes, well, the thread's work is the callback execution.  The caller's <code>Subtask</code> isn't important; the callback execution loop just calls the <code>on_start</code> and <code>on_resolve</code> callbacks whenever it wants to and it's someone else's business of how to materialize the args and handle the results</p>",
        "id": 558242499,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763567928
    },
    {
        "content": "<p>The <code>canon_lift</code> for that guest-&gt;guest call dictates AFAICT that we call the callback until we get an exit</p>",
        "id": 558242550,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763567937
    },
    {
        "content": "<p>Correct</p>",
        "id": 558242606,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763567948
    },
    {
        "content": "<p>And in host-&gt;guest</p>",
        "id": 558242655,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763567958
    },
    {
        "content": "<p>Yup! So my problem is that I'm currently stuck in the <code>wait_until</code> branch</p>",
        "id": 558242719,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763567972
    },
    {
        "content": "<p>Because the only time we set a pending event is <code>on-start()</code> (the first time we start executing, that's good for ONE pass through the</p>",
        "id": 558242820,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763567994
    },
    {
        "content": "<p>And we'll never call <code>on_resolve()</code> because we never get to run the callback again and find out it's completed</p>",
        "id": 558242926,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763568011
    },
    {
        "content": "<p>Basically, there needs to be another call to <code>on_progress()</code> somewhere</p>",
        "id": 558243020,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763568029
    },
    {
        "content": "<p>as far as I can tell anyway. </p>\n<p>Once you look at the pending event (via function) once, it's wiped -- it gets reset to <code>None</code></p>",
        "id": 558243253,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763568079
    },
    {
        "content": "<p>Why isn't a <code>Waitable</code> in the <code>WaitableSet</code> passed to <code>wait_until</code> being set with a pending event?</p>",
        "id": 558243284,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763568084
    },
    {
        "content": "<p>That should happen independently of the callback loop that is waiting on the <code>WaitableSet</code></p>",
        "id": 558243452,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763568121
    },
    {
        "content": "<p>So the pending event is set once, due to <code>on_start()</code> being called (and resultingly <code>on_progress()</code></p>",
        "id": 558243484,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763568129
    },
    {
        "content": "<p>Ah sorry meeting! brb</p>",
        "id": 558243542,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763568141
    },
    {
        "content": "<p>It sounds like maybe you're conflating the <code>on_progress</code> events of a task A (which would be delivered to the <em>super</em>task of A) with the <code>on_progress</code> events of a <em>sub</em>task of A.  The callback loop of A can never be waiting on A's own events.</p>",
        "id": 558243988,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763568242
    },
    {
        "content": "<p>OK, meeting finished early -- I guess the first clarifying question I'd ask is what is the loop that the subtask is supposed to be in?</p>\n<p><code>canon_lower</code> <em>sets</em> the <code>Subtask</code>'s <code>callee</code> w/ <code>on_progress</code></p>",
        "id": 558245610,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763568592
    },
    {
        "content": "<p>I should say, <code>on_progress</code> via <code>on_start</code> and <code>on_resolve</code></p>",
        "id": 558245790,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763568633
    },
    {
        "content": "<p>This line: </p>\n<div class=\"codehilite\" data-code-language=\"Python\"><pre><span></span><code>   <span class=\"n\">subtask</span><span class=\"o\">.</span><span class=\"n\">callee</span> <span class=\"o\">=</span> <span class=\"n\">callee</span><span class=\"p\">(</span><span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"n\">task</span><span class=\"p\">,</span> <span class=\"n\">on_start</span><span class=\"p\">,</span> <span class=\"n\">on_resolve</span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 558245842,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763568646
    },
    {
        "content": "<p>Does <code>subtask.callee()</code> just get called in a loop somewhere? The <code>Subtask()</code> class does not seem to drive itself AFAICT -- so what I was understanding was that the <em>task</em>'s callback loop is what drives that to completion (I'll call this the \"callback &amp; check\" loop). </p>\n<p>The thread that is running all this <em>is running</em> that callback &amp; check loop (AFAICT)</p>",
        "id": 558246936,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763568880
    },
    {
        "content": "<p>So with what I have written now, here's what happens:</p>\n<ol start=\"0\">\n<li>\n<p>Host-&gt;Guest call runs, <code>task.return</code>s quickly, host gets a response.</p>\n<p>- The <code>Thread</code>'s run loop is still going (we haven't gotten a <code>CallbackCode.EXIT</code> yet)<br>\n  - AFTER the <code>task.return</code>, the <code>AsyncStartCall</code> for the guest-&gt;guest call starts </p>\n</li>\n<li>\n<p>The initial callback call returns the code <code>2</code> (i.e. wait) and the waitable rep to watch is <code>1</code>, the new <code>Subtask</code> itself</p>\n</li>\n<li><code>wait_until</code> spits out <code>{ code: State.Subtask, index: 1, result: 1 }</code>which makes sense because we have to wait for that spawned subtask, and the task is <code>STARTED</code> (<code>result</code>) -- the pending event fn was cleared for this</li>\n<li>The callback is run a second time, and returns the unpacked code <code>2</code> (wait) w/ waitable <code>1</code> (the subtask) -- this all makes sense</li>\n<li>We get into the <em>second</em> <code>wait_until()</code>, and the task will never resolve because we never re-set the pending event:</li>\n</ol>",
        "id": 558247488,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763568985
    },
    {
        "content": "<p>The line <code>subtask.callee = callee(thread.task, on_start, on_resolve)</code> runs <code>callee</code> in a separate <code>Thread</code> so it can run its own event loop (or not... it can run synchronously or, in the future, as a stackful coroutine) and call <code>on_start</code>/<code>on_resolve</code> either synchronously or at some point in the future</p>",
        "id": 558247880,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763569069
    },
    {
        "content": "<p>So in that sequence, after 4, what I'd expect is that the subtask (later, concurrently, from its own <code>Thread</code>) calls <code>on_resolve</code> which calls <code>on_progress</code> which re-sets the pending event on the <code>Subtask</code> and thus turns the waiting event loop</p>",
        "id": 558248650,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763569239
    },
    {
        "content": "<p>OK, so that looks to be the bit I'm missing -- maybe that <code>callee(...)</code> like should be <code>Store#invoke</code> ?</p>",
        "id": 558248899,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763569296
    },
    {
        "content": "<p>Also, it's not clear that spawns a new thread that just... calls the callee forever/what the loop governing that behavior should be</p>",
        "id": 558249007,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763569322
    },
    {
        "content": "<p>AH OK, I got it: </p>\n<blockquote>\n<p>Critically, calling a <code>FuncInst</code> never \"blocks\" (i.e., waits on I/O); if the callee <em>would</em> block, the <code>FuncInst</code> immediately returns a <code>Call</code> object representing the ongoing asynchronous and internally creates a <code>Thread</code> that can make progress via <code>Store.tick</code>.</p>\n</blockquote>",
        "id": 558250541,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763569644
    },
    {
        "content": "<p>Thanks, I think this is what I was missing -- the <code>Subtask</code> needs to start a completely separate <code>Thread</code> that  calls the callee repeatedly in a loop <em>and</em> calls the <code>on_start()</code> and <code>on_resolve()</code> hooks. </p>\n<p>So this line:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">subtask</span><span class=\"p\">.</span><span class=\"n\">callee</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">callee</span><span class=\"p\">(</span><span class=\"n\">thread</span><span class=\"p\">.</span><span class=\"n\">task</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">on_start</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">on_resolve</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>Is more like: </p>\n<ol>\n<li>Start new Thread (set super task to prevent re-entrance)</li>\n<li>In the body of the thread:<p>- Run <code>on_start()</code><br>\n  - Run <code>callee</code> in a tight loop... suspending after every one iteration? <br>\n  - once <code>callee</code> finished, run <code>on_resolve()</code></p>\n</li>\n</ol>",
        "id": 558252215,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763570048
    },
    {
        "content": "<p>Almost: <code>on_resolve</code> is called somewhere during the loop, and the loop keeps running until <code>EXIT</code> is returned</p>",
        "id": 558252613,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763570111
    },
    {
        "content": "<p>yes -- so the <code>on_resolve</code> would be called after <code>task.return</code> got called from the guest -&gt; guest call</p>",
        "id": 558252727,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763570138
    },
    {
        "content": "<p>I'm calling that \"once <code>callee</code> finished\"</p>",
        "id": 558252792,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763570153
    },
    {
        "content": "<p>I'd say that the <code>task.return</code> built-in synchronously calls <code>on_resolve</code> which sets a pending event on any guest caller's <code>Waitable</code> and also does all the lowering shenanigans (calling <code>realloc</code>, copying return values, etc)</p>",
        "id": 558253128,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763570249
    },
    {
        "content": "<p>OK yup, that's definitely how I understand it</p>",
        "id": 558253320,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763570300
    },
    {
        "content": "<p>One clarification as well though -- that \"tight loop\" is supposed to be interpreting the <code>callee</code> results as well, no?</p>",
        "id": 558253441,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763570335
    },
    {
        "content": "<p>How do you mean \"interpreting the <code>callee</code> results\"?</p>",
        "id": 558253789,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763570421
    },
    {
        "content": "<p>I meant similarly to the other callback and check loop -- so when in this other thread I call the <code>callee</code> (which is an async callback) I was thinking I should be unpacking that result</p>",
        "id": 558254347,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763570577
    },
    {
        "content": "<p>not the <code>task.return</code> result obviously the direct async status/code result</p>",
        "id": 558254429,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763570597
    },
    {
        "content": "<p>Ah, yes, the loop in that thread unpacks the <code>i32</code> return value of the lifted <code>callee</code> core function and the <code>callback</code> function (in a loop)</p>",
        "id": 558254753,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763570689
    },
    {
        "content": "<p>Yeah, so I basically need a second version of that loop in the new Thread</p>",
        "id": 558254817,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763570703
    },
    {
        "content": "<p>Yeah, there's one logical event loop per <code>async callback</code>-lifted function invocation</p>",
        "id": 558255195,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763570758
    },
    {
        "content": "<p>I had something similar before, but again this gets me to the problem of what <code>wait_until</code></p>",
        "id": 558255369,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763570795
    },
    {
        "content": "<p>When that new <code>Thread</code> gets called the first time, we call <code>on_start()</code> and set the pending event. </p>\n<p>IF inside the thread we're doing the callback &amp; check loop, we're going to get stuck, because only the first pending event will allow us to progress (the second time we enter the <code>wait_until</code> branch, there's no pending event). </p>\n<p>BUT if inside that loop we're <em>NOT</em> doing callback and check, and we're just running the callback, then in this case enough <code>tick</code>s will get it to eventually call <code>on_resolve()</code> (the component is just waiting a set amount of time)</p>",
        "id": 558255931,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763570937
    },
    {
        "content": "<blockquote>\n<p>When that new <code>Thread</code> gets called the first time, we call <code>on_start()</code> and set the pending event.</p>\n</blockquote>\n<p>Technically, the <code>Task.enter</code> hits backpressure, it can suspend before calling <code>on_start</code>, such that an <code>async</code> caller will receive a subtask in the initial <code>STARTING</code> state.</p>",
        "id": 558256654,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763571129
    },
    {
        "content": "<p>So I guess what I'm getting at is -- I think the <code>Thread</code> that <code>FuncInst</code> is supposed to create anew might need it's semantics spelled out -- it doesn't seem like the semantics should be the exact same as the Task</p>",
        "id": 558256761,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763571159
    },
    {
        "content": "<p>I don't follow this \"getting stuck\" case...</p>",
        "id": 558256798,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763571170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253998\">Luke Wagner</span> <a href=\"#narrow/channel/219900-wasi/topic/Resolving.20subtasks.20after.20parent.20task.20return/near/558256654\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>When that new <code>Thread</code> gets called the first time, we call <code>on_start()</code> and set the pending event.</p>\n</blockquote>\n<p>Technically, the <code>Task.enter</code> hits backpressure, it can suspend before calling <code>on_start</code>, such that an <code>async</code> caller will receive a subtask in the initial <code>STARTING</code> state.</p>\n</blockquote>\n<p>Ah I will keep this in mind</p>",
        "id": 558256817,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763571178
    },
    {
        "content": "<p>Ah, so OK, it's this flow: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"mf\">0.</span><span class=\"w\"> </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">initial</span><span class=\"w\"> </span><span class=\"n\">callback</span><span class=\"w\"> </span><span class=\"n\">call</span><span class=\"w\"> </span><span class=\"n\">returns</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"mi\">2</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">.</span><span class=\"n\">e</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">wait</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">waitable</span><span class=\"w\"> </span><span class=\"n\">rep</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">watch</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"mi\">1</span><span class=\"err\">`</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">Subtask</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">itself</span>\n\n<span class=\"mf\">1.</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">wait_until</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">spits</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">State</span><span class=\"p\">.</span><span class=\"n\">Subtask</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"err\">`</span><span class=\"n\">which</span><span class=\"w\"> </span><span class=\"n\">makes</span><span class=\"w\"> </span><span class=\"n\">sense</span><span class=\"w\"> </span><span class=\"n\">because</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"n\">have</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">wait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">that</span><span class=\"w\"> </span><span class=\"n\">spawned</span><span class=\"w\"> </span><span class=\"n\">subtask</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">task</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">STARTED</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"err\">`</span><span class=\"n\">result</span><span class=\"err\">`</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">pending</span><span class=\"w\"> </span><span class=\"n\">event</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">was</span><span class=\"w\"> </span><span class=\"n\">cleared</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">this</span>\n<span class=\"mf\">2.</span><span class=\"w\"> </span><span class=\"n\">The</span><span class=\"w\"> </span><span class=\"n\">callback</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">second</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">returns</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">unpacked</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"mi\">2</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">wait</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"n\">waitable</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"mi\">1</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">subtask</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">all</span><span class=\"w\"> </span><span class=\"n\">makes</span><span class=\"w\"> </span><span class=\"n\">sense</span>\n<span class=\"mf\">3.</span><span class=\"w\"> </span><span class=\"n\">We</span><span class=\"w\"> </span><span class=\"n\">get</span><span class=\"w\"> </span><span class=\"n\">into</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">second</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">wait_until</span><span class=\"p\">()</span><span class=\"err\">`</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">task</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">never</span><span class=\"w\"> </span><span class=\"n\">resolve</span><span class=\"w\"> </span><span class=\"n\">because</span><span class=\"w\"> </span><span class=\"n\">we</span><span class=\"w\"> </span><span class=\"n\">never</span><span class=\"w\"> </span><span class=\"n\">re</span><span class=\"o\">-</span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">pending</span><span class=\"w\"> </span><span class=\"n\">event</span><span class=\"p\">:</span>\n</code></pre></div>",
        "id": 558256903,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763571204
    },
    {
        "content": "<p>The semantics is spelled out by <code>canon_lift</code>: in guest-to-guest calls, <code>callee</code> is a curried <code>canon_lift</code> closure</p>",
        "id": 558256942,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763571214
    },
    {
        "content": "<p>I don't see why you're saying in step 3 that the pending event is never re-set... it gets re-set when <code>on_resolve</code> gets called by the subtask (at some point in time in the future)</p>",
        "id": 558257465,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763571358
    },
    {
        "content": "<p>Yup, that would make sense, and that is what makes me think that we need a similar \"callback &amp; check\" loop. </p>\n<p>The problem is, when I do the callback and check loop, I fall into the situation above. </p>\n<p>It seemed to me like wasmtime was just running the callback (I assume I am wrong here) until it completed, but I haven't seen exactly what they do for this case other than just calling the callback repeatedly/polling the future until it's done.</p>",
        "id": 558257471,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763571361
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253998\">Luke Wagner</span> <a href=\"#narrow/channel/219900-wasi/topic/Resolving.20subtasks.20after.20parent.20task.20return/near/558257465\">said</a>:</p>\n<blockquote>\n<p>I don't see why you're saying in step 3 that the pending event is never re-set... it gets re-set when <code>on_resolve</code> gets called by the subtask (at some point in time in the future)</p>\n</blockquote>\n<p>Hmmn, do you have time to get on a quick call? that might be higher bandwidth!</p>",
        "id": 558257643,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1763571412
    },
    {
        "content": "<p>(FWIW, I assume we're talking in the spec/Python terms, not how you're implementing this in JS)</p>",
        "id": 558257729,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763571426
    },
    {
        "content": "<p>Yeah, you bet</p>",
        "id": 558257740,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763571429
    },
    {
        "content": "<p>one sec...</p>",
        "id": 558257760,
        "sender_full_name": "Luke Wagner",
        "timestamp": 1763571432
    }
]