[
    {
        "content": "<p><a href=\"https://github.com/WebAssembly/component-model/issues/223#issuecomment-1664258641\">https://github.com/WebAssembly/component-model/issues/223#issuecomment-1664258641</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/issues/223#issuecomment-1664258641\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/60a059a034f6b2c12978a76bce06da8fa4acf8ee/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f376563303430343734336538346232333766663661626330396539653663373039393333646234306630383965646438316232396563376637323833633666632f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f6973737565732f323233&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/issues/223#issuecomment-1664258641\" title=\"Defining client callback type in WIT · Issue #223 · WebAssembly/component-model\">Defining client callback type in WIT · Issue #223 · WebAssembly/component-model</a></div><div class=\"message_embed_description\">I'm trying to define a component interface in WIT format so that components (client) can pass callbacks (closures) to host. Host can then store the callback somewhere and then invoke the callback w...</div></div></div>",
        "id": 535887188,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756020975
    },
    {
        "content": "<p>Sorry if this isn't a good format, I'm new here</p>",
        "id": 535887218,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756021008
    },
    {
        "content": "<p>I want to understand, why strictly reference counting? And can there be a way to prevent closures from referencing host resourses?</p>",
        "id": 535888247,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756022593
    },
    {
        "content": "<p>The problem seems to be when host references callback references host, making a circular dependency graph. It wouldn't be a callback if the host didn't reference it, so the other place to break the circle is preventing the callback from referencing the host.</p>",
        "id": 535888399,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756022783
    },
    {
        "content": "<p>In the example given, that translates to the JS callback not being able to reference the DOM node that registers it. Is that so bad?</p>",
        "id": 535888497,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756022930
    },
    {
        "content": "<p>i think one of the points is that it is hard to know what a JS callback references; it's not just textually what is in the closure, and not even specified on a language level.  (all implementations that i know of use a scope chain which may include objects not captured by the closure.)</p>",
        "id": 535965004,
        "sender_full_name": "Andy Wingo",
        "timestamp": 1756105304
    },
    {
        "content": "<p>but yes, there are a few ways to break the cycles, they are just annoying to do, and if there is a design pattern that doesn't have the tendency to make cycles, then it is better for the component model</p>",
        "id": 535965087,
        "sender_full_name": "Andy Wingo",
        "timestamp": 1756105351
    },
    {
        "content": "<p>In Rust, only stuff used in a closure get moved into the closure. It's unfortunate that JavaScript has this problem.</p>",
        "id": 535969025,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756107146
    },
    {
        "content": "<p>the component model needs to be agnostic of whatever language is compiled to the wasm modules inside the component (and also whatever language the host is implemented in), and it cant protect against anything it cant determine from the arguments passed to the canonical abi functions. the component model can't \"see\" into a module to determine whether or not the implementation of a closure contains cycles</p>",
        "id": 536054321,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1756136818
    },
    {
        "content": "<p>I have an idea. What if the spec disallowed callbacks from capturing the host resource, it's up to the various implementations to enforce that for their language, and the JS implementation does it by just punting on callbacks because of the scope chains? Thereby making this Javascript's problem, and not WASI's problem, such that you specifically can't register callbacks from JS.</p>",
        "id": 536103420,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756153950
    },
    {
        "content": "<p>Whereas for Rust, the tooling could detect the host resource being moved into the closure and only disallow that.</p>",
        "id": 536104030,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756154164
    },
    {
        "content": "<p>You could, however, still register callbacks <em>into</em> JS, because those callbacks could know they are not capturing the host.</p>",
        "id": 536104713,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756154420
    },
    {
        "content": "<p>So overall, JS would struggle to produce its own callbacks because of scope chains, but it could still easily work with callbacks from elsewhere.</p>",
        "id": 536105401,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756154648
    },
    {
        "content": "<p>Then in the future, if a JS implementation figures out how to adhere to the spec less bluntly, that would be all it takes for JS to produce callbacks.</p>",
        "id": 536105838,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756154832
    },
    {
        "content": "<p>in general we don't design features that only work in some languages and not others, one of the big ideas of the component model is that its an abstraction boundary where one side of an interface doesn't know or care what language the implementation on the other side of the interface is written in</p>",
        "id": 536112110,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1756157313
    },
    {
        "content": "<p>I understand that. I don't think my idea makes one side know or care what the other side is written in. Only a component developer would have to care, if they were working with JS and were met with \"sorry we don't know how to determine that your callback does not reference the host.\" The choice around my idea boils down to, should we let JS's difficulties keep everyone else from having the feature as well?</p>",
        "id": 536122009,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756162656
    },
    {
        "content": "<p>Of course, if there was a way for JS to be included that would be ideal, but it seems to me that scope chains pose a fundamental difficulty here and it sucks for other languages to be burdened with that. It feels like right now, no one gets to have callbacks because a component <em>might</em> be Javascript, which doesn't quite feel in the spirit of language agnostic. I would rather have callbacks for as many languages as possible, than not at all because one language struggles with it.</p>",
        "id": 536123670,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756163636
    },
    {
        "content": "<p>I'll put it another way: if the JS implementation was ever gonna support WASI callbacks, it would probably have to work something like this out first regardless, because closures capturing entire scope chains seems inherently problematic in this context. WASI callbacks, if we ever get them, should capture as little as possible. So, should the other languages be made to wait for JS, or can we let them have callbacks in the meantime while JS works it out?</p>",
        "id": 536126014,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756165015
    },
    {
        "content": "<p>For context, my motivation is I want to make a UI engine centering WASM, and part of that is a signals engine inspired by SolidJS and Svelte. I need callbacks for the declaration of memos and effects, which to the best of my knowledge never need to reference their host, the signal engine.</p>",
        "id": 536137699,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756172779
    },
    {
        "content": "<p>can you implement signals in terms of futures or streams?</p>",
        "id": 536176412,
        "sender_full_name": "Andy Wingo",
        "timestamp": 1756193764
    },
    {
        "content": "<p>I'd have to think on it. The basic requirement is telling the engine \"do this whenever one of the signal dependencies updates\". It must be declared by the component, but registered by the engine so the engine can invoke it later. I can't specify it as a regular function in the WIT because a component might declare arbitrarily many memos and effects, and I don't want the interface to limit a component to just one.</p>",
        "id": 536198852,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756201430
    },
    {
        "content": "<p>I think probably the answer is no, because the engine has to invoke them, ideally synchronously. Whereas, futures and streams both have their execution driven by the component that owns them.</p>",
        "id": 536199304,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756201586
    },
    {
        "content": "<p>well, just spitballing here, if it's the sort of thing that doesn't need synchronous execution, streams sound great, and if it does need synchronous execution, i wonder if the framework could pass the writer side of a future in the stream and then wait on the reader side.</p>",
        "id": 536225823,
        "sender_full_name": "Andy Wingo",
        "timestamp": 1756211490
    },
    {
        "content": "<p>the engine could transfer control directly to the stream reader (signal consumer) and then directly back if the consumer fulfilled the promise synchronously</p>",
        "id": 536226130,
        "sender_full_name": "Andy Wingo",
        "timestamp": 1756211591
    },
    {
        "content": "<p>Good suggestions. I think I need to study how async will work. For instance, will futures and streams all share a single wasm async runtime, or will some languages bring their own?</p>",
        "id": 536296051,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756234762
    },
    {
        "content": "<p>In a sense, the async runtime is provided by the host, given that it's the one responsible for starting and resuming tasks, dispatching events, etc.  And a guest must return control to the host in order to allow other tasks to run (i.e. this is not preemptive multithreading we're talking about; that will be a separate project).</p>\n<p>So yes, all async tasks, futures, and streams are backed by a single runtime in the host, but each guest language will have an appropriate abstraction on top of the raw intrinsic operations implemented by the host, and that will be responsible for bridging those low-level operations to the higher-level idioms of the language (e.g. async/await in JS, Rust, Python, and C#; goroutines in Go; virtual threads in Java; etc.).  That abstraction might need to do non-trivial things, so you could consider it a guest-level runtime on top of the host-level runtime.</p>",
        "id": 536298038,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756235681
    },
    {
        "content": "<p>Today's breakthrough: My signal engine should register components as signal subscribers, rather than individual memos and effects. I'm still working out the details, but I think this makes sense. What I've worked out so far is components need to be able to register signals with the engine by creating streams and passing the reader to the signal engine so the engine can propagate updates, and also they need to be able to subscribe to signals from the engine, which will prompt the engine to create a new stream, subscribe its writer to the designated signal, and return its reader to the component. From there, I think these mechanisms should plug into a component's internal signals library.</p>",
        "id": 536336275,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756259865
    },
    {
        "content": "<p>On the engine's part, it needs to receive and store stream readers, subscribe new stream writers to them, and pass readers to the components requesting them.</p>",
        "id": 536336396,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756259992
    },
    {
        "content": "<p>A signal, in the engine, will consist of one stream reader and a collection of subscribed stream writers. The engine will pass on everything from the reader to all of the writers. In the end, a WASI signal engine is basically a stream mediator.</p>",
        "id": 536336586,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756260139
    },
    {
        "content": "<p>A key insight is that a component should only have one stream reader for a given foreign signal, meaning from the signal's pov, every subscribed stream corresponds to a single component.</p>",
        "id": 536337181,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756260739
    },
    {
        "content": "<p>Normally, a signal library implicitly subscribes to a signal the first time its getter is called with a global variable holding the context. This works for native signals, but foreign signals must be brought into scope before they can be used, which makes that the natural time to create the subscription instead.</p>",
        "id": 536337396,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756260955
    },
    {
        "content": "<p>It's looking like this will result in a component's internal signals library needing a new signal type in addition to signal, memo, and effect for this kind of foreign signal.</p>",
        "id": 536337555,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756261138
    },
    {
        "content": "<p>I prototyped out a possible importSignal() function. Not sure what the stream API will actually look like in JS though</p>\n<div class=\"codehilite\" data-code-language=\"JavaScript\"><pre><span></span><code><span class=\"kd\">function</span><span class=\"w\"> </span><span class=\"nx\">importSignal</span><span class=\"p\">(</span><span class=\"nx\">id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nx\">stream</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nx\">Engine</span><span class=\"p\">.</span><span class=\"nx\">subscribe</span><span class=\"p\">(</span><span class=\"nx\">id</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"kd\">const</span><span class=\"w\"> </span><span class=\"nx\">observers</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[];</span>\n<span class=\"w\">  </span><span class=\"kd\">const</span><span class=\"w\"> </span><span class=\"nx\">getter</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nx\">current</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"nx\">observers</span><span class=\"p\">.</span><span class=\"nx\">includes</span><span class=\"p\">(</span><span class=\"nx\">current</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">      </span><span class=\"nx\">observers</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"nx\">current</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nx\">stream</span><span class=\"p\">.</span><span class=\"nx\">pop</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// Guessing at stream API</span>\n<span class=\"w\">  </span><span class=\"p\">};</span>\n<span class=\"w\">  </span><span class=\"c1\">// Extra logic needed for calling all the observers on a stream event.</span>\n<span class=\"w\">  </span><span class=\"c1\">// Depends on stream API.</span>\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nx\">getter</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 536348341,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756271531
    },
    {
        "content": "<p>Say, are there any plans to support generics in WIT? I sure would like to let Engine.subscribe() here return stream&lt;T&gt;.</p>",
        "id": 536348566,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1756271726
    },
    {
        "content": "<p>Some discussion here: <a href=\"https://github.com/WebAssembly/component-model/issues/543\">https://github.com/WebAssembly/component-model/issues/543</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/issues/543\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/b7834331d7136d62ca1ae6ae5fd042e629aad697/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f613530386464303339613338613461663861316165353730656234383562613531623034666532656137306365353535616338346363353364333365633262372f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f6973737565732f353433&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/issues/543\" title=\"User-defined generic types (parametric polymorphism) · Issue #543 · WebAssembly/component-model\">User-defined generic types (parametric polymorphism) · Issue #543 · WebAssembly/component-model</a></div><div class=\"message_embed_description\">Doing a search in the github issues, I have yet to see a ticket where anyone has explicitly asked for this yet. Apparently, there has been discussion on something similar to this, but from what I c...</div></div></div>",
        "id": 536411123,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756298453
    }
]