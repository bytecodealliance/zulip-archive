[
    {
        "content": "<p>with recent spec changes, 0-length stream writes are used to await \"readiness\" and, from what I understand, the expectation is that a non-zero-length write following a 0-length write is non-blocking. This works great for e.g. TCP sockets that have a well-defined and clear way of querying the readiness, however, how is this feature expected to be implemented for files and/or stdio?<br>\nIt appears that the only way to provide this functionality in the host would be buffering the data in the host and have a dedicated worker thread/task performing I/O</p>\n<p>With this approach <code>stream.write</code> returning would not guarantee that the data has reached the kernel. In case of stdio, for example, that would mean that <code>println(\"hello, world\")</code> returning does not guarantee that <code>\"hello, world\"</code> has even attempted to be written to the terminal.</p>\n<p><code>wasi:filesystem</code> defines <code>sync</code>, which seems to be the place where we could hook in to <em>await</em> the \"flush\" of file worker's buffer, but we would need to introduce a similar construct to <code>wasi:cli</code>.</p>\n<p>Personally, I have been under impression that we wanted to avoid buffering in the host - and if so, how would we implement the expected behavior for 0-length writes?</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> <span class=\"user-mention\" data-user-id=\"509936\">@Joel Dice</span> </p>\n<p>related:</p>\n<ul>\n<li><a href=\"https://github.com/WebAssembly/component-model/pull/444\">https://github.com/WebAssembly/component-model/pull/444</a></li>\n<li><a href=\"https://github.com/WebAssembly/component-model/issues/441\">https://github.com/WebAssembly/component-model/issues/441</a></li>\n<li><a href=\"https://github.com/bytecodealliance/wasmtime/pull/11515#issuecomment-3233723027\">https://github.com/bytecodealliance/wasmtime/pull/11515#issuecomment-3233723027</a></li>\n</ul>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/pull/444\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/82340290550f5fd0d79f50d2631b6c9bfefeb09e/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f303365396164623861646536653933393566396438393930383962336361613963316430303437623530353364626338366365643630366236303462373630382f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f70756c6c2f343434&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/pull/444\" title=\"Allow stream.{read,write}s of length 0 to query/signal readiness by lukewagner · Pull Request #444 · WebAssembly/component-model\">Allow stream.{read,write}s of length 0 to query/signal readiness by lukewagner · Pull Request #444 · WebAssembly/component-model</a></div><div class=\"message_embed_description\">This PR relaxes the rules for stream.{read,write} to accept lengths of 0.  This can be useful for signalling and querying readiness which in turn can be used to implement non-blocking POSIX operati...</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/issues/441\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/7de654900cdfd419ea9c7962aff36b8223c7bf56/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f646436636237306532323764393665323231633335336230336562316634666366663233366330366132323662326638653964353538313264623834353333652f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f6973737565732f343431&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/issues/441\" title=\"How to implement non-blocking POSIX `send` in terms of `stream.write`? · Issue #441 · WebAssembly/component-model\">How to implement non-blocking POSIX `send` in terms of `stream.write`? · Issue #441 · WebAssembly/component-model</a></div><div class=\"message_embed_description\">Am I correct to say that: when stream.write returns BLOCKED, it continues to have access to the provided memory buffer until the write either finishes or is canceled? If so, does this mean wasi-lib...</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/11515#issuecomment-3233723027\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/c396da18a524708d5613f1d2bc625163bc97d933/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f373835313032363263653038343737363037366363316666646538663066393830306133653133656365376538356238646663313363613732323834646235322f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3131353135&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/11515#issuecomment-3233723027\" title=\"Revamp component model stream/future host API (again) by dicej · Pull Request #11515 · bytecodealliance/wasmtime\">Revamp component model stream/future host API (again) by dicej · Pull Request #11515 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">This changes the host APIs for dealing with futures and streams from a &quot;rendezvous&quot;-style API to a callback-oriented one.\nPreviously you would create e.g. a StreamReader/StreamWriter pair...</div></div></div>",
        "id": 536625023,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756392796
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> <span class=\"user-mention\" data-user-id=\"378155\">@Dave Bakker (badeend)</span>, who came up with the zero-length read/write semantics, I believe.</p>",
        "id": 536627036,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756393342
    },
    {
        "content": "<p>Does <code>AsyncWrite::poll_write(..., &amp;[])</code> not await readiness for files or stdout?</p>",
        "id": 536632312,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756394688
    },
    {
        "content": "<p>it appears that at least for files it actually might <a href=\"https://github.com/tokio-rs/tokio/blob/925c614c89d0a26777a334612e2ed6ad0e7935c3/tokio/src/fs/file.rs#L721-L791\">https://github.com/tokio-rs/tokio/blob/925c614c89d0a26777a334612e2ed6ad0e7935c3/tokio/src/fs/file.rs#L721-L791</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/tokio-rs/tokio/blob/925c614c89d0a26777a334612e2ed6ad0e7935c3/tokio/src/fs/file.rs#L721-L791\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/c643aaa3ca3d4a98bba8203143ae34fd752632b9/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f313837363164383038663333653664636661303935636564623663613261303864623762383636333033343562383033343235396264326465613931373031612f746f6b696f2d72732f746f6b696f&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/tokio-rs/tokio/blob/925c614c89d0a26777a334612e2ed6ad0e7935c3/tokio/src/fs/file.rs#L721-L791\" title=\"tokio/tokio/src/fs/file.rs at 925c614c89d0a26777a334612e2ed6ad0e7935c3 · tokio-rs/tokio\">tokio/tokio/src/fs/file.rs at 925c614c89d0a26777a334612e2ed6ad0e7935c3 · tokio-rs/tokio</a></div><div class=\"message_embed_description\">A runtime for writing reliable asynchronous applications with Rust. Provides I/O, networking, scheduling, timers, ... - tokio-rs/tokio</div></div></div>",
        "id": 536632900,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756394860
    },
    {
        "content": "<p>It appears to buffer by default, but maybe that is <del>complete</del> ready enough from a guest's perspective?</p>",
        "id": 536633479,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756395030
    },
    {
        "content": "<p>I've just had a quick chat with <span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> about it and it appears that only 0-length reads are expected to have these semantics, 0-length writes to files/stdio are free to return immediately</p>\n<p>I think the empty <code>poll_write</code> is certainly \"good enough\"</p>",
        "id": 536633945,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756395161
    }
]