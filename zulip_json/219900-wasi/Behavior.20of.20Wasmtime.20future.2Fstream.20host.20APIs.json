[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"509936\">@Joel Dice</span> <span class=\"user-mention\" data-user-id=\"484032\">@Roman Volosatovs</span> <span class=\"user-mention\" data-user-id=\"480579\">@Lann Martin</span> continuing our conversation of <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11515\">https://github.com/bytecodealliance/wasmtime/pull/11515</a> over here.</p>\n<p>Sounds like y'all were thinking of leaning towards when a value is taken from <code>Source</code> that you're not allowed to return pending, but I wanted to push back on that. Sounds like Joel's also having second thoughts though so I'll let him copy them here</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/11515\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/48d69a71353dafd4607040facf3c235a1dc71fbf/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f363963336332393064346633343233616233613665636366316564366134346264343064346339303564386239653637333931356638653861383332303234332f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3131353135&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/11515\" title=\"Revamp component model stream/future host API (again) by dicej · Pull Request #11515 · bytecodealliance/wasmtime\">Revamp component model stream/future host API (again) by dicej · Pull Request #11515 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">This changes the host APIs for dealing with futures and streams from a &quot;rendezvous&quot;-style API to a callback-oriented one.\nPreviously you would create e.g. a StreamReader/StreamWriter pair...</div></div></div>",
        "id": 536821471,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756483863
    },
    {
        "content": "<p>Yeah, so I've sketched out yet another revision of the public API for managing the read and write ends of streams in Wasmtime <a href=\"https://gist.github.com/dicej/3d0fead64faa2432f5c673cd7098f2ab\">here</a> based on feedback from Roman as he's updating <code>wasmtime-wasi</code>'s p3 support to use it.  Overall, we're pretty happy with it, but still wrestling a bit with what it means to send a <code>COMPLETED</code> event for a <code>stream.write</code>.</p>\n<p>There are two possible interpretations of such an event:</p>\n<ol>\n<li>The reader has consumed N items from the write buffer, meaning they're no longer the writer's responsibility.</li>\n<li>In addition to #1, the reader has forwarded those N items on to wherever they were headed, e.g. the network or a file or whatever.</li>\n</ol>\n<p>If you go with #1, that means that <code>StreamConsumer::poll_consume</code> should return <code>Poll::Ready(_)</code> immediately upon taking one or more items, thereby allowing the runtime to promptly deliver the <code>COMPLETED</code> event to the writer so it knows what happened.  Alternatively, if you go with #2, it's reasonable for <code>StreamConsumer::poll_consume</code> to return <code>Poll::Pending</code> after taking one more more items, since the <code>COMPLETED</code> event should not be delivered until the items have been forwarded on to their destination.  That opens the possibility for the writer to cancel the write after the items have been consumed but before forwarding has finished.  In that case the consumer could just let it complete without interrupting, and that's probably what it <em>should</em> do since there's no way to give any of the items back to the writer at that point.</p>\n<p>It gets tricky, though, if not all the items can be forwarded before the destination is closed.  At that point we have no way to say \"I consumed N items, but was only able to forward a subset M &lt; N to the destination\".  Or at best, that would need to be communicated out-of-band.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://gist.github.com/dicej/3d0fead64faa2432f5c673cd7098f2ab\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/91f9baed8f4fc08c462d1a4de5a8c23942d45e97/68747470733a2f2f6769746875622e6769746875626173736574732e636f6d2f6173736574732f676973742d6f672d696d6167652d3534666437646330373133652e706e67&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://gist.github.com/dicej/3d0fead64faa2432f5c673cd7098f2ab\" title=\"Streams API Draft\">Streams API Draft</a></div><div class=\"message_embed_description\">Streams API Draft. GitHub Gist: instantly share code, notes, and snippets.</div></div></div>",
        "id": 536823707,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756484673
    },
    {
        "content": "<p>The good news is that we can \"cheat\" for <code>stream&lt;u8&gt;</code> (and perhaps other primitive types) since we can allow the consumer to \"peek\" at the writer's buffer without marking the bytes consumed until it knows they've been forwarded.  But for other payload types (e.g. resources), the consumer can't get access to the items without irreversibly consuming them.</p>",
        "id": 536824129,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756484819
    },
    {
        "content": "<p>I feel like this is a bit entangled and I'd like to say instead that <code>Source</code> passed to <code>StreamConsumer</code> is exclusively in charge of keeping track what to return to wasm. I think though that acquiring an item to send and sending back a notification \"it's done\" should be orthogonal operations. So for example:</p>\n<ul>\n<li>Implementations are required, once they get an item from <code>Source</code>, that they're solely responsible for it. It's up to the implementation to do its best, even in the face of cancellation from the guest, to send that value along.</li>\n<li>Guests can be arbitrarily blocked during writes as long as the host wants after it's taken  an item out since the host gets to decide when to wake up the guest.</li>\n</ul>\n<p>The exact meaning of what happens during cancellation sort of depends on what happens after it. The host is responsible for sending along the values it took out still, so if the guest continues to do more writes then I'd expect the host to apply backpressure and not read anything further from a <code>Source</code> until the previous write completes. If the guest just closes the stream then the host can sort of do whatever it wants and just shut down everything</p>",
        "id": 536824634,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756484970
    },
    {
        "content": "<p>Basically I don't think it's possible for us to provide a super strict and/or automatic and/or smooth experience on either side to provide ironclad guarantees about what happened where for every possible aspect. What we're left with is a strict boundary of \"the value was sent or not\" and that's the most we can say. Further operations on a stream like flush/close/etc can then be used to provide more guarantees about previously sent values</p>",
        "id": 536824841,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485037
    },
    {
        "content": "<p>In a sense a higher level protocol and/or more flushing/closing/etc primitives are going to be required to fully learn about what just happened with the sent values</p>",
        "id": 536824915,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485056
    },
    {
        "content": "<p>It's like as we've said before, just b/c you write to the kernel doesn't mean it's going to make it to the client on the other end of the world</p>",
        "id": 536824984,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485076
    },
    {
        "content": "<p>the guarantee the kernel provides is that if you write more data it's going to come after the prior data</p>",
        "id": 536825031,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485091
    },
    {
        "content": "<p>Yeah, I'm thinking the same thing.  So, concretely, you're in favor of letting <code>StreamConsumer::poll_consume</code> return <code>Poll::Pending</code> after having taken items from <code>source</code> to apply backpressure to the writer, but regardless of what happens after that (e.g. maybe they're all forwarded to the destination or maybe not), we'll end up sending <code>COMPLETED</code> with the count of items taken from <code>source</code>, correct?</p>",
        "id": 536825413,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756485233
    },
    {
        "content": "<p>correct</p>",
        "id": 536825453,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485247
    },
    {
        "content": "<p>and documenting that using <code>Source</code> is tricky and subtle</p>",
        "id": 536825504,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485267
    },
    {
        "content": "<p>And if the writer needs to know how many actually made it to the destination, that will need to be communicated out-of-band, e.g. via another future.</p>",
        "id": 536825507,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756485268
    },
    {
        "content": "<p>effectively yeah</p>",
        "id": 536825534,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485281
    },
    {
        "content": "<p>or we add some sort of flush operation to streams or something like that</p>",
        "id": 536825569,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485291
    },
    {
        "content": "<p>where the flush would wait for the item to be fully sent</p>",
        "id": 536825592,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485300
    },
    {
        "content": "<p>(but even that's ambiguous, it made it to the kernel, now what?)</p>",
        "id": 536825624,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485310
    },
    {
        "content": "<p>so in some sense I think truly knowing what made it where requires something higher level at the protocol/WIT layer that we can't be responsible for at the runtime layer</p>",
        "id": 536825678,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485333
    },
    {
        "content": "<p>Yeah, and that's especially true for guest-&gt;guest writes, in which case the host can't possibly know what happened after the reader took responsibility  for the items.</p>",
        "id": 536825985,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756485448
    },
    {
        "content": "<p>but we're also reflecting what (future) guests can do where they can acknowledge the write and then later say 'ok I took N items'</p>",
        "id": 536826052,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485478
    },
    {
        "content": "<p>or... something like that</p>",
        "id": 536826070,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485486
    },
    {
        "content": "<p>Like, \"remember those N items I took?  Well I just finished forwarding them on\", or \"I forwarded M of them, but then the upstream destination closed on me, sorry\"</p>",
        "id": 536826256,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756485552
    },
    {
        "content": "<p>right</p>",
        "id": 536826291,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485565
    },
    {
        "content": "<p>The other thing to consider is that, by letting <code>StreamConsumer::poll_consume</code> take items from <code>source</code> and return <code>Poll::Pending</code>, we're letting the host do something that a guest can't do: consume items but delay telling the writer they've been consumed.  It's kind of a non-virtualizable host superpower and arguably not \"fair\".</p>",
        "id": 536826820,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756485756
    },
    {
        "content": "<p>oh that's what I meant about future wasm</p>",
        "id": 536826880,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485783
    },
    {
        "content": "<p>ah, I see now</p>",
        "id": 536826905,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756485795
    },
    {
        "content": "<p>I forget the comment but Dan made it on some repo somewhere</p>",
        "id": 536826932,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485807
    },
    {
        "content": "<p><a href=\"https://github.com/WebAssembly/wasi-cli/issues/65#issuecomment-3169429925\">https://github.com/WebAssembly/wasi-cli/issues/65#issuecomment-3169429925</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/wasi-cli/issues/65#issuecomment-3169429925\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/a83305d535bfeb094c34a59d65dbbb37da20c84b/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633366306337623265356536303839356133313032353661393964373263363564303639336331633435626330623962656466326363643461343637306362632f576562417373656d626c792f776173692d636c692f6973737565732f3635&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/wasi-cli/issues/65#issuecomment-3169429925\" title=\"[0.3.0-draft]: Move away from streams as an API? · Issue #65 · WebAssembly/wasi-cli\">[0.3.0-draft]: Move away from streams as an API? · Issue #65 · WebAssembly/wasi-cli</a></div><div class=\"message_embed_description\">I'd like to propose a possible radical restructuring of stdin/stdout/stderr and how they're modeled for 0.3.0. Specifically something like this for 0.3.0: interface stdin { read: async func(amount:...</div></div></div>",
        "id": 536826980,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485826
    },
    {
        "content": "<p>I guess I'm making a distinction between three separate steps:</p>\n<ol>\n<li>reader consumes items</li>\n<li>reader tells writer it has consumed items</li>\n<li>reader tells writer what the ultimate fate of those items where (e.g. how many reached the destination)</li>\n</ol>",
        "id": 536827059,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756485867
    },
    {
        "content": "<p>I think what you suggested above covers 1 and 3, but not 2, correct?</p>",
        "id": 536827124,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756485889
    },
    {
        "content": "<p>i.e. a guest reader can't separate 1 and 2 into distinct steps with an arbitrary delay between them</p>",
        "id": 536827220,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756485921
    },
    {
        "content": "<p>not quite, today you're right a guest receiving a write is required to bundle 1/2, and I'm saying let's assume in the future the guest can split 1/2 and I'm saying that the host should be able to split 1/2 today</p>",
        "id": 536827350,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485968
    },
    {
        "content": "<p>and (3) is left to higher-level protocols</p>",
        "id": 536827375,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485975
    },
    {
        "content": "<p>ok, got it</p>",
        "id": 536827411,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756485989
    },
    {
        "content": "<p>If we consider TCP for example ultimately I don't know what to even do about (3)</p>",
        "id": 536827435,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756485998
    },
    {
        "content": "<p>at most we can delay (2) to \"ok the kernel syscall completed\"</p>",
        "id": 536827447,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486006
    },
    {
        "content": "<p>but I don't even know how to implement something further than that</p>",
        "id": 536827464,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486013
    },
    {
        "content": "<p>Presumably, e.g. a database client library will wait for an ack from the remote peer before saying e.g. a transaction is complete.  So yeah, anything beyond handing bytes to the kernel is solidly an application-level concern, IMO.</p>",
        "id": 536827730,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756486126
    },
    {
        "content": "<p>Usually TCP ACKs aren't even useful to applications; there are too many middle boxes out there to rely on it for much of anything.</p>",
        "id": 536827837,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756486168
    },
    {
        "content": "<p>It's buffers all the way down.</p>",
        "id": 536827912,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756486199
    },
    {
        "content": "<p>yeah, I guess I meant a DB-protocol-level ack</p>",
        "id": 536827929,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756486206
    },
    {
        "content": "<p>yeah I was asynchronously replying to \"what to do about TCP\" <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 536828031,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756486250
    },
    {
        "content": "<p>my point there though is that even for the most basic streams we can guarantee nothing about (3)</p>",
        "id": 536828145,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486292
    },
    {
        "content": "<p>(\"the ultimate fate of the items\")</p>",
        "id": 536828162,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486300
    },
    {
        "content": "<p>so IMO we just can't attempt to do anything beyond providing the guarantee \"this is someone else's problem now\"</p>",
        "id": 536828205,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486317
    },
    {
        "content": "<p>and that's what I mean about something in a higher level protocol, e.g. you wait for a read on something else after you write to confirm your bytes were sent</p>",
        "id": 536828279,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486345
    },
    {
        "content": "<p>right, but we <em>can</em> know if the upstream destination explicitly closed on us and definitely did <em>not</em> accept a subset of the items</p>",
        "id": 536828317,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756486360
    },
    {
        "content": "<p>Jumping late into the conversation!</p>\n<p>Personally, I would prefer for consumers to be able to return <code>Poll::Pending</code> <em>after</em> reading items.<br>\nSome implementations (like e.g. <code>wasi:filesystem</code> currently) might require to <em>move</em> values, e.g. to operate on them in a separate thread.<br>\nWith the current design, <em>peeking</em> into byte buffers is allowed, so the consumer can then clone that buffer and eventually \"mark\" the bytes read once it receives a signal from the thread.</p>\n<p>It appears that this covers WASI needs, but I think it's important to have this use case work in general case. I also imagine that it would be the least surprising behavior, which would align well with other similar constructs in Rust. That said, if necessary, I think it also makes sense to <em>only</em> allow this for byte buffers for MVP and relaxing this requirement it in the future.</p>",
        "id": 536828361,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756486381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"509936\">Joel Dice</span> <a href=\"#narrow/channel/219900-wasi/topic/Behavior.20of.20Wasmtime.20future.2Fstream.20host.20APIs/near/536828317\">said</a>:</p>\n<blockquote>\n<p>right, but we <em>can</em> know if the upstream destination explicitly closed on us and definitely did <em>not</em> accept a subset of the items</p>\n</blockquote>\n<p>for specific cases perhaps, but not in the general case?</p>",
        "id": 536828401,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486397
    },
    {
        "content": "<p>sure; either way we're agreed that this is an application-level concern</p>",
        "id": 536828507,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756486437
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"484032\">@Roman Volosatovs</span> I agree with you yeah, basically returning pending after \"officially\" reading an item should be allowed in wasmtime</p>",
        "id": 536828553,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486459
    },
    {
        "content": "<p>the consequence is that the implementation is quite a bit more complicated since now you're juggling something the guest thinks is done, but I think that's just a fact of life</p>",
        "id": 536828604,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486481
    },
    {
        "content": "<p>Yeah, <span class=\"user-mention\" data-user-id=\"484032\">@Roman Volosatovs</span> I think we're all on board with that; I'll update the gist</p>",
        "id": 536828656,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756486508
    },
    {
        "content": "<p>Is this adequately addressed in the async explainer?</p>",
        "id": 536828908,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756486612
    },
    {
        "content": "<p>sort of, but probably not what you're looking for</p>",
        "id": 536829015,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486650
    },
    {
        "content": "<p>For TCP we can actually be smarter and use various platform-specific things to query the kernel unsent buffer size to figure out how many bytes can we <em>actually</em> write without blocking. I've left a note about that in the implementation: <a href=\"https://github.com/bytecodealliance/wasmtime/blob/f7ff95747a6e2515c1a5b7a697794e5cc002e6f5/crates/wasi/src/p3/sockets/host/types/tcp.rs#L224-L266\">https://github.com/bytecodealliance/wasmtime/blob/f7ff95747a6e2515c1a5b7a697794e5cc002e6f5/crates/wasi/src/p3/sockets/host/types/tcp.rs#L224-L266</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/f7ff95747a6e2515c1a5b7a697794e5cc002e6f5/crates/wasi/src/p3/sockets/host/types/tcp.rs#L224-L266\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/65f86235aaee2f74ab1c91f9895d8e2ef8c925a7/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f636566326437643666616533356636613836353635646264303933346363376265663839386132303637656433346565353563373861636332353339393130372f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/f7ff95747a6e2515c1a5b7a697794e5cc002e6f5/crates/wasi/src/p3/sockets/host/types/tcp.rs#L224-L266\" title=\"wasmtime/crates/wasi/src/p3/sockets/host/types/tcp.rs at f7ff95747a6e2515c1a5b7a697794e5cc002e6f5 · bytecodealliance/wasmtime\">wasmtime/crates/wasi/src/p3/sockets/host/types/tcp.rs at f7ff95747a6e2515c1a5b7a697794e5cc002e6f5 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>",
        "id": 536829023,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756486653
    },
    {
        "content": "<p>Right its sort of addressed by omission</p>",
        "id": 536829047,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756486663
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"480579\">Lann Martin</span> <a href=\"#narrow/channel/219900-wasi/topic/Behavior.20of.20Wasmtime.20future.2Fstream.20host.20APIs/near/536828908\">said</a>:</p>\n<blockquote>\n<p>Is this adequately addressed in the async explainer?</p>\n</blockquote>\n<p>the explainer says what happens between guests, and it's very clear what happens there, which is that it's a \"rendezvous\" and nothing else.</p>\n<p>In that sense it's quite clear about this. It does not dive into the implications of this, however.</p>",
        "id": 536829112,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486693
    },
    {
        "content": "<p>arguably that's not what the explainer should do though (but maybe some other place should? unsure)</p>",
        "id": 536829150,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486706
    },
    {
        "content": "<p>I guess probably the doc comments of what Joel is working on?</p>",
        "id": 536829229,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756486731
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"484032\">@Roman Volosatovs</span> if we wanted to spec something like a hard guaratnee for WASI or component model things we'd have to be able to guarantee that for all platforms and all WASI things</p>",
        "id": 536829335,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486771
    },
    {
        "content": "<p>so what you describe I think might make sense as a WASI-specific method but not a stream thing per-se</p>",
        "id": 536829375,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486787
    },
    {
        "content": "<p>And for docs it probably makes sense to thoroughly document in WASI what it means to write/read from streams</p>",
        "id": 536829436,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486805
    },
    {
        "content": "<blockquote>\n<p>the consequence is that the implementation is quite a bit more complicated since now you're juggling something the guest thinks is done, but I think that's just a fact of life</p>\n</blockquote>\n<p>are we talking about cancellation? in case of filesystem and stdio, I would expect for cancellation to only finish once the worker thread is done the I/O operation</p>",
        "id": 536829446,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756486808
    },
    {
        "content": "<p>as opposed to just saying \"here's a stream go ham\"</p>",
        "id": 536829459,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"484032\">Roman Volosatovs</span> <a href=\"#narrow/channel/219900-wasi/topic/Behavior.20of.20Wasmtime.20future.2Fstream.20host.20APIs/near/536829446\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>the consequence is that the implementation is quite a bit more complicated since now you're juggling something the guest thinks is done, but I think that's just a fact of life</p>\n</blockquote>\n<p>are we talking about cancellation? in case of filesystem and stdio, I would expect for cancellation to only finish once the worker thread is done the I/O operation</p>\n</blockquote>\n<p>I'm thinking non-byte-based streams mixed with cancellation. So you had to get an item from <code>Source</code>, but upon cancellation you're still responsible for that item</p>",
        "id": 536829544,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756486845
    },
    {
        "content": "<p>right, but the host is allowed to block the guest until it's done </p>\n<p>So if we're thinking in terms of <code>futures::Sink</code></p>\n<p>it would look something like:</p>\n<ul>\n<li>read an item</li>\n<li>call <code>start_send</code></li>\n<li>call <code>poll_flush</code> and return <code>Poll::Ready</code> once it's ready</li>\n</ul>",
        "id": 536829797,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756486962
    },
    {
        "content": "<p><code>poll_consume</code> does not return ready until the sink's \"flush\" is done - doesn't that address the problem?</p>",
        "id": 536829898,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756486999
    },
    {
        "content": "<p>and presumably it would <em>also</em> wait for the flush to finish when cancelled, correct?</p>",
        "id": 536830009,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756487038
    },
    {
        "content": "<p>yes, exactly</p>",
        "id": 536830040,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756487050
    },
    {
        "content": "<p>ok, I think we're agreed that's the expected behavior for wasmtime-wasi (and other libraries/embeddings that implement <code>StreamConsumer</code>), but Alex might be pointing out that not every implementation is <em>required</em> to behave that way, and indeed guest-based virtualized impls cannot do that currently</p>",
        "id": 536830236,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756487125
    },
    {
        "content": "<p>it comes down to a sort of \"best-effort\" guarantee</p>",
        "id": 536830295,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756487144
    },
    {
        "content": "<p>That makes sense to me. In fact, we should probably just say that it's interface-specific</p>",
        "id": 536830695,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756487303
    },
    {
        "content": "<p>Yeah, I can include a \"best practices\" section in the <code>StreamConsumer</code> docs to guide implementers</p>",
        "id": 536830787,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756487341
    },
    {
        "content": "<p>Some interfaces might expose application-specific <em>flush</em> and might even expect for their writes to be buffered (e.g. for performance reasons)</p>",
        "id": 536830840,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756487367
    },
    {
        "content": "<p>It seems like just about the only end-to-end guarantee is negative: if a stream write indicates that something <em>wasn't</em> consumed then it definitely wasn't sent</p>",
        "id": 536831202,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756487532
    },
    {
        "content": "<p>Technically a misbehaving <code>StreamConsumer&lt;u8&gt;</code> could lie about that and never call <code>DirectSource::mark_read</code>, but that's just evil.</p>",
        "id": 536831388,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756487609
    },
    {
        "content": "<p>Yeah \"guarantee\" not enforced by code, but something we can definitively say is a bug</p>",
        "id": 536831594,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756487709
    },
    {
        "content": "<p>oh I also just forget that cancellation can block, but yes if we say that cancellation doesn't actually do anything then there's not really any complication</p>",
        "id": 536831879,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756487830
    },
    {
        "content": "<p>my thinking is that we don't actually want those semantics though and we want cancellation to cancel</p>",
        "id": 536831918,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756487843
    },
    {
        "content": "<p>I had a quick chat with <span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> yesterday about this problem and he pointed out that the host is free to finish any work it has to do before reporting cancellation as \"done\".<br>\nI was under impression that cancellation would immediately abort as well.</p>",
        "id": 536832664,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756488114
    },
    {
        "content": "<p>allowing the cancellation to \"block\" certainly makes host's life easier though</p>",
        "id": 536832755,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756488155
    },
    {
        "content": "<p>e.g. if we have fired a file <code>append</code> off in a thread, we can just await it's completion.<br>\nOtherwise, it seems we would need to spawn a dedicated worker thread and use something like message passing to communicate cancellation intent</p>",
        "id": 536833046,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756488264
    },
    {
        "content": "<p>actually, these kind of operations simply cannot be cancelled <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> <br>\nso if <code>cancel</code> blocks, the guest will now when the write has been finished - when the <code>cancel</code> returns<br>\nif <code>cancel</code> does not block - the guest will either never know about it, or will block until all previous appends (potentially multiple) are done on the next append <em>attempt</em></p>",
        "id": 536834207,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756488707
    },
    {
        "content": "<p>Here's the docs section I just added to <code>StreamConsumer</code> which addresses this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"sd\">/// ## Backpressure</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// As mentioned above, an implementation might choose to return</span>\n<span class=\"w\">    </span><span class=\"sd\">/// `Poll::Pending` after taking items from `source`, which tells the caller</span>\n<span class=\"w\">    </span><span class=\"sd\">/// to delay sending a `COMPLETED` event to the writer.  This can be used as</span>\n<span class=\"w\">    </span><span class=\"sd\">/// a form of backpressure when the items are forwarded to an upstream sink</span>\n<span class=\"w\">    </span><span class=\"sd\">/// asynchronously.  Note, however, that it's not possible to \"put back\"</span>\n<span class=\"w\">    </span><span class=\"sd\">/// items into `source` once they've been taken out, so if the upstream sink</span>\n<span class=\"w\">    </span><span class=\"sd\">/// is unable to accept all the items, that cannot be communicated to the</span>\n<span class=\"w\">    </span><span class=\"sd\">/// writer at this level of abstraction.  Just as with application-specific,</span>\n<span class=\"w\">    </span><span class=\"sd\">/// recoverable errors, information about which items could be forwarded and</span>\n<span class=\"w\">    </span><span class=\"sd\">/// which could not must be communicated out-of-band, e.g. by writing to an</span>\n<span class=\"w\">    </span><span class=\"sd\">/// application-specific `future`.</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// Similarly, if the writer cancels the write after items have been taken</span>\n<span class=\"w\">    </span><span class=\"sd\">/// from `source` but before the items have all been forwarded to an</span>\n<span class=\"w\">    </span><span class=\"sd\">/// upstream sink, `poll_consume` will be called with `finish` set to true,</span>\n<span class=\"w\">    </span><span class=\"sd\">/// and the implementation may either:</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// - Interrupt the forwarding process gracefully.  This may be preferrable</span>\n<span class=\"w\">    </span><span class=\"sd\">/// if there is an out-of-band channel for communicating to the writer how</span>\n<span class=\"w\">    </span><span class=\"sd\">/// many items were forwarded before being interrupted.</span>\n<span class=\"w\">    </span><span class=\"sd\">///</span>\n<span class=\"w\">    </span><span class=\"sd\">/// - Allow the forwarding to complete without interrupting it.  This is</span>\n<span class=\"w\">    </span><span class=\"sd\">/// usually preferable if there's no out-of-band channel for reporting back</span>\n<span class=\"w\">    </span><span class=\"sd\">/// to the writer how many items were forwarded.</span>\n</code></pre></div>",
        "id": 536834214,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756488713
    },
    {
        "content": "<p>It seems like \"cancel\" is a little misleading; its more like \"stop asap\".</p>",
        "id": 536834235,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756488724
    },
    {
        "content": "<p>with pseudocode like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">tx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rx</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">stream</span><span class=\"p\">();</span>\n<span class=\"n\">file</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">rx</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">tx</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"s\">\"hello\"</span><span class=\"p\">);</span>\n<span class=\"n\">cancel</span><span class=\"p\">(</span><span class=\"n\">fut</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">tx</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"s\">\", world\"</span><span class=\"p\">);</span>\n<span class=\"n\">cancel</span><span class=\"p\">(</span><span class=\"n\">fut</span><span class=\"p\">);</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">tx</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"s\">\"!\"</span><span class=\"p\">);</span>\n<span class=\"n\">cancel</span><span class=\"p\">(</span><span class=\"n\">fut</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>IMO the expectation is always that <code>hello, world!</code> will <em>eventually</em> be written to the file<br>\npersonally, I'd expect each <code>cancel</code> to \"flush\"</p>",
        "id": 536834584,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756488885
    },
    {
        "content": "<p>alternatively, we can say that once a stream write has been cancelled, the stream is \"corrupted\", <code>file.append</code> resolves to an error and the guest has to try again</p>",
        "id": 536834933,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756489046
    },
    {
        "content": "<p>remember that for <code>stream&lt;u8&gt;</code> you have the option of not calling <code>DirectSource::mark_read</code> until the write is flushed, so you don't have to worry about the cancel-after-taking-from-source-but-before-flushed in that case</p>",
        "id": 536835046,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756489090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"484032\">Roman Volosatovs</span> <a href=\"#narrow/channel/219900-wasi/topic/Behavior.20of.20Wasmtime.20future.2Fstream.20host.20APIs/near/536832664\">said</a>:</p>\n<blockquote>\n<p>I had a quick chat with <span class=\"user-mention silent\" data-user-id=\"253998\">Luke Wagner</span> yesterday about this problem and he pointed out that the host is free to finish any work it has to do before reporting cancellation as \"done\".<br>\nI was under impression that cancellation would immediately abort as well.</p>\n</blockquote>\n<p>To clarify my thinking on this, I understand the host is allowed to do this and it's going to be required for filesystem things that simply cannot be cancelled. That being said we should avoid this wherever possible as it largely defeats the point of cancellation in the first place.</p>\n<p>Rust, for example, will synchronously await cancellation of futures meaning that if we liberally use this on the host then it means that all Rust guests will block quite a lot due to this behavior</p>",
        "id": 536835193,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489165
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253994\">Alex Crichton</span> <a href=\"#narrow/channel/219900-wasi/topic/Behavior.20of.20Wasmtime.20future.2Fstream.20host.20APIs/near/536835193\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"484032\">Roman Volosatovs</span> <a href=\"#narrow/channel/219900-wasi/topic/Behavior.20of.20Wasmtime.20future.2Fstream.20host.20APIs/near/536832664\">said</a>:</p>\n<blockquote>\n<p>I had a quick chat with <span class=\"user-mention silent\" data-user-id=\"253998\">Luke Wagner</span> yesterday about this problem and he pointed out that the host is free to finish any work it has to do before reporting cancellation as \"done\".<br>\nI was under impression that cancellation would immediately abort as well.</p>\n</blockquote>\n<p>To clarify my thinking on this, I understand the host is allowed to do this and it's going to be required for filesystem things that simply cannot be cancelled. That being said we should avoid this wherever possible as it largely defeats the point of cancellation in the first place.</p>\n<p>Rust, for example, will synchronously await cancellation of futures meaning that if we liberally use this on the host then it means that all Rust guests will block quite a lot due to this behavior</p>\n</blockquote>\n<p>Totally agree with that, <em>most</em> implementations should not do that, but some simply have to</p>",
        "id": 536835304,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756489219
    },
    {
        "content": "<p>For your \"write hello world in 3 chunks\" example, given Rust bindings and the predicted WASI implementation, yes cancellation means nothing and it'll just pretend that didn't happen</p>",
        "id": 536835336,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489234
    },
    {
        "content": "<p>we as a host, however, have the option of doing something fancier here</p>",
        "id": 536835391,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489263
    },
    {
        "content": "<p>for example we could immediately say a cancelled write is indeed cancelled</p>",
        "id": 536835405,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489271
    },
    {
        "content": "<p>then the next write is blocked until the previous write actually completes</p>",
        "id": 536835422,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489278
    },
    {
        "content": "<p>If I write a buffer of two things to a stream, then cancel, and get a result of progress = 1, is that semantically the same as not cancelling and getting a result of progress = 1?</p>",
        "id": 536835504,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756489316
    },
    {
        "content": "<p>so the first cancellation call above would return immediately but eventually <code>hello</code> would get written. The other two calls wouldn't actually spawn anything b/c the previous write is still ongoing, so cancellation would successfully actually cancel (and report 0 bytes written immediately)</p>",
        "id": 536835506,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489317
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"480579\">Lann Martin</span> <a href=\"#narrow/channel/219900-wasi/topic/Behavior.20of.20Wasmtime.20future.2Fstream.20host.20APIs/near/536835504\">said</a>:</p>\n<blockquote>\n<p>If I write a buffer of two things to a stream, then cancel, and get a result of progress = 1, is that semantically the same as not cancelling and getting a result of progress = 1?</p>\n</blockquote>\n<p>IMO, yes</p>",
        "id": 536835534,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489332
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"480579\">@Lann Martin</span> you <em>may</em> get different codes (<code>COMPLETED</code> vs. <code>CANCELLED</code>), though; it's up to the guest how it wants to interpret them</p>",
        "id": 536835659,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756489387
    },
    {
        "content": "<p>That is a different answer <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 536835781,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756489425
    },
    {
        "content": "<p>well, at an ABI level yes</p>",
        "id": 536835803,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489428
    },
    {
        "content": "<p>but semantically they mean the same thing</p>",
        "id": 536835813,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489432
    },
    {
        "content": "<p>from a \"what was written\" perspective</p>",
        "id": 536835822,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489437
    },
    {
        "content": "<p>yeah, they'll both have a payload of 1, in any case</p>",
        "id": 536835873,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756489456
    },
    {
        "content": "<p>Is CANCELLED actually useful?</p>",
        "id": 536835933,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756489466
    },
    {
        "content": "<p>I think it's <em>supposed</em> to mean \"I could have done more, but you interrupted me, dammit\"</p>",
        "id": 536835998,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756489497
    },
    {
        "content": "<p>Sure but the writer knows what it did</p>",
        "id": 536836039,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756489512
    },
    {
        "content": "<p>it resolves the race of \"did this finish due to cancellation or due to the thing completing\"</p>",
        "id": 536836074,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489527
    },
    {
        "content": "<p>which is not the most meaningful thing, sure, but why not transfer the extra bit?</p>",
        "id": 536836115,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"480579\">Lann Martin</span> <a href=\"#narrow/channel/219900-wasi/topic/Behavior.20of.20Wasmtime.20future.2Fstream.20host.20APIs/near/536836039\">said</a>:</p>\n<blockquote>\n<p>Sure but the writer knows what it did</p>\n</blockquote>\n<p>But it doesn't know what the reader <em>would</em> have done otherwise</p>",
        "id": 536836155,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756489558
    },
    {
        "content": "<p>It makes the semantics of cancellation more ambiguous</p>",
        "id": 536836240,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756489588
    },
    {
        "content": "<p>but yeah, I agree that it's not very useful in practice</p>",
        "id": 536836255,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756489592
    },
    {
        "content": "<p>for that I'd recommend an issue on the CM repo for possible 0.3.x adjustments</p>",
        "id": 536836463,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253994\">Alex Crichton</span> <a href=\"#narrow/channel/219900-wasi/topic/Behavior.20of.20Wasmtime.20future.2Fstream.20host.20APIs/near/536836074\">said</a>:</p>\n<blockquote>\n<p>it resolves the race of \"did this finish due to cancellation or due to the thing completing\"</p>\n</blockquote>\n<p>for this to work, runtime would need to do something like this, right?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">poll_consume</span><span class=\"p\">(</span><span class=\"n\">finish</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">false</span><span class=\"p\">)</span>\n<span class=\"n\">consumer_cx</span><span class=\"p\">.</span><span class=\"n\">wake</span><span class=\"p\">()</span>\n<span class=\"n\">cancel</span><span class=\"p\">()</span>\n<span class=\"n\">poll_consume</span><span class=\"p\">(</span><span class=\"n\">finish</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">false</span><span class=\"p\">)</span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">pending</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">poll_consume</span><span class=\"p\">(</span><span class=\"n\">finish</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">true</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>i.e. if guest called <code>cancel</code> after the consumer had called <code>wake</code>, but before <code>poll_consume</code> was called (since these things are concurrent), runtime might need to call <code>poll_consume</code> twice</p>",
        "id": 536836600,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756489751
    },
    {
        "content": "<p>I'm not sure that cancellation affects that?</p>",
        "id": 536836792,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489837
    },
    {
        "content": "<p>but yes, that happens</p>",
        "id": 536836808,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489843
    },
    {
        "content": "<p>one event, the \"thing completing\", and another event \"cancel\", causing two polls seems normal to me?</p>",
        "id": 536836844,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489860
    },
    {
        "content": "<p>e.g. it's \"two events generate two polls\" and cancellation doesn't seem special here</p>",
        "id": 536836877,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489878
    },
    {
        "content": "<p>For the runtime to know whether return <code>CANCELLED</code> or <code>COMPLETED</code> it needs to know if <code>poll_consume</code> after <code>wake</code> would result in <code>Poll::Ready</code></p>",
        "id": 536836910,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756489892
    },
    {
        "content": "<p>if it gives <code>finish: true</code>, consumer is forced to return ASAP and the runtime cannot know which one it is anymore</p>",
        "id": 536836967,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1756489919
    },
    {
        "content": "<p>another difference between COMPLETED and CANCELLED: the former can only have a zero payload for a zero-length read/write, while the latter can have a zero payload any time.  Whether that justifies the existence of CANCELLED is debateable</p>",
        "id": 536836975,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756489923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"484032\">Roman Volosatovs</span> <a href=\"#narrow/channel/219900-wasi/topic/Behavior.20of.20Wasmtime.20future.2Fstream.20host.20APIs/near/536836967\">said</a>:</p>\n<blockquote>\n<p>if it gives <code>finish: true</code>, consumer is forced to return ASAP and the runtime cannot know which one it is anymore</p>\n</blockquote>\n<p>yeah, good point</p>",
        "id": 536837093,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756489978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"484032\">Roman Volosatovs</span> <a href=\"#narrow/channel/219900-wasi/topic/Behavior.20of.20Wasmtime.20future.2Fstream.20host.20APIs/near/536836910\">said</a>:</p>\n<blockquote>\n<p>For the runtime to know whether return <code>CANCELLED</code> or <code>COMPLETED</code> it needs to know if <code>poll_consume</code> after <code>wake</code> would result in <code>Poll::Ready</code></p>\n</blockquote>\n<p>I think this depends on <code>poll_consume</code>, if the first <code>poll_consume(finish: false)</code> after the <code>cancel()</code> above says \"I'm ready\" the host would say <code>COMPLETED</code> and that's not a spec violation</p>",
        "id": 536837096,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756489978
    },
    {
        "content": "<p>We can always add a <code>Cancelled</code> variant to the <code>StreamState</code> enum if desired</p>",
        "id": 536837166,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756490011
    },
    {
        "content": "<p>Yeah again, the writer knows it cancelled; I think it's even supposed to trap if it gets CANCELLED otherwise</p>",
        "id": 536837188,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756490018
    },
    {
        "content": "<p>I guess I'm just trying to make sure I/we aren't missing anything semantically</p>",
        "id": 536837257,
        "sender_full_name": "Lann Martin",
        "timestamp": 1756490044
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"509936\">Joel Dice</span> <a href=\"#narrow/channel/219900-wasi/topic/Behavior.20of.20Wasmtime.20future.2Fstream.20host.20APIs/near/536837166\">said</a>:</p>\n<blockquote>\n<p>We can always add a <code>Cancelled</code> variant to the <code>StreamState</code> enum if desired</p>\n</blockquote>\n<p>And rename <code>StreamState::Open</code> to <code>Completed</code>, and <code>Closed</code> to <code>Dropped</code> for consistency</p>",
        "id": 536837426,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756490124
    },
    {
        "content": "<p>that seems reasonable to me</p>",
        "id": 536837483,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1756490155
    },
    {
        "content": "<p>ok, I'm sick of editing that gist, but I've made those changes locally in my Wasmtime clone</p>",
        "id": 536838047,
        "sender_full_name": "Joel Dice",
        "timestamp": 1756490393
    },
    {
        "content": "<p>I like these changes, awesome work!</p>",
        "id": 538795461,
        "sender_full_name": "Nathan Petrangelo",
        "timestamp": 1757578263
    }
]