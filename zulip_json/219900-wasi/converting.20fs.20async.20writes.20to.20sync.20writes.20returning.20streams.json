[
    {
        "content": "<p>I just saw <span class=\"user-mention\" data-user-id=\"378155\">@Dave Bakker (badeend)</span> 's PR over here:<br>\n<a href=\"https://github.com/WebAssembly/WASI/pull/870\">https://github.com/WebAssembly/WASI/pull/870</a></p>\n<p>IIRC this was a point of contention (which we've gone back and forth about) around STDIN/STDOUT, thought we should maybe open up the discussion here as well. </p>\n<p>Going to over-tag for this one -- apologies ahead of time:<br>\n<span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> <span class=\"user-mention\" data-user-id=\"509936\">@Joel Dice</span> <span class=\"user-mention\" data-user-id=\"253998\">@Luke Wagner</span> <span class=\"user-mention\" data-user-id=\"484032\">@Roman Volosatovs</span></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/WASI/pull/870\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/16f7b4e3c339d4c6a49b20cfb2b33866db4be30c/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f316238643962376463376561343933363139626330386630333434643634393662303336636535626432623061666563613361653537353437376230343463642f576562417373656d626c792f574153492f70756c6c2f383730&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/WASI/pull/870\" title=\"Async write prevents Rust bindings and component composition by badeend · Pull Request #870 · WebAssembly/WASI\">Async write prevents Rust bindings and component composition by badeend · Pull Request #870 · WebAssembly/WASI</a></div><div class=\"message_embed_description\">Several WASI interfaces (stdio, filesystem, sockets) use the following pattern:\nresource example {\n  read: func() -&gt; tuple&lt;stream&lt;u8&gt;, future&lt;result&lt;_, error-code&gt;&gt;&gt;;\n  w...</div></div></div>",
        "id": 567370577,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1768112911
    },
    {
        "content": "<p>see also: <a href=\"https://github.com/WebAssembly/WASI/issues/757\">https://github.com/WebAssembly/WASI/issues/757</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/WASI/issues/757\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/a53b55052e7b3aa72ecb14543c500b6fe030d31a/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f356465646161383633623761386130616161326338326539663734653864343238653533633635346638666635316166363439366335363736343137643031342f576562417373656d626c792f574153492f6973737565732f373537&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/WASI/issues/757\" title=\"[0.3.0-draft]: Move away from streams as an API? · Issue #757 · WebAssembly/WASI\">[0.3.0-draft]: Move away from streams as an API? · Issue #757 · WebAssembly/WASI</a></div><div class=\"message_embed_description\">I'd like to propose a possible radical restructuring of stdin/stdout/stderr and how they're modeled for 0.3.0. Specifically something like this for 0.3.0: interface stdin { read: async func(amount:...</div></div></div>",
        "id": 567373248,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1768116186
    },
    {
        "content": "<p>for sockets and maybe files I think we still need streams, however for stdout/stderr async/streams are sometimes unnecessary overhead because the underlying I/O operations are blocking calls on some OSes.</p>",
        "id": 567373373,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1768116385
    },
    {
        "content": "<p>If you're thinking of <a href=\"https://github.com/WebAssembly/WASI/issues/757\">757</a>,  then I don't think these are related</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/WASI/issues/757\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/a53b55052e7b3aa72ecb14543c500b6fe030d31a/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f356465646161383633623761386130616161326338326539663734653864343238653533633635346638666635316166363439366335363736343137643031342f576562417373656d626c792f574153492f6973737565732f373537&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/WASI/issues/757\" title=\"[0.3.0-draft]: Move away from streams as an API? · Issue #757 · WebAssembly/WASI\">[0.3.0-draft]: Move away from streams as an API? · Issue #757 · WebAssembly/WASI</a></div><div class=\"message_embed_description\">I'd like to propose a possible radical restructuring of stdin/stdout/stderr and how they're modeled for 0.3.0. Specifically something like this for 0.3.0: interface stdin { read: async func(amount:...</div></div></div>",
        "id": 567373415,
        "sender_full_name": "Dave Bakker (badeend)",
        "timestamp": 1768116425
    },
    {
        "content": "<p>e.g. on windows iirc terminal writes are always blocking</p>",
        "id": 567373441,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1768116464
    },
    {
        "content": "<p>Don't get confused about the title of my PR, with what I'm proposing the relevant interfaces <em>still</em> use streams. It's just about <code>async</code> vs. <code>future</code></p>",
        "id": 567373461,
        "sender_full_name": "Dave Bakker (badeend)",
        "timestamp": 1768116490
    },
    {
        "content": "<p>Hey so noted on the PR but thanks for the link and clarifying -- One thing I was thinking about is the ergonomics side, of whether write should be async or sync to start with (which was part of the discussion in 757 -- the idea of which is more unsurprising). </p>\n<p>I think the problem you laid out definitely makes sense and the simplest fix that you laid out also works -- but another place that gave me reason for pause was the semantics of calling an async import from a sync function. Correct me if I'm wrong but <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Concurrency.md#blocking\">that case is supposed to trap</a> if the import (or other async action) is going to block.</p>\n<blockquote>\n<p>Additionally, each of these potentially-blocking operations will trap if the <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Concurrency.md#current-thread-and-task\">current task's function type</a> does not declare the <code>async</code> effect, since only <code>async</code>-typed functions are allowed to block</p>\n</blockquote>\n<p>To to make what I'm imagining a bit more concrete -- If I'm writing an implementation in a component for this resource (using your suggested change):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">resource</span><span class=\"w\"> </span><span class=\"n\">example</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">read</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">func</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">tuple</span><span class=\"o\">&lt;</span><span class=\"n\">stream</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"o\">&lt;</span><span class=\"n\">result</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">-</span><span class=\"n\">code</span><span class=\"o\">&gt;&gt;&gt;</span><span class=\"p\">;</span>\n<span class=\"w\">  </span><span class=\"n\">write</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">func</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">stream</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nc\">future</span><span class=\"o\">&lt;</span><span class=\"n\">result</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">error</span><span class=\"o\">-</span><span class=\"n\">code</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>(I think also realistically it'd probably be a <code>result&lt;future&lt;result&lt;_, error-code&gt;&gt;&gt;</code>, just in case you ran into some unrelated issue)</p>\n<p>Then I'm quite limited in what functions I can attempt to call from the <code>write</code>, no? IIUC I cannot block (i.e. reading the <code>stream&lt;u8&gt;</code>, or call any async lowered import).</p>\n<p>Happy to learn where I'm wrong here though!</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Concurrency.md#blocking\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/900b97c38ee1ed5985a092250803f1393725832a/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f323232326564336432353136636533633161386638653537656166316132363764383037333936646230316432653939396138643534643336663234633265322f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Concurrency.md#blocking\" title=\"component-model/design/mvp/Concurrency.md at main · WebAssembly/component-model\">component-model/design/mvp/Concurrency.md at main · WebAssembly/component-model</a></div><div class=\"message_embed_description\">Repository for design and specification of the Component Model - WebAssembly/component-model</div></div></div>",
        "id": 567374503,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1768118060
    },
    {
        "content": "<p>Regarding the trap, I believe the current thinking is that one can <em>call</em> an async import from a sync context, but not <em>block</em> on the result <em>before returning a value</em> (that's the trapping case).</p>",
        "id": 567375349,
        "sender_full_name": "Roman Volosatovs",
        "timestamp": 1768119464
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"484032\">@Roman Volosatovs</span> is right on the trapping behavior.<br>\nI've prototyped the change in wasmtime and it doesn't produce a trap</p>",
        "id": 567376448,
        "sender_full_name": "Dave Bakker (badeend)",
        "timestamp": 1768120871
    },
    {
        "content": "<p>Ok, scrap that last statement. I've prototyped the implementation as a host not a guest, so I wouldn't get a trap anyway. Regardless, I'm not using any special host powers.</p>\n<p>From a guest's perspective this change likely turns the <code>write</code> implementation from</p>\n<ul>\n<li>an async function that directly consumes the stream, into</li>\n<li>a sync function that spawns a task that consumes the stream</li>\n</ul>",
        "id": 567379051,
        "sender_full_name": "Dave Bakker (badeend)",
        "timestamp": 1768124347
    },
    {
        "content": "<p>Thanks for clarifying that! OK, so basically this forces the <code>write</code> to spawn</p>",
        "id": 567379075,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1768124388
    },
    {
        "content": "<p>That makes sense to me -- it seemed like either write would have to spawn or start a thread or something to actually do any (preemptive?) work that it wanted to do</p>",
        "id": 567379098,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1768124419
    },
    {
        "content": "<p>And yeah, the idea that the sync function can call but NOT block seems somewhat limiting, but maybe it's fine</p>",
        "id": 567379114,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1768124453
    },
    {
        "content": "<p>Thanks for the heads up on this! I'll want to write up some thoughts and will leave them on the PR (overall seems fine, just want to think harder about the implications of this myself)</p>",
        "id": 567606554,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1768240788
    }
]