[
    {
        "content": "<p>I have a WIT component that is imported from the host to the guest.  I want to read a \"record\" from the host, but the execution in the host is asynchronous in the same way as the guest reading from stdin.</p>\n<p>I see that there is a wasi:poll pollable component.  Is it necessary that I have my component return a pollable to let the guest know when it is ready to read? Or do I just implement a read function and wasmtime plus my tinygo compiler magically makes that call async?  Does my guest understand that that call is asynchronous, allowing other coroutines to continue execution?</p>",
        "id": 538564639,
        "sender_full_name": "Joel",
        "timestamp": 1757477740
    },
    {
        "content": "<p>Pollable is the old way to wake guests, but compared to 0.3 future/stream/async it doesn't compose. This means that you can't implement it in more than one guest component without running into serious overhead. There are existing implementations of async executors with pollable, but the new technology will be more reliable, soon.</p>",
        "id": 538573973,
        "sender_full_name": "Christof Petig",
        "timestamp": 1757484762
    },
    {
        "content": "<p>In short pollable indicates that it will be replaced soon.</p>",
        "id": 538574031,
        "sender_full_name": "Christof Petig",
        "timestamp": 1757484791
    },
    {
        "content": "<p>So for version 0.2, I should just ignore it as it will be replaced soon?   (btw thank you very much for the reply).  Also, do guests multiplex i/o handles like stdio using pollable?  I want to the guest to multiplex between multiple streams of records coming from the host.</p>",
        "id": 538574290,
        "sender_full_name": "Joel",
        "timestamp": 1757484936
    },
    {
        "content": "<p>For WASIp2, yes, you'll want a pollable. You'll want to look around the <code>wasi:http</code> APIs for future-lookalike APIs and make one of those. Effectively while in WASIp3 we have <code>future&lt;foo&gt;</code> in WASIp2 you'll have to make <code>future-foo</code> yourself and mimick all the various functions, using a <code>pollable</code> internally to represent readiness.</p>",
        "id": 538671894,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1757515680
    },
    {
        "content": "<p>Thanks. I took a look at libc_wasm2 in tinygo to see how the tcp sockets work.  I see pollable and blocking calls are used from inside tinygo.</p>",
        "id": 538829544,
        "sender_full_name": "Joel",
        "timestamp": 1757589095
    }
]