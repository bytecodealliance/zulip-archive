[
    {
        "content": "<p>Hello, I am working on a system with the goals of allowing WASM module instances to be suspended, their state saved, and then persisted to disk, to be resumed in the future at a later stage.</p>\n<p>My understanding is that in theory something like this should be possible to support. In theory, a WASM program is simply it's memory (code, globals, imports, exports, stack, heap allocations, registers, program counter, etc) - so it should be possible to serialize and deserialize all of this data into instances...</p>\n<p>How difficult would it be to implement something like this?</p>",
        "id": 572493057,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1770432588
    },
    {
        "content": "<p>However, I also probably suspect that compiled bytecode, and potentially updates to engine behavior could throw things out of alignment and create all kinds of bugs if such a thing was implemented naively...</p>",
        "id": 572493162,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1770432700
    },
    {
        "content": "<p>Because ideally, we'd want these types of snapshots to <strong>Just Work</strong> across different engine runtime versions too (they are just WASM modules... afterall)</p>",
        "id": 572493305,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1770432849
    },
    {
        "content": "<p>I guess what I am proposing is a universal serializable wasm instance snapshot interface that runtime engines would know how to both <strong>produce</strong> or <strong>resume</strong> from</p>",
        "id": 572518075,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1770460851
    },
    {
        "content": "<p>If you're looking for engine portability then you probably want to serialize to wasm. This is what <code>wasmtime wizer</code> does, for example. The caveat there is wasm has no way of representing a stack-in-progress and values of locals that are nonzero. Serializing wasm-on-the-stack has no portable representation currently, and Wasmtime also has no support for that. </p>\n<p>Supporting serializing wasm-on-the-stack has come up numerous times in the past with Wasmtime, but it's an extremely difficult feature to support. At this time we don't have plans to support it, but you're welcome to search around on Zulip/GitHub to see the past discussions</p>",
        "id": 572548557,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1770482200
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> This is something that I wish to pursue the development of out of business necessity. Would you be willing to help guide me into the right direction and address certain questions I've had?</p>\n<p>One idea I had was something along these lines</p>\n<p><a href=\"/user_uploads/15107/RE0QMQ-LbPe9xBQWZREW9Ew-/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/15107/RE0QMQ-LbPe9xBQWZREW9Ew-/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"696x1044\" src=\"/user_uploads/thumbnail/15107/RE0QMQ-LbPe9xBQWZREW9Ew-/image.png/840x560.webp\"></a></div>",
        "id": 572676768,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1770610328
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"1024720\">@Albert Marashi</span> have you taken a look at some of the issues already about this feature? </p>\n<p><a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\">https://github.com/bytecodealliance/wasmtime/issues/3017</a><br>\n<a href=\"https://github.com/bytecodealliance/wasmtime/issues/4002\">https://github.com/bytecodealliance/wasmtime/issues/4002</a></p>\n<p>I'd recommend taking in some of that context before going about this -- you'll see a discussion in the most recent issue similar to what just transpired here. Even the older issue has lots of discussion about this problem.</p>\n<p>That said -- given that the code for wasmtime and relevant tooling is open source, there is nothing stopping you from attempting a solution that matches the approach you think might work. I'm certainly eager to see a working solution and discuss it's merits!</p>\n<p>Keep in mind that your business use case might be OK with an asyncify-like business transformation (assuming that approach works, and there are many hurdles still yet to clear to make something that makes sense), but others may not want to make the trade-off in terms of performance.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/85687b63298d21947496552bbb7f085a96fc4b90/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f323235636466663765393131353265343738346237306632316635656562623961666133313661313133316239666637383838373932336463326233666136652f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f33303137&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/issues/3017\" title=\"Save WASM state and resume · Issue #3017 · bytecodealliance/wasmtime\">Save WASM state and resume · Issue #3017 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">Feature To be able to interrupt and save the state of executing WASM code and then resume it later, possibly on a different host machine. Benefit I am writing an add on for the Open Computers mod i...</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/issues/4002\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/061aad9751137bf3f5274f61e5affdb44c11b881/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633734353961643463326661646533366433383631366165353233366238623139343165623661326365396465623537306435623031376261323833396432342f62797465636f6465616c6c69616e63652f7761736d74696d652f6973737565732f34303032&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/issues/4002\" title=\"Migrating workloads - snapshot and restore somewhere else · Issue #4002 · bytecodealliance/wasmtime\">Migrating workloads - snapshot and restore somewhere else · Issue #4002 · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">Feature When running a module with wasmtime, I would like to be able to capture the running memory of a workload, perhaps, while running, pause or stop the workload, move the workload elsewhere, th...</div></div></div>",
        "id": 572731944,
        "sender_full_name": "Victor Adossi",
        "timestamp": 1770632248
    },
    {
        "content": "<p>Yes. I think I might have a viable solution</p>",
        "id": 572929844,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1770691589
    },
    {
        "content": "<p><strong>@Victor Adossi</strong> Yes, I've reviewed the prior discussions and considered several approaches. I believe I have a viable and generic solution, though it likely wouldn't align well with Wasmtime's goals directly — I'd either be forking Wasmtime or writing a custom runtime from scratch.</p>\n<p><strong>The core approach:</strong></p>\n<p>At a high level, the mechanism works by interrupting execution, advancing to a deterministic safepoint (between Wasm instructions), and then performing live analysis (precomputed during compilation) to identify which registers hold stack-relevant values. These are then pushed onto the stack of a universal, portable VM representation of the program state — producing a serializable snapshot.</p>\n<p>Resumption is the reverse: stack values are restored into the appropriate registers, and execution continues from the safepoint.</p>\n<p><strong>Safepoint insertion &amp; interruption:</strong></p>\n<p>Execution isn't interrupted at deterministic points, but the resulting snapshot <em>is</em> deterministic — safepoints are inserted at natural boundaries (function calls, loop headers) or between each Wasm-equivalent instruction. To trigger a suspension, I'm considering a guard-page mechanism: a memory page with READ permissions during normal execution, and permissions revoked when we want the module to trap — providing a low-overhead interruption signal without polling.</p>",
        "id": 574043571,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1771223671
    },
    {
        "content": "<p>Through testing of hypothetical recursive fibbonaci functions, i've determined that the cost of step-wise trap checks are on the order of 3-10% of hot-path execution time. (CPU branch prediction cost approaches 0-1 cycles)</p>\n<p>The cost of thread-based interruption would be 0% on the hot path since the code contains no checks, and the suspend/resume functionality would be amortized over the millions or billions of instructions executed between suspensions, which wouldn't be frequent enough to have any meaningful performance effects.</p>",
        "id": 574043868,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1771223920
    },
    {
        "content": "<p>The only larger cost comes at the cost of code metadata and side tables to provide information to our runtime needed for the suspend/snapshot/resume functionality (register/local/stack mappings), which may be roughly 1-3x the size of the code itself depending on my implementation efficiency.</p>\n<p>I am also considering the use of dynamic function compilation based on hot path analysis, as running some of the code in interpreted mode would mean only hot functions would need to be compiled (interpreter mode would naturally support step-wise execution and thus suspend+resume capabilities are baked in)</p>",
        "id": 574044289,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1771224200
    },
    {
        "content": "<p><a href=\"/user_uploads/15107/aGjYsAIOofBBI1NKHCRnS7C9/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/15107/aGjYsAIOofBBI1NKHCRnS7C9/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"254x104\" src=\"/user_uploads/thumbnail/15107/aGjYsAIOofBBI1NKHCRnS7C9/image.png/840x560.webp\"></a></div><p>I worked on a quick proof of concept compiler that I started off as an interpreted VM - initially being 132x slower than wasmtime but brought it down to around 3x slower with the help of some JIT code. (Also it says \"interpreter\" in there but it's somewhere more in between of \"interpreted\" and \"JIT\")</p>\n<p>I think I should be able to approach wasmtime performance</p>\n<p>The native rust approach is comparing a bit of an unfair apples and oranges approach because the release version for it compiles the function into a tail call optimization afaik - whereas my WASM module uses recursive function calls)</p>",
        "id": 574044534,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1771224354
    },
    {
        "content": "<p>I am also considering turning my WASM program's stack frames into a more friendly representation optimized towards serializability</p>",
        "id": 574044758,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1771224521
    },
    {
        "content": "<p>Out of curiosity, how do you plan to handle host references, e.g. <code>externref</code>s or open file descriptors, etc?<br>\nOr is this not relevant for your use case?</p>",
        "id": 574173668,
        "sender_full_name": "Dave Bakker (badeend)",
        "timestamp": 1771270727
    },
    {
        "content": "<p>business-wise, things like sockets will have a cost associated to them<br>\ntechnically, the host will maintain them for the sleeping modules</p>",
        "id": 574181408,
        "sender_full_name": "Albert Marashi",
        "timestamp": 1771274748
    }
]