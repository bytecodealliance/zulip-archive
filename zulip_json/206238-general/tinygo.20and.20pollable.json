[
    {
        "content": "<p>I have a WIT with a wasi:io/poll.  This version is 0.2.6.  However, I see that tinygo uses 0.20.  When I call Block() on the pollable object generated from my WIT file, it blocks execution of all my goroutines.  Do I have to do something special to use the pollable object understood by tinygo so that a Block call does not lock up my program?</p>",
        "id": 545135289,
        "sender_full_name": "Joel",
        "timestamp": 1760566303
    },
    {
        "content": "<p>correction: not 0.20, but 0.2.0</p>",
        "id": 545137339,
        "sender_full_name": "Joel",
        "timestamp": 1760567422
    },
    {
        "content": "<p>My understanding is that TinyGo uses <a href=\"https://kripken.github.io/blog/wasm/2019/07/16/asyncify.html\">Asyncify</a> to implement goroutines.  One limitation of that approach is that any call to an imported function (such as <code>wasi:io/poll#pollable.block</code>) will effectively suspend <em>all</em> goroutines until the call returns given that no Wasm code in the instance can run in the interim.</p>\n<p>I don't expect that will be addressed for WASIp2, but my hope is that with WASIp3 (which is based on a new Component Model async ABI), we'll be able to hook into TinyGo's Asyncify transformation (and, in the case of \"big\" Go, the equivalent transformation it does at the IR level before emitting Wasm code) and transparently suspend and resume goroutines as they are blocked and unblocked on I/O, respectively -- while still allowing unblocked goroutines to make progress.  I'm specifically planning to create a proof-of-concept demonstrating this for \"big\" Go when I have a chance, but I'm not sure when that will be.</p>\n<p>Eventually, once the TinyGo and \"big\" Go toolchains have embraced some flavor of Wasm stack switching, these Asyncify-style transformations will no longer be necessary, at which point we'll have a Go concurrency story that's both idiomatic <em>and</em> efficient.  That will be a bigger effort requiring more coordination, though.</p>",
        "id": 545139165,
        "sender_full_name": "Joel Dice",
        "timestamp": 1760568509
    },
    {
        "content": "<p>Oh that makes sense.  This means there is no way to do multiple polls in wasip2?</p>",
        "id": 545139504,
        "sender_full_name": "Joel",
        "timestamp": 1760568730
    },
    {
        "content": "<p>No, not concurrently.</p>",
        "id": 545139574,
        "sender_full_name": "Joel Dice",
        "timestamp": 1760568778
    },
    {
        "content": "<p>Hypothetically, you could arrange for one of your goroutines to be the \"designated poller\", calling <code>poll</code> only once all the other goroutines have submitted the <code>pollable</code>s they're interested in, e.g. via a channel.</p>",
        "id": 545139907,
        "sender_full_name": "Joel Dice",
        "timestamp": 1760569024
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"509936\">@Joel Dice</span> . So, I will give a \"designated poller\" a try.</p>",
        "id": 545147175,
        "sender_full_name": "Joel",
        "timestamp": 1760574433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"948912\">Joel</span> has marked this topic as resolved.</p>",
        "id": 545147178,
        "sender_full_name": "Notification Bot",
        "timestamp": 1760574436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"948912\">Joel</span> has marked this topic as unresolved.</p>",
        "id": 545147417,
        "sender_full_name": "Notification Bot",
        "timestamp": 1760574618
    }
]