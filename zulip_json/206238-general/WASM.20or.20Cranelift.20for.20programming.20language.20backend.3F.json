[
    {
        "content": "<p>Hello!<br>\nIm curious, if I wanted to make my own programming language, would yall recommend to compile down to WASM or Cranelift. (Let's ignore the obvious advantage WASM has in that it can run in the browser n stuff)</p>",
        "id": 558351861,
        "sender_full_name": "Srayan Jana",
        "timestamp": 1763616557
    },
    {
        "content": "<p>That cannot be answered without more information about your goals and constraints, but <em>my</em> answer is \"almost certainly Wasm\". <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 558444680,
        "sender_full_name": "Lann Martin",
        "timestamp": 1763648980
    },
    {
        "content": "<p>I ask because I’ve seen a couple of new languages like Scheme-rs use crane lift, (and obviously rust uses it) so maybe it’s like crane lift can do stuff that WASM can’t? (Though rust can ALSO compile down to WASM so….)</p>",
        "id": 558716523,
        "sender_full_name": "Srayan Jana",
        "timestamp": 1763746396
    },
    {
        "content": "<p>I guess the main thing is that wasm is automatically sandboxed and needs to be run in a VM while cranelift compiled down to normal machine code</p>",
        "id": 558716622,
        "sender_full_name": "Srayan Jana",
        "timestamp": 1763746433
    },
    {
        "content": "<p>I think the main factors in either direction are:</p>\n<ul>\n<li>Wasm is more universal and portable. Do you want your language to be able to target browsers or out-of-browser VMs in lots of environments? Do you want it to be able to easily interact (via Wasm imports/exports) with code from other toolchains?</li>\n<li>Wasm is also a bit more \"typechecked\": you'll get either static validation failures or deterministic dynamic traps if you get e.g. function signatures wrong or have an out-of-bounds pointer, for example. (You can still totally get heap corruption within the module's linear memory of course; Wasm isn't a panacea here.)</li>\n<li>On the other hand, generating native code with any compiler (Cranelift included) gives you more power: it means that you can compile arbitrary irreducible CFGs, it means that (at least in theory) you have access to whatever native CPU instructions we add Cranelift instructions for, it means that (at least in theory) you can do dynamic code-patching once we add support for that. It also buys you perhaps a 1.5-2x speedup versus Wasm, at the cost of losing the sandboxing</li>\n</ul>",
        "id": 558719225,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763747191
    },
    {
        "content": "<p>If I were designing a new language with a compiler, a Wasm backend would be an easy choice for me -- the universality is worth it. But if you want to play with low-level performance or you want a toolchain that can build native binaries then by all means feel free to play with Cranelift</p>",
        "id": 558719559,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763747242
    },
    {
        "content": "<p>That makes sense, thanks yall!</p>",
        "id": 558740575,
        "sender_full_name": "Srayan Jana",
        "timestamp": 1763754528
    },
    {
        "content": "<p>Hmm?? Cranelift <strong>is</strong> a backend of wasm, right? Is there any difference between compiling down to wasm and to cranelift?</p>",
        "id": 560228665,
        "sender_full_name": "とが",
        "timestamp": 1764096597
    },
    {
        "content": "<p>Cranelift is a compiler library. Wasmtime uses Cranelift to compile Wasm to machine code. But Cranelift is not Wasm-specific.</p>\n<blockquote>\n<p>Is there any difference between compiling down to wasm and to cranelift?</p>\n</blockquote>\n<p>Put simply, yes. In one case you emit Wasm bytecodes. In another case you emit Cranelift IR.</p>",
        "id": 560229826,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1764097035
    }
]