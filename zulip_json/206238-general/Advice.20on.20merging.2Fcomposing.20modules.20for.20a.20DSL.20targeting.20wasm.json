[
    {
        "content": "<p>I am building a DSL (domain specific language) that targets WASM directly. I need some direction on the module system within the language itself. I am struggling to find a solution to compile each module and combine them into a final root component. </p>\n<p>My basic approach so far has been to compile each source file of the DSL to it's own core wasm module. From there I see three paths forward. </p>\n<p>Convert each core module to a component and use straightforward composition. Aka dynamic linking to construct the root component.</p>\n<p>Link each core module in a shared everything linking approach and then make a new component from this linked module.</p>\n<p>Write custom code to merge core modules making assumption unique to my DSL. This is vague and not entirely sure where I'd start.</p>\n<p>I have tried the first two and ran into challenges that made me think I am going about this incorrectly.</p>\n<p>For the component composition strategy this means I need a WIT for each source file of the DSL. I can derive this but found it difficult as it seems I need to generate wit text programmatically and then immediately parse it. Additionally my DSL has generics and monomorphization so depending the program there will be unique wit definitions. Given that I believe my language features are amenable to link directly in a shared everything mode this approach seems backwards.</p>\n<p>However for the dynamic linking approach I ran into issues about the GC proposal not being supported. I use basic structs etc from the GC proposal. Is there anything fundamental about GC features that means a shared everything linking strategy will not work? Or is it simply not implementing yet? I am using the Rust wit-component crate. </p>\n<p>Anyone have some general advice on how to think about this challenge? I am new to many of these concepts so any good reading would also be appreciated.</p>",
        "id": 535753356,
        "sender_full_name": "Nathaniel Cook",
        "timestamp": 1755895358
    },
    {
        "content": "<p>Ordinarily/usually, components are seen as a trust boundary, and the copying semantics across the boundary means that they might not be the best fit for \"individual module in source language\": my expectation as a developer with most languages is that I can freely refactor code into modules and submodules and move things around with ~zero impact on the cost function. So personally I'd rule out the component-per-source-module approach unless you have some fairly unique requirements</p>",
        "id": 535753769,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1755895583
    },
    {
        "content": "<p>I <em>suspect</em> that you'll want to address the \"separate compilation\" question in general first -- i.e., decide what processing can happen per module and what needs to happen when you see the whole program. That can have some surprising subtleties, especially around things like generics/monomorphization, or inlining, or ...</p>\n<p>Then once you know this, you'll have a better idea whether you want \"just a Wasm linker, but one that understands GC\" (that seems like a thing that should exist and probably the gaps just haven't been filled in yet?) or \"LTO step that does more custom stuff\"</p>",
        "id": 535753923,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1755895667
    },
    {
        "content": "<p>clang uses a special .o format for wasm that is, internally, a wasm module with custom sections describing relocations, and clang's wasm-ld links those into a single module</p>",
        "id": 535753956,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1755895684
    },
    {
        "content": "<p>Thanks, I agree and to be clear there will be a separation between source files and modules but left those details  for simplicity</p>",
        "id": 535753958,
        "sender_full_name": "Nathaniel Cook",
        "timestamp": 1755895687
    },
    {
        "content": "<p>and chris is probably about to explain this but theres WIP for creating a canonical abi for GC proposal types. until then, you cant use gc types at component boundaries, you'd have to serialize into a memory and then use memory for canonical abi</p>",
        "id": 535754075,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1755895760
    },
    {
        "content": "<p>That as well! (fitzgen has been leading that -- won't tag him but feel free to if questions)</p>",
        "id": 535754140,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1755895799
    },
    {
        "content": "<p>Is there anything written up yet that I can read?</p>",
        "id": 535754181,
        "sender_full_name": "Nathaniel Cook",
        "timestamp": 1755895820
    },
    {
        "content": "<p>that probably falls under \"tag him if questions\" -- I'm not aware of any public writeups yet</p>",
        "id": 535754214,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1755895844
    },
    {
        "content": "<p><a href=\"https://github.com/WebAssembly/component-model/issues/525\">https://github.com/WebAssembly/component-model/issues/525</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/issues/525\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/e7d07cae567993f42dd9fd51bd21d3591b8c8e22/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f306462623062653936633334343439343331323161613164336266626135623638306464366361396163343733656365373036626639306433653037323164612f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c2f6973737565732f353235&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/issues/525\" title=\"Pre-Proposal: Wasm GC Support in the Canonical ABI 路 Issue #525 路 WebAssembly/component-model\">Pre-Proposal: Wasm GC Support in the Canonical ABI 路 Issue #525 路 WebAssembly/component-model</a></div><div class=\"message_embed_description\">Pre-Proposal: Wasm GC Support in the Canonical ABI This issue proposes extensions to the Component Model's Canonical ABI for Wasm GC support and describes some of the motivation for particular choi...</div></div></div>",
        "id": 535754279,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1755895883
    },
    {
        "content": "<p>if this is all in one trust domain, though, I'd gently nudge away from that and toward shared-everything linking with GC -- to your question</p>\n<blockquote>\n<p>Is there anything fundamental about GC features that means a shared everything linking strategy will not work? Or is it simply not implementing yet?</p>\n</blockquote>\n<p>it should be possible to merge GC type sections the same way wasm-ld merges data, functions, and other entities -- likely it's \"just\" a matter of extending it, nothing fundamental.</p>",
        "id": 535754321,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1755895911
    },
    {
        "content": "<p>Ok excellent, yeah it's all one trust domain and using shared everything seems simpler in my case. I'll give it a try. Thanks for the advice and context</p>",
        "id": 535754636,
        "sender_full_name": "Nathaniel Cook",
        "timestamp": 1755896059
    }
]