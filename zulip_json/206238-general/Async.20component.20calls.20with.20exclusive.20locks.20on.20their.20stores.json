[
    {
        "content": "<p>I am currently changing my codebase (an the components it uses) to support Wasmtime's <code>component-model-async</code> feature and am wondering how async component calls will work, as currently every call into a component requires a mutable reference to its store which is exclusive?</p>\n<p>Example code snippet from one of my projects on how I currently handle this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">call_event</span><span class=\"p\">(</span>\n<span class=\"w\">        </span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">plugin_name</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">,</span>\n<span class=\"w\">        </span><span class=\"n\">event</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kp\">&amp;</span><span class=\"nc\">DiscordEvents</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">-&gt;</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">DiscordRequests</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">plugins</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">plugins</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">;</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">plugin</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">plugins</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">plugin_name</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span>\n\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">plugin</span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">instance</span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">discord_bot_plugin_plugin_functions</span><span class=\"p\">()</span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">call_discord_event</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">plugin</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">event</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// plugin.store is of the type Mutex&lt;Store&lt;InternalRuntime&gt;&gt;</span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"k\">await</span>\n<span class=\"w\">        </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">call_result</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">call_result</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">discord_requests</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">discord_requests</span><span class=\"p\">),</span>\n<span class=\"w\">                </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">err</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                    </span><span class=\"n\">error</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"The plugin returned an error: {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">err</span><span class=\"p\">);</span>\n<span class=\"w\">                    </span><span class=\"nb\">Err</span><span class=\"p\">(())</span>\n<span class=\"w\">                </span><span class=\"p\">}</span>\n<span class=\"w\">            </span><span class=\"p\">},</span>\n<span class=\"w\">            </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">err</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">                </span><span class=\"n\">error</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"Something went wrong while calling the plugin: {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">err</span><span class=\"p\">);</span>\n<span class=\"w\">                </span><span class=\"nb\">Err</span><span class=\"p\">(())</span>\n<span class=\"w\">            </span><span class=\"p\">}</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>I assume this is a pretty negligent question so feel free to link me to resources which explain/expand upon this topic (any resources regarding wasmtime's v36/37 WASIp3 changes are welcome as well).</p>\n<p>NOTE: I have done some more research before posting and have found <code>wasmtime::component::Access</code> and its <code>new</code> function, it seems that this might solve my issue as I can also pass it to my component call function instead of the Store itself? I am just not sure how to implement it.</p>",
        "id": 541710052,
        "sender_full_name": "Celarye",
        "timestamp": 1758905354
    },
    {
        "content": "<blockquote>\n<p>I assume this is a pretty negligent question so feel free to link me to resources which explain/expand upon this topic</p>\n</blockquote>\n<p>Heh no worries at all! WASIp3 isn't released yet so we're still in the lead-up phase where we're getting things in place, and docs are one of those things that only scantily exists so far. It's mostly \"documented\" through examples and tests in the Wasmtime repo.</p>\n<blockquote>\n<p>currently every call into a component requires a mutable reference to its store which is exclusive</p>\n</blockquote>\n<p>The basic answer to this question is: we solved this by not taking a mutable reference. <a href=\"https://docs.rs/wasmtime/latest/wasmtime/component/struct.Instance.html#method.run_concurrent\"><code>Instance::run_concurrent</code></a> sort of transforms a <code>StoreContextMut</code> into an <code>Accessor</code> which is then threaded around to functions such as <a href=\"https://docs.rs/wasmtime/latest/wasmtime/component/struct.Func.html#method.call_concurrent\"><code>Func::call_concurrent</code></a> to achieve concurrent execution.</p>\n<p>To get access to this in bindgen-generated bindings you'll either want the WIT function to specify that it's <code>async</code> (e.g. <code>export foo: async func();</code>) or you'll want to specify <code>exports: { default: store }</code> in your <code>bindgen!</code> configuration</p>",
        "id": 541735747,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1758916169
    },
    {
        "content": "<p>This leaves me with two main issues/questions.</p>\n<p>1.</p>\n<p>I am not sure how to incorporate this into my current design as <code>run_concurrent</code> still requires a mutable reference to a <code>Store</code>. Is there a way I can instead maybe store an <code>Accessor</code> in a struct which I can then just re-use? Maybe I am missing a way to make this work with <code>run_concurrent</code>?</p>\n<hr>\n<p>2.</p>\n<p>Before I had:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wasmtime</span><span class=\"p\">::</span><span class=\"n\">component</span><span class=\"p\">::</span><span class=\"n\">bindgen</span><span class=\"o\">!</span><span class=\"p\">({</span><span class=\"w\"> </span><span class=\"n\">imports</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">async</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"n\">exports</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">async</span><span class=\"w\"> </span><span class=\"p\">}});</span>\n</code></pre></div>\n<ul>\n<li>This correctly makes all my host functions async.</li>\n<li>This makes all component calls async, but still allows you to pass a mutable reference to a <code>Store</code> and all call arguments need to be references.</li>\n</ul>\n<p>Now I tried to replace the above line with:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wasmtime</span><span class=\"p\">::</span><span class=\"n\">component</span><span class=\"p\">::</span><span class=\"n\">bindgen</span><span class=\"o\">!</span><span class=\"p\">();</span>\n</code></pre></div>\n<p>And instead I added the <code>async</code>keyword to all my host and component functions in my WIT files.</p>\n<ul>\n<li>This breaks all host functions:</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"mf\">2.</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">no</span><span class=\"w\"> </span><span class=\"n\">implementations</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">consider</span><span class=\"w\"> </span><span class=\"n\">adding</span><span class=\"w\"> </span><span class=\"n\">one</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">E0277</span><span class=\"p\">]</span>\n</code></pre></div>\n<ul>\n<li>This makes it so component calls only accept on <code>&amp;wasmtime::component::Accessor&lt;_, _&gt;</code> and no mutable references to <code>Stores</code> and all call arguments need to be owned values.</li>\n</ul>\n<p>Meaning that what I ended up with is that I only added the <code>async</code>keyword to my component functions and:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wasmtime</span><span class=\"p\">::</span><span class=\"n\">component</span><span class=\"p\">::</span><span class=\"n\">bindgen</span><span class=\"o\">!</span><span class=\"p\">({</span><span class=\"w\"> </span><span class=\"n\">imports</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">async</span><span class=\"w\"> </span><span class=\"p\">}});</span>\n</code></pre></div>\n<p>Is this intended behavior?</p>",
        "id": 541817074,
        "sender_full_name": "Celarye",
        "timestamp": 1758988783
    },
    {
        "content": "<p>I am actually not sure where I should get access to the <code>run_concurrent</code> method using <code>bingen!</code>, I also tried <code>exports: { default: store }</code> (alongside the <code>async</code> keyword) but could not find it.</p>\n<p>Image as example for where I try to access it, <code>Plugin</code> is the <code>bindgen!</code> generated <code>Instance</code>: <a href=\"/user_uploads/15107/oM5biUD3CCNgQa8n5itXoRH_/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/15107/oM5biUD3CCNgQa8n5itXoRH_/image.png\" title=\"image.png\"><img data-original-content-type=\"image/png\" data-original-dimensions=\"3004x1866\" src=\"/user_uploads/thumbnail/15107/oM5biUD3CCNgQa8n5itXoRH_/image.png/840x560.webp\"></a></div><p>This is kind of related to my second question above but anywhere I can find more docs on the <code>bindgen!</code> options like <code>exports: { default: store }</code> or <code>exports: { default: tracing }</code>(curious what it's for). No worries if there aren't any yet!</p>",
        "id": 541905958,
        "sender_full_name": "Celarye",
        "timestamp": 1759079009
    }
]