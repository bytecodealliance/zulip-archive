[
    {
        "content": "<p>Hello, I have a problem with Pollable in wasmtime.</p>\n<p>I have:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[async_trait]</span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Pollable</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyResource</span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"n\">ready</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">){</span>\n<span class=\"w\">    </span><span class=\"n\">eprintln</span><span class=\"p\">(</span><span class=\"s\">\"ready - 1\"</span><span class=\"p\">);</span>\n<span class=\"w\">    </span><span class=\"n\">tokio</span><span class=\"p\">::</span><span class=\"n\">time</span><span class=\"p\">::</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"n\">tokio</span><span class=\"p\">::</span><span class=\"n\">time</span><span class=\"p\">::</span><span class=\"n\">Duration</span><span class=\"p\">::</span><span class=\"n\">from_secs</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)).</span><span class=\"k\">await</span><span class=\"p\">;</span>\n<span class=\"w\">    </span><span class=\"n\">eprintln</span><span class=\"p\">(</span><span class=\"s\">\"ready - 2\"</span><span class=\"p\">);</span>\n<span class=\"w\">  </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>The sleep timer never clicks. I only see \"ready - 1\" in the logs.  I never see \"ready - 2\".  Is this because I call Ready() before Block() inside my wasm guest?</p>",
        "id": 545827532,
        "sender_full_name": "Joel",
        "timestamp": 1760877823
    },
    {
        "content": "<p>so just to set the table there are two different <code>ready</code>s: <code>pollable.ready</code> the wit method, and <code>async fn Pollable::ready(&amp;mut self)</code> the Rust method</p>",
        "id": 545857297,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760908422
    },
    {
        "content": "<p><code>pollable.block</code> is equivalent to <code>Pollable::ready(&amp;mut pollable_resource).await</code>. <code>pollable.ready</code> is equivalent to <code>futures::future::[poll_immediate](https://docs.rs/futures/latest/futures/future/fn.poll_immediate.html)(async { Pollable::ready(&amp;mut pollable_resource).await }).await</code>- basically it creates the future returned by the Pollable::ready method, and then it calls Future::poll on it exactly once, and returns true if it was <code>Poll::Ready</code> and false if it was <code>Poll::Pending</code></p>",
        "id": 545857396,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760908540
    },
    {
        "content": "<p>Hi.  I am trying to implement the pollable.ready WIT method in the host.  So I implemented Pollable::read(&amp;mut self).  </p>\n<p>I notice that if I add a panic after \"read - 2\" log line, that the future gets \"read\".</p>",
        "id": 545857417,
        "sender_full_name": "Joel",
        "timestamp": 1760908562
    },
    {
        "content": "<p>yeah, thats intended</p>",
        "id": 545857453,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760908604
    },
    {
        "content": "<p>whats going on there is that async {} block is changed by rustc to a Future</p>",
        "id": 545857464,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760908616
    },
    {
        "content": "<p>the async block contains your eprintln!(1), then a function that will be Pending for 3 seconds and finally Ready, then eprintln!(2)</p>",
        "id": 545857481,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760908639
    },
    {
        "content": "<p>But without the panic, the 3 second timer never lapses for me.</p>",
        "id": 545857495,
        "sender_full_name": "Joel",
        "timestamp": 1760908665
    },
    {
        "content": "<p>correct, the panic is just the symptom</p>",
        "id": 545857502,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760908678
    },
    {
        "content": "<p>what are you trying to achieve here</p>",
        "id": 545857504,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760908682
    },
    {
        "content": "<p>theres a disconnect between your understanding of rust Futures and my docs and description of this interface, the differences are indeed subtle</p>",
        "id": 545857522,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760908713
    },
    {
        "content": "<p>the goal of <code>async fn Pollable::ready</code> is that it becomes ready when the pollable is ready, but the method itself can be called a number of times (in calls to <code>pollable.ready</code> which is a nonblocking check, in calls to <code>pollable.block</code>, and in calls to <code>poll.poll</code>)</p>",
        "id": 545857559,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760908776
    },
    {
        "content": "<p>I am trying to write a ready function using tokio async (ie a normal async function).  And my wasm guest calls Block(). I expect the host-side ready function to resolve after the timer elapses and the guest to unblock.</p>",
        "id": 545857561,
        "sender_full_name": "Joel",
        "timestamp": 1760908780
    },
    {
        "content": "<p>so if you write an implementation of <code>Pollable::ready</code> that cant handle it being created and canceled arbitrarily you will not get what you want</p>",
        "id": 545857589,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760908808
    },
    {
        "content": "<p>tell me more about what a normal async function is in your context.</p>",
        "id": 545857604,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760908826
    },
    {
        "content": "<p>I have a flume channel I want to read from. But, I cannot even get a simple tokio timer to work.</p>",
        "id": 545857652,
        "sender_full_name": "Joel",
        "timestamp": 1760908883
    },
    {
        "content": "<p>so, if you want to implement a pollable for something that is only ready 3 seconds after creation, you need to write the resource as storing the Instant at which it is ready, and impl Pollable with <code>tokio::time::sleep_until(self.instant).await</code>, see <a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi/src/p2/host/clocks.rs#L124\">https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi/src/p2/host/clocks.rs#L124</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi/src/p2/host/clocks.rs#L124\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/fd8cc1e57b91f7a120ad0010773aee0b7a9e9508/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f633665353136363961363565333065383434326638316335336336363961663064666363366334643766336131323563303961346132323563313463303762342f62797465636f6465616c6c69616e63652f7761736d74696d65&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/blob/main/crates/wasi/src/p2/host/clocks.rs#L124\" title=\"wasmtime/crates/wasi/src/p2/host/clocks.rs at main · bytecodealliance/wasmtime\">wasmtime/crates/wasi/src/p2/host/clocks.rs at main · bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">A lightweight WebAssembly runtime that is fast, secure, and standards-compliant - bytecodealliance/wasmtime</div></div></div>",
        "id": 545857967,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760909180
    },
    {
        "content": "<p>because theres a difference between the creation of the resource itself, and the lifetime of the future given by the <code>Pollable::ready</code> function.</p>",
        "id": 545857991,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760909221
    },
    {
        "content": "<p>theres a lot going on in there because of the way wasi works</p>",
        "id": 545858031,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760909245
    },
    {
        "content": "<p>you'll have to read the source code of that clocks impl in wasmtime-wasi p2 and also the wasmtime-wasi-io implementation of pollable if you want to fully internalize it</p>",
        "id": 545858061,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760909281
    },
    {
        "content": "<p>Thanks, I will take another crack at this focusing on the clock and wasi-io example.</p>",
        "id": 545858106,
        "sender_full_name": "Joel",
        "timestamp": 1760909341
    },
    {
        "content": "<p>I am guessing the future canceling part is what I am missing, but I need to do more research to understand.</p>",
        "id": 545858127,
        "sender_full_name": "Joel",
        "timestamp": 1760909373
    },
    {
        "content": "<p>you could also write your resource to contain a MaybeDone(your-fut) <a href=\"https://docs.rs/futures/latest/futures/future/enum.MaybeDone.html\">https://docs.rs/futures/latest/futures/future/enum.MaybeDone.html</a> and then Pollable can await the MaybeDone, and when youre trying to add another method to the resource to get a thing out of your flume channel, you can use MaybeDone::output_mut to pop something out of the inside.</p>",
        "id": 545858140,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1760909390
    },
    {
        "content": "<p>Ah, this looks easier for me.</p>",
        "id": 545858176,
        "sender_full_name": "Joel",
        "timestamp": 1760909432
    },
    {
        "content": "<p>I tried using a simple <code>tokio::time::sleep_until(*instant).await</code> just like the Clock example, but to no avail.  I am not sure how to use MaybeDone in the Pollable implementation.  </p>\n<p>I tried defining an async block on every invocation of the ready function, then doing an await on the result.  However, that did not work either.</p>",
        "id": 545859350,
        "sender_full_name": "Joel",
        "timestamp": 1760910855
    },
    {
        "content": "<p>Thanks. I appreciate the help, but there must be something else going on with my setup as the future is not being read. I tried your suggestion, but the timer never goes off.</p>\n<p>I can't really understand why by putting a panic in a future the future is evaluated, but if I don't put a panic the future is never evaluated. So, I will do research on that.</p>",
        "id": 545868541,
        "sender_full_name": "Joel",
        "timestamp": 1760921765
    },
    {
        "content": "<p>Ok, so, it looks like if I make multiple Ready calls from the wasm guest, all the Pollable futures get blocked. If I just do one call at a time from the guest, I don't get blocks.  This is similar to what someone told me in a previous question I asked on this forum, but I assumed that was for Block calls and not Ready calls.</p>",
        "id": 545869741,
        "sender_full_name": "Joel",
        "timestamp": 1760923037
    }
]