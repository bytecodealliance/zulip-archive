[
    {
        "content": "<p>I implemented a WIT bindgen host-side set of functions that utilize the WIT \"future\" keyword.  In Rust on the host side, I need to return a FutureReader.  But, I only have a WasiCtx and ResourceTable.  It does not seem possible to use a FutureReader because I need access to the store and instance objects.  Is there a way to generate a FutureReader with just a WasiCtx? I just want to asynchronously return a u64 after a database lookup.</p>",
        "id": 538114578,
        "sender_full_name": "Joel",
        "timestamp": 1757291057
    },
    {
        "content": "<p>I think you'll want <a href=\"https://github.com/bytecodealliance/wasmtime/pull/11628\">this commit</a>, where in the meantime you can use the <code>async</code> option and get to the store via an <code>Accessor</code></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasmtime/pull/11628\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/6c34d0c9f4fdf359e733fbd84b9b5262d4ca89ac/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f643436333662343662303433643134376166653434623733333361323561313261393166313434656539333931613930643836633332303037623566393838302f62797465636f6465616c6c69616e63652f7761736d74696d652f70756c6c2f3131363238&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasmtime/pull/11628\" title=\" Support store-access in `bindgen!` generated imports  by alexcrichton 路 Pull Request #11628 路 bytecodealliance/wasmtime\"> Support store-access in `bindgen!` generated imports  by alexcrichton 路 Pull Request #11628 路 bytecodealliance/wasmtime</a></div><div class=\"message_embed_description\">This commit adds support to accessing the store in bindgen!-generated\nimport functions in traits. Since the inception of bindgen! this has\nnever been possible and access to the store requires manua...</div></div></div>",
        "id": 538126973,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1757304384
    },
    {
        "content": "<p>Thanks for the pointer! I see that in the host implementation all the calls are already async.  Why is it necessary to set \"future\" in the WIT file and use FutureReader instead of just using async functions on the Host side?</p>",
        "id": 538188206,
        "sender_full_name": "Joel",
        "timestamp": 1757327742
    },
    {
        "content": "<p>I might be missing something perhaps? Are you writing these WIT files yourself or are you using, for example, WIT files for WASI?</p>\n<p>The <code>FutureReader</code> type corresponds to <code>future&lt;T&gt;</code> in WIT, no more and no less. Whether or not a function is <code>async</code> on the host defaults to the <code>async</code> annotation in WIT but can also be configured on the host too</p>",
        "id": 538240713,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1757341522
    },
    {
        "content": "<p>Yes, I am writing my own WIT files.  I have a simple function call  that returns a u64. But I am not sure whether to have \"future&lt;result&lt;u64,error-code&gt;&gt;\", or just \"result&lt;u64,error-code&gt;\" as the response.  i just want to avoid the WIT for WASI runtime to no hit a deadlock due to guest code interacting with the host.</p>",
        "id": 538241278,
        "sender_full_name": "Joel",
        "timestamp": 1757341651
    },
    {
        "content": "<p>The signatures are pretty similar, but for example you can transfer a future to other components where you can't transfer a subtask (e.g. an <code>async</code> function). Which is more appropriate sort of depends on the context of your embedding and APIs</p>",
        "id": 538242649,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1757341996
    }
]