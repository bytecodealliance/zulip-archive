[
    {
        "content": "<p>I am working on a VM for my own blockchain and would like to know if there is any workaround or way to somehow use LLVM for AoT compilation of WASM binaries.</p>\n<p>The reason I want to do this is so that I can use wasmtime and benefit from it being up to date with the latest wasm 3.0 spec and an active ecosystem etc. while using cranelift for dev builds and llvm for much more optimized AoT builds.</p>",
        "id": 561204922,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764605296
    },
    {
        "content": "<p>there is no support for using llvm as a backend in the wasmtime project, and its reasonable to expect that there never will be. wasmtime are designed for running untrusted wasm, and llvm is not designed to accept untrusted inputs.</p>",
        "id": 561221484,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1764608505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"253992\">Pat Hickey</span> <a href=\"#narrow/channel/206238-general/topic/LLVM.20Support.20for.20AoT.20Compilation/near/561221484\">said</a>:</p>\n<blockquote>\n<p>there is no support for using llvm as a backend in the wasmtime project, and its reasonable to expect that there never will be. wasmtime are designed for running untrusted wasm, and llvm is not designed to accept untrusted inputs.</p>\n</blockquote>\n<p>Wait what really? Why so? (The LLVM untrusted inputs part.)</p>",
        "id": 561223222,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764608827
    },
    {
        "content": "<p>How does wasmer deal with this? Or other wasm runtimes that support LLVM as a backend.</p>",
        "id": 561223949,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764608984
    },
    {
        "content": "<p>The general expectation right now is that you'd use LLVM to compile-to-wasm which does all the necessary high-level optimizations that Cranelift won't do like auto-vectorization, loop rotations, etc. Cranelift is then a high-quality code generator which means that the &lt;src&gt; -&gt; LLVM -&gt; &lt;wasm&gt; -&gt; Cranelift -&gt; &lt;asm&gt; chain is still quite well optimized. Our experience is that tight loops are on-par with other WebAssembly compilers in terms of performance. In that sense while Cranelift is not as optimized of a code generator as LLVM it's expected that the lion's share of performance is still gained.</p>\n<blockquote>\n<p>Wait what really? Why so? (The LLVM untrusted inputs part.)</p>\n</blockquote>\n<p>LLVM is not written or architected to compile untrusted inputs. It's not really supposed to be since it's tasked with being a suitable compiler for first-party-sourced code. Compiling untrusted inputs (like what Wasmtime/WebAssembly are) is an entirely different problem. The expectation is \"garbage in garbage out\" with LLVM.</p>\n<p>An example of this is that a miscompile in LLVM is not a CVE. Every single miscompile, however, has the possibility of being a CVE in the context of compiling untrusted code. LLVM maintainers (rightfully) are not reviewing all commits for evaluating the imapct of bug fixes and changes. Such behavior is required in the space of compiling untrusted inputs, however.</p>",
        "id": 561223955,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1764608985
    },
    {
        "content": "<p>As far as we are aware no other WebAssembly runtime using LLVM deals with this. They're either unaware of the consequences of using LLVM or choose to ignore it.</p>",
        "id": 561224099,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1764609014
    },
    {
        "content": "<p>You can read up on LLVM's security policy <a href=\"https://llvm.org/docs/Security.html#what-is-considered-a-security-issue\">here</a>, notably:</p>\n<blockquote>\n<p>For example, a maliciously crafted C, Rust or bitcode input file can cause arbitrary code to execute in LLVM</p>\n</blockquote>\n<p>And this is NOT considered a security issue in LLVM since LLVM explicitly does not provide this guarantee</p>",
        "id": 561224516,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1764609111
    },
    {
        "content": "<p>Oh wow damn. I didn't know this.</p>\n<p>Is Cranelift the most optimized right now?</p>",
        "id": 561224547,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764609118
    },
    {
        "content": "<p>For Wasmtime, yes.</p>",
        "id": 561224609,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1764609128
    },
    {
        "content": "<p>What do you mean?</p>",
        "id": 561224641,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764609138
    },
    {
        "content": "<p>Cranelift is Wasmtime's most optimized code generator</p>",
        "id": 561224698,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1764609152
    },
    {
        "content": "<p>Are there better code generators which give the best runtime performance as in my usecase startup times are a lesser priority over runtime performance.</p>",
        "id": 561224793,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764609182
    },
    {
        "content": "<p>Like not specific to wasmtime.</p>",
        "id": 561224890,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764609205
    },
    {
        "content": "<p>I am stilling exploring options to commit to a runtime.</p>",
        "id": 561224925,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764609212
    },
    {
        "content": "<p>wasmtime seems to be the best bet because of the strong backing by huge corporations.</p>",
        "id": 561224989,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764609232
    },
    {
        "content": "<p>That you'll have to evaluate for yourself, I at least do not personally keep tabs on other runtimes.</p>",
        "id": 561225009,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1764609236
    },
    {
        "content": "<p>Yeah I mean I just wanted to suggest that like someone at BCA should probably release benchmarks with every major release comparing wasmtime with other runtimes.</p>\n<p>Really helps because I don't know what all kind of workloads to test the runtime on to properly compare two runtimes or whether I am even testing the runtimes on the right thing in the first place.</p>",
        "id": 561225489,
        "sender_full_name": "Aarav Dayal",
        "timestamp": 1764609339
    },
    {
        "content": "<blockquote>\n<p>Yeah I mean I just wanted to suggest that like someone at BCA should probably release benchmarks with every major release comparing wasmtime with other runtimes.</p>\n</blockquote>\n<p>Please feel free to do so and post results here -- in the spirit of open source, \"be the change you want to see\" etc etc. As-is we don't have a benchmarking team ready to go (we're all quite busy).</p>\n<p>If you do a modest amount of Internet searching, you'll find various comparisons people have done. Frank Denis has a round of benchmarks of a bunch of major engines that showed Wasmtime+Cranelift comparing well to LLVM-based engines. On <a href=\"http://cranelift.dev\">cranelift.dev</a> we link a paper that has detailed data as well.</p>",
        "id": 561231691,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1764610688
    },
    {
        "content": "<p>moreover, to be useful the benchmarking would need to be largely agreed upon across the runtime ecosystem, and as each runtime is optimized for certain scenarios that were originally important to them, that agreement is unlikely to come. you, however, are free to help out others in your position by doing something about that. :-)</p>",
        "id": 561259389,
        "sender_full_name": "Ralph",
        "timestamp": 1764618017
    }
]