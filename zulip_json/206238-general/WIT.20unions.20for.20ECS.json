[
    {
        "content": "<p>I want to make ECS using wasm component model</p>\n<p>I can't figure out how to make function which accepts different components (records)<br>\nThe only approach I see is to use variants:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">record</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span>\n<span class=\"p\">}</span>\n<span class=\"n\">record</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">u32</span>\n<span class=\"p\">}</span>\n<span class=\"n\">variant</span><span class=\"w\"> </span><span class=\"n\">components</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">),</span>\n<span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">spawn</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">func</span><span class=\"p\">(</span><span class=\"n\">components</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">list</span><span class=\"o\">&lt;</span><span class=\"n\">components</span><span class=\"o\">&gt;</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>Is there any other way to achieve similar effect (list&lt;components&gt;) without using variants (because of repeated names), something similar to unions (removed in 2023), builder pattern is possible, but not preferred</p>",
        "id": 531158950,
        "sender_full_name": "Lacosst0",
        "timestamp": 1753629660
    },
    {
        "content": "<p>I think a variant is the best option. It is very likely that a union without some sort of discriminator does not exist, variant makes this explicit and portable across languages. I would assume that name spaces give a way to distinguish the elements of the same name (there might be a limitation of the language binding you are using). </p>\n<p>Unions got removed because of security concerns and not being used in practice.</p>",
        "id": 531281312,
        "sender_full_name": "Christof Petig",
        "timestamp": 1753682389
    },
    {
        "content": "<p>Yeah, unions were removed because many (most?) languages would require awkward-at-best name generation for cases like <code>list&lt;u8&gt;</code>. IMO a little redundancy in the WIT  is worth it to make the mappings easier to follow in general.</p>",
        "id": 531388219,
        "sender_full_name": "Lann Martin",
        "timestamp": 1753713687
    },
    {
        "content": "<p>The only way to store named fields is record, and the only way to have unions is variant. Both of them are named</p>\n<p>For example rust can store named fields inside enums</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span><span class=\"w\"> </span><span class=\"nc\">Message</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"n\">Quit</span><span class=\"p\">,</span>\n<span class=\"w\">    </span><span class=\"n\">Move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"p\">},</span>\n<span class=\"w\">    </span><span class=\"n\">Write</span><span class=\"p\">(</span><span class=\"nb\">String</span><span class=\"p\">),</span>\n<span class=\"w\">    </span><span class=\"n\">ChangeColor</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">),</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Can WIT support something similar to that?<br>\nIn my opinion this covers most, if not all use cases of unions<br>\nFor languages which can't support this style in any way, WIT can potentially use A(A) as a fallback</p>",
        "id": 531398798,
        "sender_full_name": "Lacosst0",
        "timestamp": 1753716473
    },
    {
        "content": "<p>wit doesn't support Rust style named fields inside enums, because the goal of wit is to target many different programming languages, and very few have that capability natively, so they'd have to emulate it with a combination of their variant and record constructions. The goal of wit and wit-bindgen isn't to produce perfect idiomatic code in the language of your choice, and we expect that to produce ideal code in your given language you will need to add some hand-written code on top of the types output by wit-bindgen, or otherwise customize your wit-bindgen</p>",
        "id": 531407869,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1753719087
    },
    {
        "content": "<p>Sorry for misunderstanding. I thought the entire point of WIT is to <em>not</em> write hand-written code and have <em>good enough</em> code generation without compromises (because why even use wit then). I think my use case isn't covered by WIT and I am ready to help with the design of the idea (to the best of my ability)<br>\nAre there wit-bindgen methods/separate projects to customize wit generation? Maybe alternatives to wit?</p>",
        "id": 531441329,
        "sender_full_name": "Lacosst0",
        "timestamp": 1753730392
    },
    {
        "content": "<p>wit is the language which is specified in the component-model standard, wit-bindgen is a generator created by the bytecode alliance that makes bindings from the canonical ABI to bindings for a given language. the two projects are distinct, though the people who contribute to them are often the same - but the spec of wit and components exists separately so that anyone can write their own tools that take the place of wit-bindgen.</p>",
        "id": 531445188,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1753731691
    },
    {
        "content": "<p>the wit language is designed to balance making the best possible bindings in some given language with being accessible to a very wide range of languages, and tries not to unnecessarily privilege some languages over others where possible. We have already had complaints from various users that wit is too rust-like and languages that lack Algebraic Datatypes (ADTs), which rust calls <code>enum</code>, have a harder time using it. so, I personally would be against making wit develop even more language features that are not even specific to ADTs but to a small number of languages's implementations of ADTs.</p>",
        "id": 531445843,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1753731905
    },
    {
        "content": "<p>the alternative approach you could take here is to work on wit-bindgen to make it even more clever when it comes to generating rust bindings. You could add a pass that looks to see if a record definition is only used in variant variations, and then expand those variant variations to use those record fields as named fields, instead of defininig an intermediate record. this would make no difference to either the canonical abi lowering or, likely, to any sort of performance in the Rust, since the representation would be the same and any accesses would inline to the same, but it might make the bindings look more idiomatic if that makes a huge difference to you. my judgement is thats a lot of work for a small benefit, but if it matters to you, you can open issues or PRs on wit-bindgen to discuss or submit an implementation.</p>",
        "id": 531449546,
        "sender_full_name": "Pat Hickey",
        "timestamp": 1753732080
    },
    {
        "content": "<p>I'd suggest an issue or discussion in <a class=\"stream\" data-stream-id=\"327223\" href=\"/#narrow/channel/327223-wit-bindgen\">#wit-bindgen</a> before a PR for major feature changes <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 531450067,
        "sender_full_name": "Lann Martin",
        "timestamp": 1753732278
    }
]