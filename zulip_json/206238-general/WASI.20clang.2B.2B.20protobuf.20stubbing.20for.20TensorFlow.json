[
    {
        "content": "<p>When ONNX Runtime loads ORT format models in WASM/WASI, protobuf's RepeatedPtrField calls constructors like onnx::TensorProto::TensorProto(google::protobuf::Arena*, bool) via function pointers (see <a href=\"https://github.com/microsoft/onnxruntime/blob/main/onnxruntime/core/graph/graph.cc\">onnxruntime/core/graph/graph.cc</a> around the LoadFromOrtFormat method that processes initializers). wasmtime validates these function pointer signatures against the C++ ABI and rejects them as mismatched, even with stub implementations, because the function pointer calling convention doesn't match wasmtime's expected C++ member function signature.<br>\n  References:<br>\n  • ONNX Runtime: onnxruntime/core/graph/graph.cc - Graph::LoadFromOrtFormat() method that processes initializers using protobuf's RepeatedPtrField<br>\n  • Protobuf: google/protobuf/repeated_ptr_field.h - TypeHandler::NewFromPrototype() which calls constructors via function pointers</p>\n<p>I'm able to compile to wasip1 and run without issue, however, I can't get it to work with either the adapter or compiling directly to wasip2</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/microsoft/onnxruntime/blob/main/onnxruntime/core/graph/graph.cc\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/888ef02556971c17443eb37b7c45d1c4e5e024c4/68747470733a2f2f7265706f7369746f72792d696d616765732e67697468756275736572636f6e74656e742e636f6d2f3135363933393637322f33376231636230302d383634622d313165622d383232302d373631353339333566376461&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/microsoft/onnxruntime/blob/main/onnxruntime/core/graph/graph.cc\" title=\"onnxruntime/onnxruntime/core/graph/graph.cc at main · microsoft/onnxruntime\">onnxruntime/onnxruntime/core/graph/graph.cc at main · microsoft/onnxruntime</a></div><div class=\"message_embed_description\">ONNX Runtime: cross-platform, high performance ML inferencing and training accelerator - microsoft/onnxruntime</div></div></div>",
        "id": 555447077,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763063892
    },
    {
        "content": "<p>I'm trying to parse this problem and having some trouble -- could you fill in some details?</p>\n<ul>\n<li>Wasmtime doesn't have knowledge of the C++ ABI (it's not a C++ compiler or runtime). What do you mean by \"wasmtime validates these function pointer signatures against the C++ ABI\"? Or \"wasmtime's expected C++ member function signature\"?</li>\n<li>Is this an issue with code running inside the guest? If so, what is the observed symptom? Does the Wasm trap? What is the trap? Does the trap make sense given the static information in the module? Does the module run successfully on any other runtimes?</li>\n</ul>\n<p>Basically I'm very confused about what you're actually doing -- sorry!</p>",
        "id": 555448566,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763064375
    },
    {
        "content": "<p>(If I guess that you're running C++ in the guest, and hitting some sort of signature mismatch, that would be a toolchain bug in your C++-to-Wasm compiler; but it's not 100% clear that's what you mean)</p>",
        "id": 555448724,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763064428
    },
    {
        "content": "<p>Sorry. I wish I understood better. I'm able to build and compose the component I built with ONNX Runtime, but it fails when I try to run it.<br>\nThe WASM module traps with wasm trap: wasm unreachable instruction executed when ONNX Runtime's Graph::LoadFromOrtFormat() processes initializers. The backtrace shows the trap occurs at address 0x29340 when attempting to call what should be  onnx::TensorProto::TensorProto(google::protobuf::Arena*, bool).<br>\n  What's happening:</p>\n<p>1. Guest code: ONNX Runtime (onnxruntime/core/graph/graph.cc lines 6067-6097) uses protobuf's RepeatedPtrField to add TensorProto objects. Despite my patch to use UnsafeArenaAddAllocated, protobuf still invokes a constructor via function pointer.<br>\n  2. Function pointer call: Protobuf calls the constructor through a function pointer stored in its type metadata.<br>\n  3. wasmtime validation: When wasmtime executes the indirect call, it validates the function signature against the function table entry. This validation fails.<br>\n  4. Trap: wasmtime traps with \"unreachable\" (either because validation inserted unreachable, or the called function immediately executes unreachable).</p>",
        "id": 555453201,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763066171
    },
    {
        "content": "<p>OK. It sounds like, then, that this is either an ONNX issue or C++ compiler issue. \"Wasmtime traps when calling a function pointer of the wrong signature\" is spec-compliant behavior and the only thing we can do. If I were you I would work with the ONNX project to debug this further</p>",
        "id": 555453702,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763066349
    },
    {
        "content": "<p>The problem is that I have to stub out the protobufs. They are trying to access system information that doesn't exist in the runtime. It's just frustrating that I didn't have this trouble with preview 1. It just worked.</p>",
        "id": 555454381,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763066591
    },
    {
        "content": "<p>I don't know what to tell you, sorry -- it's surprising that changing the target would affect something in the guest like that, but from an engine perspective, at a signature mismatch there's nothing we can do; the standard says we must trap; it's very clearly a bug somewhere in the guest</p>",
        "id": 555454963,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763066746
    },
    {
        "content": "<p>It doesn't match because I'm trying to stub out a mangled function name.</p>",
        "id": 555455079,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763066789
    },
    {
        "content": "<p>I'm still missing some context here. Why are you trying to stub something out? Or if you have to, why not stub it out with the correct signature?</p>",
        "id": 555455194,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763066834
    },
    {
        "content": "<p>We'd need something like this, but for WASI<br>\n<a href=\"https://github.com/invokr/protobuf-emscripten\">protobuf-emscripten</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/invokr/protobuf-emscripten\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/4b37d12c824f7dd861e8d62b71efccb753f95366/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f366338383261313061653131653662356634613364373134633031633631343737336364383339656565373162323033343664623538396630613631326363312f696e766f6b722f70726f746f6275662d656d736372697074656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/invokr/protobuf-emscripten\" title=\"GitHub - invokr/protobuf-emscripten: Google's Protocol Buffers for emscripten\">GitHub - invokr/protobuf-emscripten: Google's Protocol Buffers for emscripten</a></div><div class=\"message_embed_description\">Google's Protocol Buffers for emscripten. Contribute to invokr/protobuf-emscripten development by creating an account on GitHub.</div></div></div>",
        "id": 555455435,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763066933
    },
    {
        "content": "<p>Or this: <a href=\"https://github.com/dsyer/protobuf-wasm\">https://github.com/dsyer/protobuf-wasm</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/dsyer/protobuf-wasm\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/6284a326275202946c5dc6fabecd733c05a5ec42/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f366638633635316136386131326133333132623063396663663434363730613439303733343033646534353730336536373430366465313434363730333261662f64737965722f70726f746f6275662d7761736d&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/dsyer/protobuf-wasm\" title=\"GitHub - dsyer/protobuf-wasm\">GitHub - dsyer/protobuf-wasm</a></div><div class=\"message_embed_description\">Contribute to dsyer/protobuf-wasm development by creating an account on GitHub.</div></div></div>",
        "id": 555455538,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763066980
    },
    {
        "content": "<p>I'm still missing something, sorry. So you're building stubs equivalent to the above (it looks like the first one at least is just replacing atomics). Why not write those stubs with the correct signature?</p>",
        "id": 555455748,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763067063
    },
    {
        "content": "<p>I'm sorry. I'm going to ask perplexity why stubbing protobufs is so hard. I'm not a C++ person. I hope this helps</p>\n<p>Why stubbing protobuf signatures is hard:</p>\n<p>1. Function pointer calls vs direct calls: Protobuf stores constructor function pointers in type metadata (TypeHandler::NewFromPrototype). When protobuf calls via these pointers, wasmtime validates the indirect call against the function table entry. The stub signature must match exactly what wasmtime expects for that table entry, not just the C++ signature.<br>\n  2. C++ calling convention differences: For a C++ member function like TensorProto::TensorProto(Arena*, bool), the this pointer is implicit. When called via function pointer, this becomes explicit. The stub must match the function-pointer calling convention, which may differ from the member function signature.<br>\n  3. Type system mismatch: We've tried stubbing with void* and int32_t/bool, but wasmtime may be validating against the actual C++ types (onnx::TensorProto<em>, google::protobuf::Arena</em>, bool). The error message doesn't specify what wasmtime expects, so we're guessing.<br>\n  4. Multiple constructor variants: C++ has C1 (complete object) and C2 (base object) constructors. Both may be needed, and their signatures can differ subtly.<br>\n  5. No diagnostic information: The error signature_mismatch:onnx::TensorProto::TensorProto(google::protobuf::Arena*, bool) doesn't show:<br>\n    • What signature wasmtime expected<br>\n    • What signature was provided<br>\n    • Which parameter type mismatched</p>\n<p>6. Function table vs symbol: The function exists as a symbol (0x26f74), but the trap occurs at a different address (0x29340), suggesting the function table entry has a different signature than the actual function.</p>\n<p>The core issue: wasmtime validates indirect calls strictly, and we don't have visibility into what signature it expects for the function table entry. We're guessing based on the C++ signature, but the function-pointer calling convention may require a different signature.</p>",
        "id": 555455845,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763067108
    },
    {
        "content": "<blockquote>\n<p>I'm going to ask perplexity</p>\n</blockquote>\n<p>Asking an AI agent for a load of slop that doesn't answer my question is a gross disrespect of maintainers' time. Sorry, I'm not able to help further.</p>",
        "id": 555455980,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763067162
    },
    {
        "content": "<p>I don't understand what to tell you. If doesn't make sense then please point out where. This is obviously a difficult problem that I've spent the past week trying to work through</p>",
        "id": 555456311,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763067293
    },
    {
        "content": "<p>We don't have this problem with emscripten or preview1. So obviously something needs to work as we move towards preview 3.</p>",
        "id": 555456484,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763067358
    },
    {
        "content": "<p>Copy/pasting a half-page of text at me from your agent is not answering the question. The question was: \"why are you not able to write the stubs with the correct signature?\"</p>",
        "id": 555456541,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763067381
    },
    {
        "content": "<p>That's exactly the question it answered.</p>",
        "id": 555456576,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763067396
    },
    {
        "content": "<p>It wasn't AI slop. It's a known difficulty with protobufs that requires separate projects.</p>",
        "id": 555456625,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763067421
    },
    {
        "content": "<p>I'm unable to help further, sorry! Best of luck.</p>",
        "id": 555456750,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763067463
    },
    {
        "content": "<p>I have a little time now so I'm going to demonstrate why this AI agent's answer makes no sense:</p>\n<blockquote>\n<p>When protobuf calls via these pointers, wasmtime validates the indirect call against the function table entry. The stub signature must match exactly what wasmtime expects for that table entry, not just the C++ signature.</p>\n</blockquote>\n<p>The agent is:</p>\n<ul>\n<li>Saying \"what wasmtime expects\" rather than \"what the Wasm standard expects\"; hence sending you to us and seeing this as an issue in Wasmtime rather than a bug in the code you are writing</li>\n<li>\"The stub signature must match exactly what wasmtime expects for that table entry, not just the C++ signature.\" is nonsensical: Wasm-level signatures are determined precisely from C++-level signatures by the source toolchain (but again, this is not a wasmtime concern: we are not a C++ compiler)</li>\n<li>\"We've tried stubbing with void* and int32_t/bool, but wasmtime may be validating against the actual C++ types\"<ul>\n<li>First, why did you stub with those randomly chosen types? Use the correct types, don't guess</li>\n<li>Second, Wasmtime does not have anything to do with C++. It doesn't care what the guest language is. It doesn't know anything about the guest language. That's not how the whole pipeline works: C++ is compiled down to Wasm bytecode.</li>\n</ul>\n</li>\n<li>\"Type system mismatch\": yes, exactly, that's the problem: you're using the wrong types.</li>\n<li>\"The error message doesn't specify what wasmtime expects, so we're guessing.\" That's because Wasmtime is not a C++ compiler and doesn't know about C++ types. That's not how the abstraction layers work here.</li>\n<li>\"Multiple constructor variants:\" This is completely irrelevant.</li>\n<li>\"No diagnostic information: The error ... doesn't show what signature Wasmtime expected\": again, Wasmtime is not a C++ compiler</li>\n<li>\"The core issue: wasmtime validates indirect calls strictly, and we don't have visibility into what signature it expects\": Wasmtime is not a C++ compiler and has no concept of C++ signatures. It does validate Wasm bytecode-level signatures, because that's what the spec requires.</li>\n</ul>\n<p>Basically: this is a long essay that boils down to \"the types are wrong and that's an error\". My question remains: why not use the correct types?</p>",
        "id": 555475261,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763075467
    },
    {
        "content": "<p>The issue lies with the WASI SDK. I agree.</p>",
        "id": 555480657,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763078650
    },
    {
        "content": "<p>I'm glad we are in violent agreement. What do we need to get into the WASI SDK so that ONNX Runtime will work with components, specifically protobufs?</p>",
        "id": 555480972,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763078850
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"555446\">@Colin D Murphy</span> the other point I believe Chris is making is that it's not quite reasonable to present a very large \"black box\" of ONNX/protobufs/etc and say \"something's broken, how do I fix it?\". Those projects are quite large and the possible modes of failure are even larger. The bug here could range anywhere from UB in ONNX to UB in protobufs to bugs in either to a bug in clang to a bug in wasi-sdk to a bug in wasmtime to an architecture-specific bug, etc. There's really no way to diagnose an issue like this when it's so large. </p>\n<p>At the same time I at least personally don't think it's reasonable to expect others to reduce the issue for you. For example I know virtually nothing of ONNX/protobufs nor where to even start in terms of reduction. I know a lot about wasi-sdk, wasi-libc, and wasmtime, but \"there's a trap here\" is not sufficient knowledge to point to something and say \"it's your fault figure it out\".</p>\n<p>I'd recommend trying to reduce this failure on your end. The less source code in play the better. For example if you could give us a modest C file with no dependencies and say \"this passes on native but not on wasm\" that is light-years easier to debug.</p>",
        "id": 555482418,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1763079526
    },
    {
        "content": "<p>Also, I can reiterate, when it comes to debugging I would very strongly recommend against using LLMs. LLMs are not suitable when you're not already an expert in the problem space. When you're debugging something it's probably because you're not sure why it's going wrong, which by definition means you're not an expert in the problem space. LLMs are likely to add more confusion to the situation and they should not be used as justification for \"the problem lies here because this LLM said so\"</p>",
        "id": 555482552,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1763079598
    },
    {
        "content": "<p>Thanks for the feedback <span class=\"user-mention\" data-user-id=\"253994\">@Alex Crichton</span> . Is it fair to ask the question: what is the WASI story for protobufs for preview 2? How do we get this to work for preview3?</p>",
        "id": 555482735,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763079699
    },
    {
        "content": "<p>I can also say that I understand that reduction of a problem like this is an arduous and unforgiving task. In the past I'm sometimes successful at this, sometimes not. It unfortunately doesn't change the ground truth though in that it's up to you to figure out how to reproduce it, and more often than not if you can't figure it out then it's likely to go unsolved.</p>",
        "id": 555482816,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1763079742
    },
    {
        "content": "<p>Well, for protobufs, I can't really answer that. I know nothing of protobufs beyond \"they put stuff in bytes and take them out later\" and I also understand that I'm grossly misrepresenting what they can do. Beyond that the WASI story isn't lined up for particular projects individually, so no, there's no specific story for protobufs.</p>\n<p>More generally it's expected that everything \"just works\" with WASI and its versions. If you need sockets you'll need WASIp2-and-up, but otherwise it should be compatible. If it's not then that's in the realm of \"someone needs to figure out why\", and for now that's probably going to be you.</p>",
        "id": 555483003,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1763079858
    },
    {
        "content": "<p>Also, in my defense, I pointed to a very specific piece of code in a very popular library that used (from what I understand) another commonly used library. I think we should be able to ask questions about how such things should be supported, especially whrn they were supported in preview 1. It was only after several attempts to explain the problem that I resorted to asking an LLM why protobufs are so hard to stub.</p>",
        "id": 555483358,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763080059
    },
    {
        "content": "<p>I don't think that it's reasonable to conclude automatically that this is an issue in wasi-sdk and ask \"what do we need to include in WASI-SDK\". The whole idea of having a C/C++ compiler is that one can take a large C/C++ codebase and compile it with minimal effort. In theory we should never have to do a \"protobuf-specific thing\" in wasi-sdk.</p>\n<p>You linked to several projects above that build protobufs for wasm environments that stub out atomics. Atomics are indeed problematic in Wasm MVP; with the right flags you might be able to use the wasm atomics instructions though. I'm curious why you're trying to stub out other things (you were pointing to constructors above). And then when you do, you use incorrect signatures and that leads to (as expected) a trap.</p>\n<p>Basically: I think there are a lot of flawed assumptions here. The first is that protobufs should need specific support in the platform. That's not really how low-level bytecode platforms work; protobufs should work like any other code inside the guest. The next is that p1/p2 somehow change this story. To be blunt, there is a very high burden of proof to convince someone that a change in IO interfaces should cause a signature mismatch in unrelated C++ code.</p>\n<p>The last flawed assumption is -- to re-emphasize a point that Alex makes above -- that we are \"general tech support\" for any programming problem that happens to be on top of the platform. I am happy to put time in when others are working in good faith with us, but you're throwing a giant ball of conmingled problems at us here, insinuating that it's our fault and we need to fix it, and not able to explain details of what you've done or why. Per your point above that you're \"not a C++ person\", I suspect you need a C++ person here to look at your actual code to see what is wrong. That's beyond the scope of the level of free help I can offer, at least.</p>",
        "id": 555484421,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763080606
    },
    {
        "content": "<p>And to put a final point on it -- you say</p>\n<blockquote>\n<p>The issue lies with the WASI SDK. I agree.</p>\n</blockquote>\n<p>No, I strongly don't agree. If I had to guess, you wrote some code somewhere with an incorrect signature in a modified version of protobufs, and that's causing the issue. You seem to say as much -- you aren't running pure upstream, you're modifying things. \"My hacked-up version of some libraries has an error\" is a problem only you can solve, sorry</p>",
        "id": 555486063,
        "sender_full_name": "Chris Fallin",
        "timestamp": 1763081438
    },
    {
        "content": "<p>I most definitely had it working with preview1. You can ask anyone who was at Wasm Con in Atlanta where I demoed it on stage as part of my talk.<br>\nI'm not trying to cast any blame here, just trying to figure out how to get this working. I'll investigate and see what I need to do. I'm going to start with the emscripten implementation. I'd be perfectly willing to admit I'm wrong here. I don't really care about that.<br>\ncc <span class=\"user-mention\" data-user-id=\"419274\">@Mendy Berger</span> <span class=\"user-mention\" data-user-id=\"421591\">@Bailey Hayes</span></p>",
        "id": 555494061,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763086882
    },
    {
        "content": "<p>I typically use <code>wasm-objdump -x</code> to investigate function signature mismatches at the byte code level. Look for the function which works and the one it complains about. Solved a similar problem for me in minutes, but I am used to debugging c++ at the assembly level for decades, so it will probably send you on a journey to understand name mangling and wat syntax.</p>",
        "id": 555728224,
        "sender_full_name": "Christof Petig",
        "timestamp": 1763196476
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"590366\">@Christof Petig</span> . Threads should reduce the need for many of the stubs for protobufs. Once we have that working, we'll see what remains. I think there will still need be some sort of special handling for arenas. I wouldn't be pursuing this if I didn't see a lot of potential for wasmtime.</p>",
        "id": 556841129,
        "sender_full_name": "Colin D Murphy",
        "timestamp": 1763389000
    },
    {
        "content": "<p>Hey I'd like to take a stab at this one. It's easy to get lost in the sauce when diving deep on a problem with many, many variables. Using the experimental C++ bindgen target definitely seems to be part of the challenge here. I started there and a few fixes and coffees later I got a working http server component: <a href=\"https://github.com/ricochet/sample-wasi-http-cpp\">https://github.com/ricochet/sample-wasi-http-cpp</a></p>\n<p>The bindings there are using this branch on wit-bindgen: <a href=\"https://github.com/bytecodealliance/wit-bindgen/pull/1425\">https://github.com/bytecodealliance/wit-bindgen/pull/1425</a></p>\n<p>Turning to just protobuf+abseil, I definitely ran into rough edges. Abseil already has checks for __wasi__, but it seems incomplete and out of date. I resorted to stubs to compile for p1. I had to add additional stubs for abseil arenas/allocs (as you mentioned) specifically for p2.  I found that a little confusing and plan on looking into it more. Abseil does have a mode that avoids sys calls and removed the need for many of the stubs (ABSL_FORCE_WAITER_MODE=4).I hope to contribute the appropriate wasi stubs back to abseil so folks won't have to do this themselves. I have both p1 and p2 working here: <a href=\"https://github.com/ricochet/wasi-protobuf\">https://github.com/ricochet/wasi-protobuf</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/ricochet/sample-wasi-http-cpp\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/dcabfbdac2393e34ddbd993c090ed4c99b761d78/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f666262636266646363616335306136336562613135626533363733616137316164663939383139333866303139393464616234343665323933396464316238662f7269636f636865742f73616d706c652d776173692d687474702d637070&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/ricochet/sample-wasi-http-cpp\" title=\"GitHub - ricochet/sample-wasi-http-cpp: Sample WASI HTTP Server implemented with C++ and `wit-bindgen cpp`\">GitHub - ricochet/sample-wasi-http-cpp: Sample WASI HTTP Server implemented with C++ and `wit-bindgen cpp`</a></div><div class=\"message_embed_description\">Sample WASI HTTP Server implemented with C++ and `wit-bindgen cpp` - ricochet/sample-wasi-http-cpp</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/pull/1425\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/1b7452668f0fdf19cc22478a9633265c1d7e6364/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f643130396238666566393736316338626138623730323733333162396663643332386166323439636563643736633266343337393637343132633034666632382f62797465636f6465616c6c69616e63652f7769742d62696e6467656e2f70756c6c2f31343235&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/pull/1425\" title=\"cpp resources by ricochet · Pull Request #1425 · bytecodealliance/wit-bindgen\">cpp resources by ricochet · Pull Request #1425 · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">Depends on #1424\nThis adds resource support for wit-bindgen cpp + clippy cleanups across the generator.\nI think the remaining missing feature is covering multiversion. The rest all appear to be asy...</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/ricochet/wasi-protobuf\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/cdb0c186828d16144fae40dafbf7b2d2531a2237/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f666638613336303862613338626366626563393938393835363030323732663138393635336462653361643462646263316565653835313161366339643838322f7269636f636865742f776173692d70726f746f627566&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/ricochet/wasi-protobuf\" title=\"GitHub - ricochet/wasi-protobuf: Example of building protobuf (including Abseil) for WebAssembly (wasip1 and wasip2)\">GitHub - ricochet/wasi-protobuf: Example of building protobuf (including Abseil) for WebAssembly (wasip1 and wasip2)</a></div><div class=\"message_embed_description\">Example of building protobuf (including Abseil) for WebAssembly (wasip1 and wasip2) - ricochet/wasi-protobuf</div></div></div>",
        "id": 558108522,
        "sender_full_name": "Bailey Hayes",
        "timestamp": 1763523039
    }
]