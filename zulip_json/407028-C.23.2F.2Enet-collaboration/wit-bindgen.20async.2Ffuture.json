[
    {
        "content": "<p>Hi, is it too early to start adding support for async and future in the c# code gen ?  I see there are tests already in the main branch?</p>",
        "id": 529702573,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753033043
    },
    {
        "content": "<p>No, not too early -- now is a great time to get started.  I was planning to work on it myself but haven't had a chance yet.  Happy to answer any ABI-related questions if you're ready to take a stab at it.</p>",
        "id": 529711960,
        "sender_full_name": "Joel Dice",
        "timestamp": 1753044338
    },
    {
        "content": "<p>Thanks I'll make a start.</p>",
        "id": 529912473,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753110872
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"509936\">@Joel Dice</span> hi, might take me a few questions to get in the right space with this.  For <br>\n<a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d/tests/codegen/futures.wit#L6\">https://github.com/bytecodealliance/wit-bindgen/blob/454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d/tests/codegen/futures.wit#L6</a><br>\nWe have a function that takes a future as a parameter.  The import of this function sounds like it will in c#, take a <code>Task</code> and lower it to an i32.  But what can the receiver of this <code>i32</code> do with it?  I would expect that it could await the future, but how would it do that?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d/tests/codegen/futures.wit#L6\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/5d72386f0a8b57f97c674ad0b67fa6da7778b551/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f396163653961306337313835616239626564663338653030393039396439613432376465393362323535343839323364393232336130303530393565366337322f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d/tests/codegen/futures.wit#L6\" title=\"wit-bindgen/tests/codegen/futures.wit at 454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d · bytecodealliance/wit-bindgen\">wit-bindgen/tests/codegen/futures.wit at 454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div>",
        "id": 530246069,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753232644
    },
    {
        "content": "<p>For this single import I think I also need to provide a couple of extra functions , waitable-set-wait, that I must call before the calling the import, and provide a future-poll that the runtime can call to check the state of the future, is that sort of right?</p>",
        "id": 530250399,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753236408
    },
    {
        "content": "<p>Think I've confused <code>future</code> and <code>async</code>  I will start with just <code>async</code> as that looks simpler</p>",
        "id": 530666615,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753401651
    },
    {
        "content": "<p>Sorry for the late reply -- I was out on vacation for a few days.</p>\n<p>To call an imported function that takes a <code>future</code>, the guest needs to first call <code>future.new</code>, which returns a pair of <code>i32</code> handles -- one representing the writable end (roughly equivalent to a <code>TaskCompletionSource</code>) and the other representing the readable end (roughly equivalent to the <code>Task</code> corresponding to the <code>TaskCompletionSource</code>).  Then it can pass the readable end to the function and later write a value to the writable end when such a value is available.</p>\n<p>In the Rust bindings, we represent the writable end as a <a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d/crates/guest-rust/rt/src/async_support/future_support.rs#L208\">FutureWriter</a> and the readable end as a <a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d/crates/guest-rust/rt/src/async_support/future_support.rs#L535\">FutureReader</a>, which implements the <code>std::future::Future</code> trait, allowing it to be <code>await</code>ed.</p>\n<p>Anyway, I agree that you'll probably want to start with just supporting the async import and export ABIs before moving on to <code>future</code> and <code>stream</code> support.  Note that a call to an async-lowered import will either return a result immediately or return <code>BLOCKED</code> with a subtask handle representing the status of the call.  That handle may be added to a <code>waitable-set</code>, which in turn may be waited on using either <code>waitable-set.wait</code> or by returning <code>CALLBACK_CODE_WAIT</code> from the async-lifted-with-callback export function that the host originally called the guest on.  The latter is generally preferable when using the callback-based ABI, since it allows the host to make other concurrent calls to the guest.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d/crates/guest-rust/rt/src/async_support/future_support.rs#L208\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/5d72386f0a8b57f97c674ad0b67fa6da7778b551/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f396163653961306337313835616239626564663338653030393039396439613432376465393362323535343839323364393232336130303530393565366337322f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d/crates/guest-rust/rt/src/async_support/future_support.rs#L208\" title=\"wit-bindgen/crates/guest-rust/rt/src/async_support/future_support.rs at 454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d · bytecodealliance/wit-bindgen\">wit-bindgen/crates/guest-rust/rt/src/async_support/future_support.rs at 454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d/crates/guest-rust/rt/src/async_support/future_support.rs#L535\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/5d72386f0a8b57f97c674ad0b67fa6da7778b551/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f396163653961306337313835616239626564663338653030393039396439613432376465393362323535343839323364393232336130303530393565366337322f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d/crates/guest-rust/rt/src/async_support/future_support.rs#L535\" title=\"wit-bindgen/crates/guest-rust/rt/src/async_support/future_support.rs at 454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d · bytecodealliance/wit-bindgen\">wit-bindgen/crates/guest-rust/rt/src/async_support/future_support.rs at 454d6885b5b54adb3601a9b80ca9ff64f6ed7b8d · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div>",
        "id": 530792807,
        "sender_full_name": "Joel Dice",
        "timestamp": 1753455272
    },
    {
        "content": "<p>For every async function we generate a <code>[async-lift]....</code> and a <code>[callback][async-lift]</code> for those 2 scenarios you describe ?</p>",
        "id": 530865850,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753487354
    },
    {
        "content": "<p>on the export side I'm looking at first</p>",
        "id": 530866140,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753487546
    },
    {
        "content": "<p>Yes, and the signature of the <code>[async-lift]...</code> function will take the same set of parameters the sync version would, but return an <code>i32</code> representing the \"callback code\".  The <code>[callback][async-lift]...</code> function will take 3 <code>i32</code> parameters (the first is the event type, and the meaning of the rest depends on the event type) and return an <code>i32</code> callback code.  Either the <code>[async-lift]...</code> or the <code>[callback][async-lift]...</code> function will return its value to the caller by calling the <code>task.return</code> function, whose signature depends on the WIT-level return type of the function being exported.</p>\n<p>One way to get a feel for all this is to examine the output of the C bindings generator for various async-lifted exports.</p>",
        "id": 530920327,
        "sender_full_name": "Joel Dice",
        "timestamp": 1753522096
    },
    {
        "content": "<p>Thanks very much, I should be able to get the first tests passing from here.</p>",
        "id": 530946288,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753536116
    },
    {
        "content": "<p>are you using a locally built clang to get support for <code>async</code> in wit ?</p>",
        "id": 530990707,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753557606
    },
    {
        "content": "<p>Ive got</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">C</span><span class=\"p\">:</span><span class=\"err\">\\</span><span class=\"n\">github</span><span class=\"err\">\\</span><span class=\"n\">wit</span><span class=\"o\">-</span><span class=\"n\">bindgen</span><span class=\"err\">\\</span><span class=\"n\">target</span><span class=\"err\">\\</span><span class=\"n\">artifacts</span><span class=\"err\">\\</span><span class=\"n\">simple</span><span class=\"o\">-</span><span class=\"n\">import</span><span class=\"o\">-</span><span class=\"n\">params</span><span class=\"o\">-</span><span class=\"n\">results</span><span class=\"err\">\\</span><span class=\"n\">test</span><span class=\"o\">-</span><span class=\"n\">csharp</span><span class=\"err\">\\</span><span class=\"n\">bindings</span><span class=\"o\">&gt;</span><span class=\"s\">\"c:\\github\\wasi-sdk25/bin/clang\"</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"n\">obj</span><span class=\"err\">\\</span><span class=\"n\">Debug</span><span class=\"err\">\\</span><span class=\"n\">net9</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"err\">\\</span><span class=\"n\">wasi</span><span class=\"o\">-</span><span class=\"n\">wasm</span><span class=\"err\">\\</span><span class=\"n\">native</span><span class=\"err\">\\</span><span class=\"n\">link</span><span class=\"p\">.</span><span class=\"n\">rsp</span><span class=\"w\"> </span><span class=\"s\">\"</span>\n<span class=\"s\">error: unable to add component type \"</span><span class=\"n\">TestWorld_component_type</span><span class=\"p\">.</span><span class=\"n\">wit</span><span class=\"s\">\"</span>\n\n<span class=\"s\">Caused by:</span>\n<span class=\"s\">    0: expected keyword `func`, found an identifier</span>\n<span class=\"s\">            --&gt; TestWorld_component_type.wit:4:17</span>\n<span class=\"s\">             |</span>\n<span class=\"s\">           4 |   one-argument: async func(x: u32);</span>\n<span class=\"s\">             |                 ^</span>\n<span class=\"s\">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span>\n</code></pre></div>",
        "id": 530990779,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753557640
    },
    {
        "content": "<p>I believe clang is calling <code>wasm-component-ld</code>, which is producing that error.  WASI-SDK's version of <code>wasm-component-ld</code> isn't new enough to understand async, so you'll want to replace the one in WASI-SDK with <a href=\"https://github.com/bytecodealliance/wasm-component-ld/releases/tag/v0.5.15\">the latest release</a> (which isn't using the very latest wasm-tools, but it's only one version behind, so should be new enough).</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-component-ld/releases/tag/v0.5.15\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/71ec5ddeb036b8a411e4a855bea90be9892fcc01/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f646163366639663663386166613937316461663934393935333730353331356461396138346131306663363561386664333534333735616262383961303135322f62797465636f6465616c6c69616e63652f7761736d2d636f6d706f6e656e742d6c642f72656c65617365732f7461672f76302e352e3135&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-component-ld/releases/tag/v0.5.15\" title=\"Release v0.5.15 · bytecodealliance/wasm-component-ld\">Release v0.5.15 · bytecodealliance/wasm-component-ld</a></div><div class=\"message_embed_description\">Command line linker for creating WebAssembly components - Release v0.5.15 · bytecodealliance/wasm-component-ld</div></div></div>",
        "id": 530991699,
        "sender_full_name": "Joel Dice",
        "timestamp": 1753558099
    },
    {
        "content": "<p>I've been using <code>wasm-tools</code> directly to convert modules to components and/or embed component type custom sections, so I haven't tried using <code>wasm-component-ld</code> yet -- hopefully it should just work.</p>",
        "id": 530991887,
        "sender_full_name": "Joel Dice",
        "timestamp": 1753558189
    },
    {
        "content": "<p>lets see :-)</p>",
        "id": 530991946,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753558213
    },
    {
        "content": "<p>that links at least.  What is the significance of <code>[export]</code> in this c<br>\n__attribute__((__import_module__(\"[export]a:b/i\"), __import_name__(\"[task-return][async]one-argument\")))</p>",
        "id": 530995760,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753560116
    },
    {
        "content": "<p>I understand that this is the callback (task-return) for returning the async result, so it needs some specially handling by the linker I guess.</p>",
        "id": 530996303,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753560376
    },
    {
        "content": "<p>yeah, that's just the convention we made up and which <code>wit-component</code> recognizes as the import module to expect the task-return function to be imported from.  We use the <code>[export]</code> prefix to indicate that, although this is an import, we're doing the import on behalf of a specific exported function.</p>",
        "id": 530998450,
        "sender_full_name": "Joel Dice",
        "timestamp": 1753561455
    },
    {
        "content": "<p>thanks, this can all wait until Monday, I'm just asking today.  I have this error</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">------</span><span class=\"w\"> </span><span class=\"n\">Failure</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">simple</span><span class=\"o\">-</span><span class=\"n\">import</span><span class=\"o\">-</span><span class=\"n\">params</span><span class=\"o\">-</span><span class=\"n\">results</span><span class=\"w\"> </span><span class=\"o\">--------</span>\n<span class=\"w\">  </span><span class=\"n\">component</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">test</span>\n<span class=\"w\">  </span><span class=\"n\">path</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">tests</span><span class=\"err\">\\</span><span class=\"n\">runtime</span><span class=\"o\">-</span><span class=\"k\">async</span><span class=\"err\">\\</span><span class=\"k\">async</span><span class=\"err\">\\</span><span class=\"n\">simple</span><span class=\"o\">-</span><span class=\"n\">import</span><span class=\"o\">-</span><span class=\"n\">params</span><span class=\"o\">-</span><span class=\"n\">results</span><span class=\"err\">\\</span><span class=\"n\">test</span><span class=\"p\">.</span><span class=\"n\">cs</span>\n<span class=\"w\">  </span><span class=\"n\">error</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">compile</span><span class=\"w\"> </span><span class=\"n\">component</span><span class=\"w\"> </span><span class=\"s\">\"tests</span><span class=\"se\">\\\\</span><span class=\"s\">runtime-async</span><span class=\"se\">\\\\</span><span class=\"s\">async</span><span class=\"se\">\\\\</span><span class=\"s\">simple-import-params-results</span><span class=\"se\">\\\\</span><span class=\"s\">test.cs\"</span>\n\n<span class=\"w\">  </span><span class=\"n\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span><span class=\"p\">:</span>\n<span class=\"w\">      </span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">compiler</span><span class=\"w\"> </span><span class=\"n\">produced</span><span class=\"w\"> </span><span class=\"n\">invalid</span><span class=\"w\"> </span><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"s\">\"C:</span><span class=\"se\">\\\\</span><span class=\"s\">github</span><span class=\"se\">\\\\</span><span class=\"s\">wit-bindgen</span><span class=\"se\">\\\\</span><span class=\"s\">.</span><span class=\"se\">\\\\</span><span class=\"s\">target</span><span class=\"se\">\\\\</span><span class=\"s\">artifacts</span><span class=\"se\">\\\\</span><span class=\"s\">simple-import-params-results</span><span class=\"se\">\\\\</span><span class=\"s\">test-csharp.wasm\"</span>\n<span class=\"w\">      </span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">lowered</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"p\">[]</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"kr\">do</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"p\">[</span><span class=\"n\">I32</span><span class=\"p\">]</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"n\">function</span><span class=\"w\"> </span><span class=\"mi\">140</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"mh\">0xfdd769</span><span class=\"p\">)</span>\n<span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"n\">tests</span><span class=\"w\"> </span><span class=\"n\">FAILED</span>\n</code></pre></div>\n<p>Which seems like I've got the <code>[async-lower]</code> or <code>[async-lift]</code> wrong, but they are both <code>int32 (int32)</code> for a <code>void</code> async that takes an <code>int32</code> which I think is right and the same as the c code gen.  Is there any modification of signatures that goes on <code>wasm-component-ld</code> or <code>wasmtime</code> ?</p>",
        "id": 531046891,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753584606
    },
    {
        "content": "<p>its a bit weird becuse function 140 is unrelatead</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">   </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"cp\">$</span><span class=\"s\">\"Thread::ResetCachedTransitionFrame()\"</span><span class=\"w\"> </span><span class=\"p\">(;</span><span class=\"mi\">140</span><span class=\"p\">;)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">param</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 531183329,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753638569
    },
    {
        "content": "<p>oh, Im reading the <code>alias</code> wrong, but I still don't understand how this works.  The core function for this needs to return the callback code so it will have a result type of <code>i32</code>.  Is it the <code>canon lift</code> on the alias that is incorrect perhaps</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"p\">(;</span><span class=\"mi\">49</span><span class=\"p\">;)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">param</span><span class=\"w\"> </span><span class=\"s\">\"x\"</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)))</span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">alias</span><span class=\"w\"> </span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"n\">export</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"w\"> </span><span class=\"s\">\"[async-lift]a:b/i#[async]one-argument\"</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"p\">(;</span><span class=\"mi\">140</span><span class=\"p\">;)))</span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"p\">(;</span><span class=\"mi\">41</span><span class=\"p\">;)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"mi\">49</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">canon</span><span class=\"w\"> </span><span class=\"n\">lift</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"mi\">140</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"p\">))</span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">component</span><span class=\"w\"> </span><span class=\"p\">(;</span><span class=\"mi\">0</span><span class=\"p\">;)</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"p\">(;</span><span class=\"mi\">0</span><span class=\"p\">;)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">param</span><span class=\"w\"> </span><span class=\"s\">\"x\"</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)))</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">import</span><span class=\"w\"> </span><span class=\"s\">\"import-func-one-argument\"</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"p\">(;</span><span class=\"mi\">0</span><span class=\"p\">;)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)))</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"p\">(;</span><span class=\"mi\">1</span><span class=\"p\">;)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">param</span><span class=\"w\"> </span><span class=\"s\">\"x\"</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)))</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">export</span><span class=\"w\"> </span><span class=\"p\">(;</span><span class=\"mi\">1</span><span class=\"p\">;)</span><span class=\"w\"> </span><span class=\"s\">\"[async]one-argument\"</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)))</span>\n<span class=\"w\">  </span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"p\">(;</span><span class=\"mi\">20</span><span class=\"p\">;)</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">instantiate</span><span class=\"w\"> </span><span class=\"mi\">0</span>\n<span class=\"w\">      </span><span class=\"p\">(</span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"s\">\"import-func-one-argument\"</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"w\"> </span><span class=\"mi\">41</span><span class=\"p\">))</span>\n<span class=\"w\">    </span><span class=\"p\">)</span>\n<span class=\"w\">  </span><span class=\"p\">)</span>\n</code></pre></div>",
        "id": 531218892,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753652958
    },
    {
        "content": "<p>I' m going to dig further into wasm-component-ld as I suspect something there currently.  I'm probably wrong, but need to see if what you do , generating the sections manually, fixes things</p>",
        "id": 531224126,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753655148
    },
    {
        "content": "<p>If you can point me to a branch with your changes and instructions for reproducing the issue, I can take a look.</p>",
        "id": 531378514,
        "sender_full_name": "Joel Dice",
        "timestamp": 1753711221
    },
    {
        "content": "<p>Thanks very much, I wonder if its because I've got 2 wits in the link, haven't investigated that yet.<br>\n<a href=\"https://github.com/yowl/cs-wit-bindgen/tree/csharp-async-simple\">https://github.com/yowl/cs-wit-bindgen/tree/csharp-async-simple</a></p>\n<p>Download wasi sdk 25 and replace wasm-component-ld, Im using a locally built one from main yesterday.<br>\nThen <code>cargo build</code><br>\nand  </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">cargo</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">languages</span><span class=\"w\"> </span><span class=\"n\">csharp</span><span class=\"w\"> </span><span class=\"n\">tests</span><span class=\"err\">\\</span><span class=\"n\">runtime</span><span class=\"o\">-</span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">artifacts</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"err\">\\</span><span class=\"n\">target</span><span class=\"err\">\\</span><span class=\"n\">artifacts</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">rust</span><span class=\"o\">-</span><span class=\"n\">wit</span><span class=\"o\">-</span><span class=\"n\">bindgen</span><span class=\"o\">-</span><span class=\"n\">path</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"err\">\\</span><span class=\"n\">crates</span><span class=\"err\">\\</span><span class=\"n\">guest</span><span class=\"o\">-</span><span class=\"n\">rust</span><span class=\"w\"> </span><span class=\"o\">--</span><span class=\"n\">runner</span><span class=\"w\"> </span><span class=\"s\">\"wasmtime -W component-model-async\"</span>\n</code></pre></div>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/yowl/cs-wit-bindgen/tree/csharp-async-simple\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/938da4ff5fbc0b4206866958751d15811846828f/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f396337373635363035343461666431323461306331653065633331616262626234363632336336356333636432353431366534623738646331633837343033372f796f776c2f63732d7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/yowl/cs-wit-bindgen/tree/csharp-async-simple\" title=\"GitHub - yowl/cs-wit-bindgen at csharp-async-simple\">GitHub - yowl/cs-wit-bindgen at csharp-async-simple</a></div><div class=\"message_embed_description\">Testing wit-bindgen for c# and NativeAOT-LLVM. Contribute to yowl/cs-wit-bindgen development by creating an account on GitHub.</div></div></div>",
        "id": 531382851,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753712321
    },
    {
        "content": "<p>Thanks.  I've got a bunch of meetings this morning, but I'll dig in later today.</p>",
        "id": 531383051,
        "sender_full_name": "Joel Dice",
        "timestamp": 1753712375
    },
    {
        "content": "<p>I'm not totally stuck yet, I can do more research later if you have better things to do.</p>",
        "id": 531383127,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753712395
    },
    {
        "content": "<p>Okay, I reproduced this on my end.  It looks like <code>wit-component</code> is getting confused and generating an async lift <em>without</em> a callback because the core module is not exporting a callback function.  It <em>should</em> be rejecting the module when it sees that you're using the with-callback ABI but not providing a callback, but instead it produces a component that fails validation.  I'll fix the <code>wit-component</code> issue so we can catch the problem there (and hopefully provide a clearer diagnostic).</p>\n<p>Meanwhile, maybe you can dig into why the generated C# code is not exporting a callback function.</p>",
        "id": 531430533,
        "sender_full_name": "Joel Dice",
        "timestamp": 1753726551
    },
    {
        "content": "<p>Ah thanks, right, I haven't implemented that bit yet as I don't think it will be on the call path yet.  But definitely I need to do it, so might as well be now</p>",
        "id": 531430855,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753726668
    },
    {
        "content": "<p>Great, that seesm to be passing the first test.  Thanks very much.</p>",
        "id": 531618822,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753797832
    },
    {
        "content": "<p>WIth an async function that returns a value, not void, I understand that it takes an extra pointer parameter is passed .  How does that relate to the <code>task-return</code> or the pointer is nothing to do with the return value, but is just used by the runtime?  What should this pointer  point to ?</p>",
        "id": 531965009,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753927896
    },
    {
        "content": "<p>Are you referring to the async <em>lower</em> ABI?  If so, yes, the core signature of an async lowered function will include an extra parameter if the component-level signature returns a value, and that must point to an allocation in linear memory which is aligned and sized correctly for the result to be stored.  <code>task-return</code> isn't relevant here because we're talking about lowering imports, not lifting exports.</p>\n<p>The async <em>lift</em> ABI has no such result pointer parameter, since <code>task-return</code> is used to return the result, if any.  The main thing to keep in mind is that the lift and lower ABIs are different.</p>",
        "id": 532080217,
        "sender_full_name": "Joel Dice",
        "timestamp": 1753969842
    },
    {
        "content": "<p>Thank you!</p>",
        "id": 532157031,
        "sender_full_name": "Scott Waye",
        "timestamp": 1753991805
    },
    {
        "content": "<p>I see the codegen tests use the <code>waitable-...</code> way of returning , is the <code>[task-return]</code>flow well tested ?</p>",
        "id": 532390208,
        "sender_full_name": "Scott Waye",
        "timestamp": 1754089272
    },
    {
        "content": "<p>ignore that, I see the c tests use it.</p>",
        "id": 532395278,
        "sender_full_name": "Scott Waye",
        "timestamp": 1754093150
    },
    {
        "content": "<p>I have a question about the c test for simple-future.  There are 2 functions in the wit<br>\n<a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/eaf42f6c12d9cca8231d5a361d20b6c21c2a2739/tests/runtime-async/async/simple-future/test.wit#L4-L5\">https://github.com/bytecodealliance/wit-bindgen/blob/eaf42f6c12d9cca8231d5a361d20b6c21c2a2739/tests/runtime-async/async/simple-future/test.wit#L4-L5</a><br>\nLooking at the test for <code>drop-future</code> where it writes to the writer:<br>\n<a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/eaf42f6c12d9cca8231d5a361d20b6c21c2a2739/tests/runtime-async/async/simple-future/runner.c#L34\">https://github.com/bytecodealliance/wit-bindgen/blob/eaf42f6c12d9cca8231d5a361d20b6c21c2a2739/tests/runtime-async/async/simple-future/runner.c#L34</a><br>\nIt calls <code>test_future_void_write</code> which is generated as </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">runner_waitable_status_t</span><span class=\"w\"> </span><span class=\"n\">test_future_void_write</span><span class=\"p\">(</span><span class=\"n\">test_future_void_writer_t</span><span class=\"w\"> </span><span class=\"n\">writer</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">test_future_void__write</span><span class=\"p\">(</span><span class=\"n\">writer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">NULL</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>which in turn calls <code>test_future_void__write</code> defined as </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">__attribute__</span><span class=\"p\">((</span><span class=\"n\">__import_module__</span><span class=\"p\">(</span><span class=\"s\">\"my:test/i\"</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">__import_name__</span><span class=\"p\">(</span><span class=\"s\">\"[async-lower][future-write-0][async]read-future\"</span><span class=\"p\">)))</span>\n<span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"n\">uint32_t</span><span class=\"w\"> </span><span class=\"n\">test_future_void__write</span><span class=\"p\">(</span><span class=\"n\">uint32_t</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">uint8_t</span><span class=\"o\">*</span><span class=\"p\">);</span>\n</code></pre></div>\n<p>Which has the import name for the <code>read-future</code> function.  What am I missing here?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/eaf42f6c12d9cca8231d5a361d20b6c21c2a2739/tests/runtime-async/async/simple-future/test.wit#L4-L5\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/50cd0505ad3a8575e79246c21a37b2737823449e/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f396633643162306531386134363863376234383163343734366363616634323461333366353336613261393134626430613836376139316365353664373734362f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/eaf42f6c12d9cca8231d5a361d20b6c21c2a2739/tests/runtime-async/async/simple-future/test.wit#L4-L5\" title=\"wit-bindgen/tests/runtime-async/async/simple-future/test.wit at eaf42f6c12d9cca8231d5a361d20b6c21c2a2739 · bytecodealliance/wit-bindgen\">wit-bindgen/tests/runtime-async/async/simple-future/test.wit at eaf42f6c12d9cca8231d5a361d20b6c21c2a2739 · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/eaf42f6c12d9cca8231d5a361d20b6c21c2a2739/tests/runtime-async/async/simple-future/runner.c#L34\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/50cd0505ad3a8575e79246c21a37b2737823449e/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f396633643162306531386134363863376234383163343734366363616634323461333366353336613261393134626430613836376139316365353664373734362f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/eaf42f6c12d9cca8231d5a361d20b6c21c2a2739/tests/runtime-async/async/simple-future/runner.c#L34\" title=\"wit-bindgen/tests/runtime-async/async/simple-future/runner.c at eaf42f6c12d9cca8231d5a361d20b6c21c2a2739 · bytecodealliance/wit-bindgen\">wit-bindgen/tests/runtime-async/async/simple-future/runner.c at eaf42f6c12d9cca8231d5a361d20b6c21c2a2739 · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div>",
        "id": 534720917,
        "sender_full_name": "Scott Waye",
        "timestamp": 1755297793
    },
    {
        "content": "<p>I.e., I would expect to see an import for <code>drop-future</code>.</p>",
        "id": 534720976,
        "sender_full_name": "Scott Waye",
        "timestamp": 1755297853
    },
    {
        "content": "<p>Is it that internally any \"void future\" would work here, due to some internal things.  I think I read that only one task (subtask?) can be active at a time?</p>",
        "id": 534721063,
        "sender_full_name": "Scott Waye",
        "timestamp": 1755297929
    },
    {
        "content": "<p>I'm not sure I understand what you're asking, but note that we use a \"trick\" to refer to a given <code>future</code> or <code>stream</code> type in the binding generator, allowing <code>wit-component</code> to determine which type to use when generating references to the <code>future.write</code>, <code>future.drop</code>, etc. intrinsics: <a href=\"https://github.com/bytecodealliance/wasm-tools/blob/f6967282dce8f2b3be29ddcd0f33cb90a37ec8f4/crates/wit-parser/src/lib.rs#L1160-L1174\">https://github.com/bytecodealliance/wasm-tools/blob/f6967282dce8f2b3be29ddcd0f33cb90a37ec8f4/crates/wit-parser/src/lib.rs#L1160-L1174</a></p>\n<p>Trying to encode the entire type using only e.g. name mangling would be difficult if not impossible (imagine mangling <code>future&lt;list&lt;tuple&lt;some-record, some-resource-type&gt;&gt;&gt;</code>, especially given that resource types are not necessarily uniquely identified by their names, e.g. when a resource is both imported and exported), so we instead refer to some arbitrary function that uses the type we care about and use an index to indicate which one we mean.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wasm-tools/blob/f6967282dce8f2b3be29ddcd0f33cb90a37ec8f4/crates/wit-parser/src/lib.rs#L1160-L1174\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/0ea15d01313588cf5bf18f41153bad82b4a26ef6/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f623530353532303430643463363031303634303366623439663861623665363130343836663965303731613037633835363634306138336130616565376432382f62797465636f6465616c6c69616e63652f7761736d2d746f6f6c73&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wasm-tools/blob/f6967282dce8f2b3be29ddcd0f33cb90a37ec8f4/crates/wit-parser/src/lib.rs#L1160-L1174\" title=\"wasm-tools/crates/wit-parser/src/lib.rs at f6967282dce8f2b3be29ddcd0f33cb90a37ec8f4 · bytecodealliance/wasm-tools\">wasm-tools/crates/wit-parser/src/lib.rs at f6967282dce8f2b3be29ddcd0f33cb90a37ec8f4 · bytecodealliance/wasm-tools</a></div><div class=\"message_embed_description\"> CLI and Rust libraries for low-level manipulation of WebAssembly modules  - bytecodealliance/wasm-tools</div></div></div>",
        "id": 534721911,
        "sender_full_name": "Joel Dice",
        "timestamp": 1755298751
    },
    {
        "content": "<p>I'm curious about <code>read-future</code> in the name of the import used by the <code>drop-future</code> test.  Reading the link you posted, and your explanation, I think I get it.  The type is the same, so the name at the end of the import is not that important, its the type that must be matched.</p>",
        "id": 534722313,
        "sender_full_name": "Scott Waye",
        "timestamp": 1755299098
    },
    {
        "content": "<p>Yeah, the point is to pick a function that refers to the type -- if there is more than one which refers to that type, then the binding generator picks one arbitrarily and uses it.</p>",
        "id": 534767133,
        "sender_full_name": "Joel Dice",
        "timestamp": 1755356026
    },
    {
        "content": "<p>I'm thinking to add the cancel functionality next.  We can't extend <code>Task</code> to hold the handle as its sealed, so i was thinking we maintain a list of some sort of created async function tasks, so that we can map the task back to the handle.  We could then have an extensions perhaps to <code>Task</code>, e.g. <code>Cancel</code>, that would look up the handle from the hash set of <code>Task</code>s and call cancel on that handle.   Does that sound sensible?</p>",
        "id": 567276166,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768000958
    },
    {
        "content": "<p>Personally, I'd recommend leaving cancellation until later.  I haven't even added cancel support to Python or Go yet; I'm basically waiting until someone asks for it.  I'd suggest finishing everything <em>except</em> cancellation first, at which point developers will be able to start doing interesting things with WASIp3 in .NET.</p>",
        "id": 567276892,
        "sender_full_name": "Joel Dice",
        "timestamp": 1768001610
    },
    {
        "content": "<p>Anyway, whenever you do tackle cancellation, the hash set sounds plausible to me; I'd be interested to here what Pavel thinks.  I'd have to go back and study <code>Task</code> again to have more of an opinion.</p>",
        "id": 567277031,
        "sender_full_name": "Joel Dice",
        "timestamp": 1768001730
    },
    {
        "content": "<p>Ok, I will leave it for now and look at a different runtime <br>\ntest to tackle.</p>",
        "id": 567280400,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768004640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"509936\">Joel Dice</span> <a href=\"#narrow/channel/407028-C.23.2F.2Enet-collaboration/topic/wit-bindgen.20async.2Ffuture/near/567277031\">said</a>:</p>\n<blockquote>\n<p>I'd be interested to here what Pavel thinks.  I'd have to go back and study <code>Task</code> again to have more of an opinion.</p>\n</blockquote>\n<p>I'm afraid I would have to spent some time playing with latest p3 before I can offer more valuable insight. Right now I think :</p>\n<ul>\n<li>I can explain how we marshal Task&lt;-&gt;Promise between C# and JavaScript. Interesting problems are around two garbage collectors involved. In my first attempt I got confused about ownership of Task vs ownership of the TaskCompletionSource. (prepresented by resolve()/reject() JS methods on JS side). You can also drop/dispose the proxy when it's resolved/rejected. Then the GC is left to collect only abandoned Tasks/Promises.</li>\n<li>Are there delagates/functions/callbacks as call parameter to be marshaled in p3 ? Those also have GC story. In C# they could also capture a closure and keep alive other objects.</li>\n<li>I'm worried that WASI streams could be resolved multiple times. Specifically I don't want to hack and re-resolve C# Task.</li>\n<li>I think that on C# API we should marshal it as as implementation of System.IO.Stream API.  Only it's async methods. C# stream also has synchronous APIs, but those should throw PNSE. </li>\n<li>I know there are ways how WASIp3 host could offer sync-over-async. I (stubbornly) insist that we don't want to expose any of the blocking system calls. Except those which are already blocking in the browser/wasi single-threaded API landscape today (some of the FS and some of the DNS and Crypto). My reason is that I want the managed \"thread pool\" queue to process work even is some other call is waiting. And I think that we are not able to survive re-entry with existing managed call on the stack of the same thread. That would break memory state invariant. I could be convinced that I'm wrong by a prototype, but I think it's not a trivial thing to do. I'm prepared to change my opinion after we have multi-threading, in which we could maybe overcome sync-over-async on dotnet side and we could do re-entrance as another guest thread (or something).</li>\n<li>I don't know what's the current state of cooperative multi-threading. Is there some demo/presentation/lecture/video I can watch ?</li>\n</ul>",
        "id": 567331469,
        "sender_full_name": "Pavel Šavara",
        "timestamp": 1768062660
    },
    {
        "content": "<p>I'm happy to add GC Collects in places  to see what breaks in the runtime tests</p>",
        "id": 567345461,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768077744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"471788\">Pavel Šavara</span> <a href=\"#narrow/channel/407028-C.23.2F.2Enet-collaboration/topic/wit-bindgen.20async.2Ffuture/near/567331469\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Are there delagates/functions/callbacks as call parameter to be marshaled in p3 ? Those also have GC story. In C# they could also capture a closure and keep alive other objects.</li>\n</ul>\n</blockquote>\n<p>I don't have a direct answer to this, but I'll note that we've tried to make WASIp3 \"less trappy\" in that we try to avoid parent/child relationships between component model handles in general.  In p2, we had a lot of parent/child relationships such that if you dropped the parent handle before any of the children, you'd trap, which meant GC-based languages had to do extra work to ensure handles were dropped in the correct order.  p3 is a lot more relaxed about that, FWIW.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"471788\">Pavel Šavara</span> <a href=\"#narrow/channel/407028-C.23.2F.2Enet-collaboration/topic/wit-bindgen.20async.2Ffuture/near/567331469\">said</a>:</p>\n<blockquote>\n<ul>\n<li>I'm worried that WASI streams could be resolved multiple times. Specifically I don't want to hack and re-resolve C# Task.</li>\n</ul>\n</blockquote>\n<p>Yeah, I don't think a <code>stream</code> should be represented as a <code>Task</code>.  Instead, each call to <code>Read</code> or <code>Write</code> should return a new <code>Task</code>, which is equivalent to how the Rust and Python bindings generators work.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"471788\">Pavel Šavara</span> <a href=\"#narrow/channel/407028-C.23.2F.2Enet-collaboration/topic/wit-bindgen.20async.2Ffuture/near/567331469\">said</a>:</p>\n<blockquote>\n<ul>\n<li>I'm prepared to change my opinion after we have multi-threading, in which we could maybe overcome sync-over-async on dotnet side and we could do re-entrance as another guest thread (or something).</li>\n</ul>\n</blockquote>\n<p>It's looking like we might have cooperative multi-threading as part of 0.3.0, or if not, soon afterward.  And it's already implemented in Wasmtime, so I think it would be reasonable for the .NET port to just use mult-threading from the beginning.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"471788\">Pavel Šavara</span> <a href=\"#narrow/channel/407028-C.23.2F.2Enet-collaboration/topic/wit-bindgen.20async.2Ffuture/near/567331469\">said</a>:</p>\n<blockquote>\n<ul>\n<li>I don't know what's the current state of cooperative multi-threading. Is there some demo/presentation/lecture/video I can watch ?</li>\n</ul>\n</blockquote>\n<p>This is the most up-to-date resource I'm aware of: <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Concurrency.md\">https://github.com/WebAssembly/component-model/blob/main/design/mvp/Concurrency.md</a>.  You can also read about the <code>thread.*</code> intrinsics starting <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md#-canon-threadindex\">here</a> for a summary of how threads can be created, suspended, and resumed.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Concurrency.md\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/1f55ddbf76be67ec34176f4f68fde7b9a66f8257/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353637366334343738643566653735316237303563333739323730333862353134333662646639383934636332346137303463336532633634633831313665322f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/Concurrency.md\" title=\"component-model/design/mvp/Concurrency.md at main · WebAssembly/component-model\">component-model/design/mvp/Concurrency.md at main · WebAssembly/component-model</a></div><div class=\"message_embed_description\">Repository for design and specification of the Component Model - WebAssembly/component-model</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md#-canon-threadindex\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/1f55ddbf76be67ec34176f4f68fde7b9a66f8257/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f353637366334343738643566653735316237303563333739323730333862353134333662646639383934636332346137303463336532633634633831313665322f576562417373656d626c792f636f6d706f6e656e742d6d6f64656c&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/CanonicalABI.md#-canon-threadindex\" title=\"component-model/design/mvp/CanonicalABI.md at main · WebAssembly/component-model\">component-model/design/mvp/CanonicalABI.md at main · WebAssembly/component-model</a></div><div class=\"message_embed_description\">Repository for design and specification of the Component Model - WebAssembly/component-model</div></div></div>",
        "id": 567577009,
        "sender_full_name": "Joel Dice",
        "timestamp": 1768233872
    },
    {
        "content": "<p>Regards this wit</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">export</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">async</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"p\">();</span>\n</code></pre></div>\n<p>which is from a test runner.  Will the runtime try to call a <code>[callback]</code> function, and if it does, what would it pass for the <code>waitable</code>, second parameter?</p>",
        "id": 567653735,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768256517
    },
    {
        "content": "<p>It will call the callback function if the <code>run</code> export returns <code>CALLBACK_CODE_YIELD</code> or <code>CALLBACK_CODE_WAIT</code>.  If it's the former, the <code>waitable</code> will be zero (i.e. not applicable).  If it's the latter, the <code>waitable</code> will be whichever <code>waitable</code> the event concerns, i.e. one of the <code>waitable</code>s in the <code>waitable-set</code> returned as part of the <code>CALLBACK_CODE_WAIT</code> return value.</p>\n<p>If the <code>run</code> export returns <code>CALLBACK_CODE_EXIT</code>, then the <code>[callback]</code> function won't be called (at least not for that particular task).</p>",
        "id": 567654176,
        "sender_full_name": "Joel Dice",
        "timestamp": 1768256747
    },
    {
        "content": "<p>Thanks, that makes sense.  I'm trying to work out how I should handle <br>\n<a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/90b50130ee83f298581e23dffc916ff36c8fd8a3/tests/runtime-async/async/pending-import/test.c#L34\">https://github.com/bytecodealliance/wit-bindgen/blob/90b50130ee83f298581e23dffc916ff36c8fd8a3/tests/runtime-async/async/pending-import/test.c#L34</a><br>\nAs you know this drop is part of the vtable, but I didn't really want to expose the vtable to the user code, i.e. the test code, so I though I could capture the correct vtable in the event, and then and a method to the event class to \"drop the waitable\", e.g.</p>\n<div class=\"codehilite\" data-code-language=\"C#\"><pre><span></span><code><span class=\"w\">        </span><span class=\"k\">public</span><span class=\"w\"> </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"nf\">PendingImportCallback</span><span class=\"p\">(</span><span class=\"n\">AsyncSupport</span><span class=\"p\">.</span><span class=\"n\">Event</span><span class=\"w\"> </span><span class=\"n\">ev</span><span class=\"p\">)</span>\n</code></pre></div>\n<p>Then inside this method:</p>\n<div class=\"codehilite\" data-code-language=\"C#\"><pre><span></span><code><span class=\"w\">            </span><span class=\"n\">ev</span><span class=\"p\">.</span><span class=\"n\">DropWaitable</span><span class=\"p\">();</span>\n</code></pre></div>\n<p>However if I do this in the export for the exported async method in the test code, the runner code, which exports a different method, the <code>run</code>, it also ends up with that export</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">            </span><span class=\"p\">[</span><span class=\"n\">global</span><span class=\"p\">::</span><span class=\"n\">System</span><span class=\"p\">.</span><span class=\"n\">Runtime</span><span class=\"p\">.</span><span class=\"n\">InteropServices</span><span class=\"p\">.</span><span class=\"n\">UnmanagedCallersOnlyAttribute</span><span class=\"p\">(</span><span class=\"n\">EntryPoint</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"[callback][async-lift]run\"</span><span class=\"p\">)]</span>\n<span class=\"w\">            </span><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"n\">RunCallback</span><span class=\"p\">(</span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"n\">eventRaw</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"n\">waitable</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"p\">)</span>\n<span class=\"w\">            </span><span class=\"p\">{</span>\n<span class=\"w\">                </span><span class=\"n\">AsyncSupport</span><span class=\"p\">.</span><span class=\"n\">Event</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"w\"> </span><span class=\"n\">AsyncSupport</span><span class=\"p\">.</span><span class=\"n\">Event</span><span class=\"p\">(</span><span class=\"n\">eventRaw</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">waitable</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">FutureVTable</span><span class=\"p\">);</span>\n<span class=\"w\">                </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">RunnerWorldExportsImpl</span><span class=\"p\">.</span><span class=\"n\">RunCallback</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">);</span>\n<span class=\"w\">            </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>And of course I have no future vtable here.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/90b50130ee83f298581e23dffc916ff36c8fd8a3/tests/runtime-async/async/pending-import/test.c#L34\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/0038d7120ad8b67a63d9d865e77d77a498c9efb3/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f316238346161366435663132646263366230393831613532393766303638653835663966346631306332363963386536633333303835383138343630363361362f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/90b50130ee83f298581e23dffc916ff36c8fd8a3/tests/runtime-async/async/pending-import/test.c#L34\" title=\"wit-bindgen/tests/runtime-async/async/pending-import/test.c at 90b50130ee83f298581e23dffc916ff36c8fd8a3 · bytecodealliance/wit-bindgen\">wit-bindgen/tests/runtime-async/async/pending-import/test.c at 90b50130ee83f298581e23dffc916ff36c8fd8a3 · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div>",
        "id": 567655041,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768257190
    },
    {
        "content": "<p>Maybe I should capture in the function bindgen, if I have used a future, and then I can write the <code>callback</code>interop appropriately.</p>",
        "id": 567655331,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768257346
    },
    {
        "content": "<p>Its also possible, that this will be more obvious to me, when I get to a more sophisticated wit.</p>",
        "id": 567655411,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768257389
    },
    {
        "content": "<p>Let me think again about this, I may have a better question later.</p>",
        "id": 567656134,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768257842
    },
    {
        "content": "<p>Sorry, in a meeting now, but will chime in when I can</p>",
        "id": 567656172,
        "sender_full_name": "Joel Dice",
        "timestamp": 1768257864
    },
    {
        "content": "<p>Ok, thanks, I was just thinking about how my current scheme doesn't work when the export has multiple future params of different types.</p>",
        "id": 567656261,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768257919
    },
    {
        "content": "<p>Generally speaking, before returning <code>CALLBACK_CODE_WAIT</code> the bindings generator or associated runtime library should store an entry in task-local map representing the pair of the <code>waitable</code> and e.g. a closure or equivalent representing what to do when an event arrives for that <code>waitable</code>.  The key thing to note is that \"task-local\" means saved and restored using the <code>context.set</code> and <code>context.get</code> intrinsics, respectively.</p>\n<p>Don't hesitate to look at what the Rust, Python, or Go bindings generators and their runtimes do.</p>",
        "id": 567658211,
        "sender_full_name": "Joel Dice",
        "timestamp": 1768259126
    },
    {
        "content": "<p>There is also a rust example for this test, I will look at what it generates here, thanks</p>",
        "id": 567658598,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768259357
    },
    {
        "content": "<p>Ah, now I see something I tried to kick down the road, that is likely useful.  I just have a single context type.  I did notice that the c code created one for the function, but it didn't dawn on me that I could customise the one of the fields</p>",
        "id": 567658963,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768259600
    },
    {
        "content": "<p>One thing that throws me a bit here, is that the rust test here is just</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"k\">crate</span><span class=\"p\">::</span><span class=\"n\">exports</span><span class=\"p\">::</span><span class=\"n\">my</span><span class=\"p\">::</span><span class=\"n\">test</span><span class=\"p\">::</span><span class=\"n\">i</span><span class=\"p\">::</span><span class=\"n\">Guest</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Component</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"nf\">pending_import</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">FutureReader</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"k\">await</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>Whereas the <code>c</code> is way longer .  Perhaps I should not be looking at the 'c' to get an idea of what should be in the user code, but just for the final sequence of events?</p>",
        "id": 567659676,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768260050
    },
    {
        "content": "<p>That's because the C generator is ultra-minimal, leaving the details to the application developer.  The Rust, Python, and Go generators and their runtime libraries do a lot more, handling the details on behalf of the app developer.  For Rust, see <code>async_support.rs</code> and related code under the <code>rt</code> module, which is where those details are handled.</p>",
        "id": 567659933,
        "sender_full_name": "Joel Dice",
        "timestamp": 1768260218
    },
    {
        "content": "<p>You can also generate Rust bindings using the <code>wit-bindgen rust</code> subcommand to see how the generator bridges the application code with the ABI, using the <code>rt</code> library.</p>",
        "id": 567660037,
        "sender_full_name": "Joel Dice",
        "timestamp": 1768260278
    },
    {
        "content": "<p>THanks, I will reset my thinking a bit here.</p>",
        "id": 567660128,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768260342
    },
    {
        "content": "<p>Hi, I'm on the way to making the C# bindings more like Go and Rust.  Still on the pending-inport example</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">package</span><span class=\"w\"> </span><span class=\"n\">my</span><span class=\"p\">:</span><span class=\"nc\">test</span><span class=\"p\">;</span>\n\n<span class=\"n\">interface</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">pending</span><span class=\"o\">-</span><span class=\"n\">import</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">async</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">future</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">world</span><span class=\"w\"> </span><span class=\"n\">test</span><span class=\"w\"> </span><span class=\"p\">{</span>\n<span class=\"w\">  </span><span class=\"n\">export</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>When the runner writes to the future <code>x</code>, that completes successfully, but the runtime should resume the future <code>read</code> in the test side, as I understand it.  But I'm missing how that happens as there doesn't seem to be an export that is called in the test, should I have registered a callback or something before returning <code>CallbackCode.Yield;</code> ?</p>",
        "id": 568535227,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768602898
    },
    {
        "content": "<p>Perhaps  Im missing a waitable join somewhere..</p>",
        "id": 568535774,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768603295
    },
    {
        "content": "<p>yes, that might be it, let me try that.</p>",
        "id": 568536414,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768603775
    },
    {
        "content": "<p>Actually still I bit confused, I can't see where the rust is doing that, and there is no go implementation, except for the generated code which has </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wit_async</span><span class=\"p\">.</span><span class=\"n\">SubtaskWait</span><span class=\"p\">(</span><span class=\"n\">uint32</span><span class=\"p\">(</span><span class=\"n\">wasm_import_pending_import</span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"p\">).</span><span class=\"n\">TakeHandle</span><span class=\"p\">())))</span>\n</code></pre></div>\n<p>Which does do a join in <code>SubtaskWait</code> but it doesn't seem to leave space to do the writing to the future, so not sure how that works....</p>",
        "id": 568538562,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768605498
    },
    {
        "content": "<p>I 've added a join which I think was the missing bit, was trying to get away without implementing the <code>[callback]</code> part so looking at that bit now.</p>",
        "id": 568590920,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768659908
    },
    {
        "content": "<p>I'm getting this error at the end of the test execution after calling the callback on the test side</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">wasm</span><span class=\"w\"> </span><span class=\"n\">trap</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">async</span><span class=\"o\">-</span><span class=\"n\">lifted</span><span class=\"w\"> </span><span class=\"n\">export</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">produce</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">result</span>\n</code></pre></div>\n<p>The callback I have for <code>[callback][async-lift]my:test/i#pending-import</code> is returning 0 which I thought was <code>CALLBACK_CODE_EXIT</code>, is that not right ?</p>",
        "id": 568602924,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768670320
    },
    {
        "content": "<p>ah, I 've not called task-return.  Sorry for spanming</p>",
        "id": 568603507,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768670898
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"395878\">@Scott Waye</span> you spam all you want. It helps to see your thinking process -- it shows what we need to explain better and/or modify. If you can't figure it out, how can others? :-)</p>",
        "id": 568761290,
        "sender_full_name": "Ralph",
        "timestamp": 1768816658
    },
    {
        "content": "<p>Lol, I do find writing things down sometimes kicks the brain into doing something useful.  I need a chat client that just go &gt; /dev/null :-)</p>",
        "id": 568862664,
        "sender_full_name": "Scott Waye",
        "timestamp": 1768848258
    },
    {
        "content": "<p>About the implementation of the Stream <code>Write/StartWrite</code> method, the buffer is passed, but who is responsible for freeing that, is it the reader?</p>",
        "id": 570929299,
        "sender_full_name": "Scott Waye",
        "timestamp": 1769739335
    },
    {
        "content": "<p>I say freeing, but could be unpinning in C#</p>",
        "id": 570929365,
        "sender_full_name": "Scott Waye",
        "timestamp": 1769739368
    },
    {
        "content": "<p>The reader will normally be a different component from the writer (or the host), so it wouldn't be able to free the buffer even if it wanted to.  Instead, the writer is responsible for freeing or unpinning the write buffer once the write completes (i.e. after it either completes immediately without delay or after an <code>EVENT_STREAM_WRITE</code> is received for that write).  Same goes for the read end: the component that's reading must ensure the read buffer stays valid (and doesn't move) until it has been notified either via a return code or an event that the write has been completed (or cancelled).</p>",
        "id": 571081393,
        "sender_full_name": "Joel Dice",
        "timestamp": 1769792724
    },
    {
        "content": "<p><code>EVENT_STREAM_WRITE</code> gives the buffer in the args i suppose.</p>",
        "id": 571111049,
        "sender_full_name": "Scott Waye",
        "timestamp": 1769802163
    },
    {
        "content": "<p>I might be able to kick this bit down the road I suppose, with a TODO</p>",
        "id": 571111296,
        "sender_full_name": "Scott Waye",
        "timestamp": 1769802250
    },
    {
        "content": "<p>Hmm, I guess it depends on what, precisely, you plan to kick down the road.  It's fine to pin the buffer <em>longer</em> than necessary, but if you pin it <em>shorter</em> than necessary you'll end up with hard-to-debug heap corruption sooner or later.</p>",
        "id": 571111830,
        "sender_full_name": "Joel Dice",
        "timestamp": 1769802456
    },
    {
        "content": "<p>That is true, I was thinking to pin it, and leave it there.  But if the <code>EVENT_STREAM_WRITE</code> gets the buffer, then it would be trivial to clean up</p>",
        "id": 571112021,
        "sender_full_name": "Scott Waye",
        "timestamp": 1769802524
    },
    {
        "content": "<p>Looking at the Go </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">case</span><span class=\"w\"> </span><span class=\"n\">EVENT_STREAM_READ</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">EVENT_STREAM_WRITE</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">EVENT_FUTURE_READ</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">EVENT_FUTURE_WRITE</span><span class=\"p\">:</span>\n<span class=\"w\">            </span><span class=\"nc\">waitableJoin</span><span class=\"p\">(</span><span class=\"n\">event1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"w\">            </span><span class=\"n\">channel</span><span class=\"w\"> </span><span class=\"p\">:</span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">pending</span><span class=\"p\">[</span><span class=\"n\">event1</span><span class=\"p\">]</span>\n<span class=\"w\">            </span><span class=\"n\">delete</span><span class=\"p\">(</span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">pending</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">event1</span><span class=\"p\">)</span>\n<span class=\"w\">            </span><span class=\"n\">channel</span><span class=\"w\"> </span><span class=\"o\">&lt;-</span><span class=\"w\"> </span><span class=\"n\">event2</span>\n</code></pre></div>\n<p>I suppose <code>delete</code> would be the thing to look at, if I can find it.</p>",
        "id": 571112996,
        "sender_full_name": "Scott Waye",
        "timestamp": 1769802828
    },
    {
        "content": "<p>That just removes an entry from the <code>state.pending</code> map; it doesn't affect pinning.  Unpinning the read buffer for Go happens via <a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_types/wit_stream.go#L56\">this defer statement</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_types/wit_stream.go#L56\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/14bfde608a302da208e2ace8925ffe3595739189/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f613432636437353239316361663362643466346164383236353564643039353163306331306336363638303334363539336165363963316134333665633738302f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_types/wit_stream.go#L56\" title=\"wit-bindgen/crates/go/src/package/wit_types/wit_stream.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen\">wit-bindgen/crates/go/src/package/wit_types/wit_stream.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div>",
        "id": 571113814,
        "sender_full_name": "Joel Dice",
        "timestamp": 1769803173
    },
    {
        "content": "<p>That works because <code>wit_async.FutureOrStreamWait</code> (called later in the same function) blocks the calling goroutine until the read completes, at which point the buffer can be unpinned.</p>",
        "id": 571113998,
        "sender_full_name": "Joel Dice",
        "timestamp": 1769803250
    },
    {
        "content": "<p>Think I understand that code, once the lifting is complete the read buffer can go.   I suppose <code>write</code> is similar.</p>",
        "id": 571114792,
        "sender_full_name": "Scott Waye",
        "timestamp": 1769803569
    },
    {
        "content": "<p>thanks</p>",
        "id": 571114799,
        "sender_full_name": "Scott Waye",
        "timestamp": 1769803572
    },
    {
        "content": "<p>Technically, we could unpin as soon as <code>wit_async.FutureOrStreamWait</code> returns and before lifting.  Unpinning just means the GC is free to move the buffer, but that won't harm pure Go code.  The pinning is just to ensure the pointer we passed to the host remains valid, and thus is no longer needed once the host tells us the read has completed.</p>",
        "id": 571117042,
        "sender_full_name": "Joel Dice",
        "timestamp": 1769804447
    },
    {
        "content": "<p>Ah yes, of course.</p>",
        "id": 571145006,
        "sender_full_name": "Scott Waye",
        "timestamp": 1769818220
    },
    {
        "content": "<p>Not sure what I've done, but I have this error <br>\n---- simple-stream-payload | runner.cs | test.cs ----<br>\n  runner: .\\tests\\runtime-async\\async\\simple-stream-payload\\runner.cs<br>\n  compiled runner: C:\\github\\wit-bindgen\\.\\target\\artifacts\\simple-stream-payload\\simple-stream-payload\\runner-csharp.wasm<br>\n  error: failed to run <code>simple-stream-payload</code></p>\n<p>Caused by:<br>\n      0: failed to compose \"C:\\\\github\\\\wit-bindgen\\\\.\\\\target\\\\artifacts\\\\simple-stream-payload\\\\simple-stream-payload\\\\runner-csharp.wasm\" with \"C:\\\\github\\\\wit-bindgen\\\\.\\\\target\\\\artifacts\\\\simple-stream-payload\\\\simple-stream-payload\\\\test-csharp.wasm\"<br>\n      1: no dependencies of component <code>C:\\github\\wit-bindgen\\.\\target\\artifacts\\simple-stream-payload\\simple-stream-payload\\runner-csharp.wasm</code> were found</p>\n<p>What dependencies is it looking for, a particular import?</p>",
        "id": 571295267,
        "sender_full_name": "Scott Waye",
        "timestamp": 1769959909
    },
    {
        "content": "<p>Think I've missed some code in the runner, will check that.</p>",
        "id": 571329010,
        "sender_full_name": "Scott Waye",
        "timestamp": 1769993497
    },
    {
        "content": "<p>ah yeah that error means that the runner doesn't actually import the test component, so it might be that the runner is stubbed out or not importing anything?</p>",
        "id": 571331698,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1769995744
    },
    {
        "content": "<p>Yep, if I don't actually use it the NAOT compiler will trim the import</p>",
        "id": 571458114,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770045326
    },
    {
        "content": "<p>In the runtime tests, the runner exports a run method, and I have this error</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">(</span><span class=\"n\">base</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">PS</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"p\">:</span><span class=\"err\">\\</span><span class=\"n\">github</span><span class=\"err\">\\</span><span class=\"n\">wit</span><span class=\"o\">-</span><span class=\"n\">bindgen</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">wasmtime</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">W</span><span class=\"w\"> </span><span class=\"n\">component</span><span class=\"o\">-</span><span class=\"n\">model</span><span class=\"o\">-</span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"p\">:</span><span class=\"err\">\\</span><span class=\"n\">github</span><span class=\"err\">\\</span><span class=\"n\">wit</span><span class=\"o\">-</span><span class=\"n\">bindgen</span><span class=\"err\">\\</span><span class=\"n\">target</span><span class=\"err\">\\</span><span class=\"n\">artifacts</span><span class=\"err\">\\</span><span class=\"n\">simple</span><span class=\"o\">-</span><span class=\"n\">future</span><span class=\"err\">\\</span><span class=\"n\">composed</span><span class=\"o\">-</span><span class=\"n\">runner</span><span class=\"p\">.</span><span class=\"n\">cs</span><span class=\"o\">-</span><span class=\"n\">test</span><span class=\"p\">.</span><span class=\"n\">cs</span><span class=\"p\">.</span><span class=\"n\">wasm</span>\n<span class=\"n\">Error</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"nc\">failed</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">run</span><span class=\"w\"> </span><span class=\"n\">main</span><span class=\"w\"> </span><span class=\"n\">module</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">C</span><span class=\"p\">:</span><span class=\"err\">\\</span><span class=\"n\">github</span><span class=\"err\">\\</span><span class=\"n\">wit</span><span class=\"o\">-</span><span class=\"n\">bindgen</span><span class=\"err\">\\</span><span class=\"n\">target</span><span class=\"err\">\\</span><span class=\"n\">artifacts</span><span class=\"err\">\\</span><span class=\"n\">simple</span><span class=\"o\">-</span><span class=\"n\">future</span><span class=\"err\">\\</span><span class=\"n\">composed</span><span class=\"o\">-</span><span class=\"n\">runner</span><span class=\"p\">.</span><span class=\"n\">cs</span><span class=\"o\">-</span><span class=\"n\">test</span><span class=\"p\">.</span><span class=\"n\">cs</span><span class=\"p\">.</span><span class=\"n\">wasm</span><span class=\"err\">`</span>\n\n<span class=\"n\">Caused</span><span class=\"w\"> </span><span class=\"n\">by</span><span class=\"p\">:</span>\n<span class=\"w\">    </span><span class=\"nc\">no</span><span class=\"w\"> </span><span class=\"n\">exported</span><span class=\"w\"> </span><span class=\"n\">instance</span><span class=\"w\"> </span><span class=\"n\">named</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">wasi</span><span class=\"p\">:</span><span class=\"nc\">cli</span><span class=\"o\">/</span><span class=\"n\">run</span><span class=\"o\">@</span><span class=\"mf\">0.2.6</span><span class=\"err\">`</span>\n</code></pre></div>\n<p>My export is <code>[async-lift]run\"</code>  which I think used to be correct.  Has something changed - something now expects the cli run export ?</p>",
        "id": 571973207,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770226999
    },
    {
        "content": "<p>The <code>wasmtime</code> CLI defaults to the <code>run</code> command, which by default expects the component input to export <code>wasi:cli/run</code>.  However, the runner tests in wit-bindgen now export a top-level <code>run</code> function, which you can invoke using <code>wasmtime run --invoke='run()' foo.wasm</code></p>",
        "id": 571984097,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770230432
    },
    {
        "content": "<p>ah, that explains how CI is passing, thanks</p>",
        "id": 571984273,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770230478
    },
    {
        "content": "<p>With this test <a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/tests/runtime-async/async/simple-stream-payload/runner.rs\">https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/tests/runtime-async/async/simple-stream-payload/runner.rs</a> , would you expect the first write to be blocked (and need to return to the event loop before getting its <code>count</code> back?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/tests/runtime-async/async/simple-stream-payload/runner.rs\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f734695f2c7b8e454e14fd9a68e96de19e7b839d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f303461373435306461373332626430353639383038663537306565356462623664656531393436313065613538376263663532626235626532636330373362652f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/tests/runtime-async/async/simple-stream-payload/runner.rs\" title=\"wit-bindgen/tests/runtime-async/async/simple-stream-payload/runner.rs at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen\">wit-bindgen/tests/runtime-async/async/simple-stream-payload/runner.rs at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div>",
        "id": 572138668,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770295662
    },
    {
        "content": "<p>Possibly; it depends on the details of how <code>future::join!</code> is implemented and how the <code>read_stream</code> function in the composed component is implemented.  If the <code>read_stream</code> function is called first and initiates a read immediately, then the write will finish as soon as it is called.  I.e. if the read happens first it will return BLOCKED and the write will complete immediately, but if the write happens first then it will return BLOCKED and the read will complete immediately.</p>",
        "id": 572165854,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770302293
    },
    {
        "content": "<p>I see, in my case the write will happen first so the BLOCK is expected.  In which case the mechanism is for the runner to yield I think?</p>",
        "id": 572166667,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770302460
    },
    {
        "content": "<p>This seems to happen in <code>go</code> with the reading from the channel, but I can't see exactly what that does in terms of the low level ABI calls, is it <code>pollable.poll</code> or there is a callback ?</p>",
        "id": 572167074,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770302534
    },
    {
        "content": "<p>Here I think <a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L195\">https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L195</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L195\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f734695f2c7b8e454e14fd9a68e96de19e7b839d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f303461373435306461373332626430353639383038663537306565356462623664656531393436313065613538376263663532626235626532636330373362652f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L195\" title=\"wit-bindgen/crates/go/src/package/wit_async/wit_async.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen\">wit-bindgen/crates/go/src/package/wit_async/wit_async.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div>",
        "id": 572167692,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770302675
    },
    {
        "content": "<p>Are you with Akamai now ?</p>",
        "id": 572168256,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770302806
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395878\">Scott Waye</span> <a href=\"#narrow/channel/407028-C.23.2F.2Enet-collaboration/topic/wit-bindgen.20async.2Ffuture/near/572166667\">said</a>:</p>\n<blockquote>\n<p>I see, in my case the write will happen first so the BLOCK is expected.  In which case the mechanism is for the runner to yield I think?</p>\n</blockquote>\n<p>It will return <code>CALLBACK_CODE_WAIT</code> with a waitable-set containing the stream handle.  That's true for both Rust (because the \"stackless\" concurrency model using a callback for async exports matches its async/await model) and Go (because even though it has \"stackful\" goroutines, those are currently implemented by the Go compiler using a CPS transform that effectively makes them \"stackless\").</p>",
        "id": 572171894,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770303592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"395878\">Scott Waye</span> <a href=\"#narrow/channel/407028-C.23.2F.2Enet-collaboration/topic/wit-bindgen.20async.2Ffuture/near/572168256\">said</a>:</p>\n<blockquote>\n<p>Are you with Akamai now ?</p>\n</blockquote>\n<p>Yes!</p>",
        "id": 572172045,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770303617
    },
    {
        "content": "<p>I'm missing something, or looking in the wrong place.  <a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L187C6-L187C24\">https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L187C6-L187C24</a>  catches <code>RETURN_CODE_BLOCKED </code> and creates the waitable set and does the join.  Then after the write is unblocked, it enters here <a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L120\">https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L120</a> doesnt it?</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L187C6-L187C24\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f734695f2c7b8e454e14fd9a68e96de19e7b839d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f303461373435306461373332626430353639383038663537306565356462623664656531393436313065613538376263663532626235626532636330373362652f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L187C6-L187C24\" title=\"wit-bindgen/crates/go/src/package/wit_async/wit_async.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen\">wit-bindgen/crates/go/src/package/wit_async/wit_async.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L120\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/f734695f2c7b8e454e14fd9a68e96de19e7b839d/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f303461373435306461373332626430353639383038663537306565356462623664656531393436313065613538376263663532626235626532636330373362652f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L120\" title=\"wit-bindgen/crates/go/src/package/wit_async/wit_async.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen\">wit-bindgen/crates/go/src/package/wit_async/wit_async.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div>",
        "id": 572174931,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770304216
    },
    {
        "content": "<p>I'm in a meeting now; but will take a look when I have a chance.</p>",
        "id": 572175079,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770304251
    },
    {
        "content": "<p>If you prefer we can cover this in the next meeting, which I think is in 2 weeks?</p>",
        "id": 572177081,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770304716
    },
    {
        "content": "<p>In <code>FutureOrStreamWait</code>, the <code>code = (&lt;-channel)</code> line blocks the current goroutine, which unwinds the goroutine stack and passes control to the Go scheduler.  If there are no other runnable goroutines, then the \"root\" goroutine resumes <a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L127\">here</a>, and that returns control to the host <a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L161\">here</a>.</p>\n<p>Go is its own special beast; to really understand what's going on you have to read <a href=\"https://github.com/golang/go/blob/99d7121934a9cfa7963d3a9bfd840779fd2869f6/src/cmd/compile/internal/wasm/ssa.go#L19-L130\">this</a> and study the Wasm code it generates.  I don't recommend you do that, though.  Just imagine <code>FutureOrStreamWait</code> is an async function in C# that awaits a <code>Task</code> representing the future or stream and returns control to the top level event loop in the meantime.</p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L127\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/00667b18d08d4bf1aaa3a9d763f475dfc456295a/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f323966393236396466313832653263656236656133636331633863396637646239373664646262393330366566303039636639666461316365616631303937642f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L127\" title=\"wit-bindgen/crates/go/src/package/wit_async/wit_async.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen\">wit-bindgen/crates/go/src/package/wit_async/wit_async.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L161\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/00667b18d08d4bf1aaa3a9d763f475dfc456295a/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f323966393236396466313832653263656236656133636331633863396637646239373664646262393330366566303039636639666461316365616631303937642f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L161\" title=\"wit-bindgen/crates/go/src/package/wit_async/wit_async.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen\">wit-bindgen/crates/go/src/package/wit_async/wit_async.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div><div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/golang/go/blob/99d7121934a9cfa7963d3a9bfd840779fd2869f6/src/cmd/compile/internal/wasm/ssa.go#L19-L130\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/7f3ebbd97dcb1b68554a95c6f0f4e8bf5e0cc70e/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f363031343637326237656636376561363530383665313464633565343232363365366339383638653232366263613633653961363163633862653539666461312f676f6c616e672f676f&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/golang/go/blob/99d7121934a9cfa7963d3a9bfd840779fd2869f6/src/cmd/compile/internal/wasm/ssa.go#L19-L130\" title=\"go/src/cmd/compile/internal/wasm/ssa.go at 99d7121934a9cfa7963d3a9bfd840779fd2869f6 · golang/go\">go/src/cmd/compile/internal/wasm/ssa.go at 99d7121934a9cfa7963d3a9bfd840779fd2869f6 · golang/go</a></div><div class=\"message_embed_description\">The Go programming language. Contribute to golang/go development by creating an account on GitHub.</div></div></div>",
        "id": 572209204,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770312126
    },
    {
        "content": "<p>Thanks, an <code>async Task</code> is where I want to get to.  I can create that <code>Task</code> using a <code>TaskCompletionSource</code> and store it somewhere as <code>go</code> does.  Then I will need to complete that task at some point, in go that would be from <code>Callback</code> I think, where is <code>Callback</code> hooked up?  <a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L61\">https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L61</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L61\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/00667b18d08d4bf1aaa3a9d763f475dfc456295a/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f323966393236396466313832653263656236656133636331633863396637646239373664646262393330366566303039636639666461316365616631303937642f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/350e8ad7abe8f65357c8984535d7bca5b9882c2c/crates/go/src/package/wit_async/wit_async.go#L61\" title=\"wit-bindgen/crates/go/src/package/wit_async/wit_async.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen\">wit-bindgen/crates/go/src/package/wit_async/wit_async.go at 350e8ad7abe8f65357c8984535d7bca5b9882c2c · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div>",
        "id": 572212521,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770313047
    },
    {
        "content": "<p>Oh I see it</p>",
        "id": 572212770,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770313129
    },
    {
        "content": "<p>Its a <code>[callback]</code> export</p>",
        "id": 572212880,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770313163
    },
    {
        "content": "<p>Awesome, I can play some more, thanks a lot.</p>",
        "id": 572213072,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770313228
    },
    {
        "content": "<p>Hi, made a little progress, but have another question, if I return <code>CALLBACK_CODE_WAIT</code> out of the async <code>run</code> in the runner, how do I run the event loop, or is that handled by wasmtime?</p>",
        "id": 572405978,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770391908
    },
    {
        "content": "<p>Returning <code>CALLBACK_CODE_WAIT</code> tells the host: \"wait until one of the waitables in this waitable-set has an event and then deliver that event to my callback function\".  During that wait, no guest code is run for that task -- it's entirely in the host's hands at that point.</p>",
        "id": 572406440,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770392061
    },
    {
        "content": "<p>In other words, you should _not_ return <code>CALLBACK_CODE_WAIT</code> to the host until you've run out of things to do in the guest (i.e. there's nothing you can do until one of the pending waitables has an event)</p>",
        "id": 572406779,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770392141
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">public</span><span class=\"w\"> </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"n\">Task</span><span class=\"w\"> </span><span class=\"n\">Run</span><span class=\"p\">()</span>\n<span class=\"w\">    </span><span class=\"p\">{</span>\n<span class=\"w\">        </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">rx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tx</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">IIImports</span><span class=\"p\">.</span><span class=\"n\">StreamNewByte</span><span class=\"p\">();</span>\n<span class=\"w\">        </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"n\">Task</span><span class=\"w\"> </span><span class=\"n\">Test</span><span class=\"p\">()</span>\n<span class=\"w\">        </span><span class=\"p\">{</span>\n<span class=\"w\">            </span><span class=\"n\">var</span><span class=\"w\"> </span><span class=\"n\">writtenOne</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"n\">tx</span><span class=\"p\">.</span><span class=\"n\">Write</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">]);</span>\n<span class=\"w\">        </span><span class=\"p\">}</span>\n\n<span class=\"w\">        </span><span class=\"n\">AsyncSupport</span><span class=\"p\">.</span><span class=\"n\">Join</span><span class=\"p\">(</span><span class=\"n\">Test</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">IIImports</span><span class=\"p\">.</span><span class=\"n\">ReadStream</span><span class=\"p\">(</span><span class=\"n\">rx</span><span class=\"p\">));</span>\n<span class=\"w\">    </span><span class=\"p\">}</span>\n</code></pre></div>\n<p>Taking this simplified runner, if <code>Write</code> blocks, <code>AsyncSupport.Join</code> should loop calling <code>[waitable-set-poll]</code> or return and <code>Run</code> returns<code>CALLBACK_CODE_WAIT</code> ?</p>",
        "id": 572407833,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770392417
    },
    {
        "content": "<p>Like <code>Run</code> is marked <code>async</code> but if <code>Join</code> waits for its <code>Task</code>s to finish in a busy loop, then there is nothing async about it, so I suppose it needs to return <code>CALLBACK_CODE_WAIT</code></p>",
        "id": 572408505,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770392617
    },
    {
        "content": "<p>So I think that fits with your statement \"run ouf of things to do\", its the last statement in the function after all.</p>",
        "id": 572408916,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770392722
    },
    {
        "content": "<p>you must be fed up with me by now :-)<br>\n\\</p>",
        "id": 572409083,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770392765
    },
    {
        "content": "<p>Somewhere there should be a function that returns a <code>uint32</code>; it should run a task, and if that task hasn't completed yet, it should collect all the waitables created by that task into a waitable-set and return <code>CALLBACK_CODE_WAIT</code>.  It's been long enough since I worked on .NET that I can't remember what \"run a task\" looks like, so apologies for being vague about that.</p>",
        "id": 572410010,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770393014
    },
    {
        "content": "<p>if there <em>aren't</em> any waitables, then it could just return <code>CALLBACK_CODE_YIELD</code>, meaning \"I, the guest, don't have anything I'm waiting on, but I'm in the middle of a compute-intensive operation and want to give other tasks a chance to run because I'm a good citizen; call my callback after you've let other tasks run and I'll continue\"</p>",
        "id": 572410701,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770393196
    },
    {
        "content": "<p>it might help to do a zoom call at some point and walk through this together</p>",
        "id": 572410800,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770393221
    },
    {
        "content": "<p>thanks, let me try a few things first based on the above.  I feel it is very close, just might need somethings moving around.</p>",
        "id": 572411357,
        "sender_full_name": "Scott Waye",
        "timestamp": 1770393364
    },
    {
        "content": "<p>BTW, to clarify what I said above: if there <em>are</em> waitables, you still might want to return <code>CALLBACK_CODE_YIELD</code> instead of <code>CALLBACK_CODE_WAIT</code> and also call <code>waitable-set.poll</code>, which says \"I've got some waitables I'm interested in, but I also have stuff to do in the meantime, so give other tasks a chance to run and let me know if any of those waitables are ready, but otherwise let me run some more\".  You can see that logic for Rust <a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/76e9f08917cacce2515445dc69ce923410449e5f/crates/guest-rust/src/rt/async_support.rs#L250-L277\">here</a></p>\n<div class=\"message_embed\"><a class=\"message_embed_image\" href=\"https://github.com/bytecodealliance/wit-bindgen/blob/76e9f08917cacce2515445dc69ce923410449e5f/crates/guest-rust/src/rt/async_support.rs#L250-L277\" style=\"background-image: url(&quot;https://uploads.zulipusercontent.net/00667b18d08d4bf1aaa3a9d763f475dfc456295a/68747470733a2f2f6f70656e67726170682e6769746875626173736574732e636f6d2f323966393236396466313832653263656236656133636331633863396637646239373664646262393330366566303039636639666461316365616631303937642f62797465636f6465616c6c69616e63652f7769742d62696e6467656e&quot;)\"></a><div class=\"data-container\"><div class=\"message_embed_title\"><a href=\"https://github.com/bytecodealliance/wit-bindgen/blob/76e9f08917cacce2515445dc69ce923410449e5f/crates/guest-rust/src/rt/async_support.rs#L250-L277\" title=\"wit-bindgen/crates/guest-rust/src/rt/async_support.rs at 76e9f08917cacce2515445dc69ce923410449e5f · bytecodealliance/wit-bindgen\">wit-bindgen/crates/guest-rust/src/rt/async_support.rs at 76e9f08917cacce2515445dc69ce923410449e5f · bytecodealliance/wit-bindgen</a></div><div class=\"message_embed_description\">A language binding generator for WebAssembly interface types - bytecodealliance/wit-bindgen</div></div></div>",
        "id": 572412271,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770393589
    },
    {
        "content": "<p>In pseudo-code:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>if I have more work to do, regardless of any pending waitables:\n  if I have pending waitables:\n    event = call waitable-set.poll(my-waitable-set)\n    if event non nil:\n      deliver(event)\n      continue\n  return CALLBACK_CODE_YIELD\nelse:\n  return CALLBACK_CODE_WAIT | (my-waitable-set &lt;&lt; 4)\n</code></pre></div>",
        "id": 572413139,
        "sender_full_name": "Joel Dice",
        "timestamp": 1770393816
    }
]